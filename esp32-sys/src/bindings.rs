/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"2.2.0\0";
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _NANO_FORMATTED_IO: u32 = 1;
pub const __NEWLIB__: u32 = 2;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const _POSIX_THREADS: u32 = 1;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const XCHAL_HAVE_BE: u32 = 0;
pub const XCHAL_HAVE_WINDOWED: u32 = 1;
pub const XCHAL_NUM_AREGS: u32 = 64;
pub const XCHAL_NUM_AREGS_LOG2: u32 = 6;
pub const XCHAL_MAX_INSTRUCTION_SIZE: u32 = 3;
pub const XCHAL_HAVE_DEBUG: u32 = 1;
pub const XCHAL_HAVE_DENSITY: u32 = 1;
pub const XCHAL_HAVE_LOOPS: u32 = 1;
pub const XCHAL_LOOP_BUFFER_SIZE: u32 = 256;
pub const XCHAL_HAVE_NSA: u32 = 1;
pub const XCHAL_HAVE_MINMAX: u32 = 1;
pub const XCHAL_HAVE_SEXT: u32 = 1;
pub const XCHAL_HAVE_DEPBITS: u32 = 0;
pub const XCHAL_HAVE_CLAMPS: u32 = 1;
pub const XCHAL_HAVE_MUL16: u32 = 1;
pub const XCHAL_HAVE_MUL32: u32 = 1;
pub const XCHAL_HAVE_MUL32_HIGH: u32 = 1;
pub const XCHAL_HAVE_DIV32: u32 = 1;
pub const XCHAL_HAVE_L32R: u32 = 1;
pub const XCHAL_HAVE_ABSOLUTE_LITERALS: u32 = 0;
pub const XCHAL_HAVE_CONST16: u32 = 0;
pub const XCHAL_HAVE_ADDX: u32 = 1;
pub const XCHAL_HAVE_WIDE_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_PREDICTED_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_CALL4AND12: u32 = 1;
pub const XCHAL_HAVE_ABS: u32 = 1;
pub const XCHAL_HAVE_RELEASE_SYNC: u32 = 1;
pub const XCHAL_HAVE_S32C1I: u32 = 1;
pub const XCHAL_HAVE_SPECULATION: u32 = 0;
pub const XCHAL_HAVE_FULL_RESET: u32 = 1;
pub const XCHAL_NUM_CONTEXTS: u32 = 1;
pub const XCHAL_NUM_MISC_REGS: u32 = 4;
pub const XCHAL_HAVE_TAP_MASTER: u32 = 0;
pub const XCHAL_HAVE_PRID: u32 = 1;
pub const XCHAL_HAVE_EXTERN_REGS: u32 = 1;
pub const XCHAL_HAVE_MX: u32 = 0;
pub const XCHAL_HAVE_MP_INTERRUPTS: u32 = 0;
pub const XCHAL_HAVE_MP_RUNSTALL: u32 = 0;
pub const XCHAL_HAVE_PSO: u32 = 0;
pub const XCHAL_HAVE_PSO_CDM: u32 = 0;
pub const XCHAL_HAVE_PSO_FULL_RETENTION: u32 = 0;
pub const XCHAL_HAVE_THREADPTR: u32 = 1;
pub const XCHAL_HAVE_BOOLEANS: u32 = 1;
pub const XCHAL_HAVE_CP: u32 = 1;
pub const XCHAL_CP_MAXCFG: u32 = 8;
pub const XCHAL_HAVE_MAC16: u32 = 1;
pub const XCHAL_HAVE_FUSION: u32 = 0;
pub const XCHAL_HAVE_FUSION_FP: u32 = 0;
pub const XCHAL_HAVE_FUSION_LOW_POWER: u32 = 0;
pub const XCHAL_HAVE_FUSION_AES: u32 = 0;
pub const XCHAL_HAVE_FUSION_CONVENC: u32 = 0;
pub const XCHAL_HAVE_FUSION_LFSR_CRC: u32 = 0;
pub const XCHAL_HAVE_FUSION_BITOPS: u32 = 0;
pub const XCHAL_HAVE_FUSION_AVS: u32 = 0;
pub const XCHAL_HAVE_FUSION_16BIT_BASEBAND: u32 = 0;
pub const XCHAL_HAVE_FUSION_VITERBI: u32 = 0;
pub const XCHAL_HAVE_FUSION_SOFTDEMAP: u32 = 0;
pub const XCHAL_HAVE_HIFIPRO: u32 = 0;
pub const XCHAL_HAVE_HIFI4: u32 = 0;
pub const XCHAL_HAVE_HIFI4_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI3: u32 = 0;
pub const XCHAL_HAVE_HIFI3_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI2: u32 = 0;
pub const XCHAL_HAVE_HIFI2EP: u32 = 0;
pub const XCHAL_HAVE_HIFI_MINI: u32 = 0;
pub const XCHAL_HAVE_VECTORFPU2005: u32 = 0;
pub const XCHAL_HAVE_USER_DPFPU: u32 = 0;
pub const XCHAL_HAVE_USER_SPFPU: u32 = 0;
pub const XCHAL_HAVE_FP: u32 = 1;
pub const XCHAL_HAVE_FP_DIV: u32 = 1;
pub const XCHAL_HAVE_FP_RECIP: u32 = 1;
pub const XCHAL_HAVE_FP_SQRT: u32 = 1;
pub const XCHAL_HAVE_FP_RSQRT: u32 = 1;
pub const XCHAL_HAVE_DFP: u32 = 0;
pub const XCHAL_HAVE_DFP_DIV: u32 = 0;
pub const XCHAL_HAVE_DFP_RECIP: u32 = 0;
pub const XCHAL_HAVE_DFP_SQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_RSQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_ACCEL: u32 = 1;
pub const XCHAL_HAVE_DFP_accel: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_ONLY: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_DOUBLE: u32 = 0;
pub const XCHAL_HAVE_VECTRA1: u32 = 0;
pub const XCHAL_HAVE_VECTRALX: u32 = 0;
pub const XCHAL_HAVE_PDX4: u32 = 0;
pub const XCHAL_HAVE_CONNXD2: u32 = 0;
pub const XCHAL_HAVE_CONNXD2_DUALLSFLIX: u32 = 0;
pub const XCHAL_HAVE_BBE16: u32 = 0;
pub const XCHAL_HAVE_BBE16_RSQRT: u32 = 0;
pub const XCHAL_HAVE_BBE16_VECDIV: u32 = 0;
pub const XCHAL_HAVE_BBE16_DESPREAD: u32 = 0;
pub const XCHAL_HAVE_BBENEP: u32 = 0;
pub const XCHAL_HAVE_BSP3: u32 = 0;
pub const XCHAL_HAVE_BSP3_TRANSPOSE: u32 = 0;
pub const XCHAL_HAVE_SSP16: u32 = 0;
pub const XCHAL_HAVE_SSP16_VITERBI: u32 = 0;
pub const XCHAL_HAVE_TURBO16: u32 = 0;
pub const XCHAL_HAVE_BBP16: u32 = 0;
pub const XCHAL_HAVE_FLIX3: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP_HISTOGRAM: u32 = 0;
pub const XCHAL_NUM_LOADSTORE_UNITS: u32 = 1;
pub const XCHAL_NUM_WRITEBUFFER_ENTRIES: u32 = 4;
pub const XCHAL_INST_FETCH_WIDTH: u32 = 4;
pub const XCHAL_DATA_WIDTH: u32 = 4;
pub const XCHAL_DATA_PIPE_DELAY: u32 = 2;
pub const XCHAL_CLOCK_GATING_GLOBAL: u32 = 1;
pub const XCHAL_CLOCK_GATING_FUNCUNIT: u32 = 1;
pub const XCHAL_UNALIGNED_LOAD_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_STORE_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_LOAD_HW: u32 = 1;
pub const XCHAL_UNALIGNED_STORE_HW: u32 = 1;
pub const XCHAL_SW_VERSION: u32 = 1100003;
pub const XCHAL_CORE_ID: &'static [u8; 17usize] = b"esp32_v3_49_prod\0";
pub const XCHAL_BUILD_UNIQUE_ID: u32 = 392854;
pub const XCHAL_HW_CONFIGID0: u32 = 3267166206;
pub const XCHAL_HW_CONFIGID1: u32 = 482737814;
pub const XCHAL_HW_VERSION_NAME: &'static [u8; 8usize] = b"LX6.0.3\0";
pub const XCHAL_HW_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_VERSION: u32 = 260003;
pub const XCHAL_HW_REL_LX6: u32 = 1;
pub const XCHAL_HW_REL_LX6_0: u32 = 1;
pub const XCHAL_HW_REL_LX6_0_3: u32 = 1;
pub const XCHAL_HW_CONFIGID_RELIABLE: u32 = 1;
pub const XCHAL_HW_MIN_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MIN_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MIN_VERSION: u32 = 260003;
pub const XCHAL_HW_MAX_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MAX_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MAX_VERSION: u32 = 260003;
pub const XCHAL_ICACHE_LINESIZE: u32 = 4;
pub const XCHAL_DCACHE_LINESIZE: u32 = 4;
pub const XCHAL_ICACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_DCACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_ICACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_IS_WRITEBACK: u32 = 0;
pub const XCHAL_DCACHE_IS_COHERENT: u32 = 0;
pub const XCHAL_HAVE_PREFETCH: u32 = 0;
pub const XCHAL_HAVE_PREFETCH_L1: u32 = 0;
pub const XCHAL_PREFETCH_CASTOUT_LINES: u32 = 0;
pub const XCHAL_PREFETCH_ENTRIES: u32 = 0;
pub const XCHAL_PREFETCH_BLOCK_ENTRIES: u32 = 0;
pub const XCHAL_HAVE_CACHE_BLOCKOPS: u32 = 0;
pub const XCHAL_HAVE_ICACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_DCACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_ICACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_DCACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_PIF: u32 = 1;
pub const XCHAL_HAVE_AXI: u32 = 0;
pub const XCHAL_HAVE_PIF_WR_RESP: u32 = 0;
pub const XCHAL_HAVE_PIF_REQ_ATTR: u32 = 0;
pub const XCHAL_ICACHE_SETWIDTH: u32 = 0;
pub const XCHAL_DCACHE_SETWIDTH: u32 = 0;
pub const XCHAL_ICACHE_WAYS: u32 = 1;
pub const XCHAL_DCACHE_WAYS: u32 = 1;
pub const XCHAL_ICACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_DCACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_ICACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_DCACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_ICACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_BANKS: u32 = 0;
pub const XCHAL_CA_BITS: u32 = 4;
pub const XCHAL_NUM_INSTROM: u32 = 1;
pub const XCHAL_NUM_INSTRAM: u32 = 2;
pub const XCHAL_NUM_DATAROM: u32 = 1;
pub const XCHAL_NUM_DATARAM: u32 = 2;
pub const XCHAL_NUM_URAM: u32 = 0;
pub const XCHAL_NUM_XLMI: u32 = 1;
pub const XCHAL_INSTROM0_VADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_PADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_SIZE: u32 = 4194304;
pub const XCHAL_DATAROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_SIZE: u32 = 524288;
pub const XCHAL_DATARAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_SIZE: u32 = 4194304;
pub const XCHAL_DATARAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM1_BANKS: u32 = 1;
pub const XCHAL_XLMI0_VADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_PADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_SIZE: u32 = 524288;
pub const XCHAL_XLMI0_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_IMEM_LOADSTORE: u32 = 1;
pub const XCHAL_HAVE_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_HIGHPRI_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_NMI: u32 = 1;
pub const XCHAL_HAVE_CCOUNT: u32 = 1;
pub const XCHAL_NUM_TIMERS: u32 = 3;
pub const XCHAL_NUM_INTERRUPTS: u32 = 32;
pub const XCHAL_NUM_INTERRUPTS_LOG2: u32 = 5;
pub const XCHAL_NUM_EXTINTERRUPTS: u32 = 26;
pub const XCHAL_NUM_INTLEVELS: u32 = 6;
pub const XCHAL_EXCM_LEVEL: u32 = 3;
pub const XCHAL_INTLEVEL1_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_MASK: u32 = 3670016;
pub const XCHAL_INTLEVEL3_MASK: u32 = 683706368;
pub const XCHAL_INTLEVEL4_MASK: u32 = 1392508928;
pub const XCHAL_INTLEVEL5_MASK: u32 = 2214658048;
pub const XCHAL_INTLEVEL6_MASK: u32 = 0;
pub const XCHAL_INTLEVEL7_MASK: u32 = 16384;
pub const XCHAL_INTLEVEL1_ANDBELOW_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_ANDBELOW_MASK: u32 = 4077567;
pub const XCHAL_INTLEVEL3_ANDBELOW_MASK: u32 = 687783935;
pub const XCHAL_INTLEVEL4_ANDBELOW_MASK: u32 = 2080292863;
pub const XCHAL_INTLEVEL5_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL6_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL7_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INT0_LEVEL: u32 = 1;
pub const XCHAL_INT1_LEVEL: u32 = 1;
pub const XCHAL_INT2_LEVEL: u32 = 1;
pub const XCHAL_INT3_LEVEL: u32 = 1;
pub const XCHAL_INT4_LEVEL: u32 = 1;
pub const XCHAL_INT5_LEVEL: u32 = 1;
pub const XCHAL_INT6_LEVEL: u32 = 1;
pub const XCHAL_INT7_LEVEL: u32 = 1;
pub const XCHAL_INT8_LEVEL: u32 = 1;
pub const XCHAL_INT9_LEVEL: u32 = 1;
pub const XCHAL_INT10_LEVEL: u32 = 1;
pub const XCHAL_INT11_LEVEL: u32 = 3;
pub const XCHAL_INT12_LEVEL: u32 = 1;
pub const XCHAL_INT13_LEVEL: u32 = 1;
pub const XCHAL_INT14_LEVEL: u32 = 7;
pub const XCHAL_INT15_LEVEL: u32 = 3;
pub const XCHAL_INT16_LEVEL: u32 = 5;
pub const XCHAL_INT17_LEVEL: u32 = 1;
pub const XCHAL_INT18_LEVEL: u32 = 1;
pub const XCHAL_INT19_LEVEL: u32 = 2;
pub const XCHAL_INT20_LEVEL: u32 = 2;
pub const XCHAL_INT21_LEVEL: u32 = 2;
pub const XCHAL_INT22_LEVEL: u32 = 3;
pub const XCHAL_INT23_LEVEL: u32 = 3;
pub const XCHAL_INT24_LEVEL: u32 = 4;
pub const XCHAL_INT25_LEVEL: u32 = 4;
pub const XCHAL_INT26_LEVEL: u32 = 5;
pub const XCHAL_INT27_LEVEL: u32 = 3;
pub const XCHAL_INT28_LEVEL: u32 = 4;
pub const XCHAL_INT29_LEVEL: u32 = 3;
pub const XCHAL_INT30_LEVEL: u32 = 4;
pub const XCHAL_INT31_LEVEL: u32 = 5;
pub const XCHAL_DEBUGLEVEL: u32 = 6;
pub const XCHAL_HAVE_DEBUG_EXTERN_INT: u32 = 1;
pub const XCHAL_NMILEVEL: u32 = 7;
pub const XCHAL_INTTYPE_MASK_UNCONFIGURED: u32 = 0;
pub const XCHAL_INTTYPE_MASK_SOFTWARE: u32 = 536871040;
pub const XCHAL_INTTYPE_MASK_EXTERN_EDGE: u32 = 1346372608;
pub const XCHAL_INTTYPE_MASK_EXTERN_LEVEL: u32 = 2411606847;
pub const XCHAL_INTTYPE_MASK_TIMER: u32 = 98368;
pub const XCHAL_INTTYPE_MASK_NMI: u32 = 16384;
pub const XCHAL_INTTYPE_MASK_WRITE_ERROR: u32 = 0;
pub const XCHAL_INTTYPE_MASK_PROFILING: u32 = 2048;
pub const XCHAL_TIMER0_INTERRUPT: u32 = 6;
pub const XCHAL_TIMER1_INTERRUPT: u32 = 15;
pub const XCHAL_TIMER2_INTERRUPT: u32 = 16;
pub const XCHAL_NMI_INTERRUPT: u32 = 14;
pub const XCHAL_PROFILING_INTERRUPT: u32 = 11;
pub const XCHAL_INTLEVEL7_NUM: u32 = 14;
pub const XCHAL_EXTINT0_NUM: u32 = 0;
pub const XCHAL_EXTINT1_NUM: u32 = 1;
pub const XCHAL_EXTINT2_NUM: u32 = 2;
pub const XCHAL_EXTINT3_NUM: u32 = 3;
pub const XCHAL_EXTINT4_NUM: u32 = 4;
pub const XCHAL_EXTINT5_NUM: u32 = 5;
pub const XCHAL_EXTINT6_NUM: u32 = 8;
pub const XCHAL_EXTINT7_NUM: u32 = 9;
pub const XCHAL_EXTINT8_NUM: u32 = 10;
pub const XCHAL_EXTINT9_NUM: u32 = 12;
pub const XCHAL_EXTINT10_NUM: u32 = 13;
pub const XCHAL_EXTINT11_NUM: u32 = 14;
pub const XCHAL_EXTINT12_NUM: u32 = 17;
pub const XCHAL_EXTINT13_NUM: u32 = 18;
pub const XCHAL_EXTINT14_NUM: u32 = 19;
pub const XCHAL_EXTINT15_NUM: u32 = 20;
pub const XCHAL_EXTINT16_NUM: u32 = 21;
pub const XCHAL_EXTINT17_NUM: u32 = 22;
pub const XCHAL_EXTINT18_NUM: u32 = 23;
pub const XCHAL_EXTINT19_NUM: u32 = 24;
pub const XCHAL_EXTINT20_NUM: u32 = 25;
pub const XCHAL_EXTINT21_NUM: u32 = 26;
pub const XCHAL_EXTINT22_NUM: u32 = 27;
pub const XCHAL_EXTINT23_NUM: u32 = 28;
pub const XCHAL_EXTINT24_NUM: u32 = 30;
pub const XCHAL_EXTINT25_NUM: u32 = 31;
pub const XCHAL_INT0_EXTNUM: u32 = 0;
pub const XCHAL_INT1_EXTNUM: u32 = 1;
pub const XCHAL_INT2_EXTNUM: u32 = 2;
pub const XCHAL_INT3_EXTNUM: u32 = 3;
pub const XCHAL_INT4_EXTNUM: u32 = 4;
pub const XCHAL_INT5_EXTNUM: u32 = 5;
pub const XCHAL_INT8_EXTNUM: u32 = 6;
pub const XCHAL_INT9_EXTNUM: u32 = 7;
pub const XCHAL_INT10_EXTNUM: u32 = 8;
pub const XCHAL_INT12_EXTNUM: u32 = 9;
pub const XCHAL_INT13_EXTNUM: u32 = 10;
pub const XCHAL_INT14_EXTNUM: u32 = 11;
pub const XCHAL_INT17_EXTNUM: u32 = 12;
pub const XCHAL_INT18_EXTNUM: u32 = 13;
pub const XCHAL_INT19_EXTNUM: u32 = 14;
pub const XCHAL_INT20_EXTNUM: u32 = 15;
pub const XCHAL_INT21_EXTNUM: u32 = 16;
pub const XCHAL_INT22_EXTNUM: u32 = 17;
pub const XCHAL_INT23_EXTNUM: u32 = 18;
pub const XCHAL_INT24_EXTNUM: u32 = 19;
pub const XCHAL_INT25_EXTNUM: u32 = 20;
pub const XCHAL_INT26_EXTNUM: u32 = 21;
pub const XCHAL_INT27_EXTNUM: u32 = 22;
pub const XCHAL_INT28_EXTNUM: u32 = 23;
pub const XCHAL_INT30_EXTNUM: u32 = 24;
pub const XCHAL_INT31_EXTNUM: u32 = 25;
pub const XCHAL_XEA_VERSION: u32 = 2;
pub const XCHAL_HAVE_XEA1: u32 = 0;
pub const XCHAL_HAVE_XEA2: u32 = 1;
pub const XCHAL_HAVE_XEAX: u32 = 0;
pub const XCHAL_HAVE_EXCEPTIONS: u32 = 1;
pub const XCHAL_HAVE_HALT: u32 = 0;
pub const XCHAL_HAVE_BOOTLOADER: u32 = 0;
pub const XCHAL_HAVE_MEM_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_VECTOR_SELECT: u32 = 1;
pub const XCHAL_HAVE_VECBASE: u32 = 1;
pub const XCHAL_VECBASE_RESET_VADDR: u32 = 1073741824;
pub const XCHAL_VECBASE_RESET_PADDR: u32 = 1073741824;
pub const XCHAL_RESET_VECBASE_OVERLAP: u32 = 0;
pub const XCHAL_RESET_VECTOR0_VADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR0_PADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR1_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR1_PADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XCHAL_USER_VECOFS: u32 = 832;
pub const XCHAL_USER_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USER_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_KERNEL_VECOFS: u32 = 768;
pub const XCHAL_KERNEL_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNEL_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_DOUBLEEXC_VECOFS: u32 = 960;
pub const XCHAL_DOUBLEEXC_VECTOR_VADDR: u32 = 1073742784;
pub const XCHAL_DOUBLEEXC_VECTOR_PADDR: u32 = 1073742784;
pub const XCHAL_WINDOW_OF4_VECOFS: u32 = 0;
pub const XCHAL_WINDOW_UF4_VECOFS: u32 = 64;
pub const XCHAL_WINDOW_OF8_VECOFS: u32 = 128;
pub const XCHAL_WINDOW_UF8_VECOFS: u32 = 192;
pub const XCHAL_WINDOW_OF12_VECOFS: u32 = 256;
pub const XCHAL_WINDOW_UF12_VECOFS: u32 = 320;
pub const XCHAL_WINDOW_VECTORS_VADDR: u32 = 1073741824;
pub const XCHAL_WINDOW_VECTORS_PADDR: u32 = 1073741824;
pub const XCHAL_INTLEVEL2_VECOFS: u32 = 384;
pub const XCHAL_INTLEVEL2_VECTOR_VADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL2_VECTOR_PADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL3_VECOFS: u32 = 448;
pub const XCHAL_INTLEVEL3_VECTOR_VADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL3_VECTOR_PADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL4_VECOFS: u32 = 512;
pub const XCHAL_INTLEVEL4_VECTOR_VADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL4_VECTOR_PADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL5_VECOFS: u32 = 576;
pub const XCHAL_INTLEVEL5_VECTOR_VADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL5_VECTOR_PADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL6_VECOFS: u32 = 640;
pub const XCHAL_INTLEVEL6_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_INTLEVEL6_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECOFS: u32 = 640;
pub const XCHAL_DEBUG_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_NMI_VECOFS: u32 = 704;
pub const XCHAL_NMI_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_NMI_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECOFS: u32 = 704;
pub const XCHAL_INTLEVEL7_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_HAVE_DEBUG_ERI: u32 = 1;
pub const XCHAL_HAVE_DEBUG_APB: u32 = 1;
pub const XCHAL_HAVE_DEBUG_JTAG: u32 = 1;
pub const XCHAL_HAVE_OCD: u32 = 1;
pub const XCHAL_NUM_IBREAK: u32 = 2;
pub const XCHAL_NUM_DBREAK: u32 = 2;
pub const XCHAL_HAVE_OCD_DIR_ARRAY: u32 = 0;
pub const XCHAL_HAVE_OCD_LS32DDR: u32 = 1;
pub const XCHAL_HAVE_TRAX: u32 = 1;
pub const XCHAL_TRAX_MEM_SIZE: u32 = 16384;
pub const XCHAL_TRAX_MEM_SHAREABLE: u32 = 1;
pub const XCHAL_TRAX_ATB_WIDTH: u32 = 32;
pub const XCHAL_TRAX_TIME_WIDTH: u32 = 0;
pub const XCHAL_NUM_PERF_COUNTERS: u32 = 2;
pub const XCHAL_HAVE_TLBS: u32 = 1;
pub const XCHAL_HAVE_SPANNING_WAY: u32 = 1;
pub const XCHAL_SPANNING_WAY: u32 = 0;
pub const XCHAL_HAVE_IDENTITY_MAP: u32 = 1;
pub const XCHAL_HAVE_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_MIMIC_CACHEATTR: u32 = 1;
pub const XCHAL_HAVE_XLT_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_PTP_MMU: u32 = 0;
pub const XCHAL_MMU_ASID_BITS: u32 = 0;
pub const XCHAL_MMU_RINGS: u32 = 1;
pub const XCHAL_MMU_RING_BITS: u32 = 0;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const _CLOCKS_PER_SEC_: u32 = 1000;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 3;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const _POSIX_TIMERS: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __have_longlong64: u32 = 1;
pub const __int8_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_STACK_CHECK: u32 = 1;
pub const CONFIG_MB_SERIAL_TASK_PRIO: u32 = 10;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_STACK_CHECK_NORM: u32 = 1;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &'static [u8; 4usize] = b"40m\0";
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &'static [u8; 4usize] = b"2MB\0";
pub const CONFIG_LOG_DEFAULT_LEVEL_VERBOSE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_EMAC_L2_TO_L3_RX_BUF_MODE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ_40M: u32 = 1;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_BTDM_CONTROLLER_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_BT_RESERVE_DRAM: u32 = 0;
pub const CONFIG_APP_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_ESP32_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_MB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_MBEDTLS_HAVE_TIME_DATE: u32 = 1;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &'static [u8; 8usize] = b"pthread\0";
pub const CONFIG_EMAC_TASK_PRIORITY: u32 = 20;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 8192;
pub const CONFIG_TCP_MSS: u32 = 1436;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_BTDM_CONTROLLER_BLE_MAX_CONN_EFF: u32 = 0;
pub const CONFIG_EFUSE_CODE_SCHEME_COMPAT_3_4: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ULP_COPROC_RESERVE_MEM: u32 = 0;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_ESPTOOLPY_BAUD: u32 = 115200;
pub const CONFIG_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_ADC_CAL_LUT_ENABLE: u32 = 1;
pub const CONFIG_HEAP_TASK_TRACKING: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-esp32-elf-\0";
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_MBEDTLS_RC4_DISABLED: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_MBEDTLS_CAMELLIA_C: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_RTC_CLOCK_SOURCE_INTERNAL_RC: u32 = 1;
pub const CONFIG_ESPTOOLPY_BAUD_115200B: u32 = 1;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_FOUR_UNIVERSAL_MAC_ADDRESS: u32 = 1;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_MAX_CONTENT_LEN: u32 = 16384;
pub const CONFIG_NUMBER_OF_UNIVERSAL_MAC_ADDRESS: u32 = 4;
pub const CONFIG_ESPTOOLPY_FLASHSIZE_DETECT: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_MBEDTLS_RIPEMD160_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER: u32 = 1;
pub const CONFIG_MB_SERIAL_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_OPENSSL_DEBUG: u32 = 1;
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 192;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 4096;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_0: u32 = 1;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_HEAP_TRACING_STACK_DEPTH: u32 = 2;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &'static [u8; 4usize] = b"dio\0";
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &'static [u8; 14usize] = b"default_reset\0";
pub const CONFIG_ADC2_DISABLE_DAC: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 5;
pub const CONFIG_FREERTOS_ASSERT_ON_UNTESTED_FUNCTION: u32 = 1;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_MAKE_WARN_UNDEFINED_VARIABLES: u32 = 1;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_OPENSSL_DEBUG_LEVEL: u32 = 0;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_HEAP_POISONING_COMPREHENSIVE: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_MDNS_MAX_SERVICES: u32 = 10;
pub const CONFIG_IDF_TARGET_ESP32: u32 = 1;
pub const CONFIG_HEAP_TRACING: u32 = 1;
pub const CONFIG_EMAC_CHECK_LINK_PERIOD_MS: u32 = 2000;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_DMA_RX_BUF_NUM: u32 = 10;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 6;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_BTDM_CONTROLLER_BR_EDR_MAX_SYNC_CONN_EFF: u32 = 0;
pub const CONFIG_PYTHON: &'static [u8; 7usize] = b"python\0";
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_ESP32_TIME_SYSCALL_USE_RTC_FRC1: u32 = 1;
pub const CONFIG_ESPTOOLPY_COMPRESSED: u32 = 1;
pub const CONFIG_PARTITION_TABLE_FILENAME: &'static [u8; 25usize] = b"partitions_singleapp.csv\0";
pub const CONFIG_MB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_1: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_MB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_UNITY_ENABLE_FLOAT: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_EMAC_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_PTRVAL: u32 = 1;
pub const CONFIG_MB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_MBEDTLS_DEBUG: u32 = 1;
pub const CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V: u32 = 1;
pub const CONFIG_ESP32_DEEP_SLEEP_WAKEUP_DELAY: u32 = 2000;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_DHE_RSA: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ADC_CAL_EFUSE_TP_ENABLE: u32 = 1;
pub const CONFIG_FREERTOS_ASSERT_FAIL_ABORT: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32_XTAL_FREQ: u32 = 40;
pub const CONFIG_MONITOR_BAUD_115200B: u32 = 1;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_MBEDTLS_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_MB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_ESPTOOLPY_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_BTDM_CONTROLLER_BR_EDR_MAX_ACL_CONN_EFF: u32 = 0;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_ESPTOOLPY_AFTER: &'static [u8; 11usize] = b"hard_reset\0";
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_ESP32_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_DMA_TX_BUF_NUM: u32 = 10;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_ESP32_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_PTHREAD_CORE_NO_AFFINITY: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_MBEDTLS_HARDWARE_SHA: u32 = 1;
pub const CONFIG_ESP32_DEBUG_STUBS_ENABLE: u32 = 1;
pub const CONFIG_TCPIP_LWIP: u32 = 1;
pub const CONFIG_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_FREERTOS_CORETIMER_0: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &'static [u8; 15usize] = b"partitions.csv\0";
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_ADC_CAL_EFUSE_VREF_ENABLE: u32 = 1;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_OPENSSL_ASSERT_DO_NOTHING: u32 = 1;
pub const CONFIG_IDF_TARGET: &'static [u8; 6usize] = b"esp32\0";
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_HTTPD_ERR_RESP_NO_DELAY: u32 = 1;
pub const CONFIG_MB_TIMER_INDEX: u32 = 0;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT_ONLY: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_MB_TIMER_GROUP: u32 = 0;
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_MB_TIMER_PORT_ENABLED: u32 = 1;
pub const CONFIG_MONITOR_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_ESPTOOLPY_PORT: &'static [u8; 13usize] = b"/dev/ttyUSB0\0";
pub const CONFIG_UNITY_ENABLE_DOUBLE: u32 = 1;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const portNUM_PROCESSORS: u32 = 2;
pub const XT_USE_THREAD_SAFE_CLIB: u32 = 0;
pub const configASSERT_2: u32 = 0;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const configUSE_MUTEX: u32 = 1;
pub const XT_TIMER_INDEX: u32 = 0;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS: u32 = 1;
pub const XTHAL_RELEASE_MAJOR: u32 = 11000;
pub const XTHAL_RELEASE_MINOR: u32 = 3;
pub const XTHAL_RELEASE_NAME: &'static [u8; 7usize] = b"11.0.3\0";
pub const XTHAL_REL_11: u32 = 1;
pub const XTHAL_REL_11_0: u32 = 1;
pub const XTHAL_REL_11_0_3: u32 = 1;
pub const XTHAL_MAJOR_REV: u32 = 11000;
pub const XTHAL_MINOR_REV: u32 = 3;
pub const XTHAL_MAYBE: i32 = -1;
pub const XTHAL_MAX_CPS: u32 = 8;
pub const XTHAL_LITTLEENDIAN: u32 = 0;
pub const XTHAL_BIGENDIAN: u32 = 1;
pub const XTHAL_PREFETCH_ENABLE: i32 = -1;
pub const XTHAL_PREFETCH_DISABLE: u32 = 4294901760;
pub const XTHAL_DCACHE_PREFETCH_L1_OFF: u32 = 2415919104;
pub const XTHAL_DCACHE_PREFETCH_L1: u32 = 2415923200;
pub const XTHAL_ICACHE_PREFETCH_L1_OFF: u32 = 2684354560;
pub const XTHAL_ICACHE_PREFETCH_L1: u32 = 2684362752;
pub const XTHAL_DISASM_BUFSIZE: u32 = 80;
pub const XTHAL_DISASM_OPT_ADDR: u32 = 1;
pub const XTHAL_DISASM_OPT_OPHEX: u32 = 2;
pub const XTHAL_DISASM_OPT_OPCODE: u32 = 4;
pub const XTHAL_DISASM_OPT_PARMS: u32 = 8;
pub const XTHAL_DISASM_OPT_ALL: u32 = 4095;
pub const XTHAL_MAX_INTERRUPTS: u32 = 32;
pub const XTHAL_MAX_INTLEVELS: u32 = 16;
pub const XTHAL_MAX_TIMERS: u32 = 4;
pub const XTHAL_INTTYPE_UNCONFIGURED: u32 = 0;
pub const XTHAL_INTTYPE_SOFTWARE: u32 = 1;
pub const XTHAL_INTTYPE_EXTERN_EDGE: u32 = 2;
pub const XTHAL_INTTYPE_EXTERN_LEVEL: u32 = 3;
pub const XTHAL_INTTYPE_TIMER: u32 = 4;
pub const XTHAL_INTTYPE_NMI: u32 = 5;
pub const XTHAL_INTTYPE_WRITE_ERROR: u32 = 6;
pub const XTHAL_INTTYPE_PROFILING: u32 = 7;
pub const XTHAL_MAX_INTTYPES: u32 = 8;
pub const XTHAL_TIMER_UNCONFIGURED: i32 = -1;
pub const XTHAL_TIMER_UNASSIGNED: i32 = -1;
pub const XTHAL_MEMEP_PARITY: u32 = 1;
pub const XTHAL_MEMEP_ECC: u32 = 2;
pub const XTHAL_MEMEP_F_LOCAL: u32 = 0;
pub const XTHAL_MEMEP_F_DCACHE_DATA: u32 = 4;
pub const XTHAL_MEMEP_F_DCACHE_TAG: u32 = 5;
pub const XTHAL_MEMEP_F_ICACHE_DATA: u32 = 6;
pub const XTHAL_MEMEP_F_ICACHE_TAG: u32 = 7;
pub const XTHAL_MEMEP_F_CORRECTABLE: u32 = 16;
pub const XTHAL_AMB_EXCEPTION: u32 = 0;
pub const XTHAL_AMB_HITCACHE: u32 = 1;
pub const XTHAL_AMB_ALLOCATE: u32 = 2;
pub const XTHAL_AMB_WRITETHRU: u32 = 3;
pub const XTHAL_AMB_ISOLATE: u32 = 4;
pub const XTHAL_AMB_GUARD: u32 = 5;
pub const XTHAL_AMB_COHERENT: u32 = 6;
pub const XTHAL_AM_EXCEPTION: u32 = 1;
pub const XTHAL_AM_HITCACHE: u32 = 2;
pub const XTHAL_AM_ALLOCATE: u32 = 4;
pub const XTHAL_AM_WRITETHRU: u32 = 8;
pub const XTHAL_AM_ISOLATE: u32 = 16;
pub const XTHAL_AM_GUARD: u32 = 32;
pub const XTHAL_AM_COHERENT: u32 = 64;
pub const XTHAL_FAM_EXCEPTION: u32 = 1;
pub const XTHAL_FAM_BYPASS: u32 = 0;
pub const XTHAL_FAM_CACHED: u32 = 6;
pub const XTHAL_LAM_EXCEPTION: u32 = 1;
pub const XTHAL_LAM_ISOLATE: u32 = 18;
pub const XTHAL_LAM_BYPASS: u32 = 0;
pub const XTHAL_LAM_BYPASSG: u32 = 32;
pub const XTHAL_LAM_CACHED_NOALLOC: u32 = 2;
pub const XTHAL_LAM_NACACHED: u32 = 2;
pub const XTHAL_LAM_NACACHEDG: u32 = 34;
pub const XTHAL_LAM_CACHED: u32 = 6;
pub const XTHAL_LAM_COHCACHED: u32 = 70;
pub const XTHAL_SAM_EXCEPTION: u32 = 1;
pub const XTHAL_SAM_ISOLATE: u32 = 50;
pub const XTHAL_SAM_BYPASS: u32 = 40;
pub const XTHAL_SAM_WRITETHRU: u32 = 42;
pub const XTHAL_SAM_WRITEBACK: u32 = 38;
pub const XTHAL_SAM_WRITEBACK_NOALLOC: u32 = 34;
pub const XTHAL_SAM_COHWRITEBACK: u32 = 102;
pub const XTHAL_PAM_BYPASS: u32 = 0;
pub const XTHAL_PAM_BYPASS_BUF: u32 = 16;
pub const XTHAL_PAM_CACHED_NOALLOC: u32 = 48;
pub const XTHAL_PAM_WRITETHRU: u32 = 176;
pub const XTHAL_PAM_WRITEBACK_NOALLOC: u32 = 240;
pub const XTHAL_PAM_WRITEBACK: u32 = 496;
pub const XTHAL_CAFLAG_EXPAND: u32 = 256;
pub const XTHAL_CAFLAG_EXACT: u32 = 512;
pub const XTHAL_CAFLAG_NO_PARTIAL: u32 = 1024;
pub const XTHAL_CAFLAG_NO_AUTO_WB: u32 = 2048;
pub const XTHAL_CAFLAG_NO_AUTO_INV: u32 = 4096;
pub const XCHAL_SUCCESS: u32 = 0;
pub const XCHAL_ADDRESS_MISALIGNED: i32 = -1;
pub const XCHAL_INEXACT: i32 = -2;
pub const XCHAL_INVALID_ADDRESS: i32 = -3;
pub const XCHAL_UNSUPPORTED_ON_THIS_ARCH: i32 = -4;
pub const XCHAL_NO_PAGES_MAPPED: i32 = -5;
pub const XTHAL_NO_MAPPING: i32 = -6;
pub const XCHAL_CA_R: u32 = 1073742016;
pub const XCHAL_CA_RX: u32 = 1073742032;
pub const XCHAL_CA_RW: u32 = 1073742048;
pub const XCHAL_CA_RWX: u32 = 1073742064;
pub const XTENSA_HWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_HWCIDSCHEME_T1020_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_0: u32 = 2;
pub const XTENSA_HWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_HWCIDSCHEME_T1020_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_1: u32 = 3;
pub const XTENSA_HWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2B: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2B: u32 = 5;
pub const XTENSA_HWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2: u32 = 4;
pub const XTENSA_HWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_HWCIDSCHEME_T1020_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_3: u32 = 6;
pub const XTENSA_HWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_HWCIDSCHEME_T1020_4: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_4: u32 = 7;
pub const XTENSA_HWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_HWCIDSCHEME_T1030_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_0: u32 = 9;
pub const XTENSA_HWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_HWCIDSCHEME_T1030_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_1: u32 = 10;
pub const XTENSA_HWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_HWCIDSCHEME_T1030_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_2: u32 = 11;
pub const XTENSA_HWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_HWCIDSCHEME_T1030_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_3: u32 = 12;
pub const XTENSA_HWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_HWCIDSCHEME_T1040_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_0: u32 = 15;
pub const XTENSA_HWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_1: u32 = 32;
pub const XTENSA_HWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1P: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_1P: u32 = 16;
pub const XTENSA_HWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_HWCIDSCHEME_T1040_2: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_2: u32 = 33;
pub const XTENSA_HWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_HWCIDSCHEME_T1040_3: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_3: u32 = 34;
pub const XTENSA_HWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_HWCIDSCHEME_T1050_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_0: u32 = 1;
pub const XTENSA_HWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_HWCIDSCHEME_T1050_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_1: u32 = 2;
pub const XTENSA_HWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_HWCIDSCHEME_T1050_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_2: u32 = 4;
pub const XTENSA_HWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_HWCIDSCHEME_T1050_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_3: u32 = 6;
pub const XTENSA_HWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_HWCIDSCHEME_T1050_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_4: u32 = 7;
pub const XTENSA_HWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_HWCIDSCHEME_T1050_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_5: u32 = 8;
pub const XTENSA_HWVERSION_RA_2004_1: u32 = 210000;
pub const XTENSA_HWCIDSCHEME_RA_2004_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2004_1: u32 = 3;
pub const XTENSA_HWVERSION_RA_2005_1: u32 = 210001;
pub const XTENSA_HWCIDSCHEME_RA_2005_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_1: u32 = 20;
pub const XTENSA_HWVERSION_RA_2005_2: u32 = 210002;
pub const XTENSA_HWCIDSCHEME_RA_2005_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_2: u32 = 21;
pub const XTENSA_HWVERSION_RA_2005_3: u32 = 210003;
pub const XTENSA_HWCIDSCHEME_RA_2005_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_3: u32 = 22;
pub const XTENSA_HWVERSION_RA_2006_4: u32 = 210004;
pub const XTENSA_HWCIDSCHEME_RA_2006_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_4: u32 = 23;
pub const XTENSA_HWVERSION_RA_2006_5: u32 = 210005;
pub const XTENSA_HWCIDSCHEME_RA_2006_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_5: u32 = 24;
pub const XTENSA_HWVERSION_RA_2006_6: u32 = 210006;
pub const XTENSA_HWCIDSCHEME_RA_2006_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_6: u32 = 25;
pub const XTENSA_HWVERSION_RA_2007_7: u32 = 210007;
pub const XTENSA_HWCIDSCHEME_RA_2007_7: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2007_7: u32 = 26;
pub const XTENSA_HWVERSION_RA_2008_8: u32 = 210008;
pub const XTENSA_HWCIDSCHEME_RA_2008_8: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2008_8: u32 = 27;
pub const XTENSA_HWVERSION_RB_2006_0: u32 = 220000;
pub const XTENSA_HWCIDSCHEME_RB_2006_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2006_0: u32 = 48;
pub const XTENSA_HWVERSION_RB_2007_1: u32 = 220001;
pub const XTENSA_HWCIDSCHEME_RB_2007_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_1: u32 = 49;
pub const XTENSA_HWVERSION_RB_2007_2: u32 = 221000;
pub const XTENSA_HWCIDSCHEME_RB_2007_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2: u32 = 52;
pub const XTENSA_HWVERSION_RB_2008_3: u32 = 221001;
pub const XTENSA_HWCIDSCHEME_RB_2008_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_3: u32 = 53;
pub const XTENSA_HWVERSION_RB_2008_4: u32 = 221002;
pub const XTENSA_HWCIDSCHEME_RB_2008_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_4: u32 = 54;
pub const XTENSA_HWVERSION_RB_2009_5: u32 = 221003;
pub const XTENSA_HWCIDSCHEME_RB_2009_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2009_5: u32 = 55;
pub const XTENSA_HWVERSION_RB_2007_2_MP: u32 = 221100;
pub const XTENSA_HWCIDSCHEME_RB_2007_2_MP: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2_MP: u32 = 64;
pub const XTENSA_HWVERSION_RC_2009_0: u32 = 230000;
pub const XTENSA_HWCIDSCHEME_RC_2009_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2009_0: u32 = 65;
pub const XTENSA_HWVERSION_RC_2010_1: u32 = 230001;
pub const XTENSA_HWCIDSCHEME_RC_2010_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_1: u32 = 66;
pub const XTENSA_HWVERSION_RC_2010_2: u32 = 230002;
pub const XTENSA_HWCIDSCHEME_RC_2010_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_2: u32 = 67;
pub const XTENSA_HWVERSION_RC_2011_3: u32 = 230003;
pub const XTENSA_HWCIDSCHEME_RC_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2011_3: u32 = 68;
pub const XTENSA_HWVERSION_RD_2010_0: u32 = 240000;
pub const XTENSA_HWCIDSCHEME_RD_2010_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2010_0: u32 = 80;
pub const XTENSA_HWVERSION_RD_2011_1: u32 = 240001;
pub const XTENSA_HWCIDSCHEME_RD_2011_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_1: u32 = 81;
pub const XTENSA_HWVERSION_RD_2011_2: u32 = 240002;
pub const XTENSA_HWCIDSCHEME_RD_2011_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_2: u32 = 82;
pub const XTENSA_HWVERSION_RD_2011_3: u32 = 240003;
pub const XTENSA_HWCIDSCHEME_RD_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_3: u32 = 83;
pub const XTENSA_HWVERSION_RD_2012_4: u32 = 240004;
pub const XTENSA_HWCIDSCHEME_RD_2012_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_4: u32 = 84;
pub const XTENSA_HWVERSION_RD_2012_5: u32 = 240005;
pub const XTENSA_HWCIDSCHEME_RD_2012_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_5: u32 = 85;
pub const XTENSA_HWVERSION_RE_2012_0: u32 = 250000;
pub const XTENSA_HWCIDSCHEME_RE_2012_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_0: u32 = 96;
pub const XTENSA_HWVERSION_RE_2012_1: u32 = 250001;
pub const XTENSA_HWCIDSCHEME_RE_2012_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_1: u32 = 97;
pub const XTENSA_HWVERSION_RE_2013_2: u32 = 250002;
pub const XTENSA_HWCIDSCHEME_RE_2013_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_2: u32 = 98;
pub const XTENSA_HWVERSION_RE_2013_3: u32 = 250003;
pub const XTENSA_HWCIDSCHEME_RE_2013_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_3: u32 = 99;
pub const XTENSA_HWVERSION_RE_2013_4: u32 = 250004;
pub const XTENSA_HWCIDSCHEME_RE_2013_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_4: u32 = 100;
pub const XTENSA_HWVERSION_RE_2014_5: u32 = 250005;
pub const XTENSA_HWCIDSCHEME_RE_2014_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2014_5: u32 = 101;
pub const XTENSA_HWVERSION_RE_2015_6: u32 = 250006;
pub const XTENSA_HWCIDSCHEME_RE_2015_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2015_6: u32 = 102;
pub const XTENSA_HWVERSION_RF_2014_0: u32 = 260000;
pub const XTENSA_HWCIDSCHEME_RF_2014_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_0: u32 = 112;
pub const XTENSA_HWVERSION_RF_2014_1: u32 = 260001;
pub const XTENSA_HWCIDSCHEME_RF_2014_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_1: u32 = 113;
pub const XTENSA_HWVERSION_RF_2015_2: u32 = 260002;
pub const XTENSA_HWCIDSCHEME_RF_2015_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_2: u32 = 114;
pub const XTENSA_HWVERSION_RF_2015_3: u32 = 260003;
pub const XTENSA_HWCIDSCHEME_RF_2015_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_3: u32 = 115;
pub const XTENSA_HWVERSION_RG_2015_0: u32 = 270000;
pub const XTENSA_HWCIDSCHEME_RG_2015_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2015_0: u32 = 128;
pub const XTENSA_SWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_SWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_SWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_SWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_SWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_SWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_SWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_SWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_SWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_SWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_SWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_SWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_SWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_SWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_SWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_SWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_SWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_SWVERSION_RA_2004_1: u32 = 600000;
pub const XTENSA_SWVERSION_RA_2005_1: u32 = 600001;
pub const XTENSA_SWVERSION_RA_2005_2: u32 = 600002;
pub const XTENSA_SWVERSION_RA_2005_3: u32 = 600003;
pub const XTENSA_SWVERSION_RA_2006_4: u32 = 600004;
pub const XTENSA_SWVERSION_RA_2006_5: u32 = 600005;
pub const XTENSA_SWVERSION_RA_2006_6: u32 = 600006;
pub const XTENSA_SWVERSION_RA_2007_7: u32 = 600007;
pub const XTENSA_SWVERSION_RA_2008_8: u32 = 600008;
pub const XTENSA_SWVERSION_RB_2006_0: u32 = 700000;
pub const XTENSA_SWVERSION_RB_2007_1: u32 = 700001;
pub const XTENSA_SWVERSION_RB_2007_2: u32 = 701000;
pub const XTENSA_SWVERSION_RB_2008_3: u32 = 701001;
pub const XTENSA_SWVERSION_RB_2008_4: u32 = 701002;
pub const XTENSA_SWVERSION_RB_2009_5: u32 = 701003;
pub const XTENSA_SWVERSION_RB_2007_2_MP: u32 = 701100;
pub const XTENSA_SWVERSION_RC_2009_0: u32 = 800000;
pub const XTENSA_SWVERSION_RC_2010_1: u32 = 800001;
pub const XTENSA_SWVERSION_RC_2010_2: u32 = 800002;
pub const XTENSA_SWVERSION_RC_2011_3: u32 = 800003;
pub const XTENSA_SWVERSION_RD_2010_0: u32 = 900000;
pub const XTENSA_SWVERSION_RD_2011_1: u32 = 900001;
pub const XTENSA_SWVERSION_RD_2011_2: u32 = 900002;
pub const XTENSA_SWVERSION_RD_2011_3: u32 = 900003;
pub const XTENSA_SWVERSION_RD_2012_4: u32 = 900004;
pub const XTENSA_SWVERSION_RD_2012_5: u32 = 900005;
pub const XTENSA_SWVERSION_RE_2012_0: u32 = 1000000;
pub const XTENSA_SWVERSION_RE_2012_1: u32 = 1000001;
pub const XTENSA_SWVERSION_RE_2013_2: u32 = 1000002;
pub const XTENSA_SWVERSION_RE_2013_3: u32 = 1000003;
pub const XTENSA_SWVERSION_RE_2013_4: u32 = 1000004;
pub const XTENSA_SWVERSION_RE_2014_5: u32 = 1000005;
pub const XTENSA_SWVERSION_RE_2015_6: u32 = 1000006;
pub const XTENSA_SWVERSION_RF_2014_0: u32 = 1100000;
pub const XTENSA_SWVERSION_RF_2014_1: u32 = 1100001;
pub const XTENSA_SWVERSION_RF_2015_2: u32 = 1100002;
pub const XTENSA_SWVERSION_RF_2015_3: u32 = 1100003;
pub const XTENSA_SWVERSION_RG_2015_0: u32 = 1200000;
pub const XTENSA_SWVERSION_T1040_1_PREHOTFIX: u32 = 104001;
pub const XTENSA_SWVERSION_6_0_0: u32 = 600000;
pub const XTENSA_SWVERSION_6_0_1: u32 = 600001;
pub const XTENSA_SWVERSION_6_0_2: u32 = 600002;
pub const XTENSA_SWVERSION_6_0_3: u32 = 600003;
pub const XTENSA_SWVERSION_6_0_4: u32 = 600004;
pub const XTENSA_SWVERSION_6_0_5: u32 = 600005;
pub const XTENSA_SWVERSION_6_0_6: u32 = 600006;
pub const XTENSA_SWVERSION_6_0_7: u32 = 600007;
pub const XTENSA_SWVERSION_6_0_8: u32 = 600008;
pub const XTENSA_SWVERSION_7_0_0: u32 = 700000;
pub const XTENSA_SWVERSION_7_0_1: u32 = 700001;
pub const XTENSA_SWVERSION_7_1_0: u32 = 701000;
pub const XTENSA_SWVERSION_7_1_1: u32 = 701001;
pub const XTENSA_SWVERSION_7_1_2: u32 = 701002;
pub const XTENSA_SWVERSION_7_1_3: u32 = 701003;
pub const XTENSA_SWVERSION_7_1_8_MP: u32 = 701100;
pub const XTENSA_SWVERSION_8_0_0: u32 = 800000;
pub const XTENSA_SWVERSION_8_0_1: u32 = 800001;
pub const XTENSA_SWVERSION_8_0_2: u32 = 800002;
pub const XTENSA_SWVERSION_8_0_3: u32 = 800003;
pub const XTENSA_SWVERSION_9_0_0: u32 = 900000;
pub const XTENSA_SWVERSION_9_0_1: u32 = 900001;
pub const XTENSA_SWVERSION_9_0_2: u32 = 900002;
pub const XTENSA_SWVERSION_9_0_3: u32 = 900003;
pub const XTENSA_SWVERSION_9_0_4: u32 = 900004;
pub const XTENSA_SWVERSION_9_0_5: u32 = 900005;
pub const XTENSA_SWVERSION_10_0_0: u32 = 1000000;
pub const XTENSA_SWVERSION_10_0_1: u32 = 1000001;
pub const XTENSA_SWVERSION_10_0_2: u32 = 1000002;
pub const XTENSA_SWVERSION_10_0_3: u32 = 1000003;
pub const XTENSA_SWVERSION_10_0_4: u32 = 1000004;
pub const XTENSA_SWVERSION_10_0_5: u32 = 1000005;
pub const XTENSA_SWVERSION_10_0_6: u32 = 1000006;
pub const XTENSA_SWVERSION_11_0_0: u32 = 1100000;
pub const XTENSA_SWVERSION_11_0_1: u32 = 1100001;
pub const XTENSA_SWVERSION_11_0_2: u32 = 1100002;
pub const XTENSA_SWVERSION_11_0_3: u32 = 1100003;
pub const XTENSA_SWVERSION_12_0_0: u32 = 1200000;
pub const XTENSA_RELEASE_NAME: &'static [u8; 10usize] = b"RF-2015.3\0";
pub const XTENSA_RELEASE_CANONICAL_NAME: &'static [u8; 10usize] = b"RF-2015.3\0";
pub const XTENSA_SWVERSION: u32 = 1100003;
pub const XTENSA_SWVERSION_NAME: &'static [u8; 7usize] = b"11.0.3\0";
pub const XTENSA_SWVERSION_CANONICAL_NAME: &'static [u8; 7usize] = b"11.0.3\0";
pub const XTENSA_SWVERSION_MAJORMID_NAME: &'static [u8; 5usize] = b"11.0\0";
pub const XTENSA_SWVERSION_MAJOR_NAME: &'static [u8; 3usize] = b"11\0";
pub const XTENSA_SWVERSION_LICENSE_NAME: &'static [u8; 5usize] = b"11.0\0";
pub const XCHAL_CA_BYPASS: u32 = 2;
pub const XCHAL_CA_BYPASSBUF: u32 = 6;
pub const XCHAL_CA_WRITETHRU: u32 = 2;
pub const XCHAL_CA_WRITEBACK: u32 = 2;
pub const XCHAL_HAVE_CA_WRITEBACK_NOALLOC: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC: u32 = 2;
pub const XCHAL_CA_BYPASS_RW: u32 = 0;
pub const XCHAL_CA_WRITETHRU_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC_RW: u32 = 0;
pub const XCHAL_CA_ILLEGAL: u32 = 15;
pub const XCHAL_CA_ISOLATE: u32 = 0;
pub const XCHAL_MMU_ASID_INVALID: u32 = 0;
pub const XCHAL_MMU_ASID_KERNEL: u32 = 0;
pub const XCHAL_MMU_SR_BITS: u32 = 0;
pub const XCHAL_MMU_CA_BITS: u32 = 4;
pub const XCHAL_MMU_MAX_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_MMU_MIN_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_ITLB_WAY_BITS: u32 = 0;
pub const XCHAL_ITLB_WAYS: u32 = 1;
pub const XCHAL_ITLB_ARF_WAYS: u32 = 0;
pub const XCHAL_ITLB_SETS: u32 = 1;
pub const XCHAL_ITLB_WAY0_SET: u32 = 0;
pub const XCHAL_ITLB_ARF_SETS: u32 = 0;
pub const XCHAL_ITLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_ITLB_SET0_WAY: u32 = 0;
pub const XCHAL_ITLB_SET0_WAYS: u32 = 1;
pub const XCHAL_ITLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_ITLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_ITLB_SET0_ARF: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_ITLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_ITLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_ITLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_WAY_BITS: u32 = 0;
pub const XCHAL_DTLB_WAYS: u32 = 1;
pub const XCHAL_DTLB_ARF_WAYS: u32 = 0;
pub const XCHAL_DTLB_SETS: u32 = 1;
pub const XCHAL_DTLB_WAY0_SET: u32 = 0;
pub const XCHAL_DTLB_ARF_SETS: u32 = 0;
pub const XCHAL_DTLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_DTLB_SET0_WAY: u32 = 0;
pub const XCHAL_DTLB_SET0_WAYS: u32 = 1;
pub const XCHAL_DTLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_DTLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_DTLB_SET0_ARF: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_DTLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_DTLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_DTLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_CP_NUM: u32 = 1;
pub const XCHAL_CP_MAX: u32 = 1;
pub const XCHAL_CP_MASK: u32 = 1;
pub const XCHAL_CP_PORT_MASK: u32 = 0;
pub const XCHAL_CP0_NAME: &'static [u8; 4usize] = b"FPU\0";
pub const XCHAL_CP0_SA_SIZE: u32 = 72;
pub const XCHAL_CP0_SA_ALIGN: u32 = 4;
pub const XCHAL_CP_ID_FPU: u32 = 0;
pub const XCHAL_CP1_SA_SIZE: u32 = 0;
pub const XCHAL_CP1_SA_ALIGN: u32 = 1;
pub const XCHAL_CP2_SA_SIZE: u32 = 0;
pub const XCHAL_CP2_SA_ALIGN: u32 = 1;
pub const XCHAL_CP3_SA_SIZE: u32 = 0;
pub const XCHAL_CP3_SA_ALIGN: u32 = 1;
pub const XCHAL_CP4_SA_SIZE: u32 = 0;
pub const XCHAL_CP4_SA_ALIGN: u32 = 1;
pub const XCHAL_CP5_SA_SIZE: u32 = 0;
pub const XCHAL_CP5_SA_ALIGN: u32 = 1;
pub const XCHAL_CP6_SA_SIZE: u32 = 0;
pub const XCHAL_CP6_SA_ALIGN: u32 = 1;
pub const XCHAL_CP7_SA_SIZE: u32 = 0;
pub const XCHAL_CP7_SA_ALIGN: u32 = 1;
pub const XCHAL_NCP_SA_SIZE: u32 = 48;
pub const XCHAL_NCP_SA_ALIGN: u32 = 4;
pub const XCHAL_TOTAL_SA_SIZE: u32 = 128;
pub const XCHAL_TOTAL_SA_ALIGN: u32 = 4;
pub const XCHAL_NCP_SA_NUM: u32 = 12;
pub const XCHAL_CP0_SA_NUM: u32 = 18;
pub const XCHAL_CP1_SA_NUM: u32 = 0;
pub const XCHAL_CP2_SA_NUM: u32 = 0;
pub const XCHAL_CP3_SA_NUM: u32 = 0;
pub const XCHAL_CP4_SA_NUM: u32 = 0;
pub const XCHAL_CP5_SA_NUM: u32 = 0;
pub const XCHAL_CP6_SA_NUM: u32 = 0;
pub const XCHAL_CP7_SA_NUM: u32 = 0;
pub const XCHAL_HAVE_LE: u32 = 1;
pub const XCHAL_MEMORY_ORDER: u32 = 0;
pub const XCHAL_HAVE_HIGHLEVEL_INTERRUPTS: u32 = 1;
pub const XCHAL_NUM_LOWPRI_LEVELS: u32 = 1;
pub const XCHAL_FIRST_HIGHPRI_LEVEL: u32 = 2;
pub const XCHAL_INTLEVEL0_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_MASK: u32 = 0;
pub const XCHAL_INTLEVEL9_MASK: u32 = 0;
pub const XCHAL_INTLEVEL10_MASK: u32 = 0;
pub const XCHAL_INTLEVEL11_MASK: u32 = 0;
pub const XCHAL_INTLEVEL12_MASK: u32 = 0;
pub const XCHAL_INTLEVEL13_MASK: u32 = 0;
pub const XCHAL_INTLEVEL14_MASK: u32 = 0;
pub const XCHAL_INTLEVEL15_MASK: u32 = 0;
pub const XCHAL_INTLEVEL0_ANDBELOW_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL9_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL10_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL11_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL12_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL13_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL14_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL15_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_LOWPRI_MASK: u32 = 407551;
pub const XCHAL_INTCLEARABLE_MASK: u32 = 1883243648;
pub const XCHAL_INTSETTABLE_MASK: u32 = 536871040;
pub const XCHAL_EXTINT0_MASK: u32 = 1;
pub const XCHAL_EXTINT1_MASK: u32 = 2;
pub const XCHAL_EXTINT2_MASK: u32 = 4;
pub const XCHAL_EXTINT3_MASK: u32 = 8;
pub const XCHAL_EXTINT4_MASK: u32 = 16;
pub const XCHAL_EXTINT5_MASK: u32 = 32;
pub const XCHAL_EXTINT6_MASK: u32 = 256;
pub const XCHAL_EXTINT7_MASK: u32 = 512;
pub const XCHAL_EXTINT8_MASK: u32 = 1024;
pub const XCHAL_EXTINT9_MASK: u32 = 4096;
pub const XCHAL_EXTINT10_MASK: u32 = 8192;
pub const XCHAL_EXTINT11_MASK: u32 = 16384;
pub const XCHAL_EXTINT12_MASK: u32 = 131072;
pub const XCHAL_EXTINT13_MASK: u32 = 262144;
pub const XCHAL_EXTINT14_MASK: u32 = 524288;
pub const XCHAL_EXTINT15_MASK: u32 = 1048576;
pub const XCHAL_EXTINT16_MASK: u32 = 2097152;
pub const XCHAL_EXTINT17_MASK: u32 = 4194304;
pub const XCHAL_EXTINT18_MASK: u32 = 8388608;
pub const XCHAL_EXTINT19_MASK: u32 = 16777216;
pub const XCHAL_EXTINT20_MASK: u32 = 33554432;
pub const XCHAL_EXTINT21_MASK: u32 = 67108864;
pub const XCHAL_EXTINT22_MASK: u32 = 134217728;
pub const XCHAL_EXTINT23_MASK: u32 = 268435456;
pub const XCHAL_EXTINT24_MASK: u32 = 1073741824;
pub const XCHAL_EXTINT25_MASK: u32 = 2147483648;
pub const XCHAL_HAVE_OLD_EXC_ARCH: u32 = 0;
pub const XCHAL_HAVE_EXCM: u32 = 1;
pub const XCHAL_PROGRAMEXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_PROGRAMEXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_STACKEDEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_STACKEDEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_EXCCAUSE_ILLEGAL_INSTRUCTION: u32 = 0;
pub const XCHAL_EXCCAUSE_SYSTEM_CALL: u32 = 1;
pub const XCHAL_EXCCAUSE_INSTRUCTION_FETCH_ERROR: u32 = 2;
pub const XCHAL_EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const XCHAL_EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const XCHAL_EXCCAUSE_ALLOCA: u32 = 5;
pub const XCHAL_EXCCAUSE_INTEGER_DIVIDE_BY_ZERO: u32 = 6;
pub const XCHAL_EXCCAUSE_SPECULATION: u32 = 7;
pub const XCHAL_EXCCAUSE_PRIVILEGED: u32 = 8;
pub const XCHAL_EXCCAUSE_UNALIGNED: u32 = 9;
pub const XCHAL_EXCCAUSE_ITLB_MISS: u32 = 16;
pub const XCHAL_EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const XCHAL_EXCCAUSE_ITLB_PRIVILEGE: u32 = 18;
pub const XCHAL_EXCCAUSE_ITLB_SIZE_RESTRICTION: u32 = 19;
pub const XCHAL_EXCCAUSE_FETCH_CACHE_ATTRIBUTE: u32 = 20;
pub const XCHAL_EXCCAUSE_DTLB_MISS: u32 = 24;
pub const XCHAL_EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const XCHAL_EXCCAUSE_DTLB_PRIVILEGE: u32 = 26;
pub const XCHAL_EXCCAUSE_DTLB_SIZE_RESTRICTION: u32 = 27;
pub const XCHAL_EXCCAUSE_LOAD_CACHE_ATTRIBUTE: u32 = 28;
pub const XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE: u32 = 29;
pub const XCHAL_EXCCAUSE_COPROCESSOR0_DISABLED: u32 = 32;
pub const XCHAL_EXCCAUSE_COPROCESSOR1_DISABLED: u32 = 33;
pub const XCHAL_EXCCAUSE_COPROCESSOR2_DISABLED: u32 = 34;
pub const XCHAL_EXCCAUSE_COPROCESSOR3_DISABLED: u32 = 35;
pub const XCHAL_EXCCAUSE_COPROCESSOR4_DISABLED: u32 = 36;
pub const XCHAL_EXCCAUSE_COPROCESSOR5_DISABLED: u32 = 37;
pub const XCHAL_EXCCAUSE_COPROCESSOR6_DISABLED: u32 = 38;
pub const XCHAL_EXCCAUSE_COPROCESSOR7_DISABLED: u32 = 39;
pub const XCHAL_DBREAKC_VALIDMASK: u32 = 3221225535;
pub const XCHAL_DBREAKC_MASK_BITS: u32 = 6;
pub const XCHAL_DBREAKC_MASK_NUM: u32 = 64;
pub const XCHAL_DBREAKC_MASK_SHIFT: u32 = 0;
pub const XCHAL_DBREAKC_MASK_MASK: u32 = 63;
pub const XCHAL_DBREAKC_LOADBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_LOADBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const XCHAL_DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const XCHAL_DBREAKC_STOREBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_STOREBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const XCHAL_DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const XCHAL_PS_VALIDMASK: u32 = 462655;
pub const XCHAL_PS_INTLEVEL_BITS: u32 = 4;
pub const XCHAL_PS_INTLEVEL_NUM: u32 = 16;
pub const XCHAL_PS_INTLEVEL_SHIFT: u32 = 0;
pub const XCHAL_PS_INTLEVEL_MASK: u32 = 15;
pub const XCHAL_PS_EXCM_BITS: u32 = 1;
pub const XCHAL_PS_EXCM_NUM: u32 = 2;
pub const XCHAL_PS_EXCM_SHIFT: u32 = 4;
pub const XCHAL_PS_EXCM_MASK: u32 = 16;
pub const XCHAL_PS_UM_BITS: u32 = 1;
pub const XCHAL_PS_UM_NUM: u32 = 2;
pub const XCHAL_PS_UM_SHIFT: u32 = 5;
pub const XCHAL_PS_UM_MASK: u32 = 32;
pub const XCHAL_PS_RING_BITS: u32 = 2;
pub const XCHAL_PS_RING_NUM: u32 = 4;
pub const XCHAL_PS_RING_SHIFT: u32 = 6;
pub const XCHAL_PS_RING_MASK: u32 = 192;
pub const XCHAL_PS_OWB_BITS: u32 = 4;
pub const XCHAL_PS_OWB_NUM: u32 = 16;
pub const XCHAL_PS_OWB_SHIFT: u32 = 8;
pub const XCHAL_PS_OWB_MASK: u32 = 3840;
pub const XCHAL_PS_CALLINC_BITS: u32 = 2;
pub const XCHAL_PS_CALLINC_NUM: u32 = 4;
pub const XCHAL_PS_CALLINC_SHIFT: u32 = 16;
pub const XCHAL_PS_CALLINC_MASK: u32 = 196608;
pub const XCHAL_PS_WOE_BITS: u32 = 1;
pub const XCHAL_PS_WOE_NUM: u32 = 2;
pub const XCHAL_PS_WOE_SHIFT: u32 = 18;
pub const XCHAL_PS_WOE_MASK: u32 = 262144;
pub const XCHAL_EXCCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_EXCCAUSE_BITS: u32 = 6;
pub const XCHAL_EXCCAUSE_NUM: u32 = 64;
pub const XCHAL_EXCCAUSE_SHIFT: u32 = 0;
pub const XCHAL_EXCCAUSE_MASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_ICOUNT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_ICOUNT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const XCHAL_DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const XCHAL_DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const XCHAL_DEBUGCAUSE_BREAKN_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAKN_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const XCHAL_NUM_IROM: u32 = 1;
pub const XCHAL_NUM_IRAM: u32 = 2;
pub const XCHAL_NUM_DROM: u32 = 1;
pub const XCHAL_NUM_DRAM: u32 = 2;
pub const XCHAL_IROM0_VADDR: u32 = 1082130432;
pub const XCHAL_IROM0_PADDR: u32 = 1082130432;
pub const XCHAL_IROM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_SIZE: u32 = 4194304;
pub const XCHAL_DROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DROM0_SIZE: u32 = 4194304;
pub const XCHAL_DRAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_SIZE: u32 = 524288;
pub const XCHAL_DRAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_SIZE: u32 = 4194304;
pub const XCHAL_CACHE_PREFCTL_DEFAULT: u32 = 4164;
pub const XCHAL_CACHE_LINEWIDTH_MAX: u32 = 2;
pub const XCHAL_CACHE_LINESIZE_MAX: u32 = 4;
pub const XCHAL_ICACHE_SETSIZE: u32 = 1;
pub const XCHAL_DCACHE_SETSIZE: u32 = 1;
pub const XCHAL_CACHE_SETWIDTH_MAX: u32 = 0;
pub const XCHAL_CACHE_SETSIZE_MAX: u32 = 1;
pub const XCHAL_ICACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_V: u32 = 1;
pub const XCHAL_ICACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_F: u32 = 0;
pub const XCHAL_ICACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_L: u32 = 0;
pub const XCHAL_DCACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_V: u32 = 1;
pub const XCHAL_DCACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_F: u32 = 0;
pub const XCHAL_DCACHE_TAG_D_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_D: u32 = 0;
pub const XCHAL_DCACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_L: u32 = 0;
pub const XCHAL_CACHE_MEMCTL_DEFAULT: u32 = 0;
pub const _MEMCTL_SNOOP_EN: u32 = 0;
pub const _MEMCTL_L0IBUF_EN: u32 = 1;
pub const XCHAL_SNOOP_LB_MEMCTL_DEFAULT: u32 = 1;
pub const XCHAL_ALIGN_MAX: u32 = 4;
pub const XCHAL_HW_RELEASE_MAJOR: u32 = 2600;
pub const XCHAL_HW_RELEASE_MINOR: u32 = 3;
pub const XCHAL_HW_RELEASE_NAME: &'static [u8; 8usize] = b"LX6.0.3\0";
pub const XCHAL_EXTRA_SA_SIZE: u32 = 48;
pub const XCHAL_EXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CPEXTRA_SA_SIZE: u32 = 128;
pub const XCHAL_CPEXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CP1_NAME: u32 = 0;
pub const XCHAL_CP1_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP2_NAME: u32 = 0;
pub const XCHAL_CP2_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP3_NAME: u32 = 0;
pub const XCHAL_CP3_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP4_NAME: u32 = 0;
pub const XCHAL_CP4_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP5_NAME: u32 = 0;
pub const XCHAL_CP5_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP6_NAME: u32 = 0;
pub const XCHAL_CP6_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP7_NAME: u32 = 0;
pub const XCHAL_CP7_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CPEXTRA_SA_SIZE_TOR2: u32 = 128;
pub const XCHAL_INST_ILLN: u32 = 61549;
pub const XCHAL_INST_ILLN_BYTE0: u32 = 109;
pub const XCHAL_INST_ILLN_BYTE1: u32 = 240;
pub const XTHAL_INST_ILL: u32 = 0;
pub const XCHAL_ERRATUM_453: u32 = 0;
pub const XCHAL_ERRATUM_497: u32 = 0;
pub const XCHAL_ERRATUM_572: u32 = 1;
pub const XSHAL_USE_ABSOLUTE_LITERALS: u32 = 0;
pub const XSHAL_HAVE_TEXT_SECTION_LITERALS: u32 = 1;
pub const XTHAL_ABI_WINDOWED: u32 = 0;
pub const XTHAL_ABI_CALL0: u32 = 1;
pub const XTHAL_CLIB_NEWLIB: u32 = 0;
pub const XTHAL_CLIB_UCLIBC: u32 = 1;
pub const XTHAL_CLIB_XCLIB: u32 = 2;
pub const XSHAL_USE_FLOATING_POINT: u32 = 1;
pub const XSHAL_FLOATING_POINT_ABI: u32 = 0;
pub const XSHAL_IOBLOCK_CACHED_VADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_PADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_SIZE: u32 = 234881024;
pub const XSHAL_IOBLOCK_BYPASS_VADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_PADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_SIZE: u32 = 234881024;
pub const XSHAL_ROM_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_PADDR: u32 = 1342177280;
pub const XSHAL_ROM_SIZE: u32 = 16777216;
pub const XSHAL_ROM_AVAIL_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_AVAIL_VSIZE: u32 = 16777216;
pub const XSHAL_RAM_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_PADDR: u32 = 1610612736;
pub const XSHAL_RAM_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_PSIZE: u32 = 536870912;
pub const XSHAL_RAM_SIZE: u32 = 536870912;
pub const XSHAL_RAM_AVAIL_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_AVAIL_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_BYPASS_VADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PSIZE: u32 = 536870912;
pub const XSHAL_SIMIO_CACHED_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_BYPASS_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_PADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_SIZE: u32 = 536870912;
pub const XSHAL_MAGIC_EXIT: u32 = 0;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEBACK: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEALLOC: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITETHRU: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_BYPASS: u32 = 572662306;
pub const XSHAL_ALLVALID_CACHEATTR_DEFAULT: u32 = 572657938;
pub const XSHAL_STRICT_CACHEATTR_WRITEBACK: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITEALLOC: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITETHRU: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_BYPASS: u32 = 4294910511;
pub const XSHAL_STRICT_CACHEATTR_DEFAULT: u32 = 4294906143;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_TRAPNULL_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_ISS_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_PIPE_REGIONS: u32 = 0;
pub const XSHAL_ISS_SDRAM_REGIONS: u32 = 0;
pub const XSHAL_XT2000_CACHEATTR_WRITEBACK: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITEALLOC: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITETHRU: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_BYPASS: u32 = 4280427055;
pub const XSHAL_XT2000_CACHEATTR_DEFAULT: u32 = 4280422687;
pub const XSHAL_XT2000_PIPE_REGIONS: u32 = 0;
pub const XSHAL_XT2000_SDRAM_REGIONS: u32 = 1088;
pub const XSHAL_VECTORS_PACKED: u32 = 0;
pub const XSHAL_STATIC_VECTOR_SELECT: u32 = 1;
pub const XSHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_SIZE: u32 = 768;
pub const XSHAL_RESET_VECTOR_ISROM: u32 = 0;
pub const XSHAL_USER_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USER_VECTOR_ISROM: u32 = 0;
pub const XSHAL_PROGRAMEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USEREXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_ISROM: u32 = 0;
pub const XSHAL_STACKEDEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNELEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DOUBLEEXC_VECTOR_SIZE: u32 = 64;
pub const XSHAL_DOUBLEEXC_VECTOR_ISROM: u32 = 0;
pub const XSHAL_WINDOW_VECTORS_SIZE: u32 = 376;
pub const XSHAL_WINDOW_VECTORS_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL2_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL2_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL3_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL3_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL4_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL4_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL5_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL5_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL6_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL6_VECTOR_ISROM: u32 = 0;
pub const XSHAL_DEBUG_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DEBUG_VECTOR_ISROM: u32 = 0;
pub const XSHAL_NMI_VECTOR_SIZE: u32 = 56;
pub const XSHAL_NMI_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL7_VECTOR_SIZE: u32 = 56;
pub const EXCCAUSE_EXCCAUSE_SHIFT: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_MASK: u32 = 63;
pub const EXCCAUSE_ILLEGAL: u32 = 0;
pub const EXCCAUSE_SYSCALL: u32 = 1;
pub const EXCCAUSE_INSTR_ERROR: u32 = 2;
pub const EXCCAUSE_IFETCHERROR: u32 = 2;
pub const EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const EXCCAUSE_LOADSTOREERROR: u32 = 3;
pub const EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const EXCCAUSE_LEVEL1INTERRUPT: u32 = 4;
pub const EXCCAUSE_ALLOCA: u32 = 5;
pub const EXCCAUSE_DIVIDE_BY_ZERO: u32 = 6;
pub const EXCCAUSE_SPECULATION: u32 = 7;
pub const EXCCAUSE_PRIVILEGED: u32 = 8;
pub const EXCCAUSE_UNALIGNED: u32 = 9;
pub const EXCCAUSE_INSTR_DATA_ERROR: u32 = 12;
pub const EXCCAUSE_LOAD_STORE_DATA_ERROR: u32 = 13;
pub const EXCCAUSE_INSTR_ADDR_ERROR: u32 = 14;
pub const EXCCAUSE_LOAD_STORE_ADDR_ERROR: u32 = 15;
pub const EXCCAUSE_ITLB_MISS: u32 = 16;
pub const EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const EXCCAUSE_INSTR_RING: u32 = 18;
pub const EXCCAUSE_INSTR_PROHIBITED: u32 = 20;
pub const EXCCAUSE_DTLB_MISS: u32 = 24;
pub const EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const EXCCAUSE_LOAD_STORE_RING: u32 = 26;
pub const EXCCAUSE_LOAD_PROHIBITED: u32 = 28;
pub const EXCCAUSE_STORE_PROHIBITED: u32 = 29;
pub const EXCCAUSE_CP0_DISABLED: u32 = 32;
pub const EXCCAUSE_CP1_DISABLED: u32 = 33;
pub const EXCCAUSE_CP2_DISABLED: u32 = 34;
pub const EXCCAUSE_CP3_DISABLED: u32 = 35;
pub const EXCCAUSE_CP4_DISABLED: u32 = 36;
pub const EXCCAUSE_CP5_DISABLED: u32 = 37;
pub const EXCCAUSE_CP6_DISABLED: u32 = 38;
pub const EXCCAUSE_CP7_DISABLED: u32 = 39;
pub const PS_WOE_SHIFT: u32 = 18;
pub const PS_WOE_MASK: u32 = 262144;
pub const PS_WOE: u32 = 262144;
pub const PS_CALLINC_SHIFT: u32 = 16;
pub const PS_CALLINC_MASK: u32 = 196608;
pub const PS_OWB_SHIFT: u32 = 8;
pub const PS_OWB_MASK: u32 = 3840;
pub const PS_RING_SHIFT: u32 = 6;
pub const PS_RING_MASK: u32 = 192;
pub const PS_UM_SHIFT: u32 = 5;
pub const PS_UM_MASK: u32 = 32;
pub const PS_UM: u32 = 32;
pub const PS_EXCM_SHIFT: u32 = 4;
pub const PS_EXCM_MASK: u32 = 16;
pub const PS_EXCM: u32 = 16;
pub const PS_INTLEVEL_SHIFT: u32 = 0;
pub const PS_INTLEVEL_MASK: u32 = 15;
pub const PS_PROGSTACK_SHIFT: u32 = 5;
pub const PS_PROGSTACK_MASK: u32 = 32;
pub const PS_PROG_SHIFT: u32 = 5;
pub const PS_PROG_MASK: u32 = 32;
pub const PS_PROG: u32 = 32;
pub const DBREAKC_MASK_SHIFT: u32 = 0;
pub const DBREAKC_MASK_MASK: u32 = 63;
pub const DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const MESR_MEME: u32 = 1;
pub const MESR_MEME_SHIFT: u32 = 0;
pub const MESR_DME: u32 = 2;
pub const MESR_DME_SHIFT: u32 = 1;
pub const MESR_RCE: u32 = 16;
pub const MESR_RCE_SHIFT: u32 = 4;
pub const MESR_ERRENAB: u32 = 256;
pub const MESR_ERRENAB_SHIFT: u32 = 8;
pub const MESR_ERRTEST: u32 = 512;
pub const MESR_ERRTEST_SHIFT: u32 = 9;
pub const MESR_DATEXC: u32 = 1024;
pub const MESR_DATEXC_SHIFT: u32 = 10;
pub const MESR_INSEXC: u32 = 2048;
pub const MESR_INSEXC_SHIFT: u32 = 11;
pub const MESR_WAYNUM_SHIFT: u32 = 16;
pub const MESR_ACCTYPE_SHIFT: u32 = 20;
pub const MESR_MEMTYPE_SHIFT: u32 = 24;
pub const MESR_ERRTYPE_SHIFT: u32 = 30;
pub const MEMCTL_SNOOP_EN_SHIFT: u32 = 1;
pub const MEMCTL_SNOOP_EN: u32 = 2;
pub const MEMCTL_L0IBUF_EN_SHIFT: u32 = 0;
pub const MEMCTL_L0IBUF_EN: u32 = 1;
pub const MEMCTL_INV_EN_SHIFT: u32 = 23;
pub const MEMCTL_INV_EN: u32 = 8388608;
pub const MEMCTL_DCWU_SHIFT: u32 = 8;
pub const MEMCTL_DCWU_BITS: u32 = 5;
pub const MEMCTL_DCWA_SHIFT: u32 = 13;
pub const MEMCTL_DCWA_BITS: u32 = 5;
pub const MEMCTL_ICWU_SHIFT: u32 = 18;
pub const MEMCTL_ICWU_BITS: u32 = 5;
pub const MEMCTL_DCWU_MASK: u32 = 7936;
pub const MEMCTL_DCWA_MASK: u32 = 253952;
pub const MEMCTL_ICWU_MASK: u32 = 8126464;
pub const MEMCTL_DCWU_CLR_MASK: i32 = -7937;
pub const MEMCTL_DCWA_CLR_MASK: i32 = -253953;
pub const MEMCTL_ICWU_CLR_MASK: i32 = -8126465;
pub const MEMCTL_DCW_CLR_MASK: i32 = -1;
pub const MEMCTL_IDCW_CLR_MASK: i32 = -1;
pub const CALL0_ABI: u32 = 0;
pub const ALIGNPAD: u32 = 2;
pub const KERNELSTACKSIZE: u32 = 1024;
pub const XT_CP0_SA: u32 = 0;
pub const XT_CPENABLE: u32 = 0;
pub const XT_CPSTORED: u32 = 2;
pub const XT_CP_CS_ST: u32 = 4;
pub const XT_CP_ASA: u32 = 8;
pub const CORE_ID_PRO: u32 = 52685;
pub const CORE_ID_APP: u32 = 43947;
pub const STK_INTEXC_EXTRA: u32 = 0;
pub const XT_CLIB_CONTEXT_AREA_SIZE: u32 = 0;
pub const XT_USER_SIZE: u32 = 1024;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __XSI_VISIBLE: u32 = 700;
pub const __BSD_VISIBLE: u32 = 1;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const PRO_CPU_NUM: u32 = 0;
pub const APP_CPU_NUM: u32 = 1;
pub const SOC_IROM_LOW: u32 = 1074593792;
pub const SOC_IROM_HIGH: u32 = 1077936128;
pub const SOC_DROM_LOW: u32 = 1061158912;
pub const SOC_DROM_HIGH: u32 = 1065353216;
pub const SOC_DRAM_LOW: u32 = 1068367872;
pub const SOC_DRAM_HIGH: u32 = 1073741824;
pub const SOC_RTC_IRAM_LOW: u32 = 1074528256;
pub const SOC_RTC_IRAM_HIGH: u32 = 1074536448;
pub const SOC_RTC_DATA_LOW: u32 = 1342177280;
pub const SOC_RTC_DATA_HIGH: u32 = 1342185472;
pub const SOC_EXTRAM_DATA_LOW: u32 = 1065353216;
pub const SOC_EXTRAM_DATA_HIGH: u32 = 1069547520;
pub const SOC_MAX_CONTIGUOUS_RAM_SIZE: u32 = 4194304;
pub const DR_REG_DPORT_BASE: u32 = 1072693248;
pub const DR_REG_AES_BASE: u32 = 1072697344;
pub const DR_REG_RSA_BASE: u32 = 1072701440;
pub const DR_REG_SHA_BASE: u32 = 1072705536;
pub const DR_REG_FLASH_MMU_TABLE_PRO: u32 = 1072758784;
pub const DR_REG_FLASH_MMU_TABLE_APP: u32 = 1072766976;
pub const DR_REG_DPORT_END: u32 = 1072775164;
pub const DR_REG_UART_BASE: u32 = 1072955392;
pub const DR_REG_SPI1_BASE: u32 = 1072963584;
pub const DR_REG_SPI0_BASE: u32 = 1072967680;
pub const DR_REG_GPIO_BASE: u32 = 1072971776;
pub const DR_REG_GPIO_SD_BASE: u32 = 1072975616;
pub const DR_REG_FE2_BASE: u32 = 1072975872;
pub const DR_REG_FE_BASE: u32 = 1072979968;
pub const DR_REG_FRC_TIMER_BASE: u32 = 1072984064;
pub const DR_REG_RTCCNTL_BASE: u32 = 1072988160;
pub const DR_REG_RTCIO_BASE: u32 = 1072989184;
pub const DR_REG_SENS_BASE: u32 = 1072990208;
pub const DR_REG_RTC_I2C_BASE: u32 = 1072991232;
pub const DR_REG_IO_MUX_BASE: u32 = 1072992256;
pub const DR_REG_HINF_BASE: u32 = 1073000448;
pub const DR_REG_UHCI1_BASE: u32 = 1073004544;
pub const DR_REG_I2S_BASE: u32 = 1073016832;
pub const DR_REG_UART1_BASE: u32 = 1073020928;
pub const DR_REG_BT_BASE: u32 = 1073025024;
pub const DR_REG_I2C_EXT_BASE: u32 = 1073033216;
pub const DR_REG_UHCI0_BASE: u32 = 1073037312;
pub const DR_REG_SLCHOST_BASE: u32 = 1073041408;
pub const DR_REG_RMT_BASE: u32 = 1073045504;
pub const DR_REG_PCNT_BASE: u32 = 1073049600;
pub const DR_REG_SLC_BASE: u32 = 1073053696;
pub const DR_REG_LEDC_BASE: u32 = 1073057792;
pub const DR_REG_EFUSE_BASE: u32 = 1073061888;
pub const DR_REG_SPI_ENCRYPT_BASE: u32 = 1073065984;
pub const DR_REG_NRX_BASE: u32 = 1073073152;
pub const DR_REG_BB_BASE: u32 = 1073074176;
pub const DR_REG_PWM_BASE: u32 = 1073078272;
pub const DR_REG_TIMERGROUP0_BASE: u32 = 1073082368;
pub const DR_REG_TIMERGROUP1_BASE: u32 = 1073086464;
pub const DR_REG_RTCMEM0_BASE: u32 = 1073090560;
pub const DR_REG_RTCMEM1_BASE: u32 = 1073094656;
pub const DR_REG_RTCMEM2_BASE: u32 = 1073098752;
pub const DR_REG_SPI2_BASE: u32 = 1073102848;
pub const DR_REG_SPI3_BASE: u32 = 1073106944;
pub const DR_REG_SYSCON_BASE: u32 = 1073111040;
pub const DR_REG_APB_CTRL_BASE: u32 = 1073111040;
pub const DR_REG_I2C1_EXT_BASE: u32 = 1073115136;
pub const DR_REG_SDMMC_BASE: u32 = 1073119232;
pub const DR_REG_EMAC_BASE: u32 = 1073123328;
pub const DR_REG_CAN_BASE: u32 = 1073131520;
pub const DR_REG_PWM1_BASE: u32 = 1073135616;
pub const DR_REG_I2S1_BASE: u32 = 1073139712;
pub const DR_REG_UART2_BASE: u32 = 1073143808;
pub const DR_REG_PWM2_BASE: u32 = 1073147904;
pub const DR_REG_PWM3_BASE: u32 = 1073152000;
pub const PERIPHS_SPI_ENCRYPT_BASEADDR: u32 = 1073065984;
pub const APB_CLK_FREQ_ROM: u32 = 26000000;
pub const CPU_CLK_FREQ_ROM: u32 = 26000000;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const REF_CLK_FREQ: u32 = 1000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const WDT_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 5000000;
pub const SPI_CLK_DIV: u32 = 4;
pub const TICKS_PER_US_ROM: u32 = 26;
pub const SOC_IROM_MASK_LOW: u32 = 1073741824;
pub const SOC_IROM_MASK_HIGH: u32 = 1074200576;
pub const SOC_CACHE_PRO_LOW: u32 = 1074200576;
pub const SOC_CACHE_PRO_HIGH: u32 = 1074233344;
pub const SOC_CACHE_APP_LOW: u32 = 1074233344;
pub const SOC_CACHE_APP_HIGH: u32 = 1074266112;
pub const SOC_IRAM_LOW: u32 = 1074266112;
pub const SOC_IRAM_HIGH: u32 = 1074397184;
pub const SOC_RTC_DRAM_LOW: u32 = 1073217536;
pub const SOC_RTC_DRAM_HIGH: u32 = 1073225728;
pub const SOC_DIRAM_IRAM_LOW: u32 = 1074397184;
pub const SOC_DIRAM_IRAM_HIGH: u32 = 1074528252;
pub const SOC_DIRAM_DRAM_LOW: u32 = 1073610752;
pub const SOC_DIRAM_DRAM_HIGH: u32 = 1073741820;
pub const SOC_DMA_LOW: u32 = 1073405952;
pub const SOC_DMA_HIGH: u32 = 1073741824;
pub const SOC_BYTE_ACCESSIBLE_LOW: u32 = 1073283072;
pub const SOC_BYTE_ACCESSIBLE_HIGH: u32 = 1073741824;
pub const SOC_MEM_INTERNAL_LOW: u32 = 1073283072;
pub const SOC_MEM_INTERNAL_HIGH: u32 = 1074536448;
pub const ETS_WIFI_MAC_INTR_SOURCE: u32 = 0;
pub const ETS_WIFI_MAC_NMI_SOURCE: u32 = 1;
pub const ETS_WIFI_BB_INTR_SOURCE: u32 = 2;
pub const ETS_BT_MAC_INTR_SOURCE: u32 = 3;
pub const ETS_BT_BB_INTR_SOURCE: u32 = 4;
pub const ETS_BT_BB_NMI_SOURCE: u32 = 5;
pub const ETS_RWBT_INTR_SOURCE: u32 = 6;
pub const ETS_RWBLE_INTR_SOURCE: u32 = 7;
pub const ETS_RWBT_NMI_SOURCE: u32 = 8;
pub const ETS_RWBLE_NMI_SOURCE: u32 = 9;
pub const ETS_SLC0_INTR_SOURCE: u32 = 10;
pub const ETS_SLC1_INTR_SOURCE: u32 = 11;
pub const ETS_UHCI0_INTR_SOURCE: u32 = 12;
pub const ETS_UHCI1_INTR_SOURCE: u32 = 13;
pub const ETS_TG0_T0_LEVEL_INTR_SOURCE: u32 = 14;
pub const ETS_TG0_T1_LEVEL_INTR_SOURCE: u32 = 15;
pub const ETS_TG0_WDT_LEVEL_INTR_SOURCE: u32 = 16;
pub const ETS_TG0_LACT_LEVEL_INTR_SOURCE: u32 = 17;
pub const ETS_TG1_T0_LEVEL_INTR_SOURCE: u32 = 18;
pub const ETS_TG1_T1_LEVEL_INTR_SOURCE: u32 = 19;
pub const ETS_TG1_WDT_LEVEL_INTR_SOURCE: u32 = 20;
pub const ETS_TG1_LACT_LEVEL_INTR_SOURCE: u32 = 21;
pub const ETS_GPIO_INTR_SOURCE: u32 = 22;
pub const ETS_GPIO_NMI_SOURCE: u32 = 23;
pub const ETS_FROM_CPU_INTR0_SOURCE: u32 = 24;
pub const ETS_FROM_CPU_INTR1_SOURCE: u32 = 25;
pub const ETS_FROM_CPU_INTR2_SOURCE: u32 = 26;
pub const ETS_FROM_CPU_INTR3_SOURCE: u32 = 27;
pub const ETS_SPI0_INTR_SOURCE: u32 = 28;
pub const ETS_SPI1_INTR_SOURCE: u32 = 29;
pub const ETS_SPI2_INTR_SOURCE: u32 = 30;
pub const ETS_SPI3_INTR_SOURCE: u32 = 31;
pub const ETS_I2S0_INTR_SOURCE: u32 = 32;
pub const ETS_I2S1_INTR_SOURCE: u32 = 33;
pub const ETS_UART0_INTR_SOURCE: u32 = 34;
pub const ETS_UART1_INTR_SOURCE: u32 = 35;
pub const ETS_UART2_INTR_SOURCE: u32 = 36;
pub const ETS_SDIO_HOST_INTR_SOURCE: u32 = 37;
pub const ETS_ETH_MAC_INTR_SOURCE: u32 = 38;
pub const ETS_PWM0_INTR_SOURCE: u32 = 39;
pub const ETS_PWM1_INTR_SOURCE: u32 = 40;
pub const ETS_PWM2_INTR_SOURCE: u32 = 41;
pub const ETS_PWM3_INTR_SOURCE: u32 = 42;
pub const ETS_LEDC_INTR_SOURCE: u32 = 43;
pub const ETS_EFUSE_INTR_SOURCE: u32 = 44;
pub const ETS_CAN_INTR_SOURCE: u32 = 45;
pub const ETS_RTC_CORE_INTR_SOURCE: u32 = 46;
pub const ETS_RMT_INTR_SOURCE: u32 = 47;
pub const ETS_PCNT_INTR_SOURCE: u32 = 48;
pub const ETS_I2C_EXT0_INTR_SOURCE: u32 = 49;
pub const ETS_I2C_EXT1_INTR_SOURCE: u32 = 50;
pub const ETS_RSA_INTR_SOURCE: u32 = 51;
pub const ETS_SPI1_DMA_INTR_SOURCE: u32 = 52;
pub const ETS_SPI2_DMA_INTR_SOURCE: u32 = 53;
pub const ETS_SPI3_DMA_INTR_SOURCE: u32 = 54;
pub const ETS_WDT_INTR_SOURCE: u32 = 55;
pub const ETS_TIMER1_INTR_SOURCE: u32 = 56;
pub const ETS_TIMER2_INTR_SOURCE: u32 = 57;
pub const ETS_TG0_T0_EDGE_INTR_SOURCE: u32 = 58;
pub const ETS_TG0_T1_EDGE_INTR_SOURCE: u32 = 59;
pub const ETS_TG0_WDT_EDGE_INTR_SOURCE: u32 = 60;
pub const ETS_TG0_LACT_EDGE_INTR_SOURCE: u32 = 61;
pub const ETS_TG1_T0_EDGE_INTR_SOURCE: u32 = 62;
pub const ETS_TG1_T1_EDGE_INTR_SOURCE: u32 = 63;
pub const ETS_TG1_WDT_EDGE_INTR_SOURCE: u32 = 64;
pub const ETS_TG1_LACT_EDGE_INTR_SOURCE: u32 = 65;
pub const ETS_MMU_IA_INTR_SOURCE: u32 = 66;
pub const ETS_MPU_IA_INTR_SOURCE: u32 = 67;
pub const ETS_CACHE_IA_INTR_SOURCE: u32 = 68;
pub const ETS_WMAC_INUM: u32 = 0;
pub const ETS_BT_HOST_INUM: u32 = 1;
pub const ETS_WBB_INUM: u32 = 4;
pub const ETS_TG0_T1_INUM: u32 = 10;
pub const ETS_FRC1_INUM: u32 = 22;
pub const ETS_T1_WDT_INUM: u32 = 24;
pub const ETS_CACHEERR_INUM: u32 = 25;
pub const ETS_DPORT_INUM: u32 = 28;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_UART0_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_INVALID_INUM: u32 = 6;
pub const MACSTR: &'static [u8; 30usize] = b"%02x:%02x:%02x:%02x:%02x:%02x\0";
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 1;
pub const configUSE_TICK_HOOK: u32 = 1;
pub const configTICK_RATE_HZ: u32 = 100;
pub const configMAX_PRIORITIES: u32 = 25;
pub const configMINIMAL_STACK_SIZE: u32 = 768;
pub const configIDLE_TASK_STACK_SIZE: u32 = 1536;
pub const configISR_STACK_SIZE: u32 = 1536;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 1;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configUSE_TRACE_FACILITY_2: u32 = 0;
pub const configBENCHMARK: u32 = 0;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 0;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 1;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const INCLUDE_pcTaskGetTaskName: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 1;
pub const INCLUDE_pxTaskGetStackStart: u32 = 1;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 1;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 1;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 3;
pub const configUSE_NEWLIB_REENTRANT: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configUSE_TIMERS: u32 = 1;
pub const configTIMER_TASK_PRIORITY: u32 = 1;
pub const configTIMER_QUEUE_LENGTH: u32 = 10;
pub const configTIMER_TASK_STACK_DEPTH: u32 = 8192;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 1;
pub const INCLUDE_eTaskGetState: u32 = 1;
pub const configUSE_QUEUE_SETS: u32 = 1;
pub const configXT_BOARD: u32 = 1;
pub const configXT_SIMULATOR: u32 = 0;
pub const configENABLE_TASK_SNAPSHOT: u32 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const LBEG: u32 = 0;
pub const LEND: u32 = 1;
pub const LCOUNT: u32 = 2;
pub const SAR: u32 = 3;
pub const BR: u32 = 4;
pub const SCOMPARE1: u32 = 12;
pub const ACCLO: u32 = 16;
pub const ACCHI: u32 = 17;
pub const MR_0: u32 = 32;
pub const MR_1: u32 = 33;
pub const MR_2: u32 = 34;
pub const MR_3: u32 = 35;
pub const WINDOWBASE: u32 = 72;
pub const WINDOWSTART: u32 = 73;
pub const IBREAKENABLE: u32 = 96;
pub const MEMCTL: u32 = 97;
pub const ATOMCTL: u32 = 99;
pub const DDR: u32 = 104;
pub const IBREAKA_0: u32 = 128;
pub const IBREAKA_1: u32 = 129;
pub const DBREAKA_0: u32 = 144;
pub const DBREAKA_1: u32 = 145;
pub const DBREAKC_0: u32 = 160;
pub const DBREAKC_1: u32 = 161;
pub const EPC_1: u32 = 177;
pub const EPC_2: u32 = 178;
pub const EPC_3: u32 = 179;
pub const EPC_4: u32 = 180;
pub const EPC_5: u32 = 181;
pub const EPC_6: u32 = 182;
pub const EPC_7: u32 = 183;
pub const DEPC: u32 = 192;
pub const EPS_2: u32 = 194;
pub const EPS_3: u32 = 195;
pub const EPS_4: u32 = 196;
pub const EPS_5: u32 = 197;
pub const EPS_6: u32 = 198;
pub const EPS_7: u32 = 199;
pub const EXCSAVE_1: u32 = 209;
pub const EXCSAVE_2: u32 = 210;
pub const EXCSAVE_3: u32 = 211;
pub const EXCSAVE_4: u32 = 212;
pub const EXCSAVE_5: u32 = 213;
pub const EXCSAVE_6: u32 = 214;
pub const EXCSAVE_7: u32 = 215;
pub const CPENABLE: u32 = 224;
pub const INTERRUPT: u32 = 226;
pub const INTENABLE: u32 = 228;
pub const PS: u32 = 230;
pub const VECBASE: u32 = 231;
pub const EXCCAUSE: u32 = 232;
pub const DEBUGCAUSE: u32 = 233;
pub const CCOUNT: u32 = 234;
pub const PRID: u32 = 235;
pub const ICOUNT: u32 = 236;
pub const ICOUNTLEVEL: u32 = 237;
pub const EXCVADDR: u32 = 238;
pub const CCOMPARE_0: u32 = 240;
pub const CCOMPARE_1: u32 = 241;
pub const CCOMPARE_2: u32 = 242;
pub const MISC_REG_0: u32 = 244;
pub const MISC_REG_1: u32 = 245;
pub const MISC_REG_2: u32 = 246;
pub const MISC_REG_3: u32 = 247;
pub const MR: u32 = 32;
pub const IBREAKA: u32 = 128;
pub const DBREAKA: u32 = 144;
pub const DBREAKC: u32 = 160;
pub const EPC: u32 = 176;
pub const EPS: u32 = 192;
pub const EXCSAVE: u32 = 208;
pub const CCOMPARE: u32 = 240;
pub const INTREAD: u32 = 226;
pub const INTSET: u32 = 226;
pub const INTCLEAR: u32 = 227;
pub const CORE_STATE_SIGNATURE: u32 = 2982522861;
pub const XTOS_KEEPON_MEM: u32 = 256;
pub const XTOS_KEEPON_MEM_SHIFT: u32 = 8;
pub const XTOS_KEEPON_DEBUG: u32 = 4096;
pub const XTOS_KEEPON_DEBUG_SHIFT: u32 = 12;
pub const XTOS_COREF_PSO: u32 = 1;
pub const XTOS_COREF_PSO_SHIFT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_cuserid: u32 = 9;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const MALLOC_CAP_EXEC: u32 = 1;
pub const MALLOC_CAP_32BIT: u32 = 2;
pub const MALLOC_CAP_8BIT: u32 = 4;
pub const MALLOC_CAP_DMA: u32 = 8;
pub const MALLOC_CAP_PID2: u32 = 16;
pub const MALLOC_CAP_PID3: u32 = 32;
pub const MALLOC_CAP_PID4: u32 = 64;
pub const MALLOC_CAP_PID5: u32 = 128;
pub const MALLOC_CAP_PID6: u32 = 256;
pub const MALLOC_CAP_PID7: u32 = 512;
pub const MALLOC_CAP_SPIRAM: u32 = 1024;
pub const MALLOC_CAP_INTERNAL: u32 = 2048;
pub const MALLOC_CAP_DEFAULT: u32 = 4096;
pub const MALLOC_CAP_INVALID: u32 = 2147483648;
pub const SOC_MEMORY_TYPE_NO_PRIOS: u32 = 3;
pub const portMUX_FREE_VAL: u32 = 3007315967;
pub const portMUX_NO_TIMEOUT: i32 = -1;
pub const portMUX_TRY_LOCK: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 1;
pub const portTcbMemoryCaps: u32 = 2052;
pub const portStackMemoryCaps: u32 = 2052;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 4;
pub const portBYTE_ALIGNMENT_MASK: u32 = 3;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const GPIO_BT_SELECT_REG: u32 = 1072971776;
pub const GPIO_BT_SEL: u32 = 4294967295;
pub const GPIO_BT_SEL_V: u32 = 4294967295;
pub const GPIO_BT_SEL_S: u32 = 0;
pub const GPIO_OUT_REG: u32 = 1072971780;
pub const GPIO_OUT_DATA: u32 = 4294967295;
pub const GPIO_OUT_DATA_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_S: u32 = 0;
pub const GPIO_OUT_W1TS_REG: u32 = 1072971784;
pub const GPIO_OUT_DATA_W1TS: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT_W1TC_REG: u32 = 1072971788;
pub const GPIO_OUT_DATA_W1TC: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_S: u32 = 0;
pub const GPIO_OUT1_REG: u32 = 1072971792;
pub const GPIO_OUT1_DATA: u32 = 255;
pub const GPIO_OUT1_DATA_V: u32 = 255;
pub const GPIO_OUT1_DATA_S: u32 = 0;
pub const GPIO_OUT1_W1TS_REG: u32 = 1072971796;
pub const GPIO_OUT1_DATA_W1TS: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT1_W1TC_REG: u32 = 1072971800;
pub const GPIO_OUT1_DATA_W1TC: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_S: u32 = 0;
pub const GPIO_SDIO_SELECT_REG: u32 = 1072971804;
pub const GPIO_SDIO_SEL: u32 = 255;
pub const GPIO_SDIO_SEL_V: u32 = 255;
pub const GPIO_SDIO_SEL_S: u32 = 0;
pub const GPIO_ENABLE_REG: u32 = 1072971808;
pub const GPIO_ENABLE_DATA: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_S: u32 = 0;
pub const GPIO_ENABLE_W1TS_REG: u32 = 1072971812;
pub const GPIO_ENABLE_DATA_W1TS: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE_W1TC_REG: u32 = 1072971816;
pub const GPIO_ENABLE_DATA_W1TC: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_S: u32 = 0;
pub const GPIO_ENABLE1_REG: u32 = 1072971820;
pub const GPIO_ENABLE1_DATA: u32 = 255;
pub const GPIO_ENABLE1_DATA_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_S: u32 = 0;
pub const GPIO_ENABLE1_W1TS_REG: u32 = 1072971824;
pub const GPIO_ENABLE1_DATA_W1TS: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE1_W1TC_REG: u32 = 1072971828;
pub const GPIO_ENABLE1_DATA_W1TC: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_S: u32 = 0;
pub const GPIO_STRAP_REG: u32 = 1072971832;
pub const GPIO_STRAPPING: u32 = 65535;
pub const GPIO_STRAPPING_V: u32 = 65535;
pub const GPIO_STRAPPING_S: u32 = 0;
pub const GPIO_IN_REG: u32 = 1072971836;
pub const GPIO_IN_DATA: u32 = 4294967295;
pub const GPIO_IN_DATA_V: u32 = 4294967295;
pub const GPIO_IN_DATA_S: u32 = 0;
pub const GPIO_IN1_REG: u32 = 1072971840;
pub const GPIO_IN1_DATA: u32 = 255;
pub const GPIO_IN1_DATA_V: u32 = 255;
pub const GPIO_IN1_DATA_S: u32 = 0;
pub const GPIO_STATUS_REG: u32 = 1072971844;
pub const GPIO_STATUS_INT: u32 = 4294967295;
pub const GPIO_STATUS_INT_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_S: u32 = 0;
pub const GPIO_STATUS_W1TS_REG: u32 = 1072971848;
pub const GPIO_STATUS_INT_W1TS: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS_W1TC_REG: u32 = 1072971852;
pub const GPIO_STATUS_INT_W1TC: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_S: u32 = 0;
pub const GPIO_STATUS1_REG: u32 = 1072971856;
pub const GPIO_STATUS1_INT: u32 = 255;
pub const GPIO_STATUS1_INT_V: u32 = 255;
pub const GPIO_STATUS1_INT_S: u32 = 0;
pub const GPIO_STATUS1_W1TS_REG: u32 = 1072971860;
pub const GPIO_STATUS1_INT_W1TS: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS1_W1TC_REG: u32 = 1072971864;
pub const GPIO_STATUS1_INT_W1TC: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_S: u32 = 0;
pub const GPIO_ACPU_INT_REG: u32 = 1072971872;
pub const GPIO_APPCPU_INT: u32 = 4294967295;
pub const GPIO_APPCPU_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_INT_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT_REG: u32 = 1072971876;
pub const GPIO_APPCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_S: u32 = 0;
pub const GPIO_PCPU_INT_REG: u32 = 1072971880;
pub const GPIO_PROCPU_INT: u32 = 4294967295;
pub const GPIO_PROCPU_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_INT_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT_REG: u32 = 1072971884;
pub const GPIO_PROCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_S: u32 = 0;
pub const GPIO_CPUSDIO_INT_REG: u32 = 1072971888;
pub const GPIO_SDIO_INT: u32 = 4294967295;
pub const GPIO_SDIO_INT_V: u32 = 4294967295;
pub const GPIO_SDIO_INT_S: u32 = 0;
pub const GPIO_ACPU_INT1_REG: u32 = 1072971892;
pub const GPIO_APPCPU_INT_H: u32 = 255;
pub const GPIO_APPCPU_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_INT_H_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT1_REG: u32 = 1072971896;
pub const GPIO_APPCPU_NMI_INT_H: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_PCPU_INT1_REG: u32 = 1072971900;
pub const GPIO_PROCPU_INT_H: u32 = 255;
pub const GPIO_PROCPU_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_INT_H_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT1_REG: u32 = 1072971904;
pub const GPIO_PROCPU_NMI_INT_H: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_CPUSDIO_INT1_REG: u32 = 1072971908;
pub const GPIO_SDIO_INT_H: u32 = 255;
pub const GPIO_SDIO_INT_H_V: u32 = 255;
pub const GPIO_SDIO_INT_H_S: u32 = 0;
pub const GPIO_PIN_INT_ENA: u32 = 31;
pub const GPIO_PIN_INT_ENA_V: u32 = 31;
pub const GPIO_PIN_INT_ENA_S: u32 = 13;
pub const GPIO_PIN_CONFIG: u32 = 3;
pub const GPIO_PIN_CONFIG_V: u32 = 3;
pub const GPIO_PIN_CONFIG_S: u32 = 11;
pub const GPIO_PIN_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN_INT_TYPE: u32 = 7;
pub const GPIO_PIN_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN0_REG: u32 = 1072971912;
pub const GPIO_PIN0_INT_ENA: u32 = 31;
pub const GPIO_PIN0_INT_ENA_V: u32 = 31;
pub const GPIO_PIN0_INT_ENA_S: u32 = 13;
pub const GPIO_PIN0_CONFIG: u32 = 3;
pub const GPIO_PIN0_CONFIG_V: u32 = 3;
pub const GPIO_PIN0_CONFIG_S: u32 = 11;
pub const GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN0_INT_TYPE: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN0_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN0_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN1_REG: u32 = 1072971916;
pub const GPIO_PIN1_INT_ENA: u32 = 31;
pub const GPIO_PIN1_INT_ENA_V: u32 = 31;
pub const GPIO_PIN1_INT_ENA_S: u32 = 13;
pub const GPIO_PIN1_CONFIG: u32 = 3;
pub const GPIO_PIN1_CONFIG_V: u32 = 3;
pub const GPIO_PIN1_CONFIG_S: u32 = 11;
pub const GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN1_INT_TYPE: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN1_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN1_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN2_REG: u32 = 1072971920;
pub const GPIO_PIN2_INT_ENA: u32 = 31;
pub const GPIO_PIN2_INT_ENA_V: u32 = 31;
pub const GPIO_PIN2_INT_ENA_S: u32 = 13;
pub const GPIO_PIN2_CONFIG: u32 = 3;
pub const GPIO_PIN2_CONFIG_V: u32 = 3;
pub const GPIO_PIN2_CONFIG_S: u32 = 11;
pub const GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN2_INT_TYPE: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN2_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN2_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN3_REG: u32 = 1072971924;
pub const GPIO_PIN3_INT_ENA: u32 = 31;
pub const GPIO_PIN3_INT_ENA_V: u32 = 31;
pub const GPIO_PIN3_INT_ENA_S: u32 = 13;
pub const GPIO_PIN3_CONFIG: u32 = 3;
pub const GPIO_PIN3_CONFIG_V: u32 = 3;
pub const GPIO_PIN3_CONFIG_S: u32 = 11;
pub const GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN3_INT_TYPE: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN3_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN3_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN4_REG: u32 = 1072971928;
pub const GPIO_PIN4_INT_ENA: u32 = 31;
pub const GPIO_PIN4_INT_ENA_V: u32 = 31;
pub const GPIO_PIN4_INT_ENA_S: u32 = 13;
pub const GPIO_PIN4_CONFIG: u32 = 3;
pub const GPIO_PIN4_CONFIG_V: u32 = 3;
pub const GPIO_PIN4_CONFIG_S: u32 = 11;
pub const GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN4_INT_TYPE: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN4_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN4_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN5_REG: u32 = 1072971932;
pub const GPIO_PIN5_INT_ENA: u32 = 31;
pub const GPIO_PIN5_INT_ENA_V: u32 = 31;
pub const GPIO_PIN5_INT_ENA_S: u32 = 13;
pub const GPIO_PIN5_CONFIG: u32 = 3;
pub const GPIO_PIN5_CONFIG_V: u32 = 3;
pub const GPIO_PIN5_CONFIG_S: u32 = 11;
pub const GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN5_INT_TYPE: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN5_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN5_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN6_REG: u32 = 1072971936;
pub const GPIO_PIN6_INT_ENA: u32 = 31;
pub const GPIO_PIN6_INT_ENA_V: u32 = 31;
pub const GPIO_PIN6_INT_ENA_S: u32 = 13;
pub const GPIO_PIN6_CONFIG: u32 = 3;
pub const GPIO_PIN6_CONFIG_V: u32 = 3;
pub const GPIO_PIN6_CONFIG_S: u32 = 11;
pub const GPIO_PIN6_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN6_INT_TYPE: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN6_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN6_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN7_REG: u32 = 1072971940;
pub const GPIO_PIN7_INT_ENA: u32 = 31;
pub const GPIO_PIN7_INT_ENA_V: u32 = 31;
pub const GPIO_PIN7_INT_ENA_S: u32 = 13;
pub const GPIO_PIN7_CONFIG: u32 = 3;
pub const GPIO_PIN7_CONFIG_V: u32 = 3;
pub const GPIO_PIN7_CONFIG_S: u32 = 11;
pub const GPIO_PIN7_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN7_INT_TYPE: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN7_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN7_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN8_REG: u32 = 1072971944;
pub const GPIO_PIN8_INT_ENA: u32 = 31;
pub const GPIO_PIN8_INT_ENA_V: u32 = 31;
pub const GPIO_PIN8_INT_ENA_S: u32 = 13;
pub const GPIO_PIN8_CONFIG: u32 = 3;
pub const GPIO_PIN8_CONFIG_V: u32 = 3;
pub const GPIO_PIN8_CONFIG_S: u32 = 11;
pub const GPIO_PIN8_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN8_INT_TYPE: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN8_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN8_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN9_REG: u32 = 1072971948;
pub const GPIO_PIN9_INT_ENA: u32 = 31;
pub const GPIO_PIN9_INT_ENA_V: u32 = 31;
pub const GPIO_PIN9_INT_ENA_S: u32 = 13;
pub const GPIO_PIN9_CONFIG: u32 = 3;
pub const GPIO_PIN9_CONFIG_V: u32 = 3;
pub const GPIO_PIN9_CONFIG_S: u32 = 11;
pub const GPIO_PIN9_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN9_INT_TYPE: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN9_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN9_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN10_REG: u32 = 1072971952;
pub const GPIO_PIN10_INT_ENA: u32 = 31;
pub const GPIO_PIN10_INT_ENA_V: u32 = 31;
pub const GPIO_PIN10_INT_ENA_S: u32 = 13;
pub const GPIO_PIN10_CONFIG: u32 = 3;
pub const GPIO_PIN10_CONFIG_V: u32 = 3;
pub const GPIO_PIN10_CONFIG_S: u32 = 11;
pub const GPIO_PIN10_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN10_INT_TYPE: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN10_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN10_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN11_REG: u32 = 1072971956;
pub const GPIO_PIN11_INT_ENA: u32 = 31;
pub const GPIO_PIN11_INT_ENA_V: u32 = 31;
pub const GPIO_PIN11_INT_ENA_S: u32 = 13;
pub const GPIO_PIN11_CONFIG: u32 = 3;
pub const GPIO_PIN11_CONFIG_V: u32 = 3;
pub const GPIO_PIN11_CONFIG_S: u32 = 11;
pub const GPIO_PIN11_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN11_INT_TYPE: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN11_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN11_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN12_REG: u32 = 1072971960;
pub const GPIO_PIN12_INT_ENA: u32 = 31;
pub const GPIO_PIN12_INT_ENA_V: u32 = 31;
pub const GPIO_PIN12_INT_ENA_S: u32 = 13;
pub const GPIO_PIN12_CONFIG: u32 = 3;
pub const GPIO_PIN12_CONFIG_V: u32 = 3;
pub const GPIO_PIN12_CONFIG_S: u32 = 11;
pub const GPIO_PIN12_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN12_INT_TYPE: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN12_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN12_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN13_REG: u32 = 1072971964;
pub const GPIO_PIN13_INT_ENA: u32 = 31;
pub const GPIO_PIN13_INT_ENA_V: u32 = 31;
pub const GPIO_PIN13_INT_ENA_S: u32 = 13;
pub const GPIO_PIN13_CONFIG: u32 = 3;
pub const GPIO_PIN13_CONFIG_V: u32 = 3;
pub const GPIO_PIN13_CONFIG_S: u32 = 11;
pub const GPIO_PIN13_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN13_INT_TYPE: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN13_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN13_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN14_REG: u32 = 1072971968;
pub const GPIO_PIN14_INT_ENA: u32 = 31;
pub const GPIO_PIN14_INT_ENA_V: u32 = 31;
pub const GPIO_PIN14_INT_ENA_S: u32 = 13;
pub const GPIO_PIN14_CONFIG: u32 = 3;
pub const GPIO_PIN14_CONFIG_V: u32 = 3;
pub const GPIO_PIN14_CONFIG_S: u32 = 11;
pub const GPIO_PIN14_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN14_INT_TYPE: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN14_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN14_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN15_REG: u32 = 1072971972;
pub const GPIO_PIN15_INT_ENA: u32 = 31;
pub const GPIO_PIN15_INT_ENA_V: u32 = 31;
pub const GPIO_PIN15_INT_ENA_S: u32 = 13;
pub const GPIO_PIN15_CONFIG: u32 = 3;
pub const GPIO_PIN15_CONFIG_V: u32 = 3;
pub const GPIO_PIN15_CONFIG_S: u32 = 11;
pub const GPIO_PIN15_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN15_INT_TYPE: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN15_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN15_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN16_REG: u32 = 1072971976;
pub const GPIO_PIN16_INT_ENA: u32 = 31;
pub const GPIO_PIN16_INT_ENA_V: u32 = 31;
pub const GPIO_PIN16_INT_ENA_S: u32 = 13;
pub const GPIO_PIN16_CONFIG: u32 = 3;
pub const GPIO_PIN16_CONFIG_V: u32 = 3;
pub const GPIO_PIN16_CONFIG_S: u32 = 11;
pub const GPIO_PIN16_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN16_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN16_INT_TYPE: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN16_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN16_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN17_REG: u32 = 1072971980;
pub const GPIO_PIN17_INT_ENA: u32 = 31;
pub const GPIO_PIN17_INT_ENA_V: u32 = 31;
pub const GPIO_PIN17_INT_ENA_S: u32 = 13;
pub const GPIO_PIN17_CONFIG: u32 = 3;
pub const GPIO_PIN17_CONFIG_V: u32 = 3;
pub const GPIO_PIN17_CONFIG_S: u32 = 11;
pub const GPIO_PIN17_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN17_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN17_INT_TYPE: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN17_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN17_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN18_REG: u32 = 1072971984;
pub const GPIO_PIN18_INT_ENA: u32 = 31;
pub const GPIO_PIN18_INT_ENA_V: u32 = 31;
pub const GPIO_PIN18_INT_ENA_S: u32 = 13;
pub const GPIO_PIN18_CONFIG: u32 = 3;
pub const GPIO_PIN18_CONFIG_V: u32 = 3;
pub const GPIO_PIN18_CONFIG_S: u32 = 11;
pub const GPIO_PIN18_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN18_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN18_INT_TYPE: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN18_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN18_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN19_REG: u32 = 1072971988;
pub const GPIO_PIN19_INT_ENA: u32 = 31;
pub const GPIO_PIN19_INT_ENA_V: u32 = 31;
pub const GPIO_PIN19_INT_ENA_S: u32 = 13;
pub const GPIO_PIN19_CONFIG: u32 = 3;
pub const GPIO_PIN19_CONFIG_V: u32 = 3;
pub const GPIO_PIN19_CONFIG_S: u32 = 11;
pub const GPIO_PIN19_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN19_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN19_INT_TYPE: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN19_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN19_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN20_REG: u32 = 1072971992;
pub const GPIO_PIN20_INT_ENA: u32 = 31;
pub const GPIO_PIN20_INT_ENA_V: u32 = 31;
pub const GPIO_PIN20_INT_ENA_S: u32 = 13;
pub const GPIO_PIN20_CONFIG: u32 = 3;
pub const GPIO_PIN20_CONFIG_V: u32 = 3;
pub const GPIO_PIN20_CONFIG_S: u32 = 11;
pub const GPIO_PIN20_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN20_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN20_INT_TYPE: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN20_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN20_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN21_REG: u32 = 1072971996;
pub const GPIO_PIN21_INT_ENA: u32 = 31;
pub const GPIO_PIN21_INT_ENA_V: u32 = 31;
pub const GPIO_PIN21_INT_ENA_S: u32 = 13;
pub const GPIO_PIN21_CONFIG: u32 = 3;
pub const GPIO_PIN21_CONFIG_V: u32 = 3;
pub const GPIO_PIN21_CONFIG_S: u32 = 11;
pub const GPIO_PIN21_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN21_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN21_INT_TYPE: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN21_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN21_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN22_REG: u32 = 1072972000;
pub const GPIO_PIN22_INT_ENA: u32 = 31;
pub const GPIO_PIN22_INT_ENA_V: u32 = 31;
pub const GPIO_PIN22_INT_ENA_S: u32 = 13;
pub const GPIO_PIN22_CONFIG: u32 = 3;
pub const GPIO_PIN22_CONFIG_V: u32 = 3;
pub const GPIO_PIN22_CONFIG_S: u32 = 11;
pub const GPIO_PIN22_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN22_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN22_INT_TYPE: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN22_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN22_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN23_REG: u32 = 1072972004;
pub const GPIO_PIN23_INT_ENA: u32 = 31;
pub const GPIO_PIN23_INT_ENA_V: u32 = 31;
pub const GPIO_PIN23_INT_ENA_S: u32 = 13;
pub const GPIO_PIN23_CONFIG: u32 = 3;
pub const GPIO_PIN23_CONFIG_V: u32 = 3;
pub const GPIO_PIN23_CONFIG_S: u32 = 11;
pub const GPIO_PIN23_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN23_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN23_INT_TYPE: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN23_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN23_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN24_REG: u32 = 1072972008;
pub const GPIO_PIN24_INT_ENA: u32 = 31;
pub const GPIO_PIN24_INT_ENA_V: u32 = 31;
pub const GPIO_PIN24_INT_ENA_S: u32 = 13;
pub const GPIO_PIN24_CONFIG: u32 = 3;
pub const GPIO_PIN24_CONFIG_V: u32 = 3;
pub const GPIO_PIN24_CONFIG_S: u32 = 11;
pub const GPIO_PIN24_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN24_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN24_INT_TYPE: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN24_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN24_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN25_REG: u32 = 1072972012;
pub const GPIO_PIN25_INT_ENA: u32 = 31;
pub const GPIO_PIN25_INT_ENA_V: u32 = 31;
pub const GPIO_PIN25_INT_ENA_S: u32 = 13;
pub const GPIO_PIN25_CONFIG: u32 = 3;
pub const GPIO_PIN25_CONFIG_V: u32 = 3;
pub const GPIO_PIN25_CONFIG_S: u32 = 11;
pub const GPIO_PIN25_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN25_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN25_INT_TYPE: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN25_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN25_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN26_REG: u32 = 1072972016;
pub const GPIO_PIN26_INT_ENA: u32 = 31;
pub const GPIO_PIN26_INT_ENA_V: u32 = 31;
pub const GPIO_PIN26_INT_ENA_S: u32 = 13;
pub const GPIO_PIN26_CONFIG: u32 = 3;
pub const GPIO_PIN26_CONFIG_V: u32 = 3;
pub const GPIO_PIN26_CONFIG_S: u32 = 11;
pub const GPIO_PIN26_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN26_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN26_INT_TYPE: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN26_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN26_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN27_REG: u32 = 1072972020;
pub const GPIO_PIN27_INT_ENA: u32 = 31;
pub const GPIO_PIN27_INT_ENA_V: u32 = 31;
pub const GPIO_PIN27_INT_ENA_S: u32 = 13;
pub const GPIO_PIN27_CONFIG: u32 = 3;
pub const GPIO_PIN27_CONFIG_V: u32 = 3;
pub const GPIO_PIN27_CONFIG_S: u32 = 11;
pub const GPIO_PIN27_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN27_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN27_INT_TYPE: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN27_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN27_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN28_REG: u32 = 1072972024;
pub const GPIO_PIN28_INT_ENA: u32 = 31;
pub const GPIO_PIN28_INT_ENA_V: u32 = 31;
pub const GPIO_PIN28_INT_ENA_S: u32 = 13;
pub const GPIO_PIN28_CONFIG: u32 = 3;
pub const GPIO_PIN28_CONFIG_V: u32 = 3;
pub const GPIO_PIN28_CONFIG_S: u32 = 11;
pub const GPIO_PIN28_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN28_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN28_INT_TYPE: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN28_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN28_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN29_REG: u32 = 1072972028;
pub const GPIO_PIN29_INT_ENA: u32 = 31;
pub const GPIO_PIN29_INT_ENA_V: u32 = 31;
pub const GPIO_PIN29_INT_ENA_S: u32 = 13;
pub const GPIO_PIN29_CONFIG: u32 = 3;
pub const GPIO_PIN29_CONFIG_V: u32 = 3;
pub const GPIO_PIN29_CONFIG_S: u32 = 11;
pub const GPIO_PIN29_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN29_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN29_INT_TYPE: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN29_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN29_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN30_REG: u32 = 1072972032;
pub const GPIO_PIN30_INT_ENA: u32 = 31;
pub const GPIO_PIN30_INT_ENA_V: u32 = 31;
pub const GPIO_PIN30_INT_ENA_S: u32 = 13;
pub const GPIO_PIN30_CONFIG: u32 = 3;
pub const GPIO_PIN30_CONFIG_V: u32 = 3;
pub const GPIO_PIN30_CONFIG_S: u32 = 11;
pub const GPIO_PIN30_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN30_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN30_INT_TYPE: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN30_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN30_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN31_REG: u32 = 1072972036;
pub const GPIO_PIN31_INT_ENA: u32 = 31;
pub const GPIO_PIN31_INT_ENA_V: u32 = 31;
pub const GPIO_PIN31_INT_ENA_S: u32 = 13;
pub const GPIO_PIN31_CONFIG: u32 = 3;
pub const GPIO_PIN31_CONFIG_V: u32 = 3;
pub const GPIO_PIN31_CONFIG_S: u32 = 11;
pub const GPIO_PIN31_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN31_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN31_INT_TYPE: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN31_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN31_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN32_REG: u32 = 1072972040;
pub const GPIO_PIN32_INT_ENA: u32 = 31;
pub const GPIO_PIN32_INT_ENA_V: u32 = 31;
pub const GPIO_PIN32_INT_ENA_S: u32 = 13;
pub const GPIO_PIN32_CONFIG: u32 = 3;
pub const GPIO_PIN32_CONFIG_V: u32 = 3;
pub const GPIO_PIN32_CONFIG_S: u32 = 11;
pub const GPIO_PIN32_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN32_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN32_INT_TYPE: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN32_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN32_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN33_REG: u32 = 1072972044;
pub const GPIO_PIN33_INT_ENA: u32 = 31;
pub const GPIO_PIN33_INT_ENA_V: u32 = 31;
pub const GPIO_PIN33_INT_ENA_S: u32 = 13;
pub const GPIO_PIN33_CONFIG: u32 = 3;
pub const GPIO_PIN33_CONFIG_V: u32 = 3;
pub const GPIO_PIN33_CONFIG_S: u32 = 11;
pub const GPIO_PIN33_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN33_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN33_INT_TYPE: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN33_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN33_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN34_REG: u32 = 1072972048;
pub const GPIO_PIN34_INT_ENA: u32 = 31;
pub const GPIO_PIN34_INT_ENA_V: u32 = 31;
pub const GPIO_PIN34_INT_ENA_S: u32 = 13;
pub const GPIO_PIN34_CONFIG: u32 = 3;
pub const GPIO_PIN34_CONFIG_V: u32 = 3;
pub const GPIO_PIN34_CONFIG_S: u32 = 11;
pub const GPIO_PIN34_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN34_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN34_INT_TYPE: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN34_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN34_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN35_REG: u32 = 1072972052;
pub const GPIO_PIN35_INT_ENA: u32 = 31;
pub const GPIO_PIN35_INT_ENA_V: u32 = 31;
pub const GPIO_PIN35_INT_ENA_S: u32 = 13;
pub const GPIO_PIN35_CONFIG: u32 = 3;
pub const GPIO_PIN35_CONFIG_V: u32 = 3;
pub const GPIO_PIN35_CONFIG_S: u32 = 11;
pub const GPIO_PIN35_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN35_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN35_INT_TYPE: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN35_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN35_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN36_REG: u32 = 1072972056;
pub const GPIO_PIN36_INT_ENA: u32 = 31;
pub const GPIO_PIN36_INT_ENA_V: u32 = 31;
pub const GPIO_PIN36_INT_ENA_S: u32 = 13;
pub const GPIO_PIN36_CONFIG: u32 = 3;
pub const GPIO_PIN36_CONFIG_V: u32 = 3;
pub const GPIO_PIN36_CONFIG_S: u32 = 11;
pub const GPIO_PIN36_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN36_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN36_INT_TYPE: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN36_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN36_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN37_REG: u32 = 1072972060;
pub const GPIO_PIN37_INT_ENA: u32 = 31;
pub const GPIO_PIN37_INT_ENA_V: u32 = 31;
pub const GPIO_PIN37_INT_ENA_S: u32 = 13;
pub const GPIO_PIN37_CONFIG: u32 = 3;
pub const GPIO_PIN37_CONFIG_V: u32 = 3;
pub const GPIO_PIN37_CONFIG_S: u32 = 11;
pub const GPIO_PIN37_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN37_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN37_INT_TYPE: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN37_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN37_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN38_REG: u32 = 1072972064;
pub const GPIO_PIN38_INT_ENA: u32 = 31;
pub const GPIO_PIN38_INT_ENA_V: u32 = 31;
pub const GPIO_PIN38_INT_ENA_S: u32 = 13;
pub const GPIO_PIN38_CONFIG: u32 = 3;
pub const GPIO_PIN38_CONFIG_V: u32 = 3;
pub const GPIO_PIN38_CONFIG_S: u32 = 11;
pub const GPIO_PIN38_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN38_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN38_INT_TYPE: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN38_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN38_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN39_REG: u32 = 1072972068;
pub const GPIO_PIN39_INT_ENA: u32 = 31;
pub const GPIO_PIN39_INT_ENA_V: u32 = 31;
pub const GPIO_PIN39_INT_ENA_S: u32 = 13;
pub const GPIO_PIN39_CONFIG: u32 = 3;
pub const GPIO_PIN39_CONFIG_V: u32 = 3;
pub const GPIO_PIN39_CONFIG_S: u32 = 11;
pub const GPIO_PIN39_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN39_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN39_INT_TYPE: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN39_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN39_PAD_DRIVER_S: u32 = 2;
pub const GPIO_cali_conf_REG: u32 = 1072972072;
pub const GPIO_CALI_START_V: u32 = 1;
pub const GPIO_CALI_START_S: u32 = 31;
pub const GPIO_CALI_RTC_MAX: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_V: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_S: u32 = 0;
pub const GPIO_cali_data_REG: u32 = 1072972076;
pub const GPIO_CALI_RDY_SYNC2_V: u32 = 1;
pub const GPIO_CALI_RDY_SYNC2_S: u32 = 31;
pub const GPIO_CALI_RDY_REAL_V: u32 = 1;
pub const GPIO_CALI_RDY_REAL_S: u32 = 30;
pub const GPIO_CALI_VALUE_SYNC2: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_V: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_S: u32 = 0;
pub const GPIO_FUNC0_IN_SEL_CFG_REG: u32 = 1072972080;
pub const GPIO_SIG0_IN_SEL_V: u32 = 1;
pub const GPIO_SIG0_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC0_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC0_IN_SEL: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC1_IN_SEL_CFG_REG: u32 = 1072972084;
pub const GPIO_SIG1_IN_SEL_V: u32 = 1;
pub const GPIO_SIG1_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC1_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC1_IN_SEL: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC2_IN_SEL_CFG_REG: u32 = 1072972088;
pub const GPIO_SIG2_IN_SEL_V: u32 = 1;
pub const GPIO_SIG2_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC2_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC2_IN_SEL: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC3_IN_SEL_CFG_REG: u32 = 1072972092;
pub const GPIO_SIG3_IN_SEL_V: u32 = 1;
pub const GPIO_SIG3_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC3_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC3_IN_SEL: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC4_IN_SEL_CFG_REG: u32 = 1072972096;
pub const GPIO_SIG4_IN_SEL_V: u32 = 1;
pub const GPIO_SIG4_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC4_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC4_IN_SEL: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC5_IN_SEL_CFG_REG: u32 = 1072972100;
pub const GPIO_SIG5_IN_SEL_V: u32 = 1;
pub const GPIO_SIG5_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC5_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC5_IN_SEL: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC6_IN_SEL_CFG_REG: u32 = 1072972104;
pub const GPIO_SIG6_IN_SEL_V: u32 = 1;
pub const GPIO_SIG6_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC6_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC6_IN_SEL: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC7_IN_SEL_CFG_REG: u32 = 1072972108;
pub const GPIO_SIG7_IN_SEL_V: u32 = 1;
pub const GPIO_SIG7_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC7_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC7_IN_SEL: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC8_IN_SEL_CFG_REG: u32 = 1072972112;
pub const GPIO_SIG8_IN_SEL_V: u32 = 1;
pub const GPIO_SIG8_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC8_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC8_IN_SEL: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC9_IN_SEL_CFG_REG: u32 = 1072972116;
pub const GPIO_SIG9_IN_SEL_V: u32 = 1;
pub const GPIO_SIG9_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC9_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC9_IN_SEL: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC10_IN_SEL_CFG_REG: u32 = 1072972120;
pub const GPIO_SIG10_IN_SEL_V: u32 = 1;
pub const GPIO_SIG10_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC10_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC10_IN_SEL: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC11_IN_SEL_CFG_REG: u32 = 1072972124;
pub const GPIO_SIG11_IN_SEL_V: u32 = 1;
pub const GPIO_SIG11_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC11_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC11_IN_SEL: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC12_IN_SEL_CFG_REG: u32 = 1072972128;
pub const GPIO_SIG12_IN_SEL_V: u32 = 1;
pub const GPIO_SIG12_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC12_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC12_IN_SEL: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC13_IN_SEL_CFG_REG: u32 = 1072972132;
pub const GPIO_SIG13_IN_SEL_V: u32 = 1;
pub const GPIO_SIG13_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC13_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC13_IN_SEL: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC14_IN_SEL_CFG_REG: u32 = 1072972136;
pub const GPIO_SIG14_IN_SEL_V: u32 = 1;
pub const GPIO_SIG14_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC14_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC14_IN_SEL: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC15_IN_SEL_CFG_REG: u32 = 1072972140;
pub const GPIO_SIG15_IN_SEL_V: u32 = 1;
pub const GPIO_SIG15_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC15_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC15_IN_SEL: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC16_IN_SEL_CFG_REG: u32 = 1072972144;
pub const GPIO_SIG16_IN_SEL_V: u32 = 1;
pub const GPIO_SIG16_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC16_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC16_IN_SEL: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC17_IN_SEL_CFG_REG: u32 = 1072972148;
pub const GPIO_SIG17_IN_SEL_V: u32 = 1;
pub const GPIO_SIG17_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC17_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC17_IN_SEL: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC18_IN_SEL_CFG_REG: u32 = 1072972152;
pub const GPIO_SIG18_IN_SEL_V: u32 = 1;
pub const GPIO_SIG18_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC18_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC18_IN_SEL: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC19_IN_SEL_CFG_REG: u32 = 1072972156;
pub const GPIO_SIG19_IN_SEL_V: u32 = 1;
pub const GPIO_SIG19_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC19_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC19_IN_SEL: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC20_IN_SEL_CFG_REG: u32 = 1072972160;
pub const GPIO_SIG20_IN_SEL_V: u32 = 1;
pub const GPIO_SIG20_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC20_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC20_IN_SEL: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC21_IN_SEL_CFG_REG: u32 = 1072972164;
pub const GPIO_SIG21_IN_SEL_V: u32 = 1;
pub const GPIO_SIG21_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC21_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC21_IN_SEL: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC22_IN_SEL_CFG_REG: u32 = 1072972168;
pub const GPIO_SIG22_IN_SEL_V: u32 = 1;
pub const GPIO_SIG22_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC22_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC22_IN_SEL: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC23_IN_SEL_CFG_REG: u32 = 1072972172;
pub const GPIO_SIG23_IN_SEL_V: u32 = 1;
pub const GPIO_SIG23_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC23_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC23_IN_SEL: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC24_IN_SEL_CFG_REG: u32 = 1072972176;
pub const GPIO_SIG24_IN_SEL_V: u32 = 1;
pub const GPIO_SIG24_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC24_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC24_IN_SEL: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC25_IN_SEL_CFG_REG: u32 = 1072972180;
pub const GPIO_SIG25_IN_SEL_V: u32 = 1;
pub const GPIO_SIG25_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC25_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC25_IN_SEL: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC26_IN_SEL_CFG_REG: u32 = 1072972184;
pub const GPIO_SIG26_IN_SEL_V: u32 = 1;
pub const GPIO_SIG26_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC26_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC26_IN_SEL: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC27_IN_SEL_CFG_REG: u32 = 1072972188;
pub const GPIO_SIG27_IN_SEL_V: u32 = 1;
pub const GPIO_SIG27_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC27_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC27_IN_SEL: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC28_IN_SEL_CFG_REG: u32 = 1072972192;
pub const GPIO_SIG28_IN_SEL_V: u32 = 1;
pub const GPIO_SIG28_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC28_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC28_IN_SEL: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC29_IN_SEL_CFG_REG: u32 = 1072972196;
pub const GPIO_SIG29_IN_SEL_V: u32 = 1;
pub const GPIO_SIG29_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC29_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC29_IN_SEL: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC30_IN_SEL_CFG_REG: u32 = 1072972200;
pub const GPIO_SIG30_IN_SEL_V: u32 = 1;
pub const GPIO_SIG30_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC30_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC30_IN_SEL: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC31_IN_SEL_CFG_REG: u32 = 1072972204;
pub const GPIO_SIG31_IN_SEL_V: u32 = 1;
pub const GPIO_SIG31_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC31_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC31_IN_SEL: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC32_IN_SEL_CFG_REG: u32 = 1072972208;
pub const GPIO_SIG32_IN_SEL_V: u32 = 1;
pub const GPIO_SIG32_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC32_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC32_IN_SEL: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC33_IN_SEL_CFG_REG: u32 = 1072972212;
pub const GPIO_SIG33_IN_SEL_V: u32 = 1;
pub const GPIO_SIG33_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC33_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC33_IN_SEL: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC34_IN_SEL_CFG_REG: u32 = 1072972216;
pub const GPIO_SIG34_IN_SEL_V: u32 = 1;
pub const GPIO_SIG34_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC34_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC34_IN_SEL: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC35_IN_SEL_CFG_REG: u32 = 1072972220;
pub const GPIO_SIG35_IN_SEL_V: u32 = 1;
pub const GPIO_SIG35_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC35_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC35_IN_SEL: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC36_IN_SEL_CFG_REG: u32 = 1072972224;
pub const GPIO_SIG36_IN_SEL_V: u32 = 1;
pub const GPIO_SIG36_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC36_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC36_IN_SEL: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC37_IN_SEL_CFG_REG: u32 = 1072972228;
pub const GPIO_SIG37_IN_SEL_V: u32 = 1;
pub const GPIO_SIG37_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC37_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC37_IN_SEL: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC38_IN_SEL_CFG_REG: u32 = 1072972232;
pub const GPIO_SIG38_IN_SEL_V: u32 = 1;
pub const GPIO_SIG38_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC38_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC38_IN_SEL: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC39_IN_SEL_CFG_REG: u32 = 1072972236;
pub const GPIO_SIG39_IN_SEL_V: u32 = 1;
pub const GPIO_SIG39_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC39_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC39_IN_SEL: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC40_IN_SEL_CFG_REG: u32 = 1072972240;
pub const GPIO_SIG40_IN_SEL_V: u32 = 1;
pub const GPIO_SIG40_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC40_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC40_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC40_IN_SEL: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC41_IN_SEL_CFG_REG: u32 = 1072972244;
pub const GPIO_SIG41_IN_SEL_V: u32 = 1;
pub const GPIO_SIG41_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC41_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC41_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC41_IN_SEL: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC42_IN_SEL_CFG_REG: u32 = 1072972248;
pub const GPIO_SIG42_IN_SEL_V: u32 = 1;
pub const GPIO_SIG42_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC42_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC42_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC42_IN_SEL: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC43_IN_SEL_CFG_REG: u32 = 1072972252;
pub const GPIO_SIG43_IN_SEL_V: u32 = 1;
pub const GPIO_SIG43_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC43_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC43_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC43_IN_SEL: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC44_IN_SEL_CFG_REG: u32 = 1072972256;
pub const GPIO_SIG44_IN_SEL_V: u32 = 1;
pub const GPIO_SIG44_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC44_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC44_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC44_IN_SEL: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC45_IN_SEL_CFG_REG: u32 = 1072972260;
pub const GPIO_SIG45_IN_SEL_V: u32 = 1;
pub const GPIO_SIG45_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC45_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC45_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC45_IN_SEL: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC46_IN_SEL_CFG_REG: u32 = 1072972264;
pub const GPIO_SIG46_IN_SEL_V: u32 = 1;
pub const GPIO_SIG46_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC46_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC46_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC46_IN_SEL: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC47_IN_SEL_CFG_REG: u32 = 1072972268;
pub const GPIO_SIG47_IN_SEL_V: u32 = 1;
pub const GPIO_SIG47_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC47_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC47_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC47_IN_SEL: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC48_IN_SEL_CFG_REG: u32 = 1072972272;
pub const GPIO_SIG48_IN_SEL_V: u32 = 1;
pub const GPIO_SIG48_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC48_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC48_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC48_IN_SEL: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC49_IN_SEL_CFG_REG: u32 = 1072972276;
pub const GPIO_SIG49_IN_SEL_V: u32 = 1;
pub const GPIO_SIG49_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC49_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC49_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC49_IN_SEL: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC50_IN_SEL_CFG_REG: u32 = 1072972280;
pub const GPIO_SIG50_IN_SEL_V: u32 = 1;
pub const GPIO_SIG50_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC50_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC50_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC50_IN_SEL: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC51_IN_SEL_CFG_REG: u32 = 1072972284;
pub const GPIO_SIG51_IN_SEL_V: u32 = 1;
pub const GPIO_SIG51_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC51_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC51_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC51_IN_SEL: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC52_IN_SEL_CFG_REG: u32 = 1072972288;
pub const GPIO_SIG52_IN_SEL_V: u32 = 1;
pub const GPIO_SIG52_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC52_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC52_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC52_IN_SEL: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC53_IN_SEL_CFG_REG: u32 = 1072972292;
pub const GPIO_SIG53_IN_SEL_V: u32 = 1;
pub const GPIO_SIG53_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC53_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC53_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC53_IN_SEL: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC54_IN_SEL_CFG_REG: u32 = 1072972296;
pub const GPIO_SIG54_IN_SEL_V: u32 = 1;
pub const GPIO_SIG54_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC54_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC54_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC54_IN_SEL: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC55_IN_SEL_CFG_REG: u32 = 1072972300;
pub const GPIO_SIG55_IN_SEL_V: u32 = 1;
pub const GPIO_SIG55_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC55_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC55_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC55_IN_SEL: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC56_IN_SEL_CFG_REG: u32 = 1072972304;
pub const GPIO_SIG56_IN_SEL_V: u32 = 1;
pub const GPIO_SIG56_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC56_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC56_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC56_IN_SEL: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC57_IN_SEL_CFG_REG: u32 = 1072972308;
pub const GPIO_SIG57_IN_SEL_V: u32 = 1;
pub const GPIO_SIG57_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC57_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC57_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC57_IN_SEL: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC58_IN_SEL_CFG_REG: u32 = 1072972312;
pub const GPIO_SIG58_IN_SEL_V: u32 = 1;
pub const GPIO_SIG58_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC58_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC58_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC58_IN_SEL: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC59_IN_SEL_CFG_REG: u32 = 1072972316;
pub const GPIO_SIG59_IN_SEL_V: u32 = 1;
pub const GPIO_SIG59_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC59_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC59_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC59_IN_SEL: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC60_IN_SEL_CFG_REG: u32 = 1072972320;
pub const GPIO_SIG60_IN_SEL_V: u32 = 1;
pub const GPIO_SIG60_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC60_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC60_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC60_IN_SEL: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC61_IN_SEL_CFG_REG: u32 = 1072972324;
pub const GPIO_SIG61_IN_SEL_V: u32 = 1;
pub const GPIO_SIG61_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC61_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC61_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC61_IN_SEL: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC62_IN_SEL_CFG_REG: u32 = 1072972328;
pub const GPIO_SIG62_IN_SEL_V: u32 = 1;
pub const GPIO_SIG62_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC62_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC62_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC62_IN_SEL: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC63_IN_SEL_CFG_REG: u32 = 1072972332;
pub const GPIO_SIG63_IN_SEL_V: u32 = 1;
pub const GPIO_SIG63_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC63_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC63_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC63_IN_SEL: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC64_IN_SEL_CFG_REG: u32 = 1072972336;
pub const GPIO_SIG64_IN_SEL_V: u32 = 1;
pub const GPIO_SIG64_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC64_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC64_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC64_IN_SEL: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC65_IN_SEL_CFG_REG: u32 = 1072972340;
pub const GPIO_SIG65_IN_SEL_V: u32 = 1;
pub const GPIO_SIG65_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC65_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC65_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC65_IN_SEL: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC66_IN_SEL_CFG_REG: u32 = 1072972344;
pub const GPIO_SIG66_IN_SEL_V: u32 = 1;
pub const GPIO_SIG66_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC66_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC66_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC66_IN_SEL: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC67_IN_SEL_CFG_REG: u32 = 1072972348;
pub const GPIO_SIG67_IN_SEL_V: u32 = 1;
pub const GPIO_SIG67_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC67_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC67_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC67_IN_SEL: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC68_IN_SEL_CFG_REG: u32 = 1072972352;
pub const GPIO_SIG68_IN_SEL_V: u32 = 1;
pub const GPIO_SIG68_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC68_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC68_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC68_IN_SEL: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC69_IN_SEL_CFG_REG: u32 = 1072972356;
pub const GPIO_SIG69_IN_SEL_V: u32 = 1;
pub const GPIO_SIG69_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC69_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC69_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC69_IN_SEL: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC70_IN_SEL_CFG_REG: u32 = 1072972360;
pub const GPIO_SIG70_IN_SEL_V: u32 = 1;
pub const GPIO_SIG70_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC70_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC70_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC70_IN_SEL: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC71_IN_SEL_CFG_REG: u32 = 1072972364;
pub const GPIO_SIG71_IN_SEL_V: u32 = 1;
pub const GPIO_SIG71_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC71_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC71_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC71_IN_SEL: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC72_IN_SEL_CFG_REG: u32 = 1072972368;
pub const GPIO_SIG72_IN_SEL_V: u32 = 1;
pub const GPIO_SIG72_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC72_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC72_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC72_IN_SEL: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC73_IN_SEL_CFG_REG: u32 = 1072972372;
pub const GPIO_SIG73_IN_SEL_V: u32 = 1;
pub const GPIO_SIG73_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC73_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC73_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC73_IN_SEL: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC74_IN_SEL_CFG_REG: u32 = 1072972376;
pub const GPIO_SIG74_IN_SEL_V: u32 = 1;
pub const GPIO_SIG74_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC74_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC74_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC74_IN_SEL: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC75_IN_SEL_CFG_REG: u32 = 1072972380;
pub const GPIO_SIG75_IN_SEL_V: u32 = 1;
pub const GPIO_SIG75_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC75_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC75_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC75_IN_SEL: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC76_IN_SEL_CFG_REG: u32 = 1072972384;
pub const GPIO_SIG76_IN_SEL_V: u32 = 1;
pub const GPIO_SIG76_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC76_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC76_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC76_IN_SEL: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC77_IN_SEL_CFG_REG: u32 = 1072972388;
pub const GPIO_SIG77_IN_SEL_V: u32 = 1;
pub const GPIO_SIG77_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC77_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC77_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC77_IN_SEL: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC78_IN_SEL_CFG_REG: u32 = 1072972392;
pub const GPIO_SIG78_IN_SEL_V: u32 = 1;
pub const GPIO_SIG78_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC78_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC78_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC78_IN_SEL: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC79_IN_SEL_CFG_REG: u32 = 1072972396;
pub const GPIO_SIG79_IN_SEL_V: u32 = 1;
pub const GPIO_SIG79_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC79_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC79_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC79_IN_SEL: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC80_IN_SEL_CFG_REG: u32 = 1072972400;
pub const GPIO_SIG80_IN_SEL_V: u32 = 1;
pub const GPIO_SIG80_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC80_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC80_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC80_IN_SEL: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC81_IN_SEL_CFG_REG: u32 = 1072972404;
pub const GPIO_SIG81_IN_SEL_V: u32 = 1;
pub const GPIO_SIG81_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC81_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC81_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC81_IN_SEL: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC82_IN_SEL_CFG_REG: u32 = 1072972408;
pub const GPIO_SIG82_IN_SEL_V: u32 = 1;
pub const GPIO_SIG82_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC82_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC82_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC82_IN_SEL: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC83_IN_SEL_CFG_REG: u32 = 1072972412;
pub const GPIO_SIG83_IN_SEL_V: u32 = 1;
pub const GPIO_SIG83_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC83_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC83_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC83_IN_SEL: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC84_IN_SEL_CFG_REG: u32 = 1072972416;
pub const GPIO_SIG84_IN_SEL_V: u32 = 1;
pub const GPIO_SIG84_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC84_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC84_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC84_IN_SEL: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC85_IN_SEL_CFG_REG: u32 = 1072972420;
pub const GPIO_SIG85_IN_SEL_V: u32 = 1;
pub const GPIO_SIG85_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC85_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC85_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC85_IN_SEL: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC86_IN_SEL_CFG_REG: u32 = 1072972424;
pub const GPIO_SIG86_IN_SEL_V: u32 = 1;
pub const GPIO_SIG86_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC86_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC86_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC86_IN_SEL: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC87_IN_SEL_CFG_REG: u32 = 1072972428;
pub const GPIO_SIG87_IN_SEL_V: u32 = 1;
pub const GPIO_SIG87_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC87_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC87_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC87_IN_SEL: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC88_IN_SEL_CFG_REG: u32 = 1072972432;
pub const GPIO_SIG88_IN_SEL_V: u32 = 1;
pub const GPIO_SIG88_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC88_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC88_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC88_IN_SEL: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC89_IN_SEL_CFG_REG: u32 = 1072972436;
pub const GPIO_SIG89_IN_SEL_V: u32 = 1;
pub const GPIO_SIG89_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC89_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC89_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC89_IN_SEL: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC90_IN_SEL_CFG_REG: u32 = 1072972440;
pub const GPIO_SIG90_IN_SEL_V: u32 = 1;
pub const GPIO_SIG90_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC90_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC90_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC90_IN_SEL: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC91_IN_SEL_CFG_REG: u32 = 1072972444;
pub const GPIO_SIG91_IN_SEL_V: u32 = 1;
pub const GPIO_SIG91_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC91_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC91_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC91_IN_SEL: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC92_IN_SEL_CFG_REG: u32 = 1072972448;
pub const GPIO_SIG92_IN_SEL_V: u32 = 1;
pub const GPIO_SIG92_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC92_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC92_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC92_IN_SEL: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC93_IN_SEL_CFG_REG: u32 = 1072972452;
pub const GPIO_SIG93_IN_SEL_V: u32 = 1;
pub const GPIO_SIG93_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC93_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC93_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC93_IN_SEL: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC94_IN_SEL_CFG_REG: u32 = 1072972456;
pub const GPIO_SIG94_IN_SEL_V: u32 = 1;
pub const GPIO_SIG94_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC94_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC94_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC94_IN_SEL: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC95_IN_SEL_CFG_REG: u32 = 1072972460;
pub const GPIO_SIG95_IN_SEL_V: u32 = 1;
pub const GPIO_SIG95_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC95_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC95_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC95_IN_SEL: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC96_IN_SEL_CFG_REG: u32 = 1072972464;
pub const GPIO_SIG96_IN_SEL_V: u32 = 1;
pub const GPIO_SIG96_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC96_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC96_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC96_IN_SEL: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC97_IN_SEL_CFG_REG: u32 = 1072972468;
pub const GPIO_SIG97_IN_SEL_V: u32 = 1;
pub const GPIO_SIG97_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC97_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC97_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC97_IN_SEL: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC98_IN_SEL_CFG_REG: u32 = 1072972472;
pub const GPIO_SIG98_IN_SEL_V: u32 = 1;
pub const GPIO_SIG98_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC98_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC98_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC98_IN_SEL: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC99_IN_SEL_CFG_REG: u32 = 1072972476;
pub const GPIO_SIG99_IN_SEL_V: u32 = 1;
pub const GPIO_SIG99_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC99_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC99_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC99_IN_SEL: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC100_IN_SEL_CFG_REG: u32 = 1072972480;
pub const GPIO_SIG100_IN_SEL_V: u32 = 1;
pub const GPIO_SIG100_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC100_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC100_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC100_IN_SEL: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC101_IN_SEL_CFG_REG: u32 = 1072972484;
pub const GPIO_SIG101_IN_SEL_V: u32 = 1;
pub const GPIO_SIG101_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC101_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC101_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC101_IN_SEL: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC102_IN_SEL_CFG_REG: u32 = 1072972488;
pub const GPIO_SIG102_IN_SEL_V: u32 = 1;
pub const GPIO_SIG102_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC102_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC102_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC102_IN_SEL: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC103_IN_SEL_CFG_REG: u32 = 1072972492;
pub const GPIO_SIG103_IN_SEL_V: u32 = 1;
pub const GPIO_SIG103_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC103_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC103_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC103_IN_SEL: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC104_IN_SEL_CFG_REG: u32 = 1072972496;
pub const GPIO_SIG104_IN_SEL_V: u32 = 1;
pub const GPIO_SIG104_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC104_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC104_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC104_IN_SEL: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC105_IN_SEL_CFG_REG: u32 = 1072972500;
pub const GPIO_SIG105_IN_SEL_V: u32 = 1;
pub const GPIO_SIG105_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC105_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC105_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC105_IN_SEL: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC106_IN_SEL_CFG_REG: u32 = 1072972504;
pub const GPIO_SIG106_IN_SEL_V: u32 = 1;
pub const GPIO_SIG106_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC106_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC106_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC106_IN_SEL: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC107_IN_SEL_CFG_REG: u32 = 1072972508;
pub const GPIO_SIG107_IN_SEL_V: u32 = 1;
pub const GPIO_SIG107_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC107_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC107_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC107_IN_SEL: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC108_IN_SEL_CFG_REG: u32 = 1072972512;
pub const GPIO_SIG108_IN_SEL_V: u32 = 1;
pub const GPIO_SIG108_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC108_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC108_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC108_IN_SEL: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC109_IN_SEL_CFG_REG: u32 = 1072972516;
pub const GPIO_SIG109_IN_SEL_V: u32 = 1;
pub const GPIO_SIG109_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC109_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC109_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC109_IN_SEL: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC110_IN_SEL_CFG_REG: u32 = 1072972520;
pub const GPIO_SIG110_IN_SEL_V: u32 = 1;
pub const GPIO_SIG110_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC110_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC110_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC110_IN_SEL: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC111_IN_SEL_CFG_REG: u32 = 1072972524;
pub const GPIO_SIG111_IN_SEL_V: u32 = 1;
pub const GPIO_SIG111_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC111_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC111_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC111_IN_SEL: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC112_IN_SEL_CFG_REG: u32 = 1072972528;
pub const GPIO_SIG112_IN_SEL_V: u32 = 1;
pub const GPIO_SIG112_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC112_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC112_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC112_IN_SEL: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC113_IN_SEL_CFG_REG: u32 = 1072972532;
pub const GPIO_SIG113_IN_SEL_V: u32 = 1;
pub const GPIO_SIG113_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC113_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC113_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC113_IN_SEL: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC114_IN_SEL_CFG_REG: u32 = 1072972536;
pub const GPIO_SIG114_IN_SEL_V: u32 = 1;
pub const GPIO_SIG114_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC114_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC114_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC114_IN_SEL: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC115_IN_SEL_CFG_REG: u32 = 1072972540;
pub const GPIO_SIG115_IN_SEL_V: u32 = 1;
pub const GPIO_SIG115_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC115_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC115_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC115_IN_SEL: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC116_IN_SEL_CFG_REG: u32 = 1072972544;
pub const GPIO_SIG116_IN_SEL_V: u32 = 1;
pub const GPIO_SIG116_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC116_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC116_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC116_IN_SEL: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC117_IN_SEL_CFG_REG: u32 = 1072972548;
pub const GPIO_SIG117_IN_SEL_V: u32 = 1;
pub const GPIO_SIG117_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC117_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC117_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC117_IN_SEL: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC118_IN_SEL_CFG_REG: u32 = 1072972552;
pub const GPIO_SIG118_IN_SEL_V: u32 = 1;
pub const GPIO_SIG118_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC118_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC118_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC118_IN_SEL: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC119_IN_SEL_CFG_REG: u32 = 1072972556;
pub const GPIO_SIG119_IN_SEL_V: u32 = 1;
pub const GPIO_SIG119_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC119_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC119_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC119_IN_SEL: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC120_IN_SEL_CFG_REG: u32 = 1072972560;
pub const GPIO_SIG120_IN_SEL_V: u32 = 1;
pub const GPIO_SIG120_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC120_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC120_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC120_IN_SEL: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC121_IN_SEL_CFG_REG: u32 = 1072972564;
pub const GPIO_SIG121_IN_SEL_V: u32 = 1;
pub const GPIO_SIG121_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC121_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC121_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC121_IN_SEL: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC122_IN_SEL_CFG_REG: u32 = 1072972568;
pub const GPIO_SIG122_IN_SEL_V: u32 = 1;
pub const GPIO_SIG122_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC122_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC122_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC122_IN_SEL: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC123_IN_SEL_CFG_REG: u32 = 1072972572;
pub const GPIO_SIG123_IN_SEL_V: u32 = 1;
pub const GPIO_SIG123_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC123_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC123_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC123_IN_SEL: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC124_IN_SEL_CFG_REG: u32 = 1072972576;
pub const GPIO_SIG124_IN_SEL_V: u32 = 1;
pub const GPIO_SIG124_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC124_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC124_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC124_IN_SEL: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC125_IN_SEL_CFG_REG: u32 = 1072972580;
pub const GPIO_SIG125_IN_SEL_V: u32 = 1;
pub const GPIO_SIG125_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC125_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC125_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC125_IN_SEL: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC126_IN_SEL_CFG_REG: u32 = 1072972584;
pub const GPIO_SIG126_IN_SEL_V: u32 = 1;
pub const GPIO_SIG126_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC126_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC126_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC126_IN_SEL: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC127_IN_SEL_CFG_REG: u32 = 1072972588;
pub const GPIO_SIG127_IN_SEL_V: u32 = 1;
pub const GPIO_SIG127_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC127_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC127_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC127_IN_SEL: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC128_IN_SEL_CFG_REG: u32 = 1072972592;
pub const GPIO_SIG128_IN_SEL_V: u32 = 1;
pub const GPIO_SIG128_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC128_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC128_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC128_IN_SEL: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC129_IN_SEL_CFG_REG: u32 = 1072972596;
pub const GPIO_SIG129_IN_SEL_V: u32 = 1;
pub const GPIO_SIG129_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC129_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC129_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC129_IN_SEL: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC130_IN_SEL_CFG_REG: u32 = 1072972600;
pub const GPIO_SIG130_IN_SEL_V: u32 = 1;
pub const GPIO_SIG130_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC130_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC130_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC130_IN_SEL: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC131_IN_SEL_CFG_REG: u32 = 1072972604;
pub const GPIO_SIG131_IN_SEL_V: u32 = 1;
pub const GPIO_SIG131_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC131_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC131_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC131_IN_SEL: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC132_IN_SEL_CFG_REG: u32 = 1072972608;
pub const GPIO_SIG132_IN_SEL_V: u32 = 1;
pub const GPIO_SIG132_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC132_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC132_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC132_IN_SEL: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC133_IN_SEL_CFG_REG: u32 = 1072972612;
pub const GPIO_SIG133_IN_SEL_V: u32 = 1;
pub const GPIO_SIG133_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC133_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC133_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC133_IN_SEL: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC134_IN_SEL_CFG_REG: u32 = 1072972616;
pub const GPIO_SIG134_IN_SEL_V: u32 = 1;
pub const GPIO_SIG134_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC134_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC134_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC134_IN_SEL: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC135_IN_SEL_CFG_REG: u32 = 1072972620;
pub const GPIO_SIG135_IN_SEL_V: u32 = 1;
pub const GPIO_SIG135_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC135_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC135_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC135_IN_SEL: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC136_IN_SEL_CFG_REG: u32 = 1072972624;
pub const GPIO_SIG136_IN_SEL_V: u32 = 1;
pub const GPIO_SIG136_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC136_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC136_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC136_IN_SEL: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC137_IN_SEL_CFG_REG: u32 = 1072972628;
pub const GPIO_SIG137_IN_SEL_V: u32 = 1;
pub const GPIO_SIG137_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC137_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC137_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC137_IN_SEL: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC138_IN_SEL_CFG_REG: u32 = 1072972632;
pub const GPIO_SIG138_IN_SEL_V: u32 = 1;
pub const GPIO_SIG138_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC138_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC138_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC138_IN_SEL: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC139_IN_SEL_CFG_REG: u32 = 1072972636;
pub const GPIO_SIG139_IN_SEL_V: u32 = 1;
pub const GPIO_SIG139_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC139_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC139_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC139_IN_SEL: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC140_IN_SEL_CFG_REG: u32 = 1072972640;
pub const GPIO_SIG140_IN_SEL_V: u32 = 1;
pub const GPIO_SIG140_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC140_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC140_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC140_IN_SEL: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC141_IN_SEL_CFG_REG: u32 = 1072972644;
pub const GPIO_SIG141_IN_SEL_V: u32 = 1;
pub const GPIO_SIG141_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC141_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC141_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC141_IN_SEL: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC142_IN_SEL_CFG_REG: u32 = 1072972648;
pub const GPIO_SIG142_IN_SEL_V: u32 = 1;
pub const GPIO_SIG142_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC142_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC142_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC142_IN_SEL: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC143_IN_SEL_CFG_REG: u32 = 1072972652;
pub const GPIO_SIG143_IN_SEL_V: u32 = 1;
pub const GPIO_SIG143_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC143_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC143_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC143_IN_SEL: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC144_IN_SEL_CFG_REG: u32 = 1072972656;
pub const GPIO_SIG144_IN_SEL_V: u32 = 1;
pub const GPIO_SIG144_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC144_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC144_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC144_IN_SEL: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC145_IN_SEL_CFG_REG: u32 = 1072972660;
pub const GPIO_SIG145_IN_SEL_V: u32 = 1;
pub const GPIO_SIG145_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC145_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC145_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC145_IN_SEL: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC146_IN_SEL_CFG_REG: u32 = 1072972664;
pub const GPIO_SIG146_IN_SEL_V: u32 = 1;
pub const GPIO_SIG146_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC146_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC146_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC146_IN_SEL: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC147_IN_SEL_CFG_REG: u32 = 1072972668;
pub const GPIO_SIG147_IN_SEL_V: u32 = 1;
pub const GPIO_SIG147_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC147_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC147_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC147_IN_SEL: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC148_IN_SEL_CFG_REG: u32 = 1072972672;
pub const GPIO_SIG148_IN_SEL_V: u32 = 1;
pub const GPIO_SIG148_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC148_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC148_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC148_IN_SEL: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC149_IN_SEL_CFG_REG: u32 = 1072972676;
pub const GPIO_SIG149_IN_SEL_V: u32 = 1;
pub const GPIO_SIG149_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC149_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC149_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC149_IN_SEL: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC150_IN_SEL_CFG_REG: u32 = 1072972680;
pub const GPIO_SIG150_IN_SEL_V: u32 = 1;
pub const GPIO_SIG150_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC150_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC150_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC150_IN_SEL: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC151_IN_SEL_CFG_REG: u32 = 1072972684;
pub const GPIO_SIG151_IN_SEL_V: u32 = 1;
pub const GPIO_SIG151_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC151_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC151_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC151_IN_SEL: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC152_IN_SEL_CFG_REG: u32 = 1072972688;
pub const GPIO_SIG152_IN_SEL_V: u32 = 1;
pub const GPIO_SIG152_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC152_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC152_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC152_IN_SEL: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC153_IN_SEL_CFG_REG: u32 = 1072972692;
pub const GPIO_SIG153_IN_SEL_V: u32 = 1;
pub const GPIO_SIG153_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC153_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC153_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC153_IN_SEL: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC154_IN_SEL_CFG_REG: u32 = 1072972696;
pub const GPIO_SIG154_IN_SEL_V: u32 = 1;
pub const GPIO_SIG154_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC154_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC154_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC154_IN_SEL: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC155_IN_SEL_CFG_REG: u32 = 1072972700;
pub const GPIO_SIG155_IN_SEL_V: u32 = 1;
pub const GPIO_SIG155_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC155_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC155_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC155_IN_SEL: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC156_IN_SEL_CFG_REG: u32 = 1072972704;
pub const GPIO_SIG156_IN_SEL_V: u32 = 1;
pub const GPIO_SIG156_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC156_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC156_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC156_IN_SEL: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC157_IN_SEL_CFG_REG: u32 = 1072972708;
pub const GPIO_SIG157_IN_SEL_V: u32 = 1;
pub const GPIO_SIG157_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC157_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC157_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC157_IN_SEL: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC158_IN_SEL_CFG_REG: u32 = 1072972712;
pub const GPIO_SIG158_IN_SEL_V: u32 = 1;
pub const GPIO_SIG158_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC158_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC158_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC158_IN_SEL: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC159_IN_SEL_CFG_REG: u32 = 1072972716;
pub const GPIO_SIG159_IN_SEL_V: u32 = 1;
pub const GPIO_SIG159_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC159_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC159_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC159_IN_SEL: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC160_IN_SEL_CFG_REG: u32 = 1072972720;
pub const GPIO_SIG160_IN_SEL_V: u32 = 1;
pub const GPIO_SIG160_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC160_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC160_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC160_IN_SEL: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC161_IN_SEL_CFG_REG: u32 = 1072972724;
pub const GPIO_SIG161_IN_SEL_V: u32 = 1;
pub const GPIO_SIG161_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC161_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC161_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC161_IN_SEL: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC162_IN_SEL_CFG_REG: u32 = 1072972728;
pub const GPIO_SIG162_IN_SEL_V: u32 = 1;
pub const GPIO_SIG162_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC162_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC162_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC162_IN_SEL: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC163_IN_SEL_CFG_REG: u32 = 1072972732;
pub const GPIO_SIG163_IN_SEL_V: u32 = 1;
pub const GPIO_SIG163_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC163_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC163_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC163_IN_SEL: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC164_IN_SEL_CFG_REG: u32 = 1072972736;
pub const GPIO_SIG164_IN_SEL_V: u32 = 1;
pub const GPIO_SIG164_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC164_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC164_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC164_IN_SEL: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC165_IN_SEL_CFG_REG: u32 = 1072972740;
pub const GPIO_SIG165_IN_SEL_V: u32 = 1;
pub const GPIO_SIG165_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC165_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC165_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC165_IN_SEL: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC166_IN_SEL_CFG_REG: u32 = 1072972744;
pub const GPIO_SIG166_IN_SEL_V: u32 = 1;
pub const GPIO_SIG166_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC166_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC166_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC166_IN_SEL: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC167_IN_SEL_CFG_REG: u32 = 1072972748;
pub const GPIO_SIG167_IN_SEL_V: u32 = 1;
pub const GPIO_SIG167_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC167_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC167_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC167_IN_SEL: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC168_IN_SEL_CFG_REG: u32 = 1072972752;
pub const GPIO_SIG168_IN_SEL_V: u32 = 1;
pub const GPIO_SIG168_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC168_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC168_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC168_IN_SEL: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC169_IN_SEL_CFG_REG: u32 = 1072972756;
pub const GPIO_SIG169_IN_SEL_V: u32 = 1;
pub const GPIO_SIG169_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC169_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC169_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC169_IN_SEL: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC170_IN_SEL_CFG_REG: u32 = 1072972760;
pub const GPIO_SIG170_IN_SEL_V: u32 = 1;
pub const GPIO_SIG170_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC170_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC170_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC170_IN_SEL: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC171_IN_SEL_CFG_REG: u32 = 1072972764;
pub const GPIO_SIG171_IN_SEL_V: u32 = 1;
pub const GPIO_SIG171_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC171_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC171_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC171_IN_SEL: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC172_IN_SEL_CFG_REG: u32 = 1072972768;
pub const GPIO_SIG172_IN_SEL_V: u32 = 1;
pub const GPIO_SIG172_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC172_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC172_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC172_IN_SEL: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC173_IN_SEL_CFG_REG: u32 = 1072972772;
pub const GPIO_SIG173_IN_SEL_V: u32 = 1;
pub const GPIO_SIG173_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC173_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC173_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC173_IN_SEL: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC174_IN_SEL_CFG_REG: u32 = 1072972776;
pub const GPIO_SIG174_IN_SEL_V: u32 = 1;
pub const GPIO_SIG174_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC174_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC174_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC174_IN_SEL: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC175_IN_SEL_CFG_REG: u32 = 1072972780;
pub const GPIO_SIG175_IN_SEL_V: u32 = 1;
pub const GPIO_SIG175_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC175_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC175_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC175_IN_SEL: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC176_IN_SEL_CFG_REG: u32 = 1072972784;
pub const GPIO_SIG176_IN_SEL_V: u32 = 1;
pub const GPIO_SIG176_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC176_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC176_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC176_IN_SEL: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC177_IN_SEL_CFG_REG: u32 = 1072972788;
pub const GPIO_SIG177_IN_SEL_V: u32 = 1;
pub const GPIO_SIG177_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC177_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC177_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC177_IN_SEL: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC178_IN_SEL_CFG_REG: u32 = 1072972792;
pub const GPIO_SIG178_IN_SEL_V: u32 = 1;
pub const GPIO_SIG178_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC178_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC178_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC178_IN_SEL: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC179_IN_SEL_CFG_REG: u32 = 1072972796;
pub const GPIO_SIG179_IN_SEL_V: u32 = 1;
pub const GPIO_SIG179_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC179_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC179_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC179_IN_SEL: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC180_IN_SEL_CFG_REG: u32 = 1072972800;
pub const GPIO_SIG180_IN_SEL_V: u32 = 1;
pub const GPIO_SIG180_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC180_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC180_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC180_IN_SEL: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC181_IN_SEL_CFG_REG: u32 = 1072972804;
pub const GPIO_SIG181_IN_SEL_V: u32 = 1;
pub const GPIO_SIG181_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC181_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC181_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC181_IN_SEL: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC182_IN_SEL_CFG_REG: u32 = 1072972808;
pub const GPIO_SIG182_IN_SEL_V: u32 = 1;
pub const GPIO_SIG182_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC182_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC182_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC182_IN_SEL: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC183_IN_SEL_CFG_REG: u32 = 1072972812;
pub const GPIO_SIG183_IN_SEL_V: u32 = 1;
pub const GPIO_SIG183_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC183_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC183_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC183_IN_SEL: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC184_IN_SEL_CFG_REG: u32 = 1072972816;
pub const GPIO_SIG184_IN_SEL_V: u32 = 1;
pub const GPIO_SIG184_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC184_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC184_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC184_IN_SEL: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC185_IN_SEL_CFG_REG: u32 = 1072972820;
pub const GPIO_SIG185_IN_SEL_V: u32 = 1;
pub const GPIO_SIG185_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC185_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC185_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC185_IN_SEL: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC186_IN_SEL_CFG_REG: u32 = 1072972824;
pub const GPIO_SIG186_IN_SEL_V: u32 = 1;
pub const GPIO_SIG186_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC186_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC186_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC186_IN_SEL: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC187_IN_SEL_CFG_REG: u32 = 1072972828;
pub const GPIO_SIG187_IN_SEL_V: u32 = 1;
pub const GPIO_SIG187_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC187_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC187_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC187_IN_SEL: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC188_IN_SEL_CFG_REG: u32 = 1072972832;
pub const GPIO_SIG188_IN_SEL_V: u32 = 1;
pub const GPIO_SIG188_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC188_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC188_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC188_IN_SEL: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC189_IN_SEL_CFG_REG: u32 = 1072972836;
pub const GPIO_SIG189_IN_SEL_V: u32 = 1;
pub const GPIO_SIG189_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC189_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC189_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC189_IN_SEL: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC190_IN_SEL_CFG_REG: u32 = 1072972840;
pub const GPIO_SIG190_IN_SEL_V: u32 = 1;
pub const GPIO_SIG190_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC190_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC190_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC190_IN_SEL: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC191_IN_SEL_CFG_REG: u32 = 1072972844;
pub const GPIO_SIG191_IN_SEL_V: u32 = 1;
pub const GPIO_SIG191_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC191_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC191_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC191_IN_SEL: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC192_IN_SEL_CFG_REG: u32 = 1072972848;
pub const GPIO_SIG192_IN_SEL_V: u32 = 1;
pub const GPIO_SIG192_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC192_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC192_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC192_IN_SEL: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC193_IN_SEL_CFG_REG: u32 = 1072972852;
pub const GPIO_SIG193_IN_SEL_V: u32 = 1;
pub const GPIO_SIG193_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC193_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC193_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC193_IN_SEL: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC194_IN_SEL_CFG_REG: u32 = 1072972856;
pub const GPIO_SIG194_IN_SEL_V: u32 = 1;
pub const GPIO_SIG194_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC194_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC194_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC194_IN_SEL: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC195_IN_SEL_CFG_REG: u32 = 1072972860;
pub const GPIO_SIG195_IN_SEL_V: u32 = 1;
pub const GPIO_SIG195_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC195_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC195_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC195_IN_SEL: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC196_IN_SEL_CFG_REG: u32 = 1072972864;
pub const GPIO_SIG196_IN_SEL_V: u32 = 1;
pub const GPIO_SIG196_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC196_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC196_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC196_IN_SEL: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC197_IN_SEL_CFG_REG: u32 = 1072972868;
pub const GPIO_SIG197_IN_SEL_V: u32 = 1;
pub const GPIO_SIG197_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC197_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC197_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC197_IN_SEL: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC198_IN_SEL_CFG_REG: u32 = 1072972872;
pub const GPIO_SIG198_IN_SEL_V: u32 = 1;
pub const GPIO_SIG198_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC198_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC198_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC198_IN_SEL: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC199_IN_SEL_CFG_REG: u32 = 1072972876;
pub const GPIO_SIG199_IN_SEL_V: u32 = 1;
pub const GPIO_SIG199_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC199_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC199_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC199_IN_SEL: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC200_IN_SEL_CFG_REG: u32 = 1072972880;
pub const GPIO_SIG200_IN_SEL_V: u32 = 1;
pub const GPIO_SIG200_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC200_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC200_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC200_IN_SEL: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC201_IN_SEL_CFG_REG: u32 = 1072972884;
pub const GPIO_SIG201_IN_SEL_V: u32 = 1;
pub const GPIO_SIG201_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC201_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC201_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC201_IN_SEL: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC202_IN_SEL_CFG_REG: u32 = 1072972888;
pub const GPIO_SIG202_IN_SEL_V: u32 = 1;
pub const GPIO_SIG202_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC202_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC202_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC202_IN_SEL: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC203_IN_SEL_CFG_REG: u32 = 1072972892;
pub const GPIO_SIG203_IN_SEL_V: u32 = 1;
pub const GPIO_SIG203_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC203_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC203_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC203_IN_SEL: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC204_IN_SEL_CFG_REG: u32 = 1072972896;
pub const GPIO_SIG204_IN_SEL_V: u32 = 1;
pub const GPIO_SIG204_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC204_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC204_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC204_IN_SEL: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC205_IN_SEL_CFG_REG: u32 = 1072972900;
pub const GPIO_SIG205_IN_SEL_V: u32 = 1;
pub const GPIO_SIG205_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC205_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC205_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC205_IN_SEL: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC206_IN_SEL_CFG_REG: u32 = 1072972904;
pub const GPIO_SIG206_IN_SEL_V: u32 = 1;
pub const GPIO_SIG206_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC206_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC206_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC206_IN_SEL: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC207_IN_SEL_CFG_REG: u32 = 1072972908;
pub const GPIO_SIG207_IN_SEL_V: u32 = 1;
pub const GPIO_SIG207_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC207_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC207_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC207_IN_SEL: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC208_IN_SEL_CFG_REG: u32 = 1072972912;
pub const GPIO_SIG208_IN_SEL_V: u32 = 1;
pub const GPIO_SIG208_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC208_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC208_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC208_IN_SEL: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC209_IN_SEL_CFG_REG: u32 = 1072972916;
pub const GPIO_SIG209_IN_SEL_V: u32 = 1;
pub const GPIO_SIG209_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC209_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC209_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC209_IN_SEL: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC210_IN_SEL_CFG_REG: u32 = 1072972920;
pub const GPIO_SIG210_IN_SEL_V: u32 = 1;
pub const GPIO_SIG210_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC210_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC210_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC210_IN_SEL: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC211_IN_SEL_CFG_REG: u32 = 1072972924;
pub const GPIO_SIG211_IN_SEL_V: u32 = 1;
pub const GPIO_SIG211_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC211_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC211_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC211_IN_SEL: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC212_IN_SEL_CFG_REG: u32 = 1072972928;
pub const GPIO_SIG212_IN_SEL_V: u32 = 1;
pub const GPIO_SIG212_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC212_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC212_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC212_IN_SEL: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC213_IN_SEL_CFG_REG: u32 = 1072972932;
pub const GPIO_SIG213_IN_SEL_V: u32 = 1;
pub const GPIO_SIG213_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC213_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC213_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC213_IN_SEL: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC214_IN_SEL_CFG_REG: u32 = 1072972936;
pub const GPIO_SIG214_IN_SEL_V: u32 = 1;
pub const GPIO_SIG214_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC214_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC214_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC214_IN_SEL: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC215_IN_SEL_CFG_REG: u32 = 1072972940;
pub const GPIO_SIG215_IN_SEL_V: u32 = 1;
pub const GPIO_SIG215_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC215_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC215_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC215_IN_SEL: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC216_IN_SEL_CFG_REG: u32 = 1072972944;
pub const GPIO_SIG216_IN_SEL_V: u32 = 1;
pub const GPIO_SIG216_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC216_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC216_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC216_IN_SEL: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC217_IN_SEL_CFG_REG: u32 = 1072972948;
pub const GPIO_SIG217_IN_SEL_V: u32 = 1;
pub const GPIO_SIG217_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC217_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC217_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC217_IN_SEL: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC218_IN_SEL_CFG_REG: u32 = 1072972952;
pub const GPIO_SIG218_IN_SEL_V: u32 = 1;
pub const GPIO_SIG218_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC218_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC218_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC218_IN_SEL: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC219_IN_SEL_CFG_REG: u32 = 1072972956;
pub const GPIO_SIG219_IN_SEL_V: u32 = 1;
pub const GPIO_SIG219_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC219_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC219_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC219_IN_SEL: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC220_IN_SEL_CFG_REG: u32 = 1072972960;
pub const GPIO_SIG220_IN_SEL_V: u32 = 1;
pub const GPIO_SIG220_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC220_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC220_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC220_IN_SEL: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC221_IN_SEL_CFG_REG: u32 = 1072972964;
pub const GPIO_SIG221_IN_SEL_V: u32 = 1;
pub const GPIO_SIG221_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC221_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC221_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC221_IN_SEL: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC222_IN_SEL_CFG_REG: u32 = 1072972968;
pub const GPIO_SIG222_IN_SEL_V: u32 = 1;
pub const GPIO_SIG222_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC222_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC222_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC222_IN_SEL: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC223_IN_SEL_CFG_REG: u32 = 1072972972;
pub const GPIO_SIG223_IN_SEL_V: u32 = 1;
pub const GPIO_SIG223_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC223_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC223_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC223_IN_SEL: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC224_IN_SEL_CFG_REG: u32 = 1072972976;
pub const GPIO_SIG224_IN_SEL_V: u32 = 1;
pub const GPIO_SIG224_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC224_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC224_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC224_IN_SEL: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC225_IN_SEL_CFG_REG: u32 = 1072972980;
pub const GPIO_SIG225_IN_SEL_V: u32 = 1;
pub const GPIO_SIG225_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC225_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC225_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC225_IN_SEL: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC226_IN_SEL_CFG_REG: u32 = 1072972984;
pub const GPIO_SIG226_IN_SEL_V: u32 = 1;
pub const GPIO_SIG226_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC226_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC226_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC226_IN_SEL: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC227_IN_SEL_CFG_REG: u32 = 1072972988;
pub const GPIO_SIG227_IN_SEL_V: u32 = 1;
pub const GPIO_SIG227_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC227_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC227_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC227_IN_SEL: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC228_IN_SEL_CFG_REG: u32 = 1072972992;
pub const GPIO_SIG228_IN_SEL_V: u32 = 1;
pub const GPIO_SIG228_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC228_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC228_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC228_IN_SEL: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC229_IN_SEL_CFG_REG: u32 = 1072972996;
pub const GPIO_SIG229_IN_SEL_V: u32 = 1;
pub const GPIO_SIG229_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC229_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC229_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC229_IN_SEL: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC230_IN_SEL_CFG_REG: u32 = 1072973000;
pub const GPIO_SIG230_IN_SEL_V: u32 = 1;
pub const GPIO_SIG230_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC230_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC230_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC230_IN_SEL: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC231_IN_SEL_CFG_REG: u32 = 1072973004;
pub const GPIO_SIG231_IN_SEL_V: u32 = 1;
pub const GPIO_SIG231_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC231_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC231_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC231_IN_SEL: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC232_IN_SEL_CFG_REG: u32 = 1072973008;
pub const GPIO_SIG232_IN_SEL_V: u32 = 1;
pub const GPIO_SIG232_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC232_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC232_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC232_IN_SEL: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC233_IN_SEL_CFG_REG: u32 = 1072973012;
pub const GPIO_SIG233_IN_SEL_V: u32 = 1;
pub const GPIO_SIG233_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC233_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC233_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC233_IN_SEL: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC234_IN_SEL_CFG_REG: u32 = 1072973016;
pub const GPIO_SIG234_IN_SEL_V: u32 = 1;
pub const GPIO_SIG234_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC234_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC234_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC234_IN_SEL: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC235_IN_SEL_CFG_REG: u32 = 1072973020;
pub const GPIO_SIG235_IN_SEL_V: u32 = 1;
pub const GPIO_SIG235_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC235_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC235_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC235_IN_SEL: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC236_IN_SEL_CFG_REG: u32 = 1072973024;
pub const GPIO_SIG236_IN_SEL_V: u32 = 1;
pub const GPIO_SIG236_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC236_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC236_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC236_IN_SEL: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC237_IN_SEL_CFG_REG: u32 = 1072973028;
pub const GPIO_SIG237_IN_SEL_V: u32 = 1;
pub const GPIO_SIG237_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC237_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC237_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC237_IN_SEL: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC238_IN_SEL_CFG_REG: u32 = 1072973032;
pub const GPIO_SIG238_IN_SEL_V: u32 = 1;
pub const GPIO_SIG238_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC238_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC238_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC238_IN_SEL: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC239_IN_SEL_CFG_REG: u32 = 1072973036;
pub const GPIO_SIG239_IN_SEL_V: u32 = 1;
pub const GPIO_SIG239_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC239_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC239_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC239_IN_SEL: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC240_IN_SEL_CFG_REG: u32 = 1072973040;
pub const GPIO_SIG240_IN_SEL_V: u32 = 1;
pub const GPIO_SIG240_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC240_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC240_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC240_IN_SEL: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC241_IN_SEL_CFG_REG: u32 = 1072973044;
pub const GPIO_SIG241_IN_SEL_V: u32 = 1;
pub const GPIO_SIG241_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC241_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC241_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC241_IN_SEL: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC242_IN_SEL_CFG_REG: u32 = 1072973048;
pub const GPIO_SIG242_IN_SEL_V: u32 = 1;
pub const GPIO_SIG242_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC242_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC242_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC242_IN_SEL: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC243_IN_SEL_CFG_REG: u32 = 1072973052;
pub const GPIO_SIG243_IN_SEL_V: u32 = 1;
pub const GPIO_SIG243_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC243_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC243_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC243_IN_SEL: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC244_IN_SEL_CFG_REG: u32 = 1072973056;
pub const GPIO_SIG244_IN_SEL_V: u32 = 1;
pub const GPIO_SIG244_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC244_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC244_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC244_IN_SEL: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC245_IN_SEL_CFG_REG: u32 = 1072973060;
pub const GPIO_SIG245_IN_SEL_V: u32 = 1;
pub const GPIO_SIG245_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC245_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC245_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC245_IN_SEL: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC246_IN_SEL_CFG_REG: u32 = 1072973064;
pub const GPIO_SIG246_IN_SEL_V: u32 = 1;
pub const GPIO_SIG246_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC246_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC246_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC246_IN_SEL: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC247_IN_SEL_CFG_REG: u32 = 1072973068;
pub const GPIO_SIG247_IN_SEL_V: u32 = 1;
pub const GPIO_SIG247_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC247_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC247_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC247_IN_SEL: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC248_IN_SEL_CFG_REG: u32 = 1072973072;
pub const GPIO_SIG248_IN_SEL_V: u32 = 1;
pub const GPIO_SIG248_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC248_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC248_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC248_IN_SEL: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC249_IN_SEL_CFG_REG: u32 = 1072973076;
pub const GPIO_SIG249_IN_SEL_V: u32 = 1;
pub const GPIO_SIG249_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC249_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC249_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC249_IN_SEL: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC250_IN_SEL_CFG_REG: u32 = 1072973080;
pub const GPIO_SIG250_IN_SEL_V: u32 = 1;
pub const GPIO_SIG250_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC250_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC250_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC250_IN_SEL: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC251_IN_SEL_CFG_REG: u32 = 1072973084;
pub const GPIO_SIG251_IN_SEL_V: u32 = 1;
pub const GPIO_SIG251_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC251_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC251_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC251_IN_SEL: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC252_IN_SEL_CFG_REG: u32 = 1072973088;
pub const GPIO_SIG252_IN_SEL_V: u32 = 1;
pub const GPIO_SIG252_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC252_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC252_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC252_IN_SEL: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC253_IN_SEL_CFG_REG: u32 = 1072973092;
pub const GPIO_SIG253_IN_SEL_V: u32 = 1;
pub const GPIO_SIG253_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC253_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC253_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC253_IN_SEL: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC254_IN_SEL_CFG_REG: u32 = 1072973096;
pub const GPIO_SIG254_IN_SEL_V: u32 = 1;
pub const GPIO_SIG254_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC254_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC254_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC254_IN_SEL: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC255_IN_SEL_CFG_REG: u32 = 1072973100;
pub const GPIO_SIG255_IN_SEL_V: u32 = 1;
pub const GPIO_SIG255_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC255_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC255_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC255_IN_SEL: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC0_OUT_SEL_CFG_REG: u32 = 1072973104;
pub const GPIO_FUNC0_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC0_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC0_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC0_OUT_SEL: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC1_OUT_SEL_CFG_REG: u32 = 1072973108;
pub const GPIO_FUNC1_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC1_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC1_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC1_OUT_SEL: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC2_OUT_SEL_CFG_REG: u32 = 1072973112;
pub const GPIO_FUNC2_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC2_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC2_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC2_OUT_SEL: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC3_OUT_SEL_CFG_REG: u32 = 1072973116;
pub const GPIO_FUNC3_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC3_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC3_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC3_OUT_SEL: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC4_OUT_SEL_CFG_REG: u32 = 1072973120;
pub const GPIO_FUNC4_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC4_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC4_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC4_OUT_SEL: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC5_OUT_SEL_CFG_REG: u32 = 1072973124;
pub const GPIO_FUNC5_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC5_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC5_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC5_OUT_SEL: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC6_OUT_SEL_CFG_REG: u32 = 1072973128;
pub const GPIO_FUNC6_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC6_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC6_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC6_OUT_SEL: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC7_OUT_SEL_CFG_REG: u32 = 1072973132;
pub const GPIO_FUNC7_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC7_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC7_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC7_OUT_SEL: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC8_OUT_SEL_CFG_REG: u32 = 1072973136;
pub const GPIO_FUNC8_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC8_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC8_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC8_OUT_SEL: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC9_OUT_SEL_CFG_REG: u32 = 1072973140;
pub const GPIO_FUNC9_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC9_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC9_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC9_OUT_SEL: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC10_OUT_SEL_CFG_REG: u32 = 1072973144;
pub const GPIO_FUNC10_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC10_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC10_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC10_OUT_SEL: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC11_OUT_SEL_CFG_REG: u32 = 1072973148;
pub const GPIO_FUNC11_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC11_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC11_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC11_OUT_SEL: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC12_OUT_SEL_CFG_REG: u32 = 1072973152;
pub const GPIO_FUNC12_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC12_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC12_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC12_OUT_SEL: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC13_OUT_SEL_CFG_REG: u32 = 1072973156;
pub const GPIO_FUNC13_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC13_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC13_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC13_OUT_SEL: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC14_OUT_SEL_CFG_REG: u32 = 1072973160;
pub const GPIO_FUNC14_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC14_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC14_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC14_OUT_SEL: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC15_OUT_SEL_CFG_REG: u32 = 1072973164;
pub const GPIO_FUNC15_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC15_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC15_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC15_OUT_SEL: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC16_OUT_SEL_CFG_REG: u32 = 1072973168;
pub const GPIO_FUNC16_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC16_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC16_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC16_OUT_SEL: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC17_OUT_SEL_CFG_REG: u32 = 1072973172;
pub const GPIO_FUNC17_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC17_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC17_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC17_OUT_SEL: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC18_OUT_SEL_CFG_REG: u32 = 1072973176;
pub const GPIO_FUNC18_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC18_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC18_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC18_OUT_SEL: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC19_OUT_SEL_CFG_REG: u32 = 1072973180;
pub const GPIO_FUNC19_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC19_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC19_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC19_OUT_SEL: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC20_OUT_SEL_CFG_REG: u32 = 1072973184;
pub const GPIO_FUNC20_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC20_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC20_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC20_OUT_SEL: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC21_OUT_SEL_CFG_REG: u32 = 1072973188;
pub const GPIO_FUNC21_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC21_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC21_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC21_OUT_SEL: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC22_OUT_SEL_CFG_REG: u32 = 1072973192;
pub const GPIO_FUNC22_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC22_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC22_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC22_OUT_SEL: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC23_OUT_SEL_CFG_REG: u32 = 1072973196;
pub const GPIO_FUNC23_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC23_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC23_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC23_OUT_SEL: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC24_OUT_SEL_CFG_REG: u32 = 1072973200;
pub const GPIO_FUNC24_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC24_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC24_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC24_OUT_SEL: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC25_OUT_SEL_CFG_REG: u32 = 1072973204;
pub const GPIO_FUNC25_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC25_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC25_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC25_OUT_SEL: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC26_OUT_SEL_CFG_REG: u32 = 1072973208;
pub const GPIO_FUNC26_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC26_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC26_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC26_OUT_SEL: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC27_OUT_SEL_CFG_REG: u32 = 1072973212;
pub const GPIO_FUNC27_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC27_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC27_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC27_OUT_SEL: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC28_OUT_SEL_CFG_REG: u32 = 1072973216;
pub const GPIO_FUNC28_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC28_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC28_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC28_OUT_SEL: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC29_OUT_SEL_CFG_REG: u32 = 1072973220;
pub const GPIO_FUNC29_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC29_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC29_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC29_OUT_SEL: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC30_OUT_SEL_CFG_REG: u32 = 1072973224;
pub const GPIO_FUNC30_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC30_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC30_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC30_OUT_SEL: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC31_OUT_SEL_CFG_REG: u32 = 1072973228;
pub const GPIO_FUNC31_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC31_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC31_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC31_OUT_SEL: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC32_OUT_SEL_CFG_REG: u32 = 1072973232;
pub const GPIO_FUNC32_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC32_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC32_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC32_OUT_SEL: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC33_OUT_SEL_CFG_REG: u32 = 1072973236;
pub const GPIO_FUNC33_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC33_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC33_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC33_OUT_SEL: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC34_OUT_SEL_CFG_REG: u32 = 1072973240;
pub const GPIO_FUNC34_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC34_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC34_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC34_OUT_SEL: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC35_OUT_SEL_CFG_REG: u32 = 1072973244;
pub const GPIO_FUNC35_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC35_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC35_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC35_OUT_SEL: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC36_OUT_SEL_CFG_REG: u32 = 1072973248;
pub const GPIO_FUNC36_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC36_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC36_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC36_OUT_SEL: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC37_OUT_SEL_CFG_REG: u32 = 1072973252;
pub const GPIO_FUNC37_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC37_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC37_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC37_OUT_SEL: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC38_OUT_SEL_CFG_REG: u32 = 1072973256;
pub const GPIO_FUNC38_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC38_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC38_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC38_OUT_SEL: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC39_OUT_SEL_CFG_REG: u32 = 1072973260;
pub const GPIO_FUNC39_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC39_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC39_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC39_OUT_SEL: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_S: u32 = 0;
pub const RTC_GPIO_OUT_REG: u32 = 1072989184;
pub const RTC_GPIO_OUT_DATA: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_V: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_S: u32 = 14;
pub const RTC_GPIO_OUT_W1TS_REG: u32 = 1072989188;
pub const RTC_GPIO_OUT_DATA_W1TS: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TS_V: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TS_S: u32 = 14;
pub const RTC_GPIO_OUT_W1TC_REG: u32 = 1072989192;
pub const RTC_GPIO_OUT_DATA_W1TC: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TC_V: u32 = 262143;
pub const RTC_GPIO_OUT_DATA_W1TC_S: u32 = 14;
pub const RTC_GPIO_ENABLE_REG: u32 = 1072989196;
pub const RTC_GPIO_ENABLE: u32 = 262143;
pub const RTC_GPIO_ENABLE_V: u32 = 262143;
pub const RTC_GPIO_ENABLE_S: u32 = 14;
pub const RTC_GPIO_ENABLE_W1TS_REG: u32 = 1072989200;
pub const RTC_GPIO_ENABLE_W1TS: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TS_V: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TS_S: u32 = 14;
pub const RTC_GPIO_ENABLE_W1TC_REG: u32 = 1072989204;
pub const RTC_GPIO_ENABLE_W1TC: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TC_V: u32 = 262143;
pub const RTC_GPIO_ENABLE_W1TC_S: u32 = 14;
pub const RTC_GPIO_STATUS_REG: u32 = 1072989208;
pub const RTC_GPIO_STATUS_INT: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_V: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_S: u32 = 14;
pub const RTC_GPIO_STATUS_W1TS_REG: u32 = 1072989212;
pub const RTC_GPIO_STATUS_INT_W1TS: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TS_V: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TS_S: u32 = 14;
pub const RTC_GPIO_STATUS_W1TC_REG: u32 = 1072989216;
pub const RTC_GPIO_STATUS_INT_W1TC: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TC_V: u32 = 262143;
pub const RTC_GPIO_STATUS_INT_W1TC_S: u32 = 14;
pub const RTC_GPIO_IN_REG: u32 = 1072989220;
pub const RTC_GPIO_IN_NEXT: u32 = 262143;
pub const RTC_GPIO_IN_NEXT_V: u32 = 262143;
pub const RTC_GPIO_IN_NEXT_S: u32 = 14;
pub const RTC_GPIO_PIN0_REG: u32 = 1072989224;
pub const RTC_GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN0_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN0_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN0_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN1_REG: u32 = 1072989228;
pub const RTC_GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN1_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN1_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN1_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN2_REG: u32 = 1072989232;
pub const RTC_GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN2_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN2_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN2_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN3_REG: u32 = 1072989236;
pub const RTC_GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN3_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN3_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN3_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN4_REG: u32 = 1072989240;
pub const RTC_GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN4_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN4_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN4_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN5_REG: u32 = 1072989244;
pub const RTC_GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN5_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN5_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN5_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN6_REG: u32 = 1072989248;
pub const RTC_GPIO_PIN6_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN6_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN6_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN6_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN6_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN7_REG: u32 = 1072989252;
pub const RTC_GPIO_PIN7_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN7_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN7_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN7_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN7_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN8_REG: u32 = 1072989256;
pub const RTC_GPIO_PIN8_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN8_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN8_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN8_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN8_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN9_REG: u32 = 1072989260;
pub const RTC_GPIO_PIN9_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN9_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN9_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN9_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN9_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN10_REG: u32 = 1072989264;
pub const RTC_GPIO_PIN10_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN10_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN10_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN10_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN10_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN11_REG: u32 = 1072989268;
pub const RTC_GPIO_PIN11_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN11_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN11_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN11_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN11_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN12_REG: u32 = 1072989272;
pub const RTC_GPIO_PIN12_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN12_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN12_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN12_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN12_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN13_REG: u32 = 1072989276;
pub const RTC_GPIO_PIN13_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN13_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN13_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN13_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN13_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN14_REG: u32 = 1072989280;
pub const RTC_GPIO_PIN14_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN14_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN14_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN14_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN14_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN15_REG: u32 = 1072989284;
pub const RTC_GPIO_PIN15_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN15_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN15_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN15_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN15_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN16_REG: u32 = 1072989288;
pub const RTC_GPIO_PIN16_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN16_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN16_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN16_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN16_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN16_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN16_PAD_DRIVER_S: u32 = 2;
pub const RTC_GPIO_PIN17_REG: u32 = 1072989292;
pub const RTC_GPIO_PIN17_WAKEUP_ENABLE_V: u32 = 1;
pub const RTC_GPIO_PIN17_WAKEUP_ENABLE_S: u32 = 10;
pub const RTC_GPIO_PIN17_INT_TYPE: u32 = 7;
pub const RTC_GPIO_PIN17_INT_TYPE_V: u32 = 7;
pub const RTC_GPIO_PIN17_INT_TYPE_S: u32 = 7;
pub const RTC_GPIO_PIN17_PAD_DRIVER_V: u32 = 1;
pub const RTC_GPIO_PIN17_PAD_DRIVER_S: u32 = 2;
pub const RTC_IO_RTC_DEBUG_SEL_REG: u32 = 1072989296;
pub const RTC_IO_DEBUG_12M_NO_GATING_V: u32 = 1;
pub const RTC_IO_DEBUG_12M_NO_GATING_S: u32 = 25;
pub const RTC_IO_DEBUG_SEL4: u32 = 31;
pub const RTC_IO_DEBUG_SEL4_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL4_S: u32 = 20;
pub const RTC_IO_DEBUG_SEL3: u32 = 31;
pub const RTC_IO_DEBUG_SEL3_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL3_S: u32 = 15;
pub const RTC_IO_DEBUG_SEL2: u32 = 31;
pub const RTC_IO_DEBUG_SEL2_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL2_S: u32 = 10;
pub const RTC_IO_DEBUG_SEL1: u32 = 31;
pub const RTC_IO_DEBUG_SEL1_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL1_S: u32 = 5;
pub const RTC_IO_DEBUG_SEL0: u32 = 31;
pub const RTC_IO_DEBUG_SEL0_V: u32 = 31;
pub const RTC_IO_DEBUG_SEL0_S: u32 = 0;
pub const RTC_IO_DEBUG_SEL0_8M: u32 = 1;
pub const RTC_IO_DEBUG_SEL0_32K_XTAL: u32 = 4;
pub const RTC_IO_DEBUG_SEL0_150K_OSC: u32 = 5;
pub const RTC_IO_DIG_PAD_HOLD_REG: u32 = 1072989300;
pub const RTC_IO_DIG_PAD_HOLD: u32 = 4294967295;
pub const RTC_IO_DIG_PAD_HOLD_V: u32 = 4294967295;
pub const RTC_IO_DIG_PAD_HOLD_S: u32 = 0;
pub const RTC_IO_HALL_SENS_REG: u32 = 1072989304;
pub const RTC_IO_XPD_HALL_V: u32 = 1;
pub const RTC_IO_XPD_HALL_S: u32 = 31;
pub const RTC_IO_HALL_PHASE_V: u32 = 1;
pub const RTC_IO_HALL_PHASE_S: u32 = 30;
pub const RTC_IO_SENSOR_PADS_REG: u32 = 1072989308;
pub const RTC_IO_SENSE1_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE1_HOLD_S: u32 = 31;
pub const RTC_IO_SENSE2_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE2_HOLD_S: u32 = 30;
pub const RTC_IO_SENSE3_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE3_HOLD_S: u32 = 29;
pub const RTC_IO_SENSE4_HOLD_V: u32 = 1;
pub const RTC_IO_SENSE4_HOLD_S: u32 = 28;
pub const RTC_IO_SENSE1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE1_MUX_SEL_S: u32 = 27;
pub const RTC_IO_SENSE2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE2_MUX_SEL_S: u32 = 26;
pub const RTC_IO_SENSE3_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE3_MUX_SEL_S: u32 = 25;
pub const RTC_IO_SENSE4_MUX_SEL_V: u32 = 1;
pub const RTC_IO_SENSE4_MUX_SEL_S: u32 = 24;
pub const RTC_IO_SENSE1_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE1_FUN_SEL_S: u32 = 22;
pub const RTC_IO_SENSE1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE1_SLP_SEL_S: u32 = 21;
pub const RTC_IO_SENSE1_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE1_SLP_IE_S: u32 = 20;
pub const RTC_IO_SENSE1_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE1_FUN_IE_S: u32 = 19;
pub const RTC_IO_SENSE2_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE2_FUN_SEL_S: u32 = 17;
pub const RTC_IO_SENSE2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE2_SLP_SEL_S: u32 = 16;
pub const RTC_IO_SENSE2_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE2_SLP_IE_S: u32 = 15;
pub const RTC_IO_SENSE2_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE2_FUN_IE_S: u32 = 14;
pub const RTC_IO_SENSE3_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE3_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE3_FUN_SEL_S: u32 = 12;
pub const RTC_IO_SENSE3_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE3_SLP_SEL_S: u32 = 11;
pub const RTC_IO_SENSE3_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE3_SLP_IE_S: u32 = 10;
pub const RTC_IO_SENSE3_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE3_FUN_IE_S: u32 = 9;
pub const RTC_IO_SENSE4_FUN_SEL: u32 = 3;
pub const RTC_IO_SENSE4_FUN_SEL_V: u32 = 3;
pub const RTC_IO_SENSE4_FUN_SEL_S: u32 = 7;
pub const RTC_IO_SENSE4_SLP_SEL_V: u32 = 1;
pub const RTC_IO_SENSE4_SLP_SEL_S: u32 = 6;
pub const RTC_IO_SENSE4_SLP_IE_V: u32 = 1;
pub const RTC_IO_SENSE4_SLP_IE_S: u32 = 5;
pub const RTC_IO_SENSE4_FUN_IE_V: u32 = 1;
pub const RTC_IO_SENSE4_FUN_IE_S: u32 = 4;
pub const RTC_IO_ADC_PAD_REG: u32 = 1072989312;
pub const RTC_IO_ADC1_HOLD_V: u32 = 1;
pub const RTC_IO_ADC1_HOLD_S: u32 = 31;
pub const RTC_IO_ADC2_HOLD_V: u32 = 1;
pub const RTC_IO_ADC2_HOLD_S: u32 = 30;
pub const RTC_IO_ADC1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_ADC1_MUX_SEL_S: u32 = 29;
pub const RTC_IO_ADC2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_ADC2_MUX_SEL_S: u32 = 28;
pub const RTC_IO_ADC1_FUN_SEL: u32 = 3;
pub const RTC_IO_ADC1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_ADC1_FUN_SEL_S: u32 = 26;
pub const RTC_IO_ADC1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_ADC1_SLP_SEL_S: u32 = 25;
pub const RTC_IO_ADC1_SLP_IE_V: u32 = 1;
pub const RTC_IO_ADC1_SLP_IE_S: u32 = 24;
pub const RTC_IO_ADC1_FUN_IE_V: u32 = 1;
pub const RTC_IO_ADC1_FUN_IE_S: u32 = 23;
pub const RTC_IO_ADC2_FUN_SEL: u32 = 3;
pub const RTC_IO_ADC2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_ADC2_FUN_SEL_S: u32 = 21;
pub const RTC_IO_ADC2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_ADC2_SLP_SEL_S: u32 = 20;
pub const RTC_IO_ADC2_SLP_IE_V: u32 = 1;
pub const RTC_IO_ADC2_SLP_IE_S: u32 = 19;
pub const RTC_IO_ADC2_FUN_IE_V: u32 = 1;
pub const RTC_IO_ADC2_FUN_IE_S: u32 = 18;
pub const RTC_IO_PAD_DAC1_REG: u32 = 1072989316;
pub const RTC_IO_PDAC1_DRV: u32 = 3;
pub const RTC_IO_PDAC1_DRV_V: u32 = 3;
pub const RTC_IO_PDAC1_DRV_S: u32 = 30;
pub const RTC_IO_PDAC1_HOLD_V: u32 = 1;
pub const RTC_IO_PDAC1_HOLD_S: u32 = 29;
pub const RTC_IO_PDAC1_RDE_V: u32 = 1;
pub const RTC_IO_PDAC1_RDE_S: u32 = 28;
pub const RTC_IO_PDAC1_RUE_V: u32 = 1;
pub const RTC_IO_PDAC1_RUE_S: u32 = 27;
pub const RTC_IO_PDAC1_DAC: u32 = 255;
pub const RTC_IO_PDAC1_DAC_V: u32 = 255;
pub const RTC_IO_PDAC1_DAC_S: u32 = 19;
pub const RTC_IO_PDAC1_XPD_DAC_V: u32 = 1;
pub const RTC_IO_PDAC1_XPD_DAC_S: u32 = 18;
pub const RTC_IO_PDAC1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_PDAC1_MUX_SEL_S: u32 = 17;
pub const RTC_IO_PDAC1_FUN_SEL: u32 = 3;
pub const RTC_IO_PDAC1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_PDAC1_FUN_SEL_S: u32 = 15;
pub const RTC_IO_PDAC1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_PDAC1_SLP_SEL_S: u32 = 14;
pub const RTC_IO_PDAC1_SLP_IE_V: u32 = 1;
pub const RTC_IO_PDAC1_SLP_IE_S: u32 = 13;
pub const RTC_IO_PDAC1_SLP_OE_V: u32 = 1;
pub const RTC_IO_PDAC1_SLP_OE_S: u32 = 12;
pub const RTC_IO_PDAC1_FUN_IE_V: u32 = 1;
pub const RTC_IO_PDAC1_FUN_IE_S: u32 = 11;
pub const RTC_IO_PDAC1_DAC_XPD_FORCE_V: u32 = 1;
pub const RTC_IO_PDAC1_DAC_XPD_FORCE_S: u32 = 10;
pub const RTC_IO_PAD_DAC2_REG: u32 = 1072989320;
pub const RTC_IO_PDAC2_DRV: u32 = 3;
pub const RTC_IO_PDAC2_DRV_V: u32 = 3;
pub const RTC_IO_PDAC2_DRV_S: u32 = 30;
pub const RTC_IO_PDAC2_HOLD_V: u32 = 1;
pub const RTC_IO_PDAC2_HOLD_S: u32 = 29;
pub const RTC_IO_PDAC2_RDE_V: u32 = 1;
pub const RTC_IO_PDAC2_RDE_S: u32 = 28;
pub const RTC_IO_PDAC2_RUE_V: u32 = 1;
pub const RTC_IO_PDAC2_RUE_S: u32 = 27;
pub const RTC_IO_PDAC2_DAC: u32 = 255;
pub const RTC_IO_PDAC2_DAC_V: u32 = 255;
pub const RTC_IO_PDAC2_DAC_S: u32 = 19;
pub const RTC_IO_PDAC2_XPD_DAC_V: u32 = 1;
pub const RTC_IO_PDAC2_XPD_DAC_S: u32 = 18;
pub const RTC_IO_PDAC2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_PDAC2_MUX_SEL_S: u32 = 17;
pub const RTC_IO_PDAC2_FUN_SEL: u32 = 3;
pub const RTC_IO_PDAC2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_PDAC2_FUN_SEL_S: u32 = 15;
pub const RTC_IO_PDAC2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_PDAC2_SLP_SEL_S: u32 = 14;
pub const RTC_IO_PDAC2_SLP_IE_V: u32 = 1;
pub const RTC_IO_PDAC2_SLP_IE_S: u32 = 13;
pub const RTC_IO_PDAC2_SLP_OE_V: u32 = 1;
pub const RTC_IO_PDAC2_SLP_OE_S: u32 = 12;
pub const RTC_IO_PDAC2_FUN_IE_V: u32 = 1;
pub const RTC_IO_PDAC2_FUN_IE_S: u32 = 11;
pub const RTC_IO_PDAC2_DAC_XPD_FORCE_V: u32 = 1;
pub const RTC_IO_PDAC2_DAC_XPD_FORCE_S: u32 = 10;
pub const RTC_IO_XTAL_32K_PAD_REG: u32 = 1072989324;
pub const RTC_IO_X32N_DRV: u32 = 3;
pub const RTC_IO_X32N_DRV_V: u32 = 3;
pub const RTC_IO_X32N_DRV_S: u32 = 30;
pub const RTC_IO_X32N_HOLD_V: u32 = 1;
pub const RTC_IO_X32N_HOLD_S: u32 = 29;
pub const RTC_IO_X32N_RDE_V: u32 = 1;
pub const RTC_IO_X32N_RDE_S: u32 = 28;
pub const RTC_IO_X32N_RUE_V: u32 = 1;
pub const RTC_IO_X32N_RUE_S: u32 = 27;
pub const RTC_IO_X32P_DRV: u32 = 3;
pub const RTC_IO_X32P_DRV_V: u32 = 3;
pub const RTC_IO_X32P_DRV_S: u32 = 25;
pub const RTC_IO_X32P_HOLD_V: u32 = 1;
pub const RTC_IO_X32P_HOLD_S: u32 = 24;
pub const RTC_IO_X32P_RDE_V: u32 = 1;
pub const RTC_IO_X32P_RDE_S: u32 = 23;
pub const RTC_IO_X32P_RUE_V: u32 = 1;
pub const RTC_IO_X32P_RUE_S: u32 = 22;
pub const RTC_IO_DAC_XTAL_32K: u32 = 3;
pub const RTC_IO_DAC_XTAL_32K_V: u32 = 3;
pub const RTC_IO_DAC_XTAL_32K_S: u32 = 20;
pub const RTC_IO_XPD_XTAL_32K_V: u32 = 1;
pub const RTC_IO_XPD_XTAL_32K_S: u32 = 19;
pub const RTC_IO_X32N_MUX_SEL_V: u32 = 1;
pub const RTC_IO_X32N_MUX_SEL_S: u32 = 18;
pub const RTC_IO_X32P_MUX_SEL_V: u32 = 1;
pub const RTC_IO_X32P_MUX_SEL_S: u32 = 17;
pub const RTC_IO_X32N_FUN_SEL: u32 = 3;
pub const RTC_IO_X32N_FUN_SEL_V: u32 = 3;
pub const RTC_IO_X32N_FUN_SEL_S: u32 = 15;
pub const RTC_IO_X32N_SLP_SEL_V: u32 = 1;
pub const RTC_IO_X32N_SLP_SEL_S: u32 = 14;
pub const RTC_IO_X32N_SLP_IE_V: u32 = 1;
pub const RTC_IO_X32N_SLP_IE_S: u32 = 13;
pub const RTC_IO_X32N_SLP_OE_V: u32 = 1;
pub const RTC_IO_X32N_SLP_OE_S: u32 = 12;
pub const RTC_IO_X32N_FUN_IE_V: u32 = 1;
pub const RTC_IO_X32N_FUN_IE_S: u32 = 11;
pub const RTC_IO_X32P_FUN_SEL: u32 = 3;
pub const RTC_IO_X32P_FUN_SEL_V: u32 = 3;
pub const RTC_IO_X32P_FUN_SEL_S: u32 = 9;
pub const RTC_IO_X32P_SLP_SEL_V: u32 = 1;
pub const RTC_IO_X32P_SLP_SEL_S: u32 = 8;
pub const RTC_IO_X32P_SLP_IE_V: u32 = 1;
pub const RTC_IO_X32P_SLP_IE_S: u32 = 7;
pub const RTC_IO_X32P_SLP_OE_V: u32 = 1;
pub const RTC_IO_X32P_SLP_OE_S: u32 = 6;
pub const RTC_IO_X32P_FUN_IE_V: u32 = 1;
pub const RTC_IO_X32P_FUN_IE_S: u32 = 5;
pub const RTC_IO_DRES_XTAL_32K: u32 = 3;
pub const RTC_IO_DRES_XTAL_32K_V: u32 = 3;
pub const RTC_IO_DRES_XTAL_32K_S: u32 = 3;
pub const RTC_IO_DBIAS_XTAL_32K: u32 = 3;
pub const RTC_IO_DBIAS_XTAL_32K_V: u32 = 3;
pub const RTC_IO_DBIAS_XTAL_32K_S: u32 = 1;
pub const RTC_IO_TOUCH_CFG_REG: u32 = 1072989328;
pub const RTC_IO_TOUCH_XPD_BIAS_V: u32 = 1;
pub const RTC_IO_TOUCH_XPD_BIAS_S: u32 = 31;
pub const RTC_IO_TOUCH_DREFH: u32 = 3;
pub const RTC_IO_TOUCH_DREFH_V: u32 = 3;
pub const RTC_IO_TOUCH_DREFH_S: u32 = 29;
pub const RTC_IO_TOUCH_DREFL: u32 = 3;
pub const RTC_IO_TOUCH_DREFL_V: u32 = 3;
pub const RTC_IO_TOUCH_DREFL_S: u32 = 27;
pub const RTC_IO_TOUCH_DRANGE: u32 = 3;
pub const RTC_IO_TOUCH_DRANGE_V: u32 = 3;
pub const RTC_IO_TOUCH_DRANGE_S: u32 = 25;
pub const RTC_IO_TOUCH_DCUR: u32 = 3;
pub const RTC_IO_TOUCH_DCUR_V: u32 = 3;
pub const RTC_IO_TOUCH_DCUR_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD0_REG: u32 = 1072989332;
pub const RTC_IO_TOUCH_PAD0_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD0_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD0_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD0_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD0_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD0_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD0_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD0_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD0_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD0_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD0_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD0_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD0_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD0_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD0_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD0_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD0_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD0_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD0_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD1_REG: u32 = 1072989336;
pub const RTC_IO_TOUCH_PAD1_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD1_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD1_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD1_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD1_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD1_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD1_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD1_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD1_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD1_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD1_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD1_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD1_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD1_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD1_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD1_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD1_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD1_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD1_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD2_REG: u32 = 1072989340;
pub const RTC_IO_TOUCH_PAD2_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD2_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD2_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD2_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD2_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD2_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD2_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD2_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD2_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD2_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD2_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD2_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD2_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD2_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD2_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD2_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD2_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD2_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD2_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD3_REG: u32 = 1072989344;
pub const RTC_IO_TOUCH_PAD3_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD3_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD3_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD3_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD3_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD3_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD3_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD3_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD3_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD3_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD3_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD3_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD3_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD3_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD3_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD3_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD3_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD3_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD3_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD4_REG: u32 = 1072989348;
pub const RTC_IO_TOUCH_PAD4_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD4_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD4_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD4_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD4_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD4_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD4_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD4_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD4_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD4_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD4_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD4_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD4_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD4_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD4_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD4_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD4_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD4_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD4_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD5_REG: u32 = 1072989352;
pub const RTC_IO_TOUCH_PAD5_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD5_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD5_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD5_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD5_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD5_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD5_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD5_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD5_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD5_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD5_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD5_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD5_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD5_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD5_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD5_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD5_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD5_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD5_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD6_REG: u32 = 1072989356;
pub const RTC_IO_TOUCH_PAD6_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD6_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD6_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD6_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD6_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD6_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD6_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD6_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD6_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD6_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD6_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD6_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD6_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD6_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD6_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD6_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD6_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD6_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD6_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD7_REG: u32 = 1072989360;
pub const RTC_IO_TOUCH_PAD7_HOLD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_HOLD_S: u32 = 31;
pub const RTC_IO_TOUCH_PAD7_DRV: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_DRV_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_DRV_S: u32 = 29;
pub const RTC_IO_TOUCH_PAD7_RDE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_RDE_S: u32 = 28;
pub const RTC_IO_TOUCH_PAD7_RUE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_RUE_S: u32 = 27;
pub const RTC_IO_TOUCH_PAD7_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD7_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD7_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD7_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD7_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD7_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD7_MUX_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_MUX_SEL_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD7_FUN_SEL: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_FUN_SEL_V: u32 = 3;
pub const RTC_IO_TOUCH_PAD7_FUN_SEL_S: u32 = 17;
pub const RTC_IO_TOUCH_PAD7_SLP_SEL_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_SLP_SEL_S: u32 = 16;
pub const RTC_IO_TOUCH_PAD7_SLP_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_SLP_IE_S: u32 = 15;
pub const RTC_IO_TOUCH_PAD7_SLP_OE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_SLP_OE_S: u32 = 14;
pub const RTC_IO_TOUCH_PAD7_FUN_IE_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_FUN_IE_S: u32 = 13;
pub const RTC_IO_TOUCH_PAD7_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD7_TO_GPIO_S: u32 = 12;
pub const RTC_IO_TOUCH_PAD8_REG: u32 = 1072989364;
pub const RTC_IO_TOUCH_PAD8_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD8_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD8_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD8_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD8_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD8_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD8_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD8_TO_GPIO_S: u32 = 19;
pub const RTC_IO_TOUCH_PAD9_REG: u32 = 1072989368;
pub const RTC_IO_TOUCH_PAD9_DAC: u32 = 7;
pub const RTC_IO_TOUCH_PAD9_DAC_V: u32 = 7;
pub const RTC_IO_TOUCH_PAD9_DAC_S: u32 = 23;
pub const RTC_IO_TOUCH_PAD9_START_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_START_S: u32 = 22;
pub const RTC_IO_TOUCH_PAD9_TIE_OPT_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_TIE_OPT_S: u32 = 21;
pub const RTC_IO_TOUCH_PAD9_XPD_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_XPD_S: u32 = 20;
pub const RTC_IO_TOUCH_PAD9_TO_GPIO_V: u32 = 1;
pub const RTC_IO_TOUCH_PAD9_TO_GPIO_S: u32 = 19;
pub const RTC_IO_EXT_WAKEUP0_REG: u32 = 1072989372;
pub const RTC_IO_EXT_WAKEUP0_SEL: u32 = 31;
pub const RTC_IO_EXT_WAKEUP0_SEL_V: u32 = 31;
pub const RTC_IO_EXT_WAKEUP0_SEL_S: u32 = 27;
pub const RTC_IO_XTL_EXT_CTR_REG: u32 = 1072989376;
pub const RTC_IO_XTL_EXT_CTR_SEL: u32 = 31;
pub const RTC_IO_XTL_EXT_CTR_SEL_V: u32 = 31;
pub const RTC_IO_XTL_EXT_CTR_SEL_S: u32 = 27;
pub const RTC_IO_SAR_I2C_IO_REG: u32 = 1072989380;
pub const RTC_IO_SAR_I2C_SDA_SEL: u32 = 3;
pub const RTC_IO_SAR_I2C_SDA_SEL_V: u32 = 3;
pub const RTC_IO_SAR_I2C_SDA_SEL_S: u32 = 30;
pub const RTC_IO_SAR_I2C_SCL_SEL: u32 = 3;
pub const RTC_IO_SAR_I2C_SCL_SEL_V: u32 = 3;
pub const RTC_IO_SAR_I2C_SCL_SEL_S: u32 = 28;
pub const RTC_IO_SAR_DEBUG_BIT_SEL: u32 = 31;
pub const RTC_IO_SAR_DEBUG_BIT_SEL_V: u32 = 31;
pub const RTC_IO_SAR_DEBUG_BIT_SEL_S: u32 = 23;
pub const RTC_IO_DATE_REG: u32 = 1072989384;
pub const RTC_IO_IO_DATE: u32 = 268435455;
pub const RTC_IO_IO_DATE_V: u32 = 268435455;
pub const RTC_IO_IO_DATE_S: u32 = 0;
pub const RTC_IO_RTC_IO_DATE_VERSION: u32 = 24129888;
pub const SLP_OE_V: u32 = 1;
pub const SLP_OE_S: u32 = 0;
pub const SLP_SEL_V: u32 = 1;
pub const SLP_SEL_S: u32 = 1;
pub const SLP_PD_V: u32 = 1;
pub const SLP_PD_S: u32 = 2;
pub const SLP_PU_V: u32 = 1;
pub const SLP_PU_S: u32 = 3;
pub const SLP_IE_V: u32 = 1;
pub const SLP_IE_S: u32 = 4;
pub const SLP_DRV: u32 = 3;
pub const SLP_DRV_V: u32 = 3;
pub const SLP_DRV_S: u32 = 5;
pub const FUN_PD_V: u32 = 1;
pub const FUN_PD_S: u32 = 7;
pub const FUN_PU_V: u32 = 1;
pub const FUN_PU_S: u32 = 8;
pub const FUN_IE_V: u32 = 1;
pub const FUN_IE_S: u32 = 9;
pub const FUN_DRV: u32 = 3;
pub const FUN_DRV_V: u32 = 3;
pub const FUN_DRV_S: u32 = 10;
pub const MCU_SEL: u32 = 7;
pub const MCU_SEL_V: u32 = 7;
pub const MCU_SEL_S: u32 = 12;
pub const PIN_FUNC_GPIO: u32 = 2;
pub const PIN_CTRL: u32 = 1072992256;
pub const CLK_OUT3: u32 = 15;
pub const CLK_OUT3_V: u32 = 15;
pub const CLK_OUT3_S: u32 = 8;
pub const CLK_OUT3_M: u32 = 3840;
pub const CLK_OUT2: u32 = 15;
pub const CLK_OUT2_V: u32 = 15;
pub const CLK_OUT2_S: u32 = 4;
pub const CLK_OUT2_M: u32 = 240;
pub const CLK_OUT1: u32 = 15;
pub const CLK_OUT1_V: u32 = 15;
pub const CLK_OUT1_S: u32 = 0;
pub const CLK_OUT1_M: u32 = 15;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1072992324;
pub const IO_MUX_GPIO0_REG: u32 = 1072992324;
pub const FUNC_GPIO0_EMAC_TX_CLK: u32 = 5;
pub const FUNC_GPIO0_GPIO0: u32 = 2;
pub const FUNC_GPIO0_CLK_OUT1: u32 = 1;
pub const FUNC_GPIO0_GPIO0_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1072992392;
pub const IO_MUX_GPIO1_REG: u32 = 1072992392;
pub const FUNC_U0TXD_EMAC_RXD2: u32 = 5;
pub const FUNC_U0TXD_GPIO1: u32 = 2;
pub const FUNC_U0TXD_CLK_OUT3: u32 = 1;
pub const FUNC_U0TXD_U0TXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1072992320;
pub const IO_MUX_GPIO2_REG: u32 = 1072992320;
pub const FUNC_GPIO2_SD_DATA0: u32 = 4;
pub const FUNC_GPIO2_HS2_DATA0: u32 = 3;
pub const FUNC_GPIO2_GPIO2: u32 = 2;
pub const FUNC_GPIO2_HSPIWP: u32 = 1;
pub const FUNC_GPIO2_GPIO2_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1072992388;
pub const IO_MUX_GPIO3_REG: u32 = 1072992388;
pub const FUNC_U0RXD_GPIO3: u32 = 2;
pub const FUNC_U0RXD_CLK_OUT2: u32 = 1;
pub const FUNC_U0RXD_U0RXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1072992328;
pub const IO_MUX_GPIO4_REG: u32 = 1072992328;
pub const FUNC_GPIO4_EMAC_TX_ER: u32 = 5;
pub const FUNC_GPIO4_SD_DATA1: u32 = 4;
pub const FUNC_GPIO4_HS2_DATA1: u32 = 3;
pub const FUNC_GPIO4_GPIO4: u32 = 2;
pub const FUNC_GPIO4_HSPIHD: u32 = 1;
pub const FUNC_GPIO4_GPIO4_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1072992364;
pub const IO_MUX_GPIO5_REG: u32 = 1072992364;
pub const FUNC_GPIO5_EMAC_RX_CLK: u32 = 5;
pub const FUNC_GPIO5_HS1_DATA6: u32 = 3;
pub const FUNC_GPIO5_GPIO5: u32 = 2;
pub const FUNC_GPIO5_VSPICS0: u32 = 1;
pub const FUNC_GPIO5_GPIO5_0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1072992352;
pub const IO_MUX_GPIO6_REG: u32 = 1072992352;
pub const FUNC_SD_CLK_U1CTS: u32 = 4;
pub const FUNC_SD_CLK_HS1_CLK: u32 = 3;
pub const FUNC_SD_CLK_GPIO6: u32 = 2;
pub const FUNC_SD_CLK_SPICLK: u32 = 1;
pub const FUNC_SD_CLK_SD_CLK: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1072992356;
pub const IO_MUX_GPIO7_REG: u32 = 1072992356;
pub const FUNC_SD_DATA0_U2RTS: u32 = 4;
pub const FUNC_SD_DATA0_HS1_DATA0: u32 = 3;
pub const FUNC_SD_DATA0_GPIO7: u32 = 2;
pub const FUNC_SD_DATA0_SPIQ: u32 = 1;
pub const FUNC_SD_DATA0_SD_DATA0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1072992360;
pub const IO_MUX_GPIO8_REG: u32 = 1072992360;
pub const FUNC_SD_DATA1_U2CTS: u32 = 4;
pub const FUNC_SD_DATA1_HS1_DATA1: u32 = 3;
pub const FUNC_SD_DATA1_GPIO8: u32 = 2;
pub const FUNC_SD_DATA1_SPID: u32 = 1;
pub const FUNC_SD_DATA1_SD_DATA1: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1072992340;
pub const IO_MUX_GPIO9_REG: u32 = 1072992340;
pub const FUNC_SD_DATA2_U1RXD: u32 = 4;
pub const FUNC_SD_DATA2_HS1_DATA2: u32 = 3;
pub const FUNC_SD_DATA2_GPIO9: u32 = 2;
pub const FUNC_SD_DATA2_SPIHD: u32 = 1;
pub const FUNC_SD_DATA2_SD_DATA2: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1072992344;
pub const IO_MUX_GPIO10_REG: u32 = 1072992344;
pub const FUNC_SD_DATA3_U1TXD: u32 = 4;
pub const FUNC_SD_DATA3_HS1_DATA3: u32 = 3;
pub const FUNC_SD_DATA3_GPIO10: u32 = 2;
pub const FUNC_SD_DATA3_SPIWP: u32 = 1;
pub const FUNC_SD_DATA3_SD_DATA3: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1072992348;
pub const IO_MUX_GPIO11_REG: u32 = 1072992348;
pub const FUNC_SD_CMD_U1RTS: u32 = 4;
pub const FUNC_SD_CMD_HS1_CMD: u32 = 3;
pub const FUNC_SD_CMD_GPIO11: u32 = 2;
pub const FUNC_SD_CMD_SPICS0: u32 = 1;
pub const FUNC_SD_CMD_SD_CMD: u32 = 0;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1072992308;
pub const IO_MUX_GPIO12_REG: u32 = 1072992308;
pub const FUNC_MTDI_EMAC_TXD3: u32 = 5;
pub const FUNC_MTDI_SD_DATA2: u32 = 4;
pub const FUNC_MTDI_HS2_DATA2: u32 = 3;
pub const FUNC_MTDI_GPIO12: u32 = 2;
pub const FUNC_MTDI_HSPIQ: u32 = 1;
pub const FUNC_MTDI_MTDI: u32 = 0;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1072992312;
pub const IO_MUX_GPIO13_REG: u32 = 1072992312;
pub const FUNC_MTCK_EMAC_RX_ER: u32 = 5;
pub const FUNC_MTCK_SD_DATA3: u32 = 4;
pub const FUNC_MTCK_HS2_DATA3: u32 = 3;
pub const FUNC_MTCK_GPIO13: u32 = 2;
pub const FUNC_MTCK_HSPID: u32 = 1;
pub const FUNC_MTCK_MTCK: u32 = 0;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1072992304;
pub const IO_MUX_GPIO14_REG: u32 = 1072992304;
pub const FUNC_MTMS_EMAC_TXD2: u32 = 5;
pub const FUNC_MTMS_SD_CLK: u32 = 4;
pub const FUNC_MTMS_HS2_CLK: u32 = 3;
pub const FUNC_MTMS_GPIO14: u32 = 2;
pub const FUNC_MTMS_HSPICLK: u32 = 1;
pub const FUNC_MTMS_MTMS: u32 = 0;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1072992316;
pub const IO_MUX_GPIO15_REG: u32 = 1072992316;
pub const FUNC_MTDO_EMAC_RXD3: u32 = 5;
pub const FUNC_MTDO_SD_CMD: u32 = 4;
pub const FUNC_MTDO_HS2_CMD: u32 = 3;
pub const FUNC_MTDO_GPIO15: u32 = 2;
pub const FUNC_MTDO_HSPICS0: u32 = 1;
pub const FUNC_MTDO_MTDO: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO16_U: u32 = 1072992332;
pub const IO_MUX_GPIO16_REG: u32 = 1072992332;
pub const FUNC_GPIO16_EMAC_CLK_OUT: u32 = 5;
pub const FUNC_GPIO16_U2RXD: u32 = 4;
pub const FUNC_GPIO16_HS1_DATA4: u32 = 3;
pub const FUNC_GPIO16_GPIO16: u32 = 2;
pub const FUNC_GPIO16_GPIO16_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO17_U: u32 = 1072992336;
pub const IO_MUX_GPIO17_REG: u32 = 1072992336;
pub const FUNC_GPIO17_EMAC_CLK_OUT_180: u32 = 5;
pub const FUNC_GPIO17_U2TXD: u32 = 4;
pub const FUNC_GPIO17_HS1_DATA5: u32 = 3;
pub const FUNC_GPIO17_GPIO17: u32 = 2;
pub const FUNC_GPIO17_GPIO17_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO18_U: u32 = 1072992368;
pub const IO_MUX_GPIO18_REG: u32 = 1072992368;
pub const FUNC_GPIO18_HS1_DATA7: u32 = 3;
pub const FUNC_GPIO18_GPIO18: u32 = 2;
pub const FUNC_GPIO18_VSPICLK: u32 = 1;
pub const FUNC_GPIO18_GPIO18_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO19_U: u32 = 1072992372;
pub const IO_MUX_GPIO19_REG: u32 = 1072992372;
pub const FUNC_GPIO19_EMAC_TXD0: u32 = 5;
pub const FUNC_GPIO19_U0CTS: u32 = 3;
pub const FUNC_GPIO19_GPIO19: u32 = 2;
pub const FUNC_GPIO19_VSPIQ: u32 = 1;
pub const FUNC_GPIO19_GPIO19_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO20_U: u32 = 1072992376;
pub const IO_MUX_GPIO20_REG: u32 = 1072992376;
pub const FUNC_GPIO20_GPIO20: u32 = 2;
pub const FUNC_GPIO20_GPIO20_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO21_U: u32 = 1072992380;
pub const IO_MUX_GPIO21_REG: u32 = 1072992380;
pub const FUNC_GPIO21_EMAC_TX_EN: u32 = 5;
pub const FUNC_GPIO21_GPIO21: u32 = 2;
pub const FUNC_GPIO21_VSPIHD: u32 = 1;
pub const FUNC_GPIO21_GPIO21_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO22_U: u32 = 1072992384;
pub const IO_MUX_GPIO22_REG: u32 = 1072992384;
pub const FUNC_GPIO22_EMAC_TXD1: u32 = 5;
pub const FUNC_GPIO22_U0RTS: u32 = 3;
pub const FUNC_GPIO22_GPIO22: u32 = 2;
pub const FUNC_GPIO22_VSPIWP: u32 = 1;
pub const FUNC_GPIO22_GPIO22_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO23_U: u32 = 1072992396;
pub const IO_MUX_GPIO23_REG: u32 = 1072992396;
pub const FUNC_GPIO23_HS1_STROBE: u32 = 3;
pub const FUNC_GPIO23_GPIO23: u32 = 2;
pub const FUNC_GPIO23_VSPID: u32 = 1;
pub const FUNC_GPIO23_GPIO23_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO24_U: u32 = 1072992400;
pub const IO_MUX_GPIO24_REG: u32 = 1072992400;
pub const FUNC_GPIO24_GPIO24: u32 = 2;
pub const FUNC_GPIO24_GPIO24_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO25_U: u32 = 1072992292;
pub const IO_MUX_GPIO25_REG: u32 = 1072992292;
pub const FUNC_GPIO25_EMAC_RXD0: u32 = 5;
pub const FUNC_GPIO25_GPIO25: u32 = 2;
pub const FUNC_GPIO25_GPIO25_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO26_U: u32 = 1072992296;
pub const IO_MUX_GPIO26_REG: u32 = 1072992296;
pub const FUNC_GPIO26_EMAC_RXD1: u32 = 5;
pub const FUNC_GPIO26_GPIO26: u32 = 2;
pub const FUNC_GPIO26_GPIO26_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO27_U: u32 = 1072992300;
pub const IO_MUX_GPIO27_REG: u32 = 1072992300;
pub const FUNC_GPIO27_EMAC_RX_DV: u32 = 5;
pub const FUNC_GPIO27_GPIO27: u32 = 2;
pub const FUNC_GPIO27_GPIO27_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO32_U: u32 = 1072992284;
pub const IO_MUX_GPIO32_REG: u32 = 1072992284;
pub const FUNC_GPIO32_GPIO32: u32 = 2;
pub const FUNC_GPIO32_GPIO32_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO33_U: u32 = 1072992288;
pub const IO_MUX_GPIO33_REG: u32 = 1072992288;
pub const FUNC_GPIO33_GPIO33: u32 = 2;
pub const FUNC_GPIO33_GPIO33_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO34_U: u32 = 1072992276;
pub const IO_MUX_GPIO34_REG: u32 = 1072992276;
pub const FUNC_GPIO34_GPIO34: u32 = 2;
pub const FUNC_GPIO34_GPIO34_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO35_U: u32 = 1072992280;
pub const IO_MUX_GPIO35_REG: u32 = 1072992280;
pub const FUNC_GPIO35_GPIO35: u32 = 2;
pub const FUNC_GPIO35_GPIO35_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO36_U: u32 = 1072992260;
pub const IO_MUX_GPIO36_REG: u32 = 1072992260;
pub const FUNC_GPIO36_GPIO36: u32 = 2;
pub const FUNC_GPIO36_GPIO36_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO37_U: u32 = 1072992264;
pub const IO_MUX_GPIO37_REG: u32 = 1072992264;
pub const FUNC_GPIO37_GPIO37: u32 = 2;
pub const FUNC_GPIO37_GPIO37_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO38_U: u32 = 1072992268;
pub const IO_MUX_GPIO38_REG: u32 = 1072992268;
pub const FUNC_GPIO38_GPIO38: u32 = 2;
pub const FUNC_GPIO38_GPIO38_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO39_U: u32 = 1072992272;
pub const IO_MUX_GPIO39_REG: u32 = 1072992272;
pub const FUNC_GPIO39_GPIO39: u32 = 2;
pub const FUNC_GPIO39_GPIO39_0: u32 = 0;
pub const SPICLK_IN_IDX: u32 = 0;
pub const SPICLK_OUT_IDX: u32 = 0;
pub const SPIQ_IN_IDX: u32 = 1;
pub const SPIQ_OUT_IDX: u32 = 1;
pub const SPID_IN_IDX: u32 = 2;
pub const SPID_OUT_IDX: u32 = 2;
pub const SPIHD_IN_IDX: u32 = 3;
pub const SPIHD_OUT_IDX: u32 = 3;
pub const SPIWP_IN_IDX: u32 = 4;
pub const SPIWP_OUT_IDX: u32 = 4;
pub const SPICS0_IN_IDX: u32 = 5;
pub const SPICS0_OUT_IDX: u32 = 5;
pub const SPICS1_IN_IDX: u32 = 6;
pub const SPICS1_OUT_IDX: u32 = 6;
pub const SPICS2_IN_IDX: u32 = 7;
pub const SPICS2_OUT_IDX: u32 = 7;
pub const HSPICLK_IN_IDX: u32 = 8;
pub const HSPICLK_OUT_IDX: u32 = 8;
pub const HSPIQ_IN_IDX: u32 = 9;
pub const HSPIQ_OUT_IDX: u32 = 9;
pub const HSPID_IN_IDX: u32 = 10;
pub const HSPID_OUT_IDX: u32 = 10;
pub const HSPICS0_IN_IDX: u32 = 11;
pub const HSPICS0_OUT_IDX: u32 = 11;
pub const HSPIHD_IN_IDX: u32 = 12;
pub const HSPIHD_OUT_IDX: u32 = 12;
pub const HSPIWP_IN_IDX: u32 = 13;
pub const HSPIWP_OUT_IDX: u32 = 13;
pub const U0RXD_IN_IDX: u32 = 14;
pub const U0TXD_OUT_IDX: u32 = 14;
pub const U0CTS_IN_IDX: u32 = 15;
pub const U0RTS_OUT_IDX: u32 = 15;
pub const U0DSR_IN_IDX: u32 = 16;
pub const U0DTR_OUT_IDX: u32 = 16;
pub const U1RXD_IN_IDX: u32 = 17;
pub const U1TXD_OUT_IDX: u32 = 17;
pub const U1CTS_IN_IDX: u32 = 18;
pub const U1RTS_OUT_IDX: u32 = 18;
pub const I2CM_SCL_O_IDX: u32 = 19;
pub const I2CM_SDA_I_IDX: u32 = 20;
pub const I2CM_SDA_O_IDX: u32 = 20;
pub const EXT_I2C_SCL_O_IDX: u32 = 21;
pub const EXT_I2C_SDA_O_IDX: u32 = 22;
pub const EXT_I2C_SDA_I_IDX: u32 = 22;
pub const I2S0O_BCK_IN_IDX: u32 = 23;
pub const I2S0O_BCK_OUT_IDX: u32 = 23;
pub const I2S1O_BCK_IN_IDX: u32 = 24;
pub const I2S1O_BCK_OUT_IDX: u32 = 24;
pub const I2S0O_WS_IN_IDX: u32 = 25;
pub const I2S0O_WS_OUT_IDX: u32 = 25;
pub const I2S1O_WS_IN_IDX: u32 = 26;
pub const I2S1O_WS_OUT_IDX: u32 = 26;
pub const I2S0I_BCK_IN_IDX: u32 = 27;
pub const I2S0I_BCK_OUT_IDX: u32 = 27;
pub const I2S0I_WS_IN_IDX: u32 = 28;
pub const I2S0I_WS_OUT_IDX: u32 = 28;
pub const I2CEXT0_SCL_IN_IDX: u32 = 29;
pub const I2CEXT0_SCL_OUT_IDX: u32 = 29;
pub const I2CEXT0_SDA_IN_IDX: u32 = 30;
pub const I2CEXT0_SDA_OUT_IDX: u32 = 30;
pub const PWM0_SYNC0_IN_IDX: u32 = 31;
pub const SDIO_TOHOST_INT_OUT_IDX: u32 = 31;
pub const PWM0_SYNC1_IN_IDX: u32 = 32;
pub const PWM0_OUT0A_IDX: u32 = 32;
pub const PWM0_SYNC2_IN_IDX: u32 = 33;
pub const PWM0_OUT0B_IDX: u32 = 33;
pub const PWM0_F0_IN_IDX: u32 = 34;
pub const PWM0_OUT1A_IDX: u32 = 34;
pub const PWM0_F1_IN_IDX: u32 = 35;
pub const PWM0_OUT1B_IDX: u32 = 35;
pub const PWM0_F2_IN_IDX: u32 = 36;
pub const PWM0_OUT2A_IDX: u32 = 36;
pub const GPIO_BT_ACTIVE_IDX: u32 = 37;
pub const PWM0_OUT2B_IDX: u32 = 37;
pub const GPIO_BT_PRIORITY_IDX: u32 = 38;
pub const PCNT_SIG_CH0_IN0_IDX: u32 = 39;
pub const PCNT_SIG_CH1_IN0_IDX: u32 = 40;
pub const GPIO_WLAN_ACTIVE_IDX: u32 = 40;
pub const PCNT_CTRL_CH0_IN0_IDX: u32 = 41;
pub const BB_DIAG0_IDX: u32 = 41;
pub const PCNT_CTRL_CH1_IN0_IDX: u32 = 42;
pub const BB_DIAG1_IDX: u32 = 42;
pub const PCNT_SIG_CH0_IN1_IDX: u32 = 43;
pub const BB_DIAG2_IDX: u32 = 43;
pub const PCNT_SIG_CH1_IN1_IDX: u32 = 44;
pub const BB_DIAG3_IDX: u32 = 44;
pub const PCNT_CTRL_CH0_IN1_IDX: u32 = 45;
pub const BB_DIAG4_IDX: u32 = 45;
pub const PCNT_CTRL_CH1_IN1_IDX: u32 = 46;
pub const BB_DIAG5_IDX: u32 = 46;
pub const PCNT_SIG_CH0_IN2_IDX: u32 = 47;
pub const BB_DIAG6_IDX: u32 = 47;
pub const PCNT_SIG_CH1_IN2_IDX: u32 = 48;
pub const BB_DIAG7_IDX: u32 = 48;
pub const PCNT_CTRL_CH0_IN2_IDX: u32 = 49;
pub const BB_DIAG8_IDX: u32 = 49;
pub const PCNT_CTRL_CH1_IN2_IDX: u32 = 50;
pub const BB_DIAG9_IDX: u32 = 50;
pub const PCNT_SIG_CH0_IN3_IDX: u32 = 51;
pub const BB_DIAG10_IDX: u32 = 51;
pub const PCNT_SIG_CH1_IN3_IDX: u32 = 52;
pub const BB_DIAG11_IDX: u32 = 52;
pub const PCNT_CTRL_CH0_IN3_IDX: u32 = 53;
pub const BB_DIAG12_IDX: u32 = 53;
pub const PCNT_CTRL_CH1_IN3_IDX: u32 = 54;
pub const BB_DIAG13_IDX: u32 = 54;
pub const PCNT_SIG_CH0_IN4_IDX: u32 = 55;
pub const BB_DIAG14_IDX: u32 = 55;
pub const PCNT_SIG_CH1_IN4_IDX: u32 = 56;
pub const BB_DIAG15_IDX: u32 = 56;
pub const PCNT_CTRL_CH0_IN4_IDX: u32 = 57;
pub const BB_DIAG16_IDX: u32 = 57;
pub const PCNT_CTRL_CH1_IN4_IDX: u32 = 58;
pub const BB_DIAG17_IDX: u32 = 58;
pub const BB_DIAG18_IDX: u32 = 59;
pub const BB_DIAG19_IDX: u32 = 60;
pub const HSPICS1_IN_IDX: u32 = 61;
pub const HSPICS1_OUT_IDX: u32 = 61;
pub const HSPICS2_IN_IDX: u32 = 62;
pub const HSPICS2_OUT_IDX: u32 = 62;
pub const VSPICLK_IN_IDX: u32 = 63;
pub const VSPICLK_OUT_IDX: u32 = 63;
pub const VSPIQ_IN_IDX: u32 = 64;
pub const VSPIQ_OUT_IDX: u32 = 64;
pub const VSPID_IN_IDX: u32 = 65;
pub const VSPID_OUT_IDX: u32 = 65;
pub const VSPIHD_IN_IDX: u32 = 66;
pub const VSPIHD_OUT_IDX: u32 = 66;
pub const VSPIWP_IN_IDX: u32 = 67;
pub const VSPIWP_OUT_IDX: u32 = 67;
pub const VSPICS0_IN_IDX: u32 = 68;
pub const VSPICS0_OUT_IDX: u32 = 68;
pub const VSPICS1_IN_IDX: u32 = 69;
pub const VSPICS1_OUT_IDX: u32 = 69;
pub const VSPICS2_IN_IDX: u32 = 70;
pub const VSPICS2_OUT_IDX: u32 = 70;
pub const PCNT_SIG_CH0_IN5_IDX: u32 = 71;
pub const LEDC_HS_SIG_OUT0_IDX: u32 = 71;
pub const PCNT_SIG_CH1_IN5_IDX: u32 = 72;
pub const LEDC_HS_SIG_OUT1_IDX: u32 = 72;
pub const PCNT_CTRL_CH0_IN5_IDX: u32 = 73;
pub const LEDC_HS_SIG_OUT2_IDX: u32 = 73;
pub const PCNT_CTRL_CH1_IN5_IDX: u32 = 74;
pub const LEDC_HS_SIG_OUT3_IDX: u32 = 74;
pub const PCNT_SIG_CH0_IN6_IDX: u32 = 75;
pub const LEDC_HS_SIG_OUT4_IDX: u32 = 75;
pub const PCNT_SIG_CH1_IN6_IDX: u32 = 76;
pub const LEDC_HS_SIG_OUT5_IDX: u32 = 76;
pub const PCNT_CTRL_CH0_IN6_IDX: u32 = 77;
pub const LEDC_HS_SIG_OUT6_IDX: u32 = 77;
pub const PCNT_CTRL_CH1_IN6_IDX: u32 = 78;
pub const LEDC_HS_SIG_OUT7_IDX: u32 = 78;
pub const PCNT_SIG_CH0_IN7_IDX: u32 = 79;
pub const LEDC_LS_SIG_OUT0_IDX: u32 = 79;
pub const PCNT_SIG_CH1_IN7_IDX: u32 = 80;
pub const LEDC_LS_SIG_OUT1_IDX: u32 = 80;
pub const PCNT_CTRL_CH0_IN7_IDX: u32 = 81;
pub const LEDC_LS_SIG_OUT2_IDX: u32 = 81;
pub const PCNT_CTRL_CH1_IN7_IDX: u32 = 82;
pub const LEDC_LS_SIG_OUT3_IDX: u32 = 82;
pub const RMT_SIG_IN0_IDX: u32 = 83;
pub const LEDC_LS_SIG_OUT4_IDX: u32 = 83;
pub const RMT_SIG_IN1_IDX: u32 = 84;
pub const LEDC_LS_SIG_OUT5_IDX: u32 = 84;
pub const RMT_SIG_IN2_IDX: u32 = 85;
pub const LEDC_LS_SIG_OUT6_IDX: u32 = 85;
pub const RMT_SIG_IN3_IDX: u32 = 86;
pub const LEDC_LS_SIG_OUT7_IDX: u32 = 86;
pub const RMT_SIG_IN4_IDX: u32 = 87;
pub const RMT_SIG_OUT0_IDX: u32 = 87;
pub const RMT_SIG_IN5_IDX: u32 = 88;
pub const RMT_SIG_OUT1_IDX: u32 = 88;
pub const RMT_SIG_IN6_IDX: u32 = 89;
pub const RMT_SIG_OUT2_IDX: u32 = 89;
pub const RMT_SIG_IN7_IDX: u32 = 90;
pub const RMT_SIG_OUT3_IDX: u32 = 90;
pub const RMT_SIG_OUT4_IDX: u32 = 91;
pub const RMT_SIG_OUT5_IDX: u32 = 92;
pub const EXT_ADC_START_IDX: u32 = 93;
pub const RMT_SIG_OUT6_IDX: u32 = 93;
pub const CAN_RX_IDX: u32 = 94;
pub const RMT_SIG_OUT7_IDX: u32 = 94;
pub const I2CEXT1_SCL_IN_IDX: u32 = 95;
pub const I2CEXT1_SCL_OUT_IDX: u32 = 95;
pub const I2CEXT1_SDA_IN_IDX: u32 = 96;
pub const I2CEXT1_SDA_OUT_IDX: u32 = 96;
pub const HOST_CARD_DETECT_N_1_IDX: u32 = 97;
pub const HOST_CCMD_OD_PULLUP_EN_N_IDX: u32 = 97;
pub const HOST_CARD_DETECT_N_2_IDX: u32 = 98;
pub const HOST_RST_N_1_IDX: u32 = 98;
pub const HOST_CARD_WRITE_PRT_1_IDX: u32 = 99;
pub const HOST_RST_N_2_IDX: u32 = 99;
pub const HOST_CARD_WRITE_PRT_2_IDX: u32 = 100;
pub const GPIO_SD0_OUT_IDX: u32 = 100;
pub const HOST_CARD_INT_N_1_IDX: u32 = 101;
pub const GPIO_SD1_OUT_IDX: u32 = 101;
pub const HOST_CARD_INT_N_2_IDX: u32 = 102;
pub const GPIO_SD2_OUT_IDX: u32 = 102;
pub const PWM1_SYNC0_IN_IDX: u32 = 103;
pub const GPIO_SD3_OUT_IDX: u32 = 103;
pub const PWM1_SYNC1_IN_IDX: u32 = 104;
pub const GPIO_SD4_OUT_IDX: u32 = 104;
pub const PWM1_SYNC2_IN_IDX: u32 = 105;
pub const GPIO_SD5_OUT_IDX: u32 = 105;
pub const PWM1_F0_IN_IDX: u32 = 106;
pub const GPIO_SD6_OUT_IDX: u32 = 106;
pub const PWM1_F1_IN_IDX: u32 = 107;
pub const GPIO_SD7_OUT_IDX: u32 = 107;
pub const PWM1_F2_IN_IDX: u32 = 108;
pub const PWM1_OUT0A_IDX: u32 = 108;
pub const PWM0_CAP0_IN_IDX: u32 = 109;
pub const PWM1_OUT0B_IDX: u32 = 109;
pub const PWM0_CAP1_IN_IDX: u32 = 110;
pub const PWM1_OUT1A_IDX: u32 = 110;
pub const PWM0_CAP2_IN_IDX: u32 = 111;
pub const PWM1_OUT1B_IDX: u32 = 111;
pub const PWM1_CAP0_IN_IDX: u32 = 112;
pub const PWM1_OUT2A_IDX: u32 = 112;
pub const PWM1_CAP1_IN_IDX: u32 = 113;
pub const PWM1_OUT2B_IDX: u32 = 113;
pub const PWM1_CAP2_IN_IDX: u32 = 114;
pub const PWM2_OUT1H_IDX: u32 = 114;
pub const PWM2_FLTA_IDX: u32 = 115;
pub const PWM2_OUT1L_IDX: u32 = 115;
pub const PWM2_FLTB_IDX: u32 = 116;
pub const PWM2_OUT2H_IDX: u32 = 116;
pub const PWM2_CAP1_IN_IDX: u32 = 117;
pub const PWM2_OUT2L_IDX: u32 = 117;
pub const PWM2_CAP2_IN_IDX: u32 = 118;
pub const PWM2_OUT3H_IDX: u32 = 118;
pub const PWM2_CAP3_IN_IDX: u32 = 119;
pub const PWM2_OUT3L_IDX: u32 = 119;
pub const PWM3_FLTA_IDX: u32 = 120;
pub const PWM2_OUT4H_IDX: u32 = 120;
pub const PWM3_FLTB_IDX: u32 = 121;
pub const PWM2_OUT4L_IDX: u32 = 121;
pub const PWM3_CAP1_IN_IDX: u32 = 122;
pub const PWM3_CAP2_IN_IDX: u32 = 123;
pub const CAN_TX_IDX: u32 = 123;
pub const PWM3_CAP3_IN_IDX: u32 = 124;
pub const CAN_BUS_OFF_ON_IDX: u32 = 124;
pub const CAN_CLKOUT_IDX: u32 = 125;
pub const SPID4_IN_IDX: u32 = 128;
pub const SPID4_OUT_IDX: u32 = 128;
pub const SPID5_IN_IDX: u32 = 129;
pub const SPID5_OUT_IDX: u32 = 129;
pub const SPID6_IN_IDX: u32 = 130;
pub const SPID6_OUT_IDX: u32 = 130;
pub const SPID7_IN_IDX: u32 = 131;
pub const SPID7_OUT_IDX: u32 = 131;
pub const HSPID4_IN_IDX: u32 = 132;
pub const HSPID4_OUT_IDX: u32 = 132;
pub const HSPID5_IN_IDX: u32 = 133;
pub const HSPID5_OUT_IDX: u32 = 133;
pub const HSPID6_IN_IDX: u32 = 134;
pub const HSPID6_OUT_IDX: u32 = 134;
pub const HSPID7_IN_IDX: u32 = 135;
pub const HSPID7_OUT_IDX: u32 = 135;
pub const VSPID4_IN_IDX: u32 = 136;
pub const VSPID4_OUT_IDX: u32 = 136;
pub const VSPID5_IN_IDX: u32 = 137;
pub const VSPID5_OUT_IDX: u32 = 137;
pub const VSPID6_IN_IDX: u32 = 138;
pub const VSPID6_OUT_IDX: u32 = 138;
pub const VSPID7_IN_IDX: u32 = 139;
pub const VSPID7_OUT_IDX: u32 = 139;
pub const I2S0I_DATA_IN0_IDX: u32 = 140;
pub const I2S0O_DATA_OUT0_IDX: u32 = 140;
pub const I2S0I_DATA_IN1_IDX: u32 = 141;
pub const I2S0O_DATA_OUT1_IDX: u32 = 141;
pub const I2S0I_DATA_IN2_IDX: u32 = 142;
pub const I2S0O_DATA_OUT2_IDX: u32 = 142;
pub const I2S0I_DATA_IN3_IDX: u32 = 143;
pub const I2S0O_DATA_OUT3_IDX: u32 = 143;
pub const I2S0I_DATA_IN4_IDX: u32 = 144;
pub const I2S0O_DATA_OUT4_IDX: u32 = 144;
pub const I2S0I_DATA_IN5_IDX: u32 = 145;
pub const I2S0O_DATA_OUT5_IDX: u32 = 145;
pub const I2S0I_DATA_IN6_IDX: u32 = 146;
pub const I2S0O_DATA_OUT6_IDX: u32 = 146;
pub const I2S0I_DATA_IN7_IDX: u32 = 147;
pub const I2S0O_DATA_OUT7_IDX: u32 = 147;
pub const I2S0I_DATA_IN8_IDX: u32 = 148;
pub const I2S0O_DATA_OUT8_IDX: u32 = 148;
pub const I2S0I_DATA_IN9_IDX: u32 = 149;
pub const I2S0O_DATA_OUT9_IDX: u32 = 149;
pub const I2S0I_DATA_IN10_IDX: u32 = 150;
pub const I2S0O_DATA_OUT10_IDX: u32 = 150;
pub const I2S0I_DATA_IN11_IDX: u32 = 151;
pub const I2S0O_DATA_OUT11_IDX: u32 = 151;
pub const I2S0I_DATA_IN12_IDX: u32 = 152;
pub const I2S0O_DATA_OUT12_IDX: u32 = 152;
pub const I2S0I_DATA_IN13_IDX: u32 = 153;
pub const I2S0O_DATA_OUT13_IDX: u32 = 153;
pub const I2S0I_DATA_IN14_IDX: u32 = 154;
pub const I2S0O_DATA_OUT14_IDX: u32 = 154;
pub const I2S0I_DATA_IN15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT16_IDX: u32 = 156;
pub const I2S0O_DATA_OUT17_IDX: u32 = 157;
pub const I2S0O_DATA_OUT18_IDX: u32 = 158;
pub const I2S0O_DATA_OUT19_IDX: u32 = 159;
pub const I2S0O_DATA_OUT20_IDX: u32 = 160;
pub const I2S0O_DATA_OUT21_IDX: u32 = 161;
pub const I2S0O_DATA_OUT22_IDX: u32 = 162;
pub const I2S0O_DATA_OUT23_IDX: u32 = 163;
pub const I2S1I_BCK_IN_IDX: u32 = 164;
pub const I2S1I_BCK_OUT_IDX: u32 = 164;
pub const I2S1I_WS_IN_IDX: u32 = 165;
pub const I2S1I_WS_OUT_IDX: u32 = 165;
pub const I2S1I_DATA_IN0_IDX: u32 = 166;
pub const I2S1O_DATA_OUT0_IDX: u32 = 166;
pub const I2S1I_DATA_IN1_IDX: u32 = 167;
pub const I2S1O_DATA_OUT1_IDX: u32 = 167;
pub const I2S1I_DATA_IN2_IDX: u32 = 168;
pub const I2S1O_DATA_OUT2_IDX: u32 = 168;
pub const I2S1I_DATA_IN3_IDX: u32 = 169;
pub const I2S1O_DATA_OUT3_IDX: u32 = 169;
pub const I2S1I_DATA_IN4_IDX: u32 = 170;
pub const I2S1O_DATA_OUT4_IDX: u32 = 170;
pub const I2S1I_DATA_IN5_IDX: u32 = 171;
pub const I2S1O_DATA_OUT5_IDX: u32 = 171;
pub const I2S1I_DATA_IN6_IDX: u32 = 172;
pub const I2S1O_DATA_OUT6_IDX: u32 = 172;
pub const I2S1I_DATA_IN7_IDX: u32 = 173;
pub const I2S1O_DATA_OUT7_IDX: u32 = 173;
pub const I2S1I_DATA_IN8_IDX: u32 = 174;
pub const I2S1O_DATA_OUT8_IDX: u32 = 174;
pub const I2S1I_DATA_IN9_IDX: u32 = 175;
pub const I2S1O_DATA_OUT9_IDX: u32 = 175;
pub const I2S1I_DATA_IN10_IDX: u32 = 176;
pub const I2S1O_DATA_OUT10_IDX: u32 = 176;
pub const I2S1I_DATA_IN11_IDX: u32 = 177;
pub const I2S1O_DATA_OUT11_IDX: u32 = 177;
pub const I2S1I_DATA_IN12_IDX: u32 = 178;
pub const I2S1O_DATA_OUT12_IDX: u32 = 178;
pub const I2S1I_DATA_IN13_IDX: u32 = 179;
pub const I2S1O_DATA_OUT13_IDX: u32 = 179;
pub const I2S1I_DATA_IN14_IDX: u32 = 180;
pub const I2S1O_DATA_OUT14_IDX: u32 = 180;
pub const I2S1I_DATA_IN15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT16_IDX: u32 = 182;
pub const I2S1O_DATA_OUT17_IDX: u32 = 183;
pub const I2S1O_DATA_OUT18_IDX: u32 = 184;
pub const I2S1O_DATA_OUT19_IDX: u32 = 185;
pub const I2S1O_DATA_OUT20_IDX: u32 = 186;
pub const I2S1O_DATA_OUT21_IDX: u32 = 187;
pub const I2S1O_DATA_OUT22_IDX: u32 = 188;
pub const I2S1O_DATA_OUT23_IDX: u32 = 189;
pub const I2S0I_H_SYNC_IDX: u32 = 190;
pub const PWM3_OUT1H_IDX: u32 = 190;
pub const I2S0I_V_SYNC_IDX: u32 = 191;
pub const PWM3_OUT1L_IDX: u32 = 191;
pub const I2S0I_H_ENABLE_IDX: u32 = 192;
pub const PWM3_OUT2H_IDX: u32 = 192;
pub const I2S1I_H_SYNC_IDX: u32 = 193;
pub const PWM3_OUT2L_IDX: u32 = 193;
pub const I2S1I_V_SYNC_IDX: u32 = 194;
pub const PWM3_OUT3H_IDX: u32 = 194;
pub const I2S1I_H_ENABLE_IDX: u32 = 195;
pub const PWM3_OUT3L_IDX: u32 = 195;
pub const PWM3_OUT4H_IDX: u32 = 196;
pub const PWM3_OUT4L_IDX: u32 = 197;
pub const U2RXD_IN_IDX: u32 = 198;
pub const U2TXD_OUT_IDX: u32 = 198;
pub const U2CTS_IN_IDX: u32 = 199;
pub const U2RTS_OUT_IDX: u32 = 199;
pub const EMAC_MDC_I_IDX: u32 = 200;
pub const EMAC_MDC_O_IDX: u32 = 200;
pub const EMAC_MDI_I_IDX: u32 = 201;
pub const EMAC_MDO_O_IDX: u32 = 201;
pub const EMAC_CRS_I_IDX: u32 = 202;
pub const EMAC_CRS_O_IDX: u32 = 202;
pub const EMAC_COL_I_IDX: u32 = 203;
pub const EMAC_COL_O_IDX: u32 = 203;
pub const PCMFSYNC_IN_IDX: u32 = 204;
pub const BT_AUDIO0_IRQ_IDX: u32 = 204;
pub const PCMCLK_IN_IDX: u32 = 205;
pub const BT_AUDIO1_IRQ_IDX: u32 = 205;
pub const PCMDIN_IDX: u32 = 206;
pub const BT_AUDIO2_IRQ_IDX: u32 = 206;
pub const BLE_AUDIO0_IRQ_IDX: u32 = 207;
pub const BLE_AUDIO1_IRQ_IDX: u32 = 208;
pub const BLE_AUDIO2_IRQ_IDX: u32 = 209;
pub const PCMFSYNC_OUT_IDX: u32 = 210;
pub const PCMCLK_OUT_IDX: u32 = 211;
pub const PCMDOUT_IDX: u32 = 212;
pub const BLE_AUDIO_SYNC0_P_IDX: u32 = 213;
pub const BLE_AUDIO_SYNC1_P_IDX: u32 = 214;
pub const BLE_AUDIO_SYNC2_P_IDX: u32 = 215;
pub const ANT_SEL0_IDX: u32 = 216;
pub const ANT_SEL1_IDX: u32 = 217;
pub const ANT_SEL2_IDX: u32 = 218;
pub const ANT_SEL3_IDX: u32 = 219;
pub const ANT_SEL4_IDX: u32 = 220;
pub const ANT_SEL5_IDX: u32 = 221;
pub const ANT_SEL6_IDX: u32 = 222;
pub const ANT_SEL7_IDX: u32 = 223;
pub const SIG_IN_FUNC224_IDX: u32 = 224;
pub const SIG_IN_FUNC225_IDX: u32 = 225;
pub const SIG_IN_FUNC226_IDX: u32 = 226;
pub const SIG_IN_FUNC227_IDX: u32 = 227;
pub const SIG_IN_FUNC228_IDX: u32 = 228;
pub const SIG_GPIO_OUT_IDX: u32 = 256;
pub const GPIO_PIN_COUNT: u32 = 40;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_FUNC_IN_HIGH: u32 = 56;
pub const GPIO_FUNC_IN_LOW: u32 = 48;
pub const ESP_INTR_FLAG_LEVEL1: u32 = 2;
pub const ESP_INTR_FLAG_LEVEL2: u32 = 4;
pub const ESP_INTR_FLAG_LEVEL3: u32 = 8;
pub const ESP_INTR_FLAG_LEVEL4: u32 = 16;
pub const ESP_INTR_FLAG_LEVEL5: u32 = 32;
pub const ESP_INTR_FLAG_LEVEL6: u32 = 64;
pub const ESP_INTR_FLAG_NMI: u32 = 128;
pub const ESP_INTR_FLAG_SHARED: u32 = 256;
pub const ESP_INTR_FLAG_EDGE: u32 = 512;
pub const ESP_INTR_FLAG_IRAM: u32 = 1024;
pub const ESP_INTR_FLAG_INTRDISABLED: u32 = 2048;
pub const ESP_INTR_FLAG_LOWMED: u32 = 14;
pub const ESP_INTR_FLAG_HIGH: u32 = 240;
pub const ESP_INTR_FLAG_LEVELMASK: u32 = 254;
pub const ETS_INTERNAL_TIMER0_INTR_SOURCE: i32 = -1;
pub const ETS_INTERNAL_TIMER1_INTR_SOURCE: i32 = -2;
pub const ETS_INTERNAL_TIMER2_INTR_SOURCE: i32 = -3;
pub const ETS_INTERNAL_SW0_INTR_SOURCE: i32 = -4;
pub const ETS_INTERNAL_SW1_INTR_SOURCE: i32 = -5;
pub const ETS_INTERNAL_PROFILING_INTR_SOURCE: i32 = -6;
pub const ETS_INTERNAL_INTR_SOURCE_OFF: u32 = 6;
pub const GPIO_PIN_REG_0: u32 = 1072992324;
pub const GPIO_PIN_REG_1: u32 = 1072992392;
pub const GPIO_PIN_REG_2: u32 = 1072992320;
pub const GPIO_PIN_REG_3: u32 = 1072992388;
pub const GPIO_PIN_REG_4: u32 = 1072992328;
pub const GPIO_PIN_REG_5: u32 = 1072992364;
pub const GPIO_PIN_REG_6: u32 = 1072992352;
pub const GPIO_PIN_REG_7: u32 = 1072992356;
pub const GPIO_PIN_REG_8: u32 = 1072992360;
pub const GPIO_PIN_REG_9: u32 = 1072992340;
pub const GPIO_PIN_REG_10: u32 = 1072992344;
pub const GPIO_PIN_REG_11: u32 = 1072992348;
pub const GPIO_PIN_REG_12: u32 = 1072992308;
pub const GPIO_PIN_REG_13: u32 = 1072992312;
pub const GPIO_PIN_REG_14: u32 = 1072992304;
pub const GPIO_PIN_REG_15: u32 = 1072992316;
pub const GPIO_PIN_REG_16: u32 = 1072992332;
pub const GPIO_PIN_REG_17: u32 = 1072992336;
pub const GPIO_PIN_REG_18: u32 = 1072992368;
pub const GPIO_PIN_REG_19: u32 = 1072992372;
pub const GPIO_PIN_REG_20: u32 = 1072992376;
pub const GPIO_PIN_REG_21: u32 = 1072992380;
pub const GPIO_PIN_REG_22: u32 = 1072992384;
pub const GPIO_PIN_REG_23: u32 = 1072992396;
pub const GPIO_PIN_REG_25: u32 = 1072992292;
pub const GPIO_PIN_REG_26: u32 = 1072992296;
pub const GPIO_PIN_REG_27: u32 = 1072992300;
pub const GPIO_PIN_REG_32: u32 = 1072992284;
pub const GPIO_PIN_REG_33: u32 = 1072992288;
pub const GPIO_PIN_REG_34: u32 = 1072992276;
pub const GPIO_PIN_REG_35: u32 = 1072992280;
pub const GPIO_PIN_REG_36: u32 = 1072992260;
pub const GPIO_PIN_REG_37: u32 = 1072992264;
pub const GPIO_PIN_REG_38: u32 = 1072992268;
pub const GPIO_PIN_REG_39: u32 = 1072992272;
pub const GPIO_MODE_DEF_DISABLE: u32 = 0;
pub const GPIO_MODE_DEF_INPUT: u32 = 1;
pub const GPIO_MODE_DEF_OUTPUT: u32 = 2;
pub const GPIO_MODE_DEF_OD: u32 = 4;
pub const TOUCH_PAD_NUM0_GPIO_NUM: u32 = 4;
pub const TOUCH_PAD_NUM1_GPIO_NUM: u32 = 0;
pub const TOUCH_PAD_NUM2_GPIO_NUM: u32 = 2;
pub const TOUCH_PAD_NUM3_GPIO_NUM: u32 = 15;
pub const TOUCH_PAD_NUM4_GPIO_NUM: u32 = 13;
pub const TOUCH_PAD_NUM5_GPIO_NUM: u32 = 12;
pub const TOUCH_PAD_NUM6_GPIO_NUM: u32 = 14;
pub const TOUCH_PAD_NUM7_GPIO_NUM: u32 = 27;
pub const TOUCH_PAD_NUM8_GPIO_NUM: u32 = 33;
pub const TOUCH_PAD_NUM9_GPIO_NUM: u32 = 32;
pub const TOUCH_PAD_SLEEP_CYCLE_DEFAULT: u32 = 4096;
pub const TOUCH_PAD_MEASURE_CYCLE_DEFAULT: u32 = 32767;
pub const TOUCH_PAD_MEASURE_WAIT_DEFAULT: u32 = 255;
pub const TOUCH_PAD_BIT_MASK_MAX: u32 = 1023;
pub const TWO_UNIVERSAL_MAC_ADDR: u32 = 2;
pub const FOUR_UNIVERSAL_MAC_ADDR: u32 = 4;
pub const UNIVERSAL_MAC_ADDR_NUM: u32 = 4;
pub const INCLUDE_xTimerGetTimerDaemonTaskHandle: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xEventGroupSetBitFromISR: u32 = 0;
pub const configASSERT_DEFINED: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 0;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configTASKLIST_INCLUDE_COREID: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 1;
pub const configESP32_PER_TASK_DATA: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const ARG_MAX: u32 = 4096;
pub const PATH_MAX: u32 = 4096;
pub const tskKERNEL_VERSION_NUMBER: &'static [u8; 7usize] = b"V8.2.0\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 8;
pub const tskKERNEL_VERSION_MINOR: u32 = 2;
pub const tskKERNEL_VERSION_BUILD: u32 = 0;
pub const WIFI_PROTOCOL_11B: u32 = 1;
pub const WIFI_PROTOCOL_11G: u32 = 2;
pub const WIFI_PROTOCOL_11N: u32 = 4;
pub const WIFI_PROTOCOL_LR: u32 = 8;
pub const ESP_WIFI_MAX_CONN_NUM: u32 = 10;
pub const WIFI_VENDOR_IE_ELEMENT_ID: u32 = 221;
pub const WIFI_PROMIS_FILTER_MASK_ALL: u32 = 4294967295;
pub const WIFI_PROMIS_FILTER_MASK_MGMT: u32 = 1;
pub const WIFI_PROMIS_FILTER_MASK_CTRL: u32 = 2;
pub const WIFI_PROMIS_FILTER_MASK_DATA: u32 = 4;
pub const WIFI_PROMIS_FILTER_MASK_MISC: u32 = 8;
pub const WIFI_PROMIS_FILTER_MASK_DATA_MPDU: u32 = 16;
pub const WIFI_PROMIS_FILTER_MASK_DATA_AMPDU: u32 = 32;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ALL: u32 = 4286578688;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_WRAPPER: u32 = 8388608;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BAR: u32 = 16777216;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_BA: u32 = 33554432;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_PSPOLL: u32 = 67108864;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_RTS: u32 = 134217728;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CTS: u32 = 268435456;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_ACK: u32 = 536870912;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFEND: u32 = 1073741824;
pub const WIFI_PROMIS_CTRL_FILTER_MASK_CFENDACK: u32 = 2147483648;
pub const WIFI_EVENT_MASK_ALL: u32 = 4294967295;
pub const WIFI_EVENT_MASK_NONE: u32 = 0;
pub const ESP_WIFI_CRYPTO_VERSION: u32 = 1;
pub const ESP_EVENT_ANY_ID: i32 = -1;
pub const F_OK: u32 = 0;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_CHILD_MAX: u32 = 1;
pub const _SC_CLK_TCK: u32 = 2;
pub const _SC_NGROUPS_MAX: u32 = 3;
pub const _SC_OPEN_MAX: u32 = 4;
pub const _SC_JOB_CONTROL: u32 = 5;
pub const _SC_SAVED_IDS: u32 = 6;
pub const _SC_VERSION: u32 = 7;
pub const _SC_PAGESIZE: u32 = 8;
pub const _SC_PAGE_SIZE: u32 = 8;
pub const _SC_NPROCESSORS_CONF: u32 = 9;
pub const _SC_NPROCESSORS_ONLN: u32 = 10;
pub const _SC_PHYS_PAGES: u32 = 11;
pub const _SC_AVPHYS_PAGES: u32 = 12;
pub const _SC_MQ_OPEN_MAX: u32 = 13;
pub const _SC_MQ_PRIO_MAX: u32 = 14;
pub const _SC_RTSIG_MAX: u32 = 15;
pub const _SC_SEM_NSEMS_MAX: u32 = 16;
pub const _SC_SEM_VALUE_MAX: u32 = 17;
pub const _SC_SIGQUEUE_MAX: u32 = 18;
pub const _SC_TIMER_MAX: u32 = 19;
pub const _SC_TZNAME_MAX: u32 = 20;
pub const _SC_ASYNCHRONOUS_IO: u32 = 21;
pub const _SC_FSYNC: u32 = 22;
pub const _SC_MAPPED_FILES: u32 = 23;
pub const _SC_MEMLOCK: u32 = 24;
pub const _SC_MEMLOCK_RANGE: u32 = 25;
pub const _SC_MEMORY_PROTECTION: u32 = 26;
pub const _SC_MESSAGE_PASSING: u32 = 27;
pub const _SC_PRIORITIZED_IO: u32 = 28;
pub const _SC_REALTIME_SIGNALS: u32 = 29;
pub const _SC_SEMAPHORES: u32 = 30;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 31;
pub const _SC_SYNCHRONIZED_IO: u32 = 32;
pub const _SC_TIMERS: u32 = 33;
pub const _SC_AIO_LISTIO_MAX: u32 = 34;
pub const _SC_AIO_MAX: u32 = 35;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 36;
pub const _SC_DELAYTIMER_MAX: u32 = 37;
pub const _SC_THREAD_KEYS_MAX: u32 = 38;
pub const _SC_THREAD_STACK_MIN: u32 = 39;
pub const _SC_THREAD_THREADS_MAX: u32 = 40;
pub const _SC_TTY_NAME_MAX: u32 = 41;
pub const _SC_THREADS: u32 = 42;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 43;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 44;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 45;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 46;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 47;
pub const _SC_THREAD_PRIO_CEILING: u32 = 47;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 48;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 49;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 50;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 51;
pub const _SC_LOGIN_NAME_MAX: u32 = 52;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 53;
pub const _SC_ADVISORY_INFO: u32 = 54;
pub const _SC_ATEXIT_MAX: u32 = 55;
pub const _SC_BARRIERS: u32 = 56;
pub const _SC_BC_BASE_MAX: u32 = 57;
pub const _SC_BC_DIM_MAX: u32 = 58;
pub const _SC_BC_SCALE_MAX: u32 = 59;
pub const _SC_BC_STRING_MAX: u32 = 60;
pub const _SC_CLOCK_SELECTION: u32 = 61;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 62;
pub const _SC_CPUTIME: u32 = 63;
pub const _SC_EXPR_NEST_MAX: u32 = 64;
pub const _SC_HOST_NAME_MAX: u32 = 65;
pub const _SC_IOV_MAX: u32 = 66;
pub const _SC_IPV6: u32 = 67;
pub const _SC_LINE_MAX: u32 = 68;
pub const _SC_MONOTONIC_CLOCK: u32 = 69;
pub const _SC_RAW_SOCKETS: u32 = 70;
pub const _SC_READER_WRITER_LOCKS: u32 = 71;
pub const _SC_REGEXP: u32 = 72;
pub const _SC_RE_DUP_MAX: u32 = 73;
pub const _SC_SHELL: u32 = 74;
pub const _SC_SPAWN: u32 = 75;
pub const _SC_SPIN_LOCKS: u32 = 76;
pub const _SC_SPORADIC_SERVER: u32 = 77;
pub const _SC_SS_REPL_MAX: u32 = 78;
pub const _SC_SYMLOOP_MAX: u32 = 79;
pub const _SC_THREAD_CPUTIME: u32 = 80;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 81;
pub const _SC_TIMEOUTS: u32 = 82;
pub const _SC_TRACE: u32 = 83;
pub const _SC_TRACE_EVENT_FILTER: u32 = 84;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 85;
pub const _SC_TRACE_INHERIT: u32 = 86;
pub const _SC_TRACE_LOG: u32 = 87;
pub const _SC_TRACE_NAME_MAX: u32 = 88;
pub const _SC_TRACE_SYS_MAX: u32 = 89;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 90;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 91;
pub const _SC_V7_ILP32_OFF32: u32 = 92;
pub const _SC_V6_ILP32_OFF32: u32 = 92;
pub const _SC_XBS5_ILP32_OFF32: u32 = 92;
pub const _SC_V7_ILP32_OFFBIG: u32 = 93;
pub const _SC_V6_ILP32_OFFBIG: u32 = 93;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 93;
pub const _SC_V7_LP64_OFF64: u32 = 94;
pub const _SC_V6_LP64_OFF64: u32 = 94;
pub const _SC_XBS5_LP64_OFF64: u32 = 94;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 95;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XOPEN_CRYPT: u32 = 96;
pub const _SC_XOPEN_ENH_I18N: u32 = 97;
pub const _SC_XOPEN_LEGACY: u32 = 98;
pub const _SC_XOPEN_REALTIME: u32 = 99;
pub const _SC_STREAM_MAX: u32 = 100;
pub const _SC_PRIORITY_SCHEDULING: u32 = 101;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 102;
pub const _SC_XOPEN_SHM: u32 = 103;
pub const _SC_XOPEN_STREAMS: u32 = 104;
pub const _SC_XOPEN_UNIX: u32 = 105;
pub const _SC_XOPEN_VERSION: u32 = 106;
pub const _SC_2_CHAR_TERM: u32 = 107;
pub const _SC_2_C_BIND: u32 = 108;
pub const _SC_2_C_DEV: u32 = 109;
pub const _SC_2_FORT_DEV: u32 = 110;
pub const _SC_2_FORT_RUN: u32 = 111;
pub const _SC_2_LOCALEDEF: u32 = 112;
pub const _SC_2_PBS: u32 = 113;
pub const _SC_2_PBS_ACCOUNTING: u32 = 114;
pub const _SC_2_PBS_CHECKPOINT: u32 = 115;
pub const _SC_2_PBS_LOCATE: u32 = 116;
pub const _SC_2_PBS_MESSAGE: u32 = 117;
pub const _SC_2_PBS_TRACK: u32 = 118;
pub const _SC_2_SW_DEV: u32 = 119;
pub const _SC_2_UPE: u32 = 120;
pub const _SC_2_VERSION: u32 = 121;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 122;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 123;
pub const _SC_XOPEN_UUCP: u32 = 124;
pub const _PC_LINK_MAX: u32 = 0;
pub const _PC_MAX_CANON: u32 = 1;
pub const _PC_MAX_INPUT: u32 = 2;
pub const _PC_NAME_MAX: u32 = 3;
pub const _PC_PATH_MAX: u32 = 4;
pub const _PC_PIPE_BUF: u32 = 5;
pub const _PC_CHOWN_RESTRICTED: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_ASYNC_IO: u32 = 9;
pub const _PC_PRIO_IO: u32 = 10;
pub const _PC_SYNC_IO: u32 = 11;
pub const _PC_FILESIZEBITS: u32 = 12;
pub const _PC_2_SYMLINKS: u32 = 13;
pub const _PC_SYMLINK_MAX: u32 = 14;
pub const _PC_ALLOC_SIZE_MIN: u32 = 15;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 16;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 17;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 18;
pub const _PC_REC_XFER_ALIGN: u32 = 19;
pub const _PC_TIMESTAMP_RESOLUTION: u32 = 20;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const _FOPEN: i32 = -1;
pub const _FREAD: u32 = 1;
pub const _FWRITE: u32 = 2;
pub const _FAPPEND: u32 = 8;
pub const _FMARK: u32 = 16;
pub const _FDEFER: u32 = 32;
pub const _FASYNC: u32 = 64;
pub const _FSHLOCK: u32 = 128;
pub const _FEXLOCK: u32 = 256;
pub const _FCREAT: u32 = 512;
pub const _FTRUNC: u32 = 1024;
pub const _FEXCL: u32 = 2048;
pub const _FNBIO: u32 = 4096;
pub const _FSYNC: u32 = 8192;
pub const _FNONBLOCK: u32 = 16384;
pub const _FNDELAY: u32 = 16384;
pub const _FNOCTTY: u32 = 32768;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_APPEND: u32 = 8;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const O_SYNC: u32 = 8192;
pub const O_NONBLOCK: u32 = 16384;
pub const O_NOCTTY: u32 = 32768;
pub const FAPPEND: u32 = 8;
pub const FSYNC: u32 = 8192;
pub const FASYNC: u32 = 64;
pub const FNBIO: u32 = 4096;
pub const FNONBIO: u32 = 16384;
pub const FNDELAY: u32 = 16384;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const FMARK: u32 = 16;
pub const FDEFER: u32 = 32;
pub const FSHLOCK: u32 = 128;
pub const FEXLOCK: u32 = 256;
pub const FOPEN: i32 = -1;
pub const FCREAT: u32 = 512;
pub const FTRUNC: u32 = 1024;
pub const FEXCL: u32 = 2048;
pub const FNOCTTY: u32 = 32768;
pub const FD_CLOEXEC: u32 = 1;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_RGETLK: u32 = 10;
pub const F_RSETLK: u32 = 11;
pub const F_CNVT: u32 = 12;
pub const F_RSETLKW: u32 = 13;
pub const F_RDLCK: u32 = 1;
pub const F_WRLCK: u32 = 2;
pub const F_UNLCK: u32 = 3;
pub const F_UNLKSYS: u32 = 4;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 1;
pub const AT_SYMLINK_NOFOLLOW: u32 = 2;
pub const AT_SYMLINK_FOLLOW: u32 = 4;
pub const AT_REMOVEDIR: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const _IFMT: u32 = 61440;
pub const _IFDIR: u32 = 16384;
pub const _IFCHR: u32 = 8192;
pub const _IFBLK: u32 = 24576;
pub const _IFREG: u32 = 32768;
pub const _IFLNK: u32 = 40960;
pub const _IFSOCK: u32 = 49152;
pub const _IFIFO: u32 = 4096;
pub const S_BLKSIZE: u32 = 1024;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_ENFMT: u32 = 1024;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFIFO: u32 = 4096;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const DEFFILEMODE: u32 = 438;
pub const ESP_TASK_PRIO_MAX: u32 = 25;
pub const ESP_TASK_PRIO_MIN: u32 = 0;
pub const ESP_TASK_BT_CONTROLLER_PRIO: u32 = 23;
pub const TASK_EXTRA_STACK_SIZE: u32 = 512;
pub const BT_TASK_EXTRA_STACK_SIZE: u32 = 512;
pub const ESP_TASK_BT_CONTROLLER_STACK: u32 = 4096;
pub const ESP_TASK_TIMER_PRIO: u32 = 22;
pub const ESP_TASK_TIMER_STACK: u32 = 4096;
pub const ESP_TASKD_EVENT_PRIO: u32 = 20;
pub const ESP_TASKD_EVENT_STACK: u32 = 2816;
pub const ESP_TASK_TCPIP_PRIO: u32 = 18;
pub const ESP_TASK_TCPIP_STACK: u32 = 4608;
pub const ESP_TASK_MAIN_PRIO: u32 = 1;
pub const ESP_TASK_MAIN_STACK: u32 = 4096;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 1;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_MEM_MALLOC: u32 = 1;
pub const MEM_ALIGNMENT: u32 = 4;
pub const MEMP_NUM_NETCONN: u32 = 10;
pub const MEMP_NUM_RAW_PCB: u32 = 16;
pub const MEMP_NUM_TCP_PCB: u32 = 16;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 16;
pub const MEMP_NUM_UDP_PCB: u32 = 16;
pub const ARP_QUEUEING: u32 = 1;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const LWIP_RAW: u32 = 1;
pub const LWIP_DHCP: u32 = 1;
pub const DHCP_MAXRTX: u32 = 0;
pub const DHCP_DOES_ARP_CHECK: u32 = 1;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_DNS: u32 = 1;
pub const DNS_MAX_SERVERS: u32 = 3;
pub const DNS_FALLBACK_SERVER_INDEX: u32 = 2;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 1436;
pub const TCP_MSL: u32 = 60000;
pub const TCP_MAXRTX: u32 = 12;
pub const TCP_SYNMAXRTX: u32 = 6;
pub const TCP_LISTEN_BACKLOG: u32 = 1;
pub const TCP_OVERSIZE: u32 = 1436;
pub const LWIP_NETIF_HOSTNAME: u32 = 1;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 1;
pub const LWIP_NETIF_LOOPBACK: u32 = 1;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const TCPIP_THREAD_NAME: &'static [u8; 4usize] = b"tiT\0";
pub const TCPIP_THREAD_STACKSIZE: u32 = 4608;
pub const TCPIP_THREAD_PRIO: u32 = 18;
pub const TCPIP_MBOX_SIZE: u32 = 32;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 6;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 6;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 6;
pub const DEFAULT_THREAD_STACKSIZE: u32 = 4608;
pub const DEFAULT_THREAD_PRIO: u32 = 18;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 6;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 0;
pub const LWIP_SO_SNDTIMEO: u32 = 1;
pub const LWIP_SO_RCVTIMEO: u32 = 1;
pub const LWIP_TCP_KEEPALIVE: u32 = 1;
pub const SO_REUSE: u32 = 1;
pub const SO_REUSE_RXTOALL: u32 = 1;
pub const LWIP_IPV6: u32 = 1;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 0;
pub const LWIP_SOCKET_OFFSET: u32 = 54;
pub const ESP_LWIP: u32 = 1;
pub const ESP_LWIP_ARP: u32 = 1;
pub const ESP_PER_SOC_TCP_WND: u32 = 0;
pub const ESP_THREAD_SAFE: u32 = 1;
pub const ESP_DHCP: u32 = 1;
pub const ESP_DNS: u32 = 1;
pub const ESP_IPV6_AUTOCONFIG: u32 = 1;
pub const ESP_PERF: u32 = 0;
pub const ESP_RANDOM_TCP_PORT: u32 = 1;
pub const ESP_IP4_ATON: u32 = 1;
pub const ESP_LIGHT_SLEEP: u32 = 1;
pub const ESP_STATS_TCP: u32 = 0;
pub const ESP_DHCP_TIMER: u32 = 1;
pub const ESP_DHCPS_TIMER: u32 = 1;
pub const ESP_PING: u32 = 1;
pub const ESP_HAS_SELECT: u32 = 1;
pub const ESP_AUTO_RECV: u32 = 1;
pub const ESP_GRATUITOUS_ARP: u32 = 1;
pub const DBG_PERF_FILTER_LEN: u32 = 1000;
pub const TCP_SND_BUF: u32 = 5744;
pub const TCP_WND: u32 = 5744;
pub const CHECKSUM_CHECK_UDP: u32 = 0;
pub const CHECKSUM_CHECK_IP: u32 = 0;
pub const LWIP_NETCONN_FULLDUPLEX: u32 = 1;
pub const LWIP_NETCONN_SEM_PER_THREAD: u32 = 1;
pub const LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_TIMEVAL_PRIVATE: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const __error_t_defined: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const ENOMSG: u32 = 35;
pub const EIDRM: u32 = 36;
pub const EDEADLK: u32 = 45;
pub const ENOLCK: u32 = 46;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENOLINK: u32 = 67;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 74;
pub const EBADMSG: u32 = 77;
pub const EFTYPE: u32 = 79;
pub const ENOSYS: u32 = 88;
pub const ENOTEMPTY: u32 = 90;
pub const ENAMETOOLONG: u32 = 91;
pub const ELOOP: u32 = 92;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EAFNOSUPPORT: u32 = 106;
pub const EPROTOTYPE: u32 = 107;
pub const ENOTSOCK: u32 = 108;
pub const ENOPROTOOPT: u32 = 109;
pub const ECONNREFUSED: u32 = 111;
pub const EADDRINUSE: u32 = 112;
pub const ECONNABORTED: u32 = 113;
pub const ENETUNREACH: u32 = 114;
pub const ENETDOWN: u32 = 115;
pub const ETIMEDOUT: u32 = 116;
pub const EHOSTDOWN: u32 = 117;
pub const EHOSTUNREACH: u32 = 118;
pub const EINPROGRESS: u32 = 119;
pub const EALREADY: u32 = 120;
pub const EDESTADDRREQ: u32 = 121;
pub const EMSGSIZE: u32 = 122;
pub const EPROTONOSUPPORT: u32 = 123;
pub const EADDRNOTAVAIL: u32 = 125;
pub const ENETRESET: u32 = 126;
pub const EISCONN: u32 = 127;
pub const ENOTCONN: u32 = 128;
pub const ETOOMANYREFS: u32 = 129;
pub const EDQUOT: u32 = 132;
pub const ESTALE: u32 = 133;
pub const ENOTSUP: u32 = 134;
pub const EILSEQ: u32 = 138;
pub const EOVERFLOW: u32 = 139;
pub const ECANCELED: u32 = 140;
pub const ENOTRECOVERABLE: u32 = 141;
pub const EOWNERDEAD: u32 = 142;
pub const EWOULDBLOCK: u32 = 11;
pub const __ELASTERROR: u32 = 2000;
pub const ESHUTDOWN: u32 = 108;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const LWIP_COMPAT_MUTEX: u32 = 0;
pub const BYTE_ORDER: u32 = 1234;
pub const S16_F: &'static [u8; 2usize] = b"d\0";
pub const U16_F: &'static [u8; 2usize] = b"d\0";
pub const X16_F: &'static [u8; 2usize] = b"x\0";
pub const S32_F: &'static [u8; 2usize] = b"d\0";
pub const U32_F: &'static [u8; 2usize] = b"d\0";
pub const X32_F: &'static [u8; 2usize] = b"x\0";
pub const LWIP_NO_STDDEF_H: u32 = 0;
pub const LWIP_NO_STDINT_H: u32 = 0;
pub const LWIP_NO_INTTYPES_H: u32 = 0;
pub const X8_F: &'static [u8; 3usize] = b"02\0";
pub const LWIP_NO_LIMITS_H: u32 = 0;
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const NO_SYS: u32 = 0;
pub const LWIP_TIMERS: u32 = 1;
pub const LWIP_TIMERS_CUSTOM: u32 = 0;
pub const LWIP_MPU_COMPATIBLE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const MEM_SIZE: u32 = 1600;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 0;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 16;
pub const MEMP_NUM_TCP_SEG: u32 = 16;
pub const MEMP_NUM_REASSDATA: u32 = 5;
pub const MEMP_NUM_FRAG_PBUF: u32 = 15;
pub const MEMP_NUM_ARP_QUEUE: u32 = 30;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 2;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 8;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 8;
pub const MEMP_NUM_NETDB: u32 = 1;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 1;
pub const PBUF_POOL_SIZE: u32 = 16;
pub const MEMP_NUM_API_MSG: u32 = 8;
pub const MEMP_NUM_DNS_API_MSG: u32 = 8;
pub const MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA: u32 = 8;
pub const MEMP_NUM_NETIFAPI_MSG: u32 = 8;
pub const LWIP_ARP: u32 = 1;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_MAXAGE: u32 = 300;
pub const ARP_QUEUE_LEN: u32 = 3;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const LWIP_ETHERNET: u32 = 1;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const ETHARP_TABLE_MATCH_NETIF: u32 = 0;
pub const LWIP_IPV4: u32 = 1;
pub const IP_FORWARD: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_DEFAULT_TTL: u32 = 255;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const IP_FORWARD_ALLOW_TX_ON_RX_NETIF: u32 = 0;
pub const LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS: u32 = 0;
pub const LWIP_ICMP: u32 = 1;
pub const ICMP_TTL: u32 = 255;
pub const RAW_TTL: u32 = 255;
pub const LWIP_DHCP_CHECK_LINK_UP: u32 = 0;
pub const LWIP_DHCP_BOOTP_FILE: u32 = 0;
pub const LWIP_DHCP_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP_MAX_DNS_SERVERS: u32 = 3;
pub const LWIP_AUTOIP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_MIB2_CALLBACKS: u32 = 0;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const LWIP_DNS_SECURE_RAND_XID: u32 = 1;
pub const LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING: u32 = 2;
pub const LWIP_DNS_SECURE_RAND_SRC_PORT: u32 = 4;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 0;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 255;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const LWIP_TCP: u32 = 1;
pub const TCP_TTL: u32 = 255;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_QUEUELEN: u32 = 16;
pub const TCP_OOSEQ_MAX_BYTES: u32 = 0;
pub const TCP_OOSEQ_MAX_PBUFS: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const LWIP_WND_SCALE: u32 = 0;
pub const TCP_RCV_SCALE: u32 = 0;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_REMOVE_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const LWIP_HAVE_LOOPIF: u32 = 1;
pub const LWIP_LOOPIF_MULTICAST: u32 = 0;
pub const SLIPIF_THREAD_NAME: &'static [u8; 12usize] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &'static [u8; 5usize] = b"lwIP\0";
pub const LWIP_NETCONN: u32 = 1;
pub const LWIP_TCPIP_TIMEOUT: u32 = 0;
pub const LWIP_SOCKET: u32 = 1;
pub const LWIP_SOCKET_SET_ERRNO: u32 = 1;
pub const LWIP_COMPAT_SOCKETS: u32 = 1;
pub const LWIP_SO_SNDRCVTIMEO_NONSTANDARD: u32 = 0;
pub const LWIP_SO_LINGER: u32 = 0;
pub const LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT: u32 = 20000;
pub const LWIP_FIONREAD_LINUXMODE: u32 = 0;
pub const LINK_STATS: u32 = 0;
pub const ETHARP_STATS: u32 = 0;
pub const IP_STATS: u32 = 0;
pub const IPFRAG_STATS: u32 = 0;
pub const ICMP_STATS: u32 = 0;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 0;
pub const TCP_STATS: u32 = 0;
pub const MEM_STATS: u32 = 0;
pub const MEMP_STATS: u32 = 0;
pub const SYS_STATS: u32 = 0;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const IP6_STATS: u32 = 0;
pub const ICMP6_STATS: u32 = 0;
pub const IP6_FRAG_STATS: u32 = 0;
pub const MLD6_STATS: u32 = 0;
pub const ND6_STATS: u32 = 0;
pub const MIB2_STATS: u32 = 0;
pub const LWIP_CHECKSUM_CTRL_PER_NETIF: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_GEN_ICMP: u32 = 1;
pub const CHECKSUM_GEN_ICMP6: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP6: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const LWIP_IPV6_FORWARD: u32 = 0;
pub const LWIP_IPV6_FRAG: u32 = 0;
pub const LWIP_IPV6_REASS: u32 = 1;
pub const LWIP_IPV6_SEND_ROUTER_SOLICIT: u32 = 1;
pub const LWIP_IPV6_AUTOCONFIG: u32 = 1;
pub const LWIP_IPV6_DUP_DETECT_ATTEMPTS: u32 = 1;
pub const LWIP_ICMP6: u32 = 1;
pub const LWIP_ICMP6_DATASIZE: u32 = 8;
pub const LWIP_ICMP6_HL: u32 = 255;
pub const LWIP_IPV6_MLD: u32 = 1;
pub const MEMP_NUM_MLD6_GROUP: u32 = 4;
pub const LWIP_ND6_QUEUEING: u32 = 1;
pub const MEMP_NUM_ND6_QUEUE: u32 = 20;
pub const LWIP_ND6_NUM_NEIGHBORS: u32 = 10;
pub const LWIP_ND6_NUM_DESTINATIONS: u32 = 10;
pub const LWIP_ND6_NUM_PREFIXES: u32 = 5;
pub const LWIP_ND6_NUM_ROUTERS: u32 = 3;
pub const LWIP_ND6_MAX_MULTICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_UNICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_ANYCAST_DELAY_TIME: u32 = 1000;
pub const LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT: u32 = 3;
pub const LWIP_ND6_REACHABLE_TIME: u32 = 30000;
pub const LWIP_ND6_RETRANS_TIMER: u32 = 1000;
pub const LWIP_ND6_DELAY_FIRST_PROBE_TIME: u32 = 5000;
pub const LWIP_ND6_ALLOW_RA_UPDATES: u32 = 1;
pub const LWIP_ND6_TCP_REACHABILITY_HINTS: u32 = 1;
pub const LWIP_ND6_RDNSS_MAX_DNS_SERVERS: u32 = 0;
pub const LWIP_IPV6_DHCP6: u32 = 0;
pub const LWIP_DBG_MIN_LEVEL: u32 = 0;
pub const LWIP_DBG_TYPES_ON: u32 = 128;
pub const API_MSG_DEBUG: u32 = 0;
pub const IGMP_DEBUG: u32 = 0;
pub const INET_DEBUG: u32 = 0;
pub const IP_REASS_DEBUG: u32 = 0;
pub const RAW_DEBUG: u32 = 0;
pub const MEM_DEBUG: u32 = 0;
pub const SYS_DEBUG: u32 = 0;
pub const TIMERS_DEBUG: u32 = 0;
pub const TCP_FR_DEBUG: u32 = 0;
pub const TCP_RTO_DEBUG: u32 = 0;
pub const TCP_CWND_DEBUG: u32 = 0;
pub const TCP_WND_DEBUG: u32 = 0;
pub const TCP_RST_DEBUG: u32 = 0;
pub const TCP_QLEN_DEBUG: u32 = 0;
pub const UDP_DEBUG: u32 = 0;
pub const SLIP_DEBUG: u32 = 0;
pub const AUTOIP_DEBUG: u32 = 0;
pub const DNS_DEBUG: u32 = 0;
pub const IP6_DEBUG: u32 = 0;
pub const LWIP_PERF: u32 = 0;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IP4ADDR_STRLEN_MAX: u32 = 16;
pub const IP6_MULTICAST_SCOPE_RESERVED: u32 = 0;
pub const IP6_MULTICAST_SCOPE_RESERVED0: u32 = 0;
pub const IP6_MULTICAST_SCOPE_INTERFACE_LOCAL: u32 = 1;
pub const IP6_MULTICAST_SCOPE_LINK_LOCAL: u32 = 2;
pub const IP6_MULTICAST_SCOPE_RESERVED3: u32 = 3;
pub const IP6_MULTICAST_SCOPE_ADMIN_LOCAL: u32 = 4;
pub const IP6_MULTICAST_SCOPE_SITE_LOCAL: u32 = 5;
pub const IP6_MULTICAST_SCOPE_ORGANIZATION_LOCAL: u32 = 8;
pub const IP6_MULTICAST_SCOPE_GLOBAL: u32 = 14;
pub const IP6_MULTICAST_SCOPE_RESERVEDF: u32 = 15;
pub const IP6_ADDR_INVALID: u32 = 0;
pub const IP6_ADDR_TENTATIVE: u32 = 8;
pub const IP6_ADDR_TENTATIVE_1: u32 = 9;
pub const IP6_ADDR_TENTATIVE_2: u32 = 10;
pub const IP6_ADDR_TENTATIVE_3: u32 = 11;
pub const IP6_ADDR_TENTATIVE_4: u32 = 12;
pub const IP6_ADDR_TENTATIVE_5: u32 = 13;
pub const IP6_ADDR_TENTATIVE_6: u32 = 14;
pub const IP6_ADDR_TENTATIVE_7: u32 = 15;
pub const IP6_ADDR_VALID: u32 = 16;
pub const IP6_ADDR_PREFERRED: u32 = 48;
pub const IP6_ADDR_DEPRECATED: u32 = 16;
pub const IP6_ADDR_TENTATIVE_COUNT_MASK: u32 = 7;
pub const IP6ADDR_STRLEN_MAX: u32 = 46;
pub const IPADDR_STRLEN_MAX: u32 = 46;
pub const DHCPS_COARSE_TIMER_SECS: u32 = 1;
pub const DHCPS_MAX_LEASE: u32 = 100;
pub const DHCPS_LEASE_TIME_DEF: u32 = 120;
pub const DHCPS_LEASE_UNIT: u32 = 60;
pub const IPSTR: &'static [u8; 12usize] = b"%d.%d.%d.%d\0";
pub const IPV6STR: &'static [u8; 40usize] = b"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\0";
pub const ESP_ERR_TCPIP_ADAPTER_BASE: u32 = 20480;
pub const ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS: u32 = 20481;
pub const ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY: u32 = 20482;
pub const ESP_ERR_TCPIP_ADAPTER_DHCPC_START_FAILED: u32 = 20483;
pub const ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED: u32 = 20484;
pub const ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPPED: u32 = 20485;
pub const ESP_ERR_TCPIP_ADAPTER_NO_MEM: u32 = 20486;
pub const ESP_ERR_TCPIP_ADAPTER_DHCP_NOT_STOPPED: u32 = 20487;
pub const TCPIP_HOSTNAME_MAX_SIZE: u32 = 32;
pub const ESP_WIFI_OS_ADAPTER_VERSION: u32 = 2;
pub const ESP_WIFI_OS_ADAPTER_MAGIC: u32 = 3735928495;
pub const OSI_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub const OSI_QUEUE_SEND_FRONT: u32 = 0;
pub const OSI_QUEUE_SEND_BACK: u32 = 1;
pub const OSI_QUEUE_SEND_OVERWRITE: u32 = 2;
pub const ESP_ERR_WIFI_NOT_INIT: u32 = 12289;
pub const ESP_ERR_WIFI_NOT_STARTED: u32 = 12290;
pub const ESP_ERR_WIFI_NOT_STOPPED: u32 = 12291;
pub const ESP_ERR_WIFI_IF: u32 = 12292;
pub const ESP_ERR_WIFI_MODE: u32 = 12293;
pub const ESP_ERR_WIFI_STATE: u32 = 12294;
pub const ESP_ERR_WIFI_CONN: u32 = 12295;
pub const ESP_ERR_WIFI_NVS: u32 = 12296;
pub const ESP_ERR_WIFI_MAC: u32 = 12297;
pub const ESP_ERR_WIFI_SSID: u32 = 12298;
pub const ESP_ERR_WIFI_PASSWORD: u32 = 12299;
pub const ESP_ERR_WIFI_TIMEOUT: u32 = 12300;
pub const ESP_ERR_WIFI_WAKE_FAIL: u32 = 12301;
pub const ESP_ERR_WIFI_WOULD_BLOCK: u32 = 12302;
pub const ESP_ERR_WIFI_NOT_CONNECT: u32 = 12303;
pub const WIFI_STATIC_TX_BUFFER_NUM: u32 = 0;
pub const WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const WIFI_CSI_ENABLED: u32 = 0;
pub const WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const WIFI_NVS_ENABLED: u32 = 1;
pub const WIFI_NANO_FORMAT_ENABLED: u32 = 0;
pub const WIFI_INIT_CONFIG_MAGIC: u32 = 523190095;
pub const WIFI_DEFAULT_TX_BA_WIN: u32 = 6;
pub const WIFI_DEFAULT_RX_BA_WIN: u32 = 6;
pub const WIFI_TASK_CORE_ID: u32 = 0;
pub const WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const LOG_LOCAL_LEVEL: u32 = 5;
pub const LOG_COLOR_BLACK: &'static [u8; 3usize] = b"30\0";
pub const LOG_COLOR_RED: &'static [u8; 3usize] = b"31\0";
pub const LOG_COLOR_GREEN: &'static [u8; 3usize] = b"32\0";
pub const LOG_COLOR_BROWN: &'static [u8; 3usize] = b"33\0";
pub const LOG_COLOR_BLUE: &'static [u8; 3usize] = b"34\0";
pub const LOG_COLOR_PURPLE: &'static [u8; 3usize] = b"35\0";
pub const LOG_COLOR_CYAN: &'static [u8; 3usize] = b"36\0";
pub const LOG_RESET_COLOR: &'static [u8; 5usize] = b"\x1B[0m\0";
pub const ESP_ERR_NVS_BASE: u32 = 4352;
pub const ESP_ERR_NVS_NOT_INITIALIZED: u32 = 4353;
pub const ESP_ERR_NVS_NOT_FOUND: u32 = 4354;
pub const ESP_ERR_NVS_TYPE_MISMATCH: u32 = 4355;
pub const ESP_ERR_NVS_READ_ONLY: u32 = 4356;
pub const ESP_ERR_NVS_NOT_ENOUGH_SPACE: u32 = 4357;
pub const ESP_ERR_NVS_INVALID_NAME: u32 = 4358;
pub const ESP_ERR_NVS_INVALID_HANDLE: u32 = 4359;
pub const ESP_ERR_NVS_REMOVE_FAILED: u32 = 4360;
pub const ESP_ERR_NVS_KEY_TOO_LONG: u32 = 4361;
pub const ESP_ERR_NVS_PAGE_FULL: u32 = 4362;
pub const ESP_ERR_NVS_INVALID_STATE: u32 = 4363;
pub const ESP_ERR_NVS_INVALID_LENGTH: u32 = 4364;
pub const ESP_ERR_NVS_NO_FREE_PAGES: u32 = 4365;
pub const ESP_ERR_NVS_VALUE_TOO_LONG: u32 = 4366;
pub const ESP_ERR_NVS_PART_NOT_FOUND: u32 = 4367;
pub const ESP_ERR_NVS_NEW_VERSION_FOUND: u32 = 4368;
pub const ESP_ERR_NVS_XTS_ENCR_FAILED: u32 = 4369;
pub const ESP_ERR_NVS_XTS_DECR_FAILED: u32 = 4370;
pub const ESP_ERR_NVS_XTS_CFG_FAILED: u32 = 4371;
pub const ESP_ERR_NVS_XTS_CFG_NOT_FOUND: u32 = 4372;
pub const ESP_ERR_NVS_ENCR_NOT_SUPPORTED: u32 = 4373;
pub const ESP_ERR_NVS_KEYS_NOT_INITIALIZED: u32 = 4374;
pub const ESP_ERR_NVS_CORRUPT_KEY_PART: u32 = 4375;
pub const NVS_DEFAULT_PART_NAME: &'static [u8; 4usize] = b"nvs\0";
pub const ESP_ERR_FLASH_BASE: u32 = 65552;
pub const ESP_ERR_FLASH_OP_FAIL: u32 = 65553;
pub const ESP_ERR_FLASH_OP_TIMEOUT: u32 = 65554;
pub const SPI_FLASH_SEC_SIZE: u32 = 4096;
pub const SPI_FLASH_MMU_PAGE_SIZE: u32 = 65536;
pub const NVS_KEY_SIZE: u32 = 32;
pub const UART_RXFIFO_RD_BYTE: u32 = 255;
pub const UART_RXFIFO_RD_BYTE_V: u32 = 255;
pub const UART_RXFIFO_RD_BYTE_S: u32 = 0;
pub const UART_AT_CMD_CHAR_DET_INT_RAW_V: u32 = 1;
pub const UART_AT_CMD_CHAR_DET_INT_RAW_S: u32 = 18;
pub const UART_RS485_CLASH_INT_RAW_V: u32 = 1;
pub const UART_RS485_CLASH_INT_RAW_S: u32 = 17;
pub const UART_RS485_FRM_ERR_INT_RAW_V: u32 = 1;
pub const UART_RS485_FRM_ERR_INT_RAW_S: u32 = 16;
pub const UART_RS485_PARITY_ERR_INT_RAW_V: u32 = 1;
pub const UART_RS485_PARITY_ERR_INT_RAW_S: u32 = 15;
pub const UART_TX_DONE_INT_RAW_V: u32 = 1;
pub const UART_TX_DONE_INT_RAW_S: u32 = 14;
pub const UART_TX_BRK_IDLE_DONE_INT_RAW_V: u32 = 1;
pub const UART_TX_BRK_IDLE_DONE_INT_RAW_S: u32 = 13;
pub const UART_TX_BRK_DONE_INT_RAW_V: u32 = 1;
pub const UART_TX_BRK_DONE_INT_RAW_S: u32 = 12;
pub const UART_GLITCH_DET_INT_RAW_V: u32 = 1;
pub const UART_GLITCH_DET_INT_RAW_S: u32 = 11;
pub const UART_SW_XOFF_INT_RAW_V: u32 = 1;
pub const UART_SW_XOFF_INT_RAW_S: u32 = 10;
pub const UART_SW_XON_INT_RAW_V: u32 = 1;
pub const UART_SW_XON_INT_RAW_S: u32 = 9;
pub const UART_RXFIFO_TOUT_INT_RAW_V: u32 = 1;
pub const UART_RXFIFO_TOUT_INT_RAW_S: u32 = 8;
pub const UART_BRK_DET_INT_RAW_V: u32 = 1;
pub const UART_BRK_DET_INT_RAW_S: u32 = 7;
pub const UART_CTS_CHG_INT_RAW_V: u32 = 1;
pub const UART_CTS_CHG_INT_RAW_S: u32 = 6;
pub const UART_DSR_CHG_INT_RAW_V: u32 = 1;
pub const UART_DSR_CHG_INT_RAW_S: u32 = 5;
pub const UART_RXFIFO_OVF_INT_RAW_V: u32 = 1;
pub const UART_RXFIFO_OVF_INT_RAW_S: u32 = 4;
pub const UART_FRM_ERR_INT_RAW_V: u32 = 1;
pub const UART_FRM_ERR_INT_RAW_S: u32 = 3;
pub const UART_PARITY_ERR_INT_RAW_V: u32 = 1;
pub const UART_PARITY_ERR_INT_RAW_S: u32 = 2;
pub const UART_TXFIFO_EMPTY_INT_RAW_V: u32 = 1;
pub const UART_TXFIFO_EMPTY_INT_RAW_S: u32 = 1;
pub const UART_RXFIFO_FULL_INT_RAW_V: u32 = 1;
pub const UART_RXFIFO_FULL_INT_RAW_S: u32 = 0;
pub const UART_AT_CMD_CHAR_DET_INT_ST_V: u32 = 1;
pub const UART_AT_CMD_CHAR_DET_INT_ST_S: u32 = 18;
pub const UART_RS485_CLASH_INT_ST_V: u32 = 1;
pub const UART_RS485_CLASH_INT_ST_S: u32 = 17;
pub const UART_RS485_FRM_ERR_INT_ST_V: u32 = 1;
pub const UART_RS485_FRM_ERR_INT_ST_S: u32 = 16;
pub const UART_RS485_PARITY_ERR_INT_ST_V: u32 = 1;
pub const UART_RS485_PARITY_ERR_INT_ST_S: u32 = 15;
pub const UART_TX_DONE_INT_ST_V: u32 = 1;
pub const UART_TX_DONE_INT_ST_S: u32 = 14;
pub const UART_TX_BRK_IDLE_DONE_INT_ST_V: u32 = 1;
pub const UART_TX_BRK_IDLE_DONE_INT_ST_S: u32 = 13;
pub const UART_TX_BRK_DONE_INT_ST_V: u32 = 1;
pub const UART_TX_BRK_DONE_INT_ST_S: u32 = 12;
pub const UART_GLITCH_DET_INT_ST_V: u32 = 1;
pub const UART_GLITCH_DET_INT_ST_S: u32 = 11;
pub const UART_SW_XOFF_INT_ST_V: u32 = 1;
pub const UART_SW_XOFF_INT_ST_S: u32 = 10;
pub const UART_SW_XON_INT_ST_V: u32 = 1;
pub const UART_SW_XON_INT_ST_S: u32 = 9;
pub const UART_RXFIFO_TOUT_INT_ST_V: u32 = 1;
pub const UART_RXFIFO_TOUT_INT_ST_S: u32 = 8;
pub const UART_BRK_DET_INT_ST_V: u32 = 1;
pub const UART_BRK_DET_INT_ST_S: u32 = 7;
pub const UART_CTS_CHG_INT_ST_V: u32 = 1;
pub const UART_CTS_CHG_INT_ST_S: u32 = 6;
pub const UART_DSR_CHG_INT_ST_V: u32 = 1;
pub const UART_DSR_CHG_INT_ST_S: u32 = 5;
pub const UART_RXFIFO_OVF_INT_ST_V: u32 = 1;
pub const UART_RXFIFO_OVF_INT_ST_S: u32 = 4;
pub const UART_FRM_ERR_INT_ST_V: u32 = 1;
pub const UART_FRM_ERR_INT_ST_S: u32 = 3;
pub const UART_PARITY_ERR_INT_ST_V: u32 = 1;
pub const UART_PARITY_ERR_INT_ST_S: u32 = 2;
pub const UART_TXFIFO_EMPTY_INT_ST_V: u32 = 1;
pub const UART_TXFIFO_EMPTY_INT_ST_S: u32 = 1;
pub const UART_RXFIFO_FULL_INT_ST_V: u32 = 1;
pub const UART_RXFIFO_FULL_INT_ST_S: u32 = 0;
pub const UART_AT_CMD_CHAR_DET_INT_ENA_V: u32 = 1;
pub const UART_AT_CMD_CHAR_DET_INT_ENA_S: u32 = 18;
pub const UART_RS485_CLASH_INT_ENA_V: u32 = 1;
pub const UART_RS485_CLASH_INT_ENA_S: u32 = 17;
pub const UART_RS485_FRM_ERR_INT_ENA_V: u32 = 1;
pub const UART_RS485_FRM_ERR_INT_ENA_S: u32 = 16;
pub const UART_RS485_PARITY_ERR_INT_ENA_V: u32 = 1;
pub const UART_RS485_PARITY_ERR_INT_ENA_S: u32 = 15;
pub const UART_TX_DONE_INT_ENA_V: u32 = 1;
pub const UART_TX_DONE_INT_ENA_S: u32 = 14;
pub const UART_TX_BRK_IDLE_DONE_INT_ENA_V: u32 = 1;
pub const UART_TX_BRK_IDLE_DONE_INT_ENA_S: u32 = 13;
pub const UART_TX_BRK_DONE_INT_ENA_V: u32 = 1;
pub const UART_TX_BRK_DONE_INT_ENA_S: u32 = 12;
pub const UART_GLITCH_DET_INT_ENA_V: u32 = 1;
pub const UART_GLITCH_DET_INT_ENA_S: u32 = 11;
pub const UART_SW_XOFF_INT_ENA_V: u32 = 1;
pub const UART_SW_XOFF_INT_ENA_S: u32 = 10;
pub const UART_SW_XON_INT_ENA_V: u32 = 1;
pub const UART_SW_XON_INT_ENA_S: u32 = 9;
pub const UART_RXFIFO_TOUT_INT_ENA_V: u32 = 1;
pub const UART_RXFIFO_TOUT_INT_ENA_S: u32 = 8;
pub const UART_BRK_DET_INT_ENA_V: u32 = 1;
pub const UART_BRK_DET_INT_ENA_S: u32 = 7;
pub const UART_CTS_CHG_INT_ENA_V: u32 = 1;
pub const UART_CTS_CHG_INT_ENA_S: u32 = 6;
pub const UART_DSR_CHG_INT_ENA_V: u32 = 1;
pub const UART_DSR_CHG_INT_ENA_S: u32 = 5;
pub const UART_RXFIFO_OVF_INT_ENA_V: u32 = 1;
pub const UART_RXFIFO_OVF_INT_ENA_S: u32 = 4;
pub const UART_FRM_ERR_INT_ENA_V: u32 = 1;
pub const UART_FRM_ERR_INT_ENA_S: u32 = 3;
pub const UART_PARITY_ERR_INT_ENA_V: u32 = 1;
pub const UART_PARITY_ERR_INT_ENA_S: u32 = 2;
pub const UART_TXFIFO_EMPTY_INT_ENA_V: u32 = 1;
pub const UART_TXFIFO_EMPTY_INT_ENA_S: u32 = 1;
pub const UART_RXFIFO_FULL_INT_ENA_V: u32 = 1;
pub const UART_RXFIFO_FULL_INT_ENA_S: u32 = 0;
pub const UART_AT_CMD_CHAR_DET_INT_CLR_V: u32 = 1;
pub const UART_AT_CMD_CHAR_DET_INT_CLR_S: u32 = 18;
pub const UART_RS485_CLASH_INT_CLR_V: u32 = 1;
pub const UART_RS485_CLASH_INT_CLR_S: u32 = 17;
pub const UART_RS485_FRM_ERR_INT_CLR_V: u32 = 1;
pub const UART_RS485_FRM_ERR_INT_CLR_S: u32 = 16;
pub const UART_RS485_PARITY_ERR_INT_CLR_V: u32 = 1;
pub const UART_RS485_PARITY_ERR_INT_CLR_S: u32 = 15;
pub const UART_TX_DONE_INT_CLR_V: u32 = 1;
pub const UART_TX_DONE_INT_CLR_S: u32 = 14;
pub const UART_TX_BRK_IDLE_DONE_INT_CLR_V: u32 = 1;
pub const UART_TX_BRK_IDLE_DONE_INT_CLR_S: u32 = 13;
pub const UART_TX_BRK_DONE_INT_CLR_V: u32 = 1;
pub const UART_TX_BRK_DONE_INT_CLR_S: u32 = 12;
pub const UART_GLITCH_DET_INT_CLR_V: u32 = 1;
pub const UART_GLITCH_DET_INT_CLR_S: u32 = 11;
pub const UART_SW_XOFF_INT_CLR_V: u32 = 1;
pub const UART_SW_XOFF_INT_CLR_S: u32 = 10;
pub const UART_SW_XON_INT_CLR_V: u32 = 1;
pub const UART_SW_XON_INT_CLR_S: u32 = 9;
pub const UART_RXFIFO_TOUT_INT_CLR_V: u32 = 1;
pub const UART_RXFIFO_TOUT_INT_CLR_S: u32 = 8;
pub const UART_BRK_DET_INT_CLR_V: u32 = 1;
pub const UART_BRK_DET_INT_CLR_S: u32 = 7;
pub const UART_CTS_CHG_INT_CLR_V: u32 = 1;
pub const UART_CTS_CHG_INT_CLR_S: u32 = 6;
pub const UART_DSR_CHG_INT_CLR_V: u32 = 1;
pub const UART_DSR_CHG_INT_CLR_S: u32 = 5;
pub const UART_RXFIFO_OVF_INT_CLR_V: u32 = 1;
pub const UART_RXFIFO_OVF_INT_CLR_S: u32 = 4;
pub const UART_FRM_ERR_INT_CLR_V: u32 = 1;
pub const UART_FRM_ERR_INT_CLR_S: u32 = 3;
pub const UART_PARITY_ERR_INT_CLR_V: u32 = 1;
pub const UART_PARITY_ERR_INT_CLR_S: u32 = 2;
pub const UART_TXFIFO_EMPTY_INT_CLR_V: u32 = 1;
pub const UART_TXFIFO_EMPTY_INT_CLR_S: u32 = 1;
pub const UART_RXFIFO_FULL_INT_CLR_V: u32 = 1;
pub const UART_RXFIFO_FULL_INT_CLR_S: u32 = 0;
pub const UART_CLKDIV_FRAG: u32 = 15;
pub const UART_CLKDIV_FRAG_V: u32 = 15;
pub const UART_CLKDIV_FRAG_S: u32 = 20;
pub const UART_CLKDIV: u32 = 1048575;
pub const UART_CLKDIV_V: u32 = 1048575;
pub const UART_CLKDIV_S: u32 = 0;
pub const UART_GLITCH_FILT: u32 = 255;
pub const UART_GLITCH_FILT_V: u32 = 255;
pub const UART_GLITCH_FILT_S: u32 = 8;
pub const UART_AUTOBAUD_EN_V: u32 = 1;
pub const UART_AUTOBAUD_EN_S: u32 = 0;
pub const UART_TXD_V: u32 = 1;
pub const UART_TXD_S: u32 = 31;
pub const UART_RTSN_V: u32 = 1;
pub const UART_RTSN_S: u32 = 30;
pub const UART_DTRN_V: u32 = 1;
pub const UART_DTRN_S: u32 = 29;
pub const UART_ST_UTX_OUT: u32 = 15;
pub const UART_ST_UTX_OUT_V: u32 = 15;
pub const UART_ST_UTX_OUT_S: u32 = 24;
pub const UART_TXFIFO_CNT: u32 = 255;
pub const UART_TXFIFO_CNT_V: u32 = 255;
pub const UART_TXFIFO_CNT_S: u32 = 16;
pub const UART_RXD_V: u32 = 1;
pub const UART_RXD_S: u32 = 15;
pub const UART_CTSN_V: u32 = 1;
pub const UART_CTSN_S: u32 = 14;
pub const UART_DSRN_V: u32 = 1;
pub const UART_DSRN_S: u32 = 13;
pub const UART_ST_URX_OUT: u32 = 15;
pub const UART_ST_URX_OUT_V: u32 = 15;
pub const UART_ST_URX_OUT_S: u32 = 8;
pub const UART_RXFIFO_CNT: u32 = 255;
pub const UART_RXFIFO_CNT_V: u32 = 255;
pub const UART_RXFIFO_CNT_S: u32 = 0;
pub const UART_TICK_REF_ALWAYS_ON_V: u32 = 1;
pub const UART_TICK_REF_ALWAYS_ON_S: u32 = 27;
pub const UART_ERR_WR_MASK_V: u32 = 1;
pub const UART_ERR_WR_MASK_S: u32 = 26;
pub const UART_CLK_EN_V: u32 = 1;
pub const UART_CLK_EN_S: u32 = 25;
pub const UART_DTR_INV_V: u32 = 1;
pub const UART_DTR_INV_S: u32 = 24;
pub const UART_RTS_INV_V: u32 = 1;
pub const UART_RTS_INV_S: u32 = 23;
pub const UART_TXD_INV_V: u32 = 1;
pub const UART_TXD_INV_S: u32 = 22;
pub const UART_DSR_INV_V: u32 = 1;
pub const UART_DSR_INV_S: u32 = 21;
pub const UART_CTS_INV_V: u32 = 1;
pub const UART_CTS_INV_S: u32 = 20;
pub const UART_RXD_INV_V: u32 = 1;
pub const UART_RXD_INV_S: u32 = 19;
pub const UART_TXFIFO_RST_V: u32 = 1;
pub const UART_TXFIFO_RST_S: u32 = 18;
pub const UART_RXFIFO_RST_V: u32 = 1;
pub const UART_RXFIFO_RST_S: u32 = 17;
pub const UART_IRDA_EN_V: u32 = 1;
pub const UART_IRDA_EN_S: u32 = 16;
pub const UART_TX_FLOW_EN_V: u32 = 1;
pub const UART_TX_FLOW_EN_S: u32 = 15;
pub const UART_LOOPBACK_V: u32 = 1;
pub const UART_LOOPBACK_S: u32 = 14;
pub const UART_IRDA_RX_INV_V: u32 = 1;
pub const UART_IRDA_RX_INV_S: u32 = 13;
pub const UART_IRDA_TX_INV_V: u32 = 1;
pub const UART_IRDA_TX_INV_S: u32 = 12;
pub const UART_IRDA_WCTL_V: u32 = 1;
pub const UART_IRDA_WCTL_S: u32 = 11;
pub const UART_IRDA_TX_EN_V: u32 = 1;
pub const UART_IRDA_TX_EN_S: u32 = 10;
pub const UART_IRDA_DPLX_V: u32 = 1;
pub const UART_IRDA_DPLX_S: u32 = 9;
pub const UART_TXD_BRK_V: u32 = 1;
pub const UART_TXD_BRK_S: u32 = 8;
pub const UART_SW_DTR_V: u32 = 1;
pub const UART_SW_DTR_S: u32 = 7;
pub const UART_SW_RTS_V: u32 = 1;
pub const UART_SW_RTS_S: u32 = 6;
pub const UART_STOP_BIT_NUM: u32 = 3;
pub const UART_STOP_BIT_NUM_V: u32 = 3;
pub const UART_STOP_BIT_NUM_S: u32 = 4;
pub const UART_BIT_NUM: u32 = 3;
pub const UART_BIT_NUM_V: u32 = 3;
pub const UART_BIT_NUM_S: u32 = 2;
pub const UART_PARITY_EN_V: u32 = 1;
pub const UART_PARITY_EN_S: u32 = 1;
pub const UART_PARITY_V: u32 = 1;
pub const UART_PARITY_S: u32 = 0;
pub const UART_RX_TOUT_EN_V: u32 = 1;
pub const UART_RX_TOUT_EN_S: u32 = 31;
pub const UART_RX_TOUT_THRHD: u32 = 127;
pub const UART_RX_TOUT_THRHD_V: u32 = 127;
pub const UART_RX_TOUT_THRHD_S: u32 = 24;
pub const UART_RX_FLOW_EN_V: u32 = 1;
pub const UART_RX_FLOW_EN_S: u32 = 23;
pub const UART_RX_FLOW_THRHD: u32 = 127;
pub const UART_RX_FLOW_THRHD_V: u32 = 127;
pub const UART_RX_FLOW_THRHD_S: u32 = 16;
pub const UART_TXFIFO_EMPTY_THRHD: u32 = 127;
pub const UART_TXFIFO_EMPTY_THRHD_V: u32 = 127;
pub const UART_TXFIFO_EMPTY_THRHD_S: u32 = 8;
pub const UART_RXFIFO_FULL_THRHD: u32 = 127;
pub const UART_RXFIFO_FULL_THRHD_V: u32 = 127;
pub const UART_RXFIFO_FULL_THRHD_S: u32 = 0;
pub const UART_LOWPULSE_MIN_CNT: u32 = 1048575;
pub const UART_LOWPULSE_MIN_CNT_V: u32 = 1048575;
pub const UART_LOWPULSE_MIN_CNT_S: u32 = 0;
pub const UART_HIGHPULSE_MIN_CNT: u32 = 1048575;
pub const UART_HIGHPULSE_MIN_CNT_V: u32 = 1048575;
pub const UART_HIGHPULSE_MIN_CNT_S: u32 = 0;
pub const UART_RXD_EDGE_CNT: u32 = 1023;
pub const UART_RXD_EDGE_CNT_V: u32 = 1023;
pub const UART_RXD_EDGE_CNT_S: u32 = 0;
pub const UART_SEND_XOFF_V: u32 = 1;
pub const UART_SEND_XOFF_S: u32 = 5;
pub const UART_SEND_XON_V: u32 = 1;
pub const UART_SEND_XON_S: u32 = 4;
pub const UART_FORCE_XOFF_V: u32 = 1;
pub const UART_FORCE_XOFF_S: u32 = 3;
pub const UART_FORCE_XON_V: u32 = 1;
pub const UART_FORCE_XON_S: u32 = 2;
pub const UART_XONOFF_DEL_V: u32 = 1;
pub const UART_XONOFF_DEL_S: u32 = 1;
pub const UART_SW_FLOW_CON_EN_V: u32 = 1;
pub const UART_SW_FLOW_CON_EN_S: u32 = 0;
pub const UART_ACTIVE_THRESHOLD: u32 = 1023;
pub const UART_ACTIVE_THRESHOLD_V: u32 = 1023;
pub const UART_ACTIVE_THRESHOLD_S: u32 = 0;
pub const UART_XOFF_CHAR: u32 = 255;
pub const UART_XOFF_CHAR_V: u32 = 255;
pub const UART_XOFF_CHAR_S: u32 = 24;
pub const UART_XON_CHAR: u32 = 255;
pub const UART_XON_CHAR_V: u32 = 255;
pub const UART_XON_CHAR_S: u32 = 16;
pub const UART_XOFF_THRESHOLD: u32 = 255;
pub const UART_XOFF_THRESHOLD_V: u32 = 255;
pub const UART_XOFF_THRESHOLD_S: u32 = 8;
pub const UART_XON_THRESHOLD: u32 = 255;
pub const UART_XON_THRESHOLD_V: u32 = 255;
pub const UART_XON_THRESHOLD_S: u32 = 0;
pub const UART_TX_BRK_NUM: u32 = 255;
pub const UART_TX_BRK_NUM_V: u32 = 255;
pub const UART_TX_BRK_NUM_S: u32 = 20;
pub const UART_TX_IDLE_NUM: u32 = 1023;
pub const UART_TX_IDLE_NUM_V: u32 = 1023;
pub const UART_TX_IDLE_NUM_S: u32 = 10;
pub const UART_RX_IDLE_THRHD: u32 = 1023;
pub const UART_RX_IDLE_THRHD_V: u32 = 1023;
pub const UART_RX_IDLE_THRHD_S: u32 = 0;
pub const UART_RS485_TX_DLY_NUM: u32 = 15;
pub const UART_RS485_TX_DLY_NUM_V: u32 = 15;
pub const UART_RS485_TX_DLY_NUM_S: u32 = 6;
pub const UART_RS485_RX_DLY_NUM_V: u32 = 1;
pub const UART_RS485_RX_DLY_NUM_S: u32 = 5;
pub const UART_RS485RXBY_TX_EN_V: u32 = 1;
pub const UART_RS485RXBY_TX_EN_S: u32 = 4;
pub const UART_RS485TX_RX_EN_V: u32 = 1;
pub const UART_RS485TX_RX_EN_S: u32 = 3;
pub const UART_DL1_EN_V: u32 = 1;
pub const UART_DL1_EN_S: u32 = 2;
pub const UART_DL0_EN_V: u32 = 1;
pub const UART_DL0_EN_S: u32 = 1;
pub const UART_RS485_EN_V: u32 = 1;
pub const UART_RS485_EN_S: u32 = 0;
pub const UART_PRE_IDLE_NUM: u32 = 16777215;
pub const UART_PRE_IDLE_NUM_V: u32 = 16777215;
pub const UART_PRE_IDLE_NUM_S: u32 = 0;
pub const UART_POST_IDLE_NUM: u32 = 16777215;
pub const UART_POST_IDLE_NUM_V: u32 = 16777215;
pub const UART_POST_IDLE_NUM_S: u32 = 0;
pub const UART_RX_GAP_TOUT: u32 = 16777215;
pub const UART_RX_GAP_TOUT_V: u32 = 16777215;
pub const UART_RX_GAP_TOUT_S: u32 = 0;
pub const UART_CHAR_NUM: u32 = 255;
pub const UART_CHAR_NUM_V: u32 = 255;
pub const UART_CHAR_NUM_S: u32 = 8;
pub const UART_AT_CMD_CHAR: u32 = 255;
pub const UART_AT_CMD_CHAR_V: u32 = 255;
pub const UART_AT_CMD_CHAR_S: u32 = 0;
pub const UART_TX_MEM_EMPTY_THRHD: u32 = 7;
pub const UART_TX_MEM_EMPTY_THRHD_V: u32 = 7;
pub const UART_TX_MEM_EMPTY_THRHD_S: u32 = 28;
pub const UART_RX_MEM_FULL_THRHD: u32 = 7;
pub const UART_RX_MEM_FULL_THRHD_V: u32 = 7;
pub const UART_RX_MEM_FULL_THRHD_S: u32 = 25;
pub const UART_XOFF_THRESHOLD_H2: u32 = 3;
pub const UART_XOFF_THRESHOLD_H2_V: u32 = 3;
pub const UART_XOFF_THRESHOLD_H2_S: u32 = 23;
pub const UART_XON_THRESHOLD_H2: u32 = 3;
pub const UART_XON_THRESHOLD_H2_V: u32 = 3;
pub const UART_XON_THRESHOLD_H2_S: u32 = 21;
pub const UART_RX_TOUT_THRHD_H3: u32 = 7;
pub const UART_RX_TOUT_THRHD_H3_V: u32 = 7;
pub const UART_RX_TOUT_THRHD_H3_S: u32 = 18;
pub const UART_RX_FLOW_THRHD_H3: u32 = 7;
pub const UART_RX_FLOW_THRHD_H3_V: u32 = 7;
pub const UART_RX_FLOW_THRHD_H3_S: u32 = 15;
pub const UART_TX_SIZE: u32 = 15;
pub const UART_TX_SIZE_V: u32 = 15;
pub const UART_TX_SIZE_S: u32 = 7;
pub const UART_RX_SIZE: u32 = 15;
pub const UART_RX_SIZE_V: u32 = 15;
pub const UART_RX_SIZE_S: u32 = 3;
pub const UART_MEM_PD_V: u32 = 1;
pub const UART_MEM_PD_S: u32 = 0;
pub const UART_MEM_TX_STATUS: u32 = 16777215;
pub const UART_MEM_TX_STATUS_V: u32 = 16777215;
pub const UART_MEM_TX_STATUS_S: u32 = 0;
pub const UART_MEM_RX_STATUS: u32 = 16777215;
pub const UART_MEM_RX_STATUS_V: u32 = 16777215;
pub const UART_MEM_RX_STATUS_S: u32 = 0;
pub const UART_MEM_RX_RD_ADDR: u32 = 2047;
pub const UART_MEM_RX_RD_ADDR_V: u32 = 2047;
pub const UART_MEM_RX_RD_ADDR_S: u32 = 2;
pub const UART_MEM_RX_WR_ADDR: u32 = 2047;
pub const UART_MEM_RX_WR_ADDR_V: u32 = 2047;
pub const UART_MEM_RX_WR_ADDR_S: u32 = 13;
pub const UART_TX_MEM_CNT: u32 = 7;
pub const UART_TX_MEM_CNT_V: u32 = 7;
pub const UART_TX_MEM_CNT_S: u32 = 3;
pub const UART_RX_MEM_CNT: u32 = 7;
pub const UART_RX_MEM_CNT_V: u32 = 7;
pub const UART_RX_MEM_CNT_S: u32 = 0;
pub const UART_POSEDGE_MIN_CNT: u32 = 1048575;
pub const UART_POSEDGE_MIN_CNT_V: u32 = 1048575;
pub const UART_POSEDGE_MIN_CNT_S: u32 = 0;
pub const UART_NEGEDGE_MIN_CNT: u32 = 1048575;
pub const UART_NEGEDGE_MIN_CNT_V: u32 = 1048575;
pub const UART_NEGEDGE_MIN_CNT_S: u32 = 0;
pub const UART_DATE: u32 = 4294967295;
pub const UART_DATE_V: u32 = 4294967295;
pub const UART_DATE_S: u32 = 0;
pub const UART_ID: u32 = 4294967295;
pub const UART_ID_V: u32 = 4294967295;
pub const UART_ID_S: u32 = 0;
pub const DPORT_PRO_BOOT_REMAP_CTRL_REG: u32 = 1072693248;
pub const DPORT_PRO_BOOT_REMAP_V: u32 = 1;
pub const DPORT_PRO_BOOT_REMAP_S: u32 = 0;
pub const DPORT_APP_BOOT_REMAP_CTRL_REG: u32 = 1072693252;
pub const DPORT_APP_BOOT_REMAP_V: u32 = 1;
pub const DPORT_APP_BOOT_REMAP_S: u32 = 0;
pub const DPORT_ACCESS_CHECK_REG: u32 = 1072693256;
pub const DPORT_ACCESS_CHECK_APP_V: u32 = 1;
pub const DPORT_ACCESS_CHECK_APP_S: u32 = 8;
pub const DPORT_ACCESS_CHECK_PRO_V: u32 = 1;
pub const DPORT_ACCESS_CHECK_PRO_S: u32 = 0;
pub const DPORT_PRO_DPORT_APB_MASK0_REG: u32 = 1072693260;
pub const DPORT_PRODPORT_APB_MASK0: u32 = 4294967295;
pub const DPORT_PRODPORT_APB_MASK0_V: u32 = 4294967295;
pub const DPORT_PRODPORT_APB_MASK0_S: u32 = 0;
pub const DPORT_PRO_DPORT_APB_MASK1_REG: u32 = 1072693264;
pub const DPORT_PRODPORT_APB_MASK1: u32 = 4294967295;
pub const DPORT_PRODPORT_APB_MASK1_V: u32 = 4294967295;
pub const DPORT_PRODPORT_APB_MASK1_S: u32 = 0;
pub const DPORT_APP_DPORT_APB_MASK0_REG: u32 = 1072693268;
pub const DPORT_APPDPORT_APB_MASK0: u32 = 4294967295;
pub const DPORT_APPDPORT_APB_MASK0_V: u32 = 4294967295;
pub const DPORT_APPDPORT_APB_MASK0_S: u32 = 0;
pub const DPORT_APP_DPORT_APB_MASK1_REG: u32 = 1072693272;
pub const DPORT_APPDPORT_APB_MASK1: u32 = 4294967295;
pub const DPORT_APPDPORT_APB_MASK1_V: u32 = 4294967295;
pub const DPORT_APPDPORT_APB_MASK1_S: u32 = 0;
pub const DPORT_PERI_CLK_EN_REG: u32 = 1072693276;
pub const DPORT_PERI_CLK_EN: u32 = 4294967295;
pub const DPORT_PERI_CLK_EN_V: u32 = 4294967295;
pub const DPORT_PERI_CLK_EN_S: u32 = 0;
pub const DPORT_PERI_RST_EN_REG: u32 = 1072693280;
pub const DPORT_PERI_RST_EN: u32 = 4294967295;
pub const DPORT_PERI_RST_EN_V: u32 = 4294967295;
pub const DPORT_PERI_RST_EN_S: u32 = 0;
pub const DPORT_PERI_EN_AES: u32 = 1;
pub const DPORT_PERI_EN_SHA: u32 = 2;
pub const DPORT_PERI_EN_RSA: u32 = 4;
pub const DPORT_PERI_EN_SECUREBOOT: u32 = 8;
pub const DPORT_PERI_EN_DIGITAL_SIGNATURE: u32 = 16;
pub const DPORT_WIFI_BB_CFG_REG: u32 = 1072693284;
pub const DPORT_WIFI_BB_CFG: u32 = 4294967295;
pub const DPORT_WIFI_BB_CFG_V: u32 = 4294967295;
pub const DPORT_WIFI_BB_CFG_S: u32 = 0;
pub const DPORT_WIFI_BB_CFG_2_REG: u32 = 1072693288;
pub const DPORT_WIFI_BB_CFG_2: u32 = 4294967295;
pub const DPORT_WIFI_BB_CFG_2_V: u32 = 4294967295;
pub const DPORT_WIFI_BB_CFG_2_S: u32 = 0;
pub const DPORT_APPCPU_CTRL_A_REG: u32 = 1072693292;
pub const DPORT_APPCPU_RESETTING_V: u32 = 1;
pub const DPORT_APPCPU_RESETTING_S: u32 = 0;
pub const DPORT_APPCPU_CTRL_B_REG: u32 = 1072693296;
pub const DPORT_APPCPU_CLKGATE_EN_V: u32 = 1;
pub const DPORT_APPCPU_CLKGATE_EN_S: u32 = 0;
pub const DPORT_APPCPU_CTRL_C_REG: u32 = 1072693300;
pub const DPORT_APPCPU_RUNSTALL_V: u32 = 1;
pub const DPORT_APPCPU_RUNSTALL_S: u32 = 0;
pub const DPORT_APPCPU_CTRL_D_REG: u32 = 1072693304;
pub const DPORT_APPCPU_BOOT_ADDR: u32 = 4294967295;
pub const DPORT_APPCPU_BOOT_ADDR_V: u32 = 4294967295;
pub const DPORT_APPCPU_BOOT_ADDR_S: u32 = 0;
pub const DPORT_CPU_PER_CONF_REG: u32 = 1072693308;
pub const DPORT_FAST_CLK_RTC_SEL_V: u32 = 1;
pub const DPORT_FAST_CLK_RTC_SEL_S: u32 = 3;
pub const DPORT_LOWSPEED_CLK_SEL_V: u32 = 1;
pub const DPORT_LOWSPEED_CLK_SEL_S: u32 = 2;
pub const DPORT_CPUPERIOD_SEL: u32 = 3;
pub const DPORT_CPUPERIOD_SEL_V: u32 = 3;
pub const DPORT_CPUPERIOD_SEL_S: u32 = 0;
pub const DPORT_CPUPERIOD_SEL_80: u32 = 0;
pub const DPORT_CPUPERIOD_SEL_160: u32 = 1;
pub const DPORT_CPUPERIOD_SEL_240: u32 = 2;
pub const DPORT_PRO_CACHE_CTRL_REG: u32 = 1072693312;
pub const DPORT_PRO_DRAM_HL_V: u32 = 1;
pub const DPORT_PRO_DRAM_HL_S: u32 = 16;
pub const DPORT_SLAVE_REQ_V: u32 = 1;
pub const DPORT_SLAVE_REQ_S: u32 = 15;
pub const DPORT_AHB_SPI_REQ_V: u32 = 1;
pub const DPORT_AHB_SPI_REQ_S: u32 = 14;
pub const DPORT_PRO_SLAVE_REQ_V: u32 = 1;
pub const DPORT_PRO_SLAVE_REQ_S: u32 = 13;
pub const DPORT_PRO_AHB_SPI_REQ_V: u32 = 1;
pub const DPORT_PRO_AHB_SPI_REQ_S: u32 = 12;
pub const DPORT_PRO_DRAM_SPLIT_V: u32 = 1;
pub const DPORT_PRO_DRAM_SPLIT_S: u32 = 11;
pub const DPORT_PRO_SINGLE_IRAM_ENA_V: u32 = 1;
pub const DPORT_PRO_SINGLE_IRAM_ENA_S: u32 = 10;
pub const DPORT_PRO_CACHE_LOCK_3_EN_V: u32 = 1;
pub const DPORT_PRO_CACHE_LOCK_3_EN_S: u32 = 9;
pub const DPORT_PRO_CACHE_LOCK_2_EN_V: u32 = 1;
pub const DPORT_PRO_CACHE_LOCK_2_EN_S: u32 = 8;
pub const DPORT_PRO_CACHE_LOCK_1_EN_V: u32 = 1;
pub const DPORT_PRO_CACHE_LOCK_1_EN_S: u32 = 7;
pub const DPORT_PRO_CACHE_LOCK_0_EN_V: u32 = 1;
pub const DPORT_PRO_CACHE_LOCK_0_EN_S: u32 = 6;
pub const DPORT_PRO_CACHE_FLUSH_DONE_V: u32 = 1;
pub const DPORT_PRO_CACHE_FLUSH_DONE_S: u32 = 5;
pub const DPORT_PRO_CACHE_FLUSH_ENA_V: u32 = 1;
pub const DPORT_PRO_CACHE_FLUSH_ENA_S: u32 = 4;
pub const DPORT_PRO_CACHE_ENABLE_V: u32 = 1;
pub const DPORT_PRO_CACHE_ENABLE_S: u32 = 3;
pub const DPORT_PRO_CACHE_MODE_V: u32 = 1;
pub const DPORT_PRO_CACHE_MODE_S: u32 = 2;
pub const DPORT_PRO_CACHE_CTRL1_REG: u32 = 1072693316;
pub const DPORT_PRO_CACHE_MMU_IA_CLR_V: u32 = 1;
pub const DPORT_PRO_CACHE_MMU_IA_CLR_S: u32 = 13;
pub const DPORT_PRO_CMMU_PD_V: u32 = 1;
pub const DPORT_PRO_CMMU_PD_S: u32 = 12;
pub const DPORT_PRO_CMMU_FORCE_ON_V: u32 = 1;
pub const DPORT_PRO_CMMU_FORCE_ON_S: u32 = 11;
pub const DPORT_PRO_CMMU_FLASH_PAGE_MODE: u32 = 3;
pub const DPORT_PRO_CMMU_FLASH_PAGE_MODE_V: u32 = 3;
pub const DPORT_PRO_CMMU_FLASH_PAGE_MODE_S: u32 = 9;
pub const DPORT_PRO_CMMU_SRAM_PAGE_MODE: u32 = 7;
pub const DPORT_PRO_CMMU_SRAM_PAGE_MODE_V: u32 = 7;
pub const DPORT_PRO_CMMU_SRAM_PAGE_MODE_S: u32 = 6;
pub const DPORT_PRO_CACHE_MASK_OPSDRAM_V: u32 = 1;
pub const DPORT_PRO_CACHE_MASK_OPSDRAM_S: u32 = 5;
pub const DPORT_PRO_CACHE_MASK_DROM0_V: u32 = 1;
pub const DPORT_PRO_CACHE_MASK_DROM0_S: u32 = 4;
pub const DPORT_PRO_CACHE_MASK_DRAM1_V: u32 = 1;
pub const DPORT_PRO_CACHE_MASK_DRAM1_S: u32 = 3;
pub const DPORT_PRO_CACHE_MASK_IROM0_V: u32 = 1;
pub const DPORT_PRO_CACHE_MASK_IROM0_S: u32 = 2;
pub const DPORT_PRO_CACHE_MASK_IRAM1_V: u32 = 1;
pub const DPORT_PRO_CACHE_MASK_IRAM1_S: u32 = 1;
pub const DPORT_PRO_CACHE_MASK_IRAM0_V: u32 = 1;
pub const DPORT_PRO_CACHE_MASK_IRAM0_S: u32 = 0;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_REG: u32 = 1072693320;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_MAX: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_MAX_V: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_MAX_S: u32 = 18;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_MIN: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_MIN_V: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_MIN_S: u32 = 14;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_PRE: u32 = 16383;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_PRE_V: u32 = 16383;
pub const DPORT_PRO_CACHE_LOCK_0_ADDR_PRE_S: u32 = 0;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_REG: u32 = 1072693324;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_MAX: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_MAX_V: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_MAX_S: u32 = 18;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_MIN: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_MIN_V: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_MIN_S: u32 = 14;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_PRE: u32 = 16383;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_PRE_V: u32 = 16383;
pub const DPORT_PRO_CACHE_LOCK_1_ADDR_PRE_S: u32 = 0;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_REG: u32 = 1072693328;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_MAX: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_MAX_V: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_MAX_S: u32 = 18;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_MIN: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_MIN_V: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_MIN_S: u32 = 14;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_PRE: u32 = 16383;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_PRE_V: u32 = 16383;
pub const DPORT_PRO_CACHE_LOCK_2_ADDR_PRE_S: u32 = 0;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_REG: u32 = 1072693332;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_MAX: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_MAX_V: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_MAX_S: u32 = 18;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_MIN: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_MIN_V: u32 = 15;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_MIN_S: u32 = 14;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_PRE: u32 = 16383;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_PRE_V: u32 = 16383;
pub const DPORT_PRO_CACHE_LOCK_3_ADDR_PRE_S: u32 = 0;
pub const DPORT_APP_CACHE_CTRL_REG: u32 = 1072693336;
pub const DPORT_APP_DRAM_HL_V: u32 = 1;
pub const DPORT_APP_DRAM_HL_S: u32 = 14;
pub const DPORT_APP_SLAVE_REQ_V: u32 = 1;
pub const DPORT_APP_SLAVE_REQ_S: u32 = 13;
pub const DPORT_APP_AHB_SPI_REQ_V: u32 = 1;
pub const DPORT_APP_AHB_SPI_REQ_S: u32 = 12;
pub const DPORT_APP_DRAM_SPLIT_V: u32 = 1;
pub const DPORT_APP_DRAM_SPLIT_S: u32 = 11;
pub const DPORT_APP_SINGLE_IRAM_ENA_V: u32 = 1;
pub const DPORT_APP_SINGLE_IRAM_ENA_S: u32 = 10;
pub const DPORT_APP_CACHE_LOCK_3_EN_V: u32 = 1;
pub const DPORT_APP_CACHE_LOCK_3_EN_S: u32 = 9;
pub const DPORT_APP_CACHE_LOCK_2_EN_V: u32 = 1;
pub const DPORT_APP_CACHE_LOCK_2_EN_S: u32 = 8;
pub const DPORT_APP_CACHE_LOCK_1_EN_V: u32 = 1;
pub const DPORT_APP_CACHE_LOCK_1_EN_S: u32 = 7;
pub const DPORT_APP_CACHE_LOCK_0_EN_V: u32 = 1;
pub const DPORT_APP_CACHE_LOCK_0_EN_S: u32 = 6;
pub const DPORT_APP_CACHE_FLUSH_DONE_V: u32 = 1;
pub const DPORT_APP_CACHE_FLUSH_DONE_S: u32 = 5;
pub const DPORT_APP_CACHE_FLUSH_ENA_V: u32 = 1;
pub const DPORT_APP_CACHE_FLUSH_ENA_S: u32 = 4;
pub const DPORT_APP_CACHE_ENABLE_V: u32 = 1;
pub const DPORT_APP_CACHE_ENABLE_S: u32 = 3;
pub const DPORT_APP_CACHE_MODE_V: u32 = 1;
pub const DPORT_APP_CACHE_MODE_S: u32 = 2;
pub const DPORT_APP_CACHE_CTRL1_REG: u32 = 1072693340;
pub const DPORT_APP_CACHE_MMU_IA_CLR_V: u32 = 1;
pub const DPORT_APP_CACHE_MMU_IA_CLR_S: u32 = 13;
pub const DPORT_APP_CMMU_PD_V: u32 = 1;
pub const DPORT_APP_CMMU_PD_S: u32 = 12;
pub const DPORT_APP_CMMU_FORCE_ON_V: u32 = 1;
pub const DPORT_APP_CMMU_FORCE_ON_S: u32 = 11;
pub const DPORT_APP_CMMU_FLASH_PAGE_MODE: u32 = 3;
pub const DPORT_APP_CMMU_FLASH_PAGE_MODE_V: u32 = 3;
pub const DPORT_APP_CMMU_FLASH_PAGE_MODE_S: u32 = 9;
pub const DPORT_APP_CMMU_SRAM_PAGE_MODE: u32 = 7;
pub const DPORT_APP_CMMU_SRAM_PAGE_MODE_V: u32 = 7;
pub const DPORT_APP_CMMU_SRAM_PAGE_MODE_S: u32 = 6;
pub const DPORT_APP_CACHE_MASK_OPSDRAM_V: u32 = 1;
pub const DPORT_APP_CACHE_MASK_OPSDRAM_S: u32 = 5;
pub const DPORT_APP_CACHE_MASK_DROM0_V: u32 = 1;
pub const DPORT_APP_CACHE_MASK_DROM0_S: u32 = 4;
pub const DPORT_APP_CACHE_MASK_DRAM1_V: u32 = 1;
pub const DPORT_APP_CACHE_MASK_DRAM1_S: u32 = 3;
pub const DPORT_APP_CACHE_MASK_IROM0_V: u32 = 1;
pub const DPORT_APP_CACHE_MASK_IROM0_S: u32 = 2;
pub const DPORT_APP_CACHE_MASK_IRAM1_V: u32 = 1;
pub const DPORT_APP_CACHE_MASK_IRAM1_S: u32 = 1;
pub const DPORT_APP_CACHE_MASK_IRAM0_V: u32 = 1;
pub const DPORT_APP_CACHE_MASK_IRAM0_S: u32 = 0;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_REG: u32 = 1072693344;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_MAX: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_MAX_V: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_MAX_S: u32 = 18;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_MIN: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_MIN_V: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_MIN_S: u32 = 14;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_PRE: u32 = 16383;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_PRE_V: u32 = 16383;
pub const DPORT_APP_CACHE_LOCK_0_ADDR_PRE_S: u32 = 0;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_REG: u32 = 1072693348;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_MAX: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_MAX_V: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_MAX_S: u32 = 18;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_MIN: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_MIN_V: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_MIN_S: u32 = 14;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_PRE: u32 = 16383;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_PRE_V: u32 = 16383;
pub const DPORT_APP_CACHE_LOCK_1_ADDR_PRE_S: u32 = 0;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_REG: u32 = 1072693352;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_MAX: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_MAX_V: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_MAX_S: u32 = 18;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_MIN: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_MIN_V: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_MIN_S: u32 = 14;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_PRE: u32 = 16383;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_PRE_V: u32 = 16383;
pub const DPORT_APP_CACHE_LOCK_2_ADDR_PRE_S: u32 = 0;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_REG: u32 = 1072693356;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_MAX: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_MAX_V: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_MAX_S: u32 = 18;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_MIN: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_MIN_V: u32 = 15;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_MIN_S: u32 = 14;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_PRE: u32 = 16383;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_PRE_V: u32 = 16383;
pub const DPORT_APP_CACHE_LOCK_3_ADDR_PRE_S: u32 = 0;
pub const DPORT_TRACEMEM_MUX_MODE_REG: u32 = 1072693360;
pub const DPORT_TRACEMEM_MUX_MODE: u32 = 3;
pub const DPORT_TRACEMEM_MUX_MODE_V: u32 = 3;
pub const DPORT_TRACEMEM_MUX_MODE_S: u32 = 0;
pub const DPORT_PRO_TRACEMEM_ENA_REG: u32 = 1072693364;
pub const DPORT_PRO_TRACEMEM_ENA_V: u32 = 1;
pub const DPORT_PRO_TRACEMEM_ENA_S: u32 = 0;
pub const DPORT_APP_TRACEMEM_ENA_REG: u32 = 1072693368;
pub const DPORT_APP_TRACEMEM_ENA_V: u32 = 1;
pub const DPORT_APP_TRACEMEM_ENA_S: u32 = 0;
pub const DPORT_CACHE_MUX_MODE_REG: u32 = 1072693372;
pub const DPORT_CACHE_MUX_MODE: u32 = 3;
pub const DPORT_CACHE_MUX_MODE_V: u32 = 3;
pub const DPORT_CACHE_MUX_MODE_S: u32 = 0;
pub const DPORT_IMMU_PAGE_MODE_REG: u32 = 1072693376;
pub const DPORT_IMMU_PAGE_MODE: u32 = 3;
pub const DPORT_IMMU_PAGE_MODE_V: u32 = 3;
pub const DPORT_IMMU_PAGE_MODE_S: u32 = 1;
pub const DPORT_INTERNAL_SRAM_IMMU_ENA_V: u32 = 1;
pub const DPORT_INTERNAL_SRAM_IMMU_ENA_S: u32 = 0;
pub const DPORT_DMMU_PAGE_MODE_REG: u32 = 1072693380;
pub const DPORT_DMMU_PAGE_MODE: u32 = 3;
pub const DPORT_DMMU_PAGE_MODE_V: u32 = 3;
pub const DPORT_DMMU_PAGE_MODE_S: u32 = 1;
pub const DPORT_INTERNAL_SRAM_DMMU_ENA_V: u32 = 1;
pub const DPORT_INTERNAL_SRAM_DMMU_ENA_S: u32 = 0;
pub const DPORT_ROM_MPU_ENA_REG: u32 = 1072693384;
pub const DPORT_APP_ROM_MPU_ENA_V: u32 = 1;
pub const DPORT_APP_ROM_MPU_ENA_S: u32 = 2;
pub const DPORT_PRO_ROM_MPU_ENA_V: u32 = 1;
pub const DPORT_PRO_ROM_MPU_ENA_S: u32 = 1;
pub const DPORT_SHARE_ROM_MPU_ENA_V: u32 = 1;
pub const DPORT_SHARE_ROM_MPU_ENA_S: u32 = 0;
pub const DPORT_MEM_PD_MASK_REG: u32 = 1072693388;
pub const DPORT_LSLP_MEM_PD_MASK_V: u32 = 1;
pub const DPORT_LSLP_MEM_PD_MASK_S: u32 = 0;
pub const DPORT_ROM_PD_CTRL_REG: u32 = 1072693392;
pub const DPORT_SHARE_ROM_PD: u32 = 63;
pub const DPORT_SHARE_ROM_PD_V: u32 = 63;
pub const DPORT_SHARE_ROM_PD_S: u32 = 2;
pub const DPORT_APP_ROM_PD_V: u32 = 1;
pub const DPORT_APP_ROM_PD_S: u32 = 1;
pub const DPORT_PRO_ROM_PD_V: u32 = 1;
pub const DPORT_PRO_ROM_PD_S: u32 = 0;
pub const DPORT_ROM_FO_CTRL_REG: u32 = 1072693396;
pub const DPORT_SHARE_ROM_FO: u32 = 63;
pub const DPORT_SHARE_ROM_FO_V: u32 = 63;
pub const DPORT_SHARE_ROM_FO_S: u32 = 2;
pub const DPORT_APP_ROM_FO_V: u32 = 1;
pub const DPORT_APP_ROM_FO_S: u32 = 1;
pub const DPORT_PRO_ROM_FO_V: u32 = 1;
pub const DPORT_PRO_ROM_FO_S: u32 = 0;
pub const DPORT_SRAM_PD_CTRL_0_REG: u32 = 1072693400;
pub const DPORT_SRAM_PD_0: u32 = 4294967295;
pub const DPORT_SRAM_PD_0_V: u32 = 4294967295;
pub const DPORT_SRAM_PD_0_S: u32 = 0;
pub const DPORT_SRAM_PD_CTRL_1_REG: u32 = 1072693404;
pub const DPORT_SRAM_PD_1_V: u32 = 1;
pub const DPORT_SRAM_PD_1_S: u32 = 0;
pub const DPORT_SRAM_FO_CTRL_0_REG: u32 = 1072693408;
pub const DPORT_SRAM_FO_0: u32 = 4294967295;
pub const DPORT_SRAM_FO_0_V: u32 = 4294967295;
pub const DPORT_SRAM_FO_0_S: u32 = 0;
pub const DPORT_SRAM_FO_CTRL_1_REG: u32 = 1072693412;
pub const DPORT_SRAM_FO_1_V: u32 = 1;
pub const DPORT_SRAM_FO_1_S: u32 = 0;
pub const DPORT_IRAM_DRAM_AHB_SEL_REG: u32 = 1072693416;
pub const DPORT_MAC_DUMP_MODE: u32 = 3;
pub const DPORT_MAC_DUMP_MODE_V: u32 = 3;
pub const DPORT_MAC_DUMP_MODE_S: u32 = 5;
pub const DPORT_MASK_AHB_V: u32 = 1;
pub const DPORT_MASK_AHB_S: u32 = 4;
pub const DPORT_MASK_APP_DRAM_V: u32 = 1;
pub const DPORT_MASK_APP_DRAM_S: u32 = 3;
pub const DPORT_MASK_PRO_DRAM_V: u32 = 1;
pub const DPORT_MASK_PRO_DRAM_S: u32 = 2;
pub const DPORT_MASK_APP_IRAM_V: u32 = 1;
pub const DPORT_MASK_APP_IRAM_S: u32 = 1;
pub const DPORT_MASK_PRO_IRAM_V: u32 = 1;
pub const DPORT_MASK_PRO_IRAM_S: u32 = 0;
pub const DPORT_TAG_FO_CTRL_REG: u32 = 1072693420;
pub const DPORT_APP_CACHE_TAG_PD_V: u32 = 1;
pub const DPORT_APP_CACHE_TAG_PD_S: u32 = 9;
pub const DPORT_APP_CACHE_TAG_FORCE_ON_V: u32 = 1;
pub const DPORT_APP_CACHE_TAG_FORCE_ON_S: u32 = 8;
pub const DPORT_PRO_CACHE_TAG_PD_V: u32 = 1;
pub const DPORT_PRO_CACHE_TAG_PD_S: u32 = 1;
pub const DPORT_PRO_CACHE_TAG_FORCE_ON_V: u32 = 1;
pub const DPORT_PRO_CACHE_TAG_FORCE_ON_S: u32 = 0;
pub const DPORT_AHB_LITE_MASK_REG: u32 = 1072693424;
pub const DPORT_AHB_LITE_SDHOST_PID_REG: u32 = 7;
pub const DPORT_AHB_LITE_SDHOST_PID_REG_V: u32 = 7;
pub const DPORT_AHB_LITE_SDHOST_PID_REG_S: u32 = 11;
pub const DPORT_AHB_LITE_MASK_APPDPORT_V: u32 = 1;
pub const DPORT_AHB_LITE_MASK_APPDPORT_S: u32 = 10;
pub const DPORT_AHB_LITE_MASK_PRODPORT_V: u32 = 1;
pub const DPORT_AHB_LITE_MASK_PRODPORT_S: u32 = 9;
pub const DPORT_AHB_LITE_MASK_SDIO_V: u32 = 1;
pub const DPORT_AHB_LITE_MASK_SDIO_S: u32 = 8;
pub const DPORT_AHB_LITE_MASK_APP_V: u32 = 1;
pub const DPORT_AHB_LITE_MASK_APP_S: u32 = 4;
pub const DPORT_AHB_LITE_MASK_PRO_V: u32 = 1;
pub const DPORT_AHB_LITE_MASK_PRO_S: u32 = 0;
pub const DPORT_AHB_MPU_TABLE_0_REG: u32 = 1072693428;
pub const DPORT_AHB_ACCESS_GRANT_0: u32 = 4294967295;
pub const DPORT_AHB_ACCESS_GRANT_0_V: u32 = 4294967295;
pub const DPORT_AHB_ACCESS_GRANT_0_S: u32 = 0;
pub const DPORT_AHB_MPU_TABLE_1_REG: u32 = 1072693432;
pub const DPORT_AHB_ACCESS_GRANT_1: u32 = 511;
pub const DPORT_AHB_ACCESS_GRANT_1_V: u32 = 511;
pub const DPORT_AHB_ACCESS_GRANT_1_S: u32 = 0;
pub const DPORT_HOST_INF_SEL_REG: u32 = 1072693436;
pub const DPORT_LINK_DEVICE_SEL: u32 = 255;
pub const DPORT_LINK_DEVICE_SEL_V: u32 = 255;
pub const DPORT_LINK_DEVICE_SEL_S: u32 = 8;
pub const DPORT_PERI_IO_SWAP: u32 = 255;
pub const DPORT_PERI_IO_SWAP_V: u32 = 255;
pub const DPORT_PERI_IO_SWAP_S: u32 = 0;
pub const DPORT_PERIP_CLK_EN_REG: u32 = 1072693440;
pub const DPORT_PERIP_CLK_EN: u32 = 4294967295;
pub const DPORT_PERIP_CLK_EN_V: u32 = 4294967295;
pub const DPORT_PERIP_CLK_EN_S: u32 = 0;
pub const DPORT_PERIP_RST_EN_REG: u32 = 1072693444;
pub const DPORT_PERIP_RST: u32 = 4294967295;
pub const DPORT_PERIP_RST_V: u32 = 4294967295;
pub const DPORT_PERIP_RST_S: u32 = 0;
pub const DPORT_SLAVE_SPI_CONFIG_REG: u32 = 1072693448;
pub const DPORT_SPI_DECRYPT_ENABLE_V: u32 = 1;
pub const DPORT_SPI_DECRYPT_ENABLE_S: u32 = 12;
pub const DPORT_SPI_ENCRYPT_ENABLE_V: u32 = 1;
pub const DPORT_SPI_ENCRYPT_ENABLE_S: u32 = 8;
pub const DPORT_SLAVE_SPI_MASK_APP_V: u32 = 1;
pub const DPORT_SLAVE_SPI_MASK_APP_S: u32 = 4;
pub const DPORT_SLAVE_SPI_MASK_PRO_V: u32 = 1;
pub const DPORT_SLAVE_SPI_MASK_PRO_S: u32 = 0;
pub const DPORT_WIFI_CLK_EN_REG: u32 = 1072693452;
pub const DPORT_WIFI_CLK_EN: u32 = 4294967295;
pub const DPORT_WIFI_CLK_EN_V: u32 = 4294967295;
pub const DPORT_WIFI_CLK_EN_S: u32 = 0;
pub const DPORT_WIFI_CLK_WIFI_EN: u32 = 1030;
pub const DPORT_WIFI_CLK_WIFI_EN_V: u32 = 1030;
pub const DPORT_WIFI_CLK_WIFI_EN_S: u32 = 0;
pub const DPORT_WIFI_CLK_BT_EN: u32 = 97;
pub const DPORT_WIFI_CLK_BT_EN_V: u32 = 97;
pub const DPORT_WIFI_CLK_BT_EN_S: u32 = 11;
pub const DPORT_WIFI_CLK_WIFI_BT_COMMON_M: u32 = 969;
pub const DPORT_CORE_RST_EN_REG: u32 = 1072693456;
pub const DPORT_BT_LPCK_DIV_INT_REG: u32 = 1072693460;
pub const DPORT_BTEXTWAKEUP_REQ_V: u32 = 1;
pub const DPORT_BTEXTWAKEUP_REQ_S: u32 = 12;
pub const DPORT_BT_LPCK_DIV_NUM: u32 = 4095;
pub const DPORT_BT_LPCK_DIV_NUM_V: u32 = 4095;
pub const DPORT_BT_LPCK_DIV_NUM_S: u32 = 0;
pub const DPORT_BT_LPCK_DIV_FRAC_REG: u32 = 1072693464;
pub const DPORT_LPCLK_SEL_XTAL32K_V: u32 = 1;
pub const DPORT_LPCLK_SEL_XTAL32K_S: u32 = 27;
pub const DPORT_LPCLK_SEL_XTAL_V: u32 = 1;
pub const DPORT_LPCLK_SEL_XTAL_S: u32 = 26;
pub const DPORT_LPCLK_SEL_8M_V: u32 = 1;
pub const DPORT_LPCLK_SEL_8M_S: u32 = 25;
pub const DPORT_LPCLK_SEL_RTC_SLOW_V: u32 = 1;
pub const DPORT_LPCLK_SEL_RTC_SLOW_S: u32 = 24;
pub const DPORT_BT_LPCK_DIV_A: u32 = 4095;
pub const DPORT_BT_LPCK_DIV_A_V: u32 = 4095;
pub const DPORT_BT_LPCK_DIV_A_S: u32 = 12;
pub const DPORT_BT_LPCK_DIV_B: u32 = 4095;
pub const DPORT_BT_LPCK_DIV_B_V: u32 = 4095;
pub const DPORT_BT_LPCK_DIV_B_S: u32 = 0;
pub const DPORT_CPU_INTR_FROM_CPU_0_REG: u32 = 1072693468;
pub const DPORT_CPU_INTR_FROM_CPU_0_V: u32 = 1;
pub const DPORT_CPU_INTR_FROM_CPU_0_S: u32 = 0;
pub const DPORT_CPU_INTR_FROM_CPU_1_REG: u32 = 1072693472;
pub const DPORT_CPU_INTR_FROM_CPU_1_V: u32 = 1;
pub const DPORT_CPU_INTR_FROM_CPU_1_S: u32 = 0;
pub const DPORT_CPU_INTR_FROM_CPU_2_REG: u32 = 1072693476;
pub const DPORT_CPU_INTR_FROM_CPU_2_V: u32 = 1;
pub const DPORT_CPU_INTR_FROM_CPU_2_S: u32 = 0;
pub const DPORT_CPU_INTR_FROM_CPU_3_REG: u32 = 1072693480;
pub const DPORT_CPU_INTR_FROM_CPU_3_V: u32 = 1;
pub const DPORT_CPU_INTR_FROM_CPU_3_S: u32 = 0;
pub const DPORT_PRO_INTR_STATUS_0_REG: u32 = 1072693484;
pub const DPORT_PRO_INTR_STATUS_0: u32 = 4294967295;
pub const DPORT_PRO_INTR_STATUS_0_V: u32 = 4294967295;
pub const DPORT_PRO_INTR_STATUS_0_S: u32 = 0;
pub const DPORT_PRO_INTR_STATUS_1_REG: u32 = 1072693488;
pub const DPORT_PRO_INTR_STATUS_1: u32 = 4294967295;
pub const DPORT_PRO_INTR_STATUS_1_V: u32 = 4294967295;
pub const DPORT_PRO_INTR_STATUS_1_S: u32 = 0;
pub const DPORT_PRO_INTR_STATUS_2_REG: u32 = 1072693492;
pub const DPORT_PRO_INTR_STATUS_2: u32 = 4294967295;
pub const DPORT_PRO_INTR_STATUS_2_V: u32 = 4294967295;
pub const DPORT_PRO_INTR_STATUS_2_S: u32 = 0;
pub const DPORT_APP_INTR_STATUS_0_REG: u32 = 1072693496;
pub const DPORT_APP_INTR_STATUS_0: u32 = 4294967295;
pub const DPORT_APP_INTR_STATUS_0_V: u32 = 4294967295;
pub const DPORT_APP_INTR_STATUS_0_S: u32 = 0;
pub const DPORT_APP_INTR_STATUS_1_REG: u32 = 1072693500;
pub const DPORT_APP_INTR_STATUS_1: u32 = 4294967295;
pub const DPORT_APP_INTR_STATUS_1_V: u32 = 4294967295;
pub const DPORT_APP_INTR_STATUS_1_S: u32 = 0;
pub const DPORT_APP_INTR_STATUS_2_REG: u32 = 1072693504;
pub const DPORT_APP_INTR_STATUS_2: u32 = 4294967295;
pub const DPORT_APP_INTR_STATUS_2_V: u32 = 4294967295;
pub const DPORT_APP_INTR_STATUS_2_S: u32 = 0;
pub const DPORT_PRO_MAC_INTR_MAP_REG: u32 = 1072693508;
pub const DPORT_PRO_MAC_INTR_MAP: u32 = 31;
pub const DPORT_PRO_MAC_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_MAC_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_MAC_NMI_MAP_REG: u32 = 1072693512;
pub const DPORT_PRO_MAC_NMI_MAP: u32 = 31;
pub const DPORT_PRO_MAC_NMI_MAP_V: u32 = 31;
pub const DPORT_PRO_MAC_NMI_MAP_S: u32 = 0;
pub const DPORT_PRO_BB_INT_MAP_REG: u32 = 1072693516;
pub const DPORT_PRO_BB_INT_MAP: u32 = 31;
pub const DPORT_PRO_BB_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_BB_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_BT_MAC_INT_MAP_REG: u32 = 1072693520;
pub const DPORT_PRO_BT_MAC_INT_MAP: u32 = 31;
pub const DPORT_PRO_BT_MAC_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_BT_MAC_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_BT_BB_INT_MAP_REG: u32 = 1072693524;
pub const DPORT_PRO_BT_BB_INT_MAP: u32 = 31;
pub const DPORT_PRO_BT_BB_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_BT_BB_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_BT_BB_NMI_MAP_REG: u32 = 1072693528;
pub const DPORT_PRO_BT_BB_NMI_MAP: u32 = 31;
pub const DPORT_PRO_BT_BB_NMI_MAP_V: u32 = 31;
pub const DPORT_PRO_BT_BB_NMI_MAP_S: u32 = 0;
pub const DPORT_PRO_RWBT_IRQ_MAP_REG: u32 = 1072693532;
pub const DPORT_PRO_RWBT_IRQ_MAP: u32 = 31;
pub const DPORT_PRO_RWBT_IRQ_MAP_V: u32 = 31;
pub const DPORT_PRO_RWBT_IRQ_MAP_S: u32 = 0;
pub const DPORT_PRO_RWBLE_IRQ_MAP_REG: u32 = 1072693536;
pub const DPORT_PRO_RWBLE_IRQ_MAP: u32 = 31;
pub const DPORT_PRO_RWBLE_IRQ_MAP_V: u32 = 31;
pub const DPORT_PRO_RWBLE_IRQ_MAP_S: u32 = 0;
pub const DPORT_PRO_RWBT_NMI_MAP_REG: u32 = 1072693540;
pub const DPORT_PRO_RWBT_NMI_MAP: u32 = 31;
pub const DPORT_PRO_RWBT_NMI_MAP_V: u32 = 31;
pub const DPORT_PRO_RWBT_NMI_MAP_S: u32 = 0;
pub const DPORT_PRO_RWBLE_NMI_MAP_REG: u32 = 1072693544;
pub const DPORT_PRO_RWBLE_NMI_MAP: u32 = 31;
pub const DPORT_PRO_RWBLE_NMI_MAP_V: u32 = 31;
pub const DPORT_PRO_RWBLE_NMI_MAP_S: u32 = 0;
pub const DPORT_PRO_SLC0_INTR_MAP_REG: u32 = 1072693548;
pub const DPORT_PRO_SLC0_INTR_MAP: u32 = 31;
pub const DPORT_PRO_SLC0_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_SLC0_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_SLC1_INTR_MAP_REG: u32 = 1072693552;
pub const DPORT_PRO_SLC1_INTR_MAP: u32 = 31;
pub const DPORT_PRO_SLC1_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_SLC1_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_UHCI0_INTR_MAP_REG: u32 = 1072693556;
pub const DPORT_PRO_UHCI0_INTR_MAP: u32 = 31;
pub const DPORT_PRO_UHCI0_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_UHCI0_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_UHCI1_INTR_MAP_REG: u32 = 1072693560;
pub const DPORT_PRO_UHCI1_INTR_MAP: u32 = 31;
pub const DPORT_PRO_UHCI1_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_UHCI1_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_TG_T0_LEVEL_INT_MAP_REG: u32 = 1072693564;
pub const DPORT_PRO_TG_T0_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG_T0_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG_T0_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG_T1_LEVEL_INT_MAP_REG: u32 = 1072693568;
pub const DPORT_PRO_TG_T1_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG_T1_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG_T1_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG_WDT_LEVEL_INT_MAP_REG: u32 = 1072693572;
pub const DPORT_PRO_TG_WDT_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG_WDT_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG_WDT_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG_LACT_LEVEL_INT_MAP_REG: u32 = 1072693576;
pub const DPORT_PRO_TG_LACT_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG_LACT_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG_LACT_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG1_T0_LEVEL_INT_MAP_REG: u32 = 1072693580;
pub const DPORT_PRO_TG1_T0_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG1_T0_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG1_T0_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG1_T1_LEVEL_INT_MAP_REG: u32 = 1072693584;
pub const DPORT_PRO_TG1_T1_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG1_T1_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG1_T1_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG1_WDT_LEVEL_INT_MAP_REG: u32 = 1072693588;
pub const DPORT_PRO_TG1_WDT_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG1_WDT_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG1_WDT_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG1_LACT_LEVEL_INT_MAP_REG: u32 = 1072693592;
pub const DPORT_PRO_TG1_LACT_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG1_LACT_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG1_LACT_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_GPIO_INTERRUPT_MAP_REG: u32 = 1072693596;
pub const DPORT_PRO_GPIO_INTERRUPT_PRO_MAP: u32 = 31;
pub const DPORT_PRO_GPIO_INTERRUPT_PRO_MAP_V: u32 = 31;
pub const DPORT_PRO_GPIO_INTERRUPT_PRO_MAP_S: u32 = 0;
pub const DPORT_PRO_GPIO_INTERRUPT_NMI_MAP_REG: u32 = 1072693600;
pub const DPORT_PRO_GPIO_INTERRUPT_PRO_NMI_MAP: u32 = 31;
pub const DPORT_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_V: u32 = 31;
pub const DPORT_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_S: u32 = 0;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_0_MAP_REG: u32 = 1072693604;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_0_MAP: u32 = 31;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_0_MAP_V: u32 = 31;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_0_MAP_S: u32 = 0;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_1_MAP_REG: u32 = 1072693608;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_1_MAP: u32 = 31;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_1_MAP_V: u32 = 31;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_1_MAP_S: u32 = 0;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_2_MAP_REG: u32 = 1072693612;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_2_MAP: u32 = 31;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_2_MAP_V: u32 = 31;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_2_MAP_S: u32 = 0;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_3_MAP_REG: u32 = 1072693616;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_3_MAP: u32 = 31;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_3_MAP_V: u32 = 31;
pub const DPORT_PRO_CPU_INTR_FROM_CPU_3_MAP_S: u32 = 0;
pub const DPORT_PRO_SPI_INTR_0_MAP_REG: u32 = 1072693620;
pub const DPORT_PRO_SPI_INTR_0_MAP: u32 = 31;
pub const DPORT_PRO_SPI_INTR_0_MAP_V: u32 = 31;
pub const DPORT_PRO_SPI_INTR_0_MAP_S: u32 = 0;
pub const DPORT_PRO_SPI_INTR_1_MAP_REG: u32 = 1072693624;
pub const DPORT_PRO_SPI_INTR_1_MAP: u32 = 31;
pub const DPORT_PRO_SPI_INTR_1_MAP_V: u32 = 31;
pub const DPORT_PRO_SPI_INTR_1_MAP_S: u32 = 0;
pub const DPORT_PRO_SPI_INTR_2_MAP_REG: u32 = 1072693628;
pub const DPORT_PRO_SPI_INTR_2_MAP: u32 = 31;
pub const DPORT_PRO_SPI_INTR_2_MAP_V: u32 = 31;
pub const DPORT_PRO_SPI_INTR_2_MAP_S: u32 = 0;
pub const DPORT_PRO_SPI_INTR_3_MAP_REG: u32 = 1072693632;
pub const DPORT_PRO_SPI_INTR_3_MAP: u32 = 31;
pub const DPORT_PRO_SPI_INTR_3_MAP_V: u32 = 31;
pub const DPORT_PRO_SPI_INTR_3_MAP_S: u32 = 0;
pub const DPORT_PRO_I2S0_INT_MAP_REG: u32 = 1072693636;
pub const DPORT_PRO_I2S0_INT_MAP: u32 = 31;
pub const DPORT_PRO_I2S0_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_I2S0_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_I2S1_INT_MAP_REG: u32 = 1072693640;
pub const DPORT_PRO_I2S1_INT_MAP: u32 = 31;
pub const DPORT_PRO_I2S1_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_I2S1_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_UART_INTR_MAP_REG: u32 = 1072693644;
pub const DPORT_PRO_UART_INTR_MAP: u32 = 31;
pub const DPORT_PRO_UART_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_UART_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_UART1_INTR_MAP_REG: u32 = 1072693648;
pub const DPORT_PRO_UART1_INTR_MAP: u32 = 31;
pub const DPORT_PRO_UART1_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_UART1_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_UART2_INTR_MAP_REG: u32 = 1072693652;
pub const DPORT_PRO_UART2_INTR_MAP: u32 = 31;
pub const DPORT_PRO_UART2_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_UART2_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_SDIO_HOST_INTERRUPT_MAP_REG: u32 = 1072693656;
pub const DPORT_PRO_SDIO_HOST_INTERRUPT_MAP: u32 = 31;
pub const DPORT_PRO_SDIO_HOST_INTERRUPT_MAP_V: u32 = 31;
pub const DPORT_PRO_SDIO_HOST_INTERRUPT_MAP_S: u32 = 0;
pub const DPORT_PRO_EMAC_INT_MAP_REG: u32 = 1072693660;
pub const DPORT_PRO_EMAC_INT_MAP: u32 = 31;
pub const DPORT_PRO_EMAC_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_EMAC_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_PWM0_INTR_MAP_REG: u32 = 1072693664;
pub const DPORT_PRO_PWM0_INTR_MAP: u32 = 31;
pub const DPORT_PRO_PWM0_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_PWM0_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_PWM1_INTR_MAP_REG: u32 = 1072693668;
pub const DPORT_PRO_PWM1_INTR_MAP: u32 = 31;
pub const DPORT_PRO_PWM1_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_PWM1_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_PWM2_INTR_MAP_REG: u32 = 1072693672;
pub const DPORT_PRO_PWM2_INTR_MAP: u32 = 31;
pub const DPORT_PRO_PWM2_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_PWM2_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_PWM3_INTR_MAP_REG: u32 = 1072693676;
pub const DPORT_PRO_PWM3_INTR_MAP: u32 = 31;
pub const DPORT_PRO_PWM3_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_PWM3_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_LEDC_INT_MAP_REG: u32 = 1072693680;
pub const DPORT_PRO_LEDC_INT_MAP: u32 = 31;
pub const DPORT_PRO_LEDC_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_LEDC_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_EFUSE_INT_MAP_REG: u32 = 1072693684;
pub const DPORT_PRO_EFUSE_INT_MAP: u32 = 31;
pub const DPORT_PRO_EFUSE_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_EFUSE_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_CAN_INT_MAP_REG: u32 = 1072693688;
pub const DPORT_PRO_CAN_INT_MAP: u32 = 31;
pub const DPORT_PRO_CAN_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_CAN_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_RTC_CORE_INTR_MAP_REG: u32 = 1072693692;
pub const DPORT_PRO_RTC_CORE_INTR_MAP: u32 = 31;
pub const DPORT_PRO_RTC_CORE_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_RTC_CORE_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_RMT_INTR_MAP_REG: u32 = 1072693696;
pub const DPORT_PRO_RMT_INTR_MAP: u32 = 31;
pub const DPORT_PRO_RMT_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_RMT_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_PCNT_INTR_MAP_REG: u32 = 1072693700;
pub const DPORT_PRO_PCNT_INTR_MAP: u32 = 31;
pub const DPORT_PRO_PCNT_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_PCNT_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_I2C_EXT0_INTR_MAP_REG: u32 = 1072693704;
pub const DPORT_PRO_I2C_EXT0_INTR_MAP: u32 = 31;
pub const DPORT_PRO_I2C_EXT0_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_I2C_EXT0_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_I2C_EXT1_INTR_MAP_REG: u32 = 1072693708;
pub const DPORT_PRO_I2C_EXT1_INTR_MAP: u32 = 31;
pub const DPORT_PRO_I2C_EXT1_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_I2C_EXT1_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_RSA_INTR_MAP_REG: u32 = 1072693712;
pub const DPORT_PRO_RSA_INTR_MAP: u32 = 31;
pub const DPORT_PRO_RSA_INTR_MAP_V: u32 = 31;
pub const DPORT_PRO_RSA_INTR_MAP_S: u32 = 0;
pub const DPORT_PRO_SPI1_DMA_INT_MAP_REG: u32 = 1072693716;
pub const DPORT_PRO_SPI1_DMA_INT_MAP: u32 = 31;
pub const DPORT_PRO_SPI1_DMA_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_SPI1_DMA_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_SPI2_DMA_INT_MAP_REG: u32 = 1072693720;
pub const DPORT_PRO_SPI2_DMA_INT_MAP: u32 = 31;
pub const DPORT_PRO_SPI2_DMA_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_SPI2_DMA_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_SPI3_DMA_INT_MAP_REG: u32 = 1072693724;
pub const DPORT_PRO_SPI3_DMA_INT_MAP: u32 = 31;
pub const DPORT_PRO_SPI3_DMA_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_SPI3_DMA_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_WDG_INT_MAP_REG: u32 = 1072693728;
pub const DPORT_PRO_WDG_INT_MAP: u32 = 31;
pub const DPORT_PRO_WDG_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_WDG_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TIMER_INT1_MAP_REG: u32 = 1072693732;
pub const DPORT_PRO_TIMER_INT1_MAP: u32 = 31;
pub const DPORT_PRO_TIMER_INT1_MAP_V: u32 = 31;
pub const DPORT_PRO_TIMER_INT1_MAP_S: u32 = 0;
pub const DPORT_PRO_TIMER_INT2_MAP_REG: u32 = 1072693736;
pub const DPORT_PRO_TIMER_INT2_MAP: u32 = 31;
pub const DPORT_PRO_TIMER_INT2_MAP_V: u32 = 31;
pub const DPORT_PRO_TIMER_INT2_MAP_S: u32 = 0;
pub const DPORT_PRO_TG_T0_EDGE_INT_MAP_REG: u32 = 1072693740;
pub const DPORT_PRO_TG_T0_EDGE_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG_T0_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG_T0_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG_T1_EDGE_INT_MAP_REG: u32 = 1072693744;
pub const DPORT_PRO_TG_T1_EDGE_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG_T1_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG_T1_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG_WDT_EDGE_INT_MAP_REG: u32 = 1072693748;
pub const DPORT_PRO_TG_WDT_EDGE_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG_WDT_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG_WDT_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG_LACT_EDGE_INT_MAP_REG: u32 = 1072693752;
pub const DPORT_PRO_TG_LACT_EDGE_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG_LACT_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG_LACT_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG1_T0_EDGE_INT_MAP_REG: u32 = 1072693756;
pub const DPORT_PRO_TG1_T0_EDGE_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG1_T0_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG1_T0_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG1_T1_EDGE_INT_MAP_REG: u32 = 1072693760;
pub const DPORT_PRO_TG1_T1_EDGE_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG1_T1_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG1_T1_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG1_WDT_EDGE_INT_MAP_REG: u32 = 1072693764;
pub const DPORT_PRO_TG1_WDT_EDGE_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG1_WDT_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG1_WDT_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_TG1_LACT_EDGE_INT_MAP_REG: u32 = 1072693768;
pub const DPORT_PRO_TG1_LACT_EDGE_INT_MAP: u32 = 31;
pub const DPORT_PRO_TG1_LACT_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_TG1_LACT_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_MMU_IA_INT_MAP_REG: u32 = 1072693772;
pub const DPORT_PRO_MMU_IA_INT_MAP: u32 = 31;
pub const DPORT_PRO_MMU_IA_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_MMU_IA_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_MPU_IA_INT_MAP_REG: u32 = 1072693776;
pub const DPORT_PRO_MPU_IA_INT_MAP: u32 = 31;
pub const DPORT_PRO_MPU_IA_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_MPU_IA_INT_MAP_S: u32 = 0;
pub const DPORT_PRO_CACHE_IA_INT_MAP_REG: u32 = 1072693780;
pub const DPORT_PRO_CACHE_IA_INT_MAP: u32 = 31;
pub const DPORT_PRO_CACHE_IA_INT_MAP_V: u32 = 31;
pub const DPORT_PRO_CACHE_IA_INT_MAP_S: u32 = 0;
pub const DPORT_APP_MAC_INTR_MAP_REG: u32 = 1072693784;
pub const DPORT_APP_MAC_INTR_MAP: u32 = 31;
pub const DPORT_APP_MAC_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_MAC_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_MAC_NMI_MAP_REG: u32 = 1072693788;
pub const DPORT_APP_MAC_NMI_MAP: u32 = 31;
pub const DPORT_APP_MAC_NMI_MAP_V: u32 = 31;
pub const DPORT_APP_MAC_NMI_MAP_S: u32 = 0;
pub const DPORT_APP_BB_INT_MAP_REG: u32 = 1072693792;
pub const DPORT_APP_BB_INT_MAP: u32 = 31;
pub const DPORT_APP_BB_INT_MAP_V: u32 = 31;
pub const DPORT_APP_BB_INT_MAP_S: u32 = 0;
pub const DPORT_APP_BT_MAC_INT_MAP_REG: u32 = 1072693796;
pub const DPORT_APP_BT_MAC_INT_MAP: u32 = 31;
pub const DPORT_APP_BT_MAC_INT_MAP_V: u32 = 31;
pub const DPORT_APP_BT_MAC_INT_MAP_S: u32 = 0;
pub const DPORT_APP_BT_BB_INT_MAP_REG: u32 = 1072693800;
pub const DPORT_APP_BT_BB_INT_MAP: u32 = 31;
pub const DPORT_APP_BT_BB_INT_MAP_V: u32 = 31;
pub const DPORT_APP_BT_BB_INT_MAP_S: u32 = 0;
pub const DPORT_APP_BT_BB_NMI_MAP_REG: u32 = 1072693804;
pub const DPORT_APP_BT_BB_NMI_MAP: u32 = 31;
pub const DPORT_APP_BT_BB_NMI_MAP_V: u32 = 31;
pub const DPORT_APP_BT_BB_NMI_MAP_S: u32 = 0;
pub const DPORT_APP_RWBT_IRQ_MAP_REG: u32 = 1072693808;
pub const DPORT_APP_RWBT_IRQ_MAP: u32 = 31;
pub const DPORT_APP_RWBT_IRQ_MAP_V: u32 = 31;
pub const DPORT_APP_RWBT_IRQ_MAP_S: u32 = 0;
pub const DPORT_APP_RWBLE_IRQ_MAP_REG: u32 = 1072693812;
pub const DPORT_APP_RWBLE_IRQ_MAP: u32 = 31;
pub const DPORT_APP_RWBLE_IRQ_MAP_V: u32 = 31;
pub const DPORT_APP_RWBLE_IRQ_MAP_S: u32 = 0;
pub const DPORT_APP_RWBT_NMI_MAP_REG: u32 = 1072693816;
pub const DPORT_APP_RWBT_NMI_MAP: u32 = 31;
pub const DPORT_APP_RWBT_NMI_MAP_V: u32 = 31;
pub const DPORT_APP_RWBT_NMI_MAP_S: u32 = 0;
pub const DPORT_APP_RWBLE_NMI_MAP_REG: u32 = 1072693820;
pub const DPORT_APP_RWBLE_NMI_MAP: u32 = 31;
pub const DPORT_APP_RWBLE_NMI_MAP_V: u32 = 31;
pub const DPORT_APP_RWBLE_NMI_MAP_S: u32 = 0;
pub const DPORT_APP_SLC0_INTR_MAP_REG: u32 = 1072693824;
pub const DPORT_APP_SLC0_INTR_MAP: u32 = 31;
pub const DPORT_APP_SLC0_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_SLC0_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_SLC1_INTR_MAP_REG: u32 = 1072693828;
pub const DPORT_APP_SLC1_INTR_MAP: u32 = 31;
pub const DPORT_APP_SLC1_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_SLC1_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_UHCI0_INTR_MAP_REG: u32 = 1072693832;
pub const DPORT_APP_UHCI0_INTR_MAP: u32 = 31;
pub const DPORT_APP_UHCI0_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_UHCI0_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_UHCI1_INTR_MAP_REG: u32 = 1072693836;
pub const DPORT_APP_UHCI1_INTR_MAP: u32 = 31;
pub const DPORT_APP_UHCI1_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_UHCI1_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_TG_T0_LEVEL_INT_MAP_REG: u32 = 1072693840;
pub const DPORT_APP_TG_T0_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_APP_TG_T0_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG_T0_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG_T1_LEVEL_INT_MAP_REG: u32 = 1072693844;
pub const DPORT_APP_TG_T1_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_APP_TG_T1_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG_T1_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG_WDT_LEVEL_INT_MAP_REG: u32 = 1072693848;
pub const DPORT_APP_TG_WDT_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_APP_TG_WDT_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG_WDT_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG_LACT_LEVEL_INT_MAP_REG: u32 = 1072693852;
pub const DPORT_APP_TG_LACT_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_APP_TG_LACT_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG_LACT_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG1_T0_LEVEL_INT_MAP_REG: u32 = 1072693856;
pub const DPORT_APP_TG1_T0_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_APP_TG1_T0_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG1_T0_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG1_T1_LEVEL_INT_MAP_REG: u32 = 1072693860;
pub const DPORT_APP_TG1_T1_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_APP_TG1_T1_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG1_T1_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG1_WDT_LEVEL_INT_MAP_REG: u32 = 1072693864;
pub const DPORT_APP_TG1_WDT_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_APP_TG1_WDT_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG1_WDT_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG1_LACT_LEVEL_INT_MAP_REG: u32 = 1072693868;
pub const DPORT_APP_TG1_LACT_LEVEL_INT_MAP: u32 = 31;
pub const DPORT_APP_TG1_LACT_LEVEL_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG1_LACT_LEVEL_INT_MAP_S: u32 = 0;
pub const DPORT_APP_GPIO_INTERRUPT_MAP_REG: u32 = 1072693872;
pub const DPORT_APP_GPIO_INTERRUPT_APP_MAP: u32 = 31;
pub const DPORT_APP_GPIO_INTERRUPT_APP_MAP_V: u32 = 31;
pub const DPORT_APP_GPIO_INTERRUPT_APP_MAP_S: u32 = 0;
pub const DPORT_APP_GPIO_INTERRUPT_NMI_MAP_REG: u32 = 1072693876;
pub const DPORT_APP_GPIO_INTERRUPT_APP_NMI_MAP: u32 = 31;
pub const DPORT_APP_GPIO_INTERRUPT_APP_NMI_MAP_V: u32 = 31;
pub const DPORT_APP_GPIO_INTERRUPT_APP_NMI_MAP_S: u32 = 0;
pub const DPORT_APP_CPU_INTR_FROM_CPU_0_MAP_REG: u32 = 1072693880;
pub const DPORT_APP_CPU_INTR_FROM_CPU_0_MAP: u32 = 31;
pub const DPORT_APP_CPU_INTR_FROM_CPU_0_MAP_V: u32 = 31;
pub const DPORT_APP_CPU_INTR_FROM_CPU_0_MAP_S: u32 = 0;
pub const DPORT_APP_CPU_INTR_FROM_CPU_1_MAP_REG: u32 = 1072693884;
pub const DPORT_APP_CPU_INTR_FROM_CPU_1_MAP: u32 = 31;
pub const DPORT_APP_CPU_INTR_FROM_CPU_1_MAP_V: u32 = 31;
pub const DPORT_APP_CPU_INTR_FROM_CPU_1_MAP_S: u32 = 0;
pub const DPORT_APP_CPU_INTR_FROM_CPU_2_MAP_REG: u32 = 1072693888;
pub const DPORT_APP_CPU_INTR_FROM_CPU_2_MAP: u32 = 31;
pub const DPORT_APP_CPU_INTR_FROM_CPU_2_MAP_V: u32 = 31;
pub const DPORT_APP_CPU_INTR_FROM_CPU_2_MAP_S: u32 = 0;
pub const DPORT_APP_CPU_INTR_FROM_CPU_3_MAP_REG: u32 = 1072693892;
pub const DPORT_APP_CPU_INTR_FROM_CPU_3_MAP: u32 = 31;
pub const DPORT_APP_CPU_INTR_FROM_CPU_3_MAP_V: u32 = 31;
pub const DPORT_APP_CPU_INTR_FROM_CPU_3_MAP_S: u32 = 0;
pub const DPORT_APP_SPI_INTR_0_MAP_REG: u32 = 1072693896;
pub const DPORT_APP_SPI_INTR_0_MAP: u32 = 31;
pub const DPORT_APP_SPI_INTR_0_MAP_V: u32 = 31;
pub const DPORT_APP_SPI_INTR_0_MAP_S: u32 = 0;
pub const DPORT_APP_SPI_INTR_1_MAP_REG: u32 = 1072693900;
pub const DPORT_APP_SPI_INTR_1_MAP: u32 = 31;
pub const DPORT_APP_SPI_INTR_1_MAP_V: u32 = 31;
pub const DPORT_APP_SPI_INTR_1_MAP_S: u32 = 0;
pub const DPORT_APP_SPI_INTR_2_MAP_REG: u32 = 1072693904;
pub const DPORT_APP_SPI_INTR_2_MAP: u32 = 31;
pub const DPORT_APP_SPI_INTR_2_MAP_V: u32 = 31;
pub const DPORT_APP_SPI_INTR_2_MAP_S: u32 = 0;
pub const DPORT_APP_SPI_INTR_3_MAP_REG: u32 = 1072693908;
pub const DPORT_APP_SPI_INTR_3_MAP: u32 = 31;
pub const DPORT_APP_SPI_INTR_3_MAP_V: u32 = 31;
pub const DPORT_APP_SPI_INTR_3_MAP_S: u32 = 0;
pub const DPORT_APP_I2S0_INT_MAP_REG: u32 = 1072693912;
pub const DPORT_APP_I2S0_INT_MAP: u32 = 31;
pub const DPORT_APP_I2S0_INT_MAP_V: u32 = 31;
pub const DPORT_APP_I2S0_INT_MAP_S: u32 = 0;
pub const DPORT_APP_I2S1_INT_MAP_REG: u32 = 1072693916;
pub const DPORT_APP_I2S1_INT_MAP: u32 = 31;
pub const DPORT_APP_I2S1_INT_MAP_V: u32 = 31;
pub const DPORT_APP_I2S1_INT_MAP_S: u32 = 0;
pub const DPORT_APP_UART_INTR_MAP_REG: u32 = 1072693920;
pub const DPORT_APP_UART_INTR_MAP: u32 = 31;
pub const DPORT_APP_UART_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_UART_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_UART1_INTR_MAP_REG: u32 = 1072693924;
pub const DPORT_APP_UART1_INTR_MAP: u32 = 31;
pub const DPORT_APP_UART1_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_UART1_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_UART2_INTR_MAP_REG: u32 = 1072693928;
pub const DPORT_APP_UART2_INTR_MAP: u32 = 31;
pub const DPORT_APP_UART2_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_UART2_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_SDIO_HOST_INTERRUPT_MAP_REG: u32 = 1072693932;
pub const DPORT_APP_SDIO_HOST_INTERRUPT_MAP: u32 = 31;
pub const DPORT_APP_SDIO_HOST_INTERRUPT_MAP_V: u32 = 31;
pub const DPORT_APP_SDIO_HOST_INTERRUPT_MAP_S: u32 = 0;
pub const DPORT_APP_EMAC_INT_MAP_REG: u32 = 1072693936;
pub const DPORT_APP_EMAC_INT_MAP: u32 = 31;
pub const DPORT_APP_EMAC_INT_MAP_V: u32 = 31;
pub const DPORT_APP_EMAC_INT_MAP_S: u32 = 0;
pub const DPORT_APP_PWM0_INTR_MAP_REG: u32 = 1072693940;
pub const DPORT_APP_PWM0_INTR_MAP: u32 = 31;
pub const DPORT_APP_PWM0_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_PWM0_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_PWM1_INTR_MAP_REG: u32 = 1072693944;
pub const DPORT_APP_PWM1_INTR_MAP: u32 = 31;
pub const DPORT_APP_PWM1_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_PWM1_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_PWM2_INTR_MAP_REG: u32 = 1072693948;
pub const DPORT_APP_PWM2_INTR_MAP: u32 = 31;
pub const DPORT_APP_PWM2_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_PWM2_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_PWM3_INTR_MAP_REG: u32 = 1072693952;
pub const DPORT_APP_PWM3_INTR_MAP: u32 = 31;
pub const DPORT_APP_PWM3_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_PWM3_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_LEDC_INT_MAP_REG: u32 = 1072693956;
pub const DPORT_APP_LEDC_INT_MAP: u32 = 31;
pub const DPORT_APP_LEDC_INT_MAP_V: u32 = 31;
pub const DPORT_APP_LEDC_INT_MAP_S: u32 = 0;
pub const DPORT_APP_EFUSE_INT_MAP_REG: u32 = 1072693960;
pub const DPORT_APP_EFUSE_INT_MAP: u32 = 31;
pub const DPORT_APP_EFUSE_INT_MAP_V: u32 = 31;
pub const DPORT_APP_EFUSE_INT_MAP_S: u32 = 0;
pub const DPORT_APP_CAN_INT_MAP_REG: u32 = 1072693964;
pub const DPORT_APP_CAN_INT_MAP: u32 = 31;
pub const DPORT_APP_CAN_INT_MAP_V: u32 = 31;
pub const DPORT_APP_CAN_INT_MAP_S: u32 = 0;
pub const DPORT_APP_RTC_CORE_INTR_MAP_REG: u32 = 1072693968;
pub const DPORT_APP_RTC_CORE_INTR_MAP: u32 = 31;
pub const DPORT_APP_RTC_CORE_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_RTC_CORE_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_RMT_INTR_MAP_REG: u32 = 1072693972;
pub const DPORT_APP_RMT_INTR_MAP: u32 = 31;
pub const DPORT_APP_RMT_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_RMT_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_PCNT_INTR_MAP_REG: u32 = 1072693976;
pub const DPORT_APP_PCNT_INTR_MAP: u32 = 31;
pub const DPORT_APP_PCNT_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_PCNT_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_I2C_EXT0_INTR_MAP_REG: u32 = 1072693980;
pub const DPORT_APP_I2C_EXT0_INTR_MAP: u32 = 31;
pub const DPORT_APP_I2C_EXT0_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_I2C_EXT0_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_I2C_EXT1_INTR_MAP_REG: u32 = 1072693984;
pub const DPORT_APP_I2C_EXT1_INTR_MAP: u32 = 31;
pub const DPORT_APP_I2C_EXT1_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_I2C_EXT1_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_RSA_INTR_MAP_REG: u32 = 1072693988;
pub const DPORT_APP_RSA_INTR_MAP: u32 = 31;
pub const DPORT_APP_RSA_INTR_MAP_V: u32 = 31;
pub const DPORT_APP_RSA_INTR_MAP_S: u32 = 0;
pub const DPORT_APP_SPI1_DMA_INT_MAP_REG: u32 = 1072693992;
pub const DPORT_APP_SPI1_DMA_INT_MAP: u32 = 31;
pub const DPORT_APP_SPI1_DMA_INT_MAP_V: u32 = 31;
pub const DPORT_APP_SPI1_DMA_INT_MAP_S: u32 = 0;
pub const DPORT_APP_SPI2_DMA_INT_MAP_REG: u32 = 1072693996;
pub const DPORT_APP_SPI2_DMA_INT_MAP: u32 = 31;
pub const DPORT_APP_SPI2_DMA_INT_MAP_V: u32 = 31;
pub const DPORT_APP_SPI2_DMA_INT_MAP_S: u32 = 0;
pub const DPORT_APP_SPI3_DMA_INT_MAP_REG: u32 = 1072694000;
pub const DPORT_APP_SPI3_DMA_INT_MAP: u32 = 31;
pub const DPORT_APP_SPI3_DMA_INT_MAP_V: u32 = 31;
pub const DPORT_APP_SPI3_DMA_INT_MAP_S: u32 = 0;
pub const DPORT_APP_WDG_INT_MAP_REG: u32 = 1072694004;
pub const DPORT_APP_WDG_INT_MAP: u32 = 31;
pub const DPORT_APP_WDG_INT_MAP_V: u32 = 31;
pub const DPORT_APP_WDG_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TIMER_INT1_MAP_REG: u32 = 1072694008;
pub const DPORT_APP_TIMER_INT1_MAP: u32 = 31;
pub const DPORT_APP_TIMER_INT1_MAP_V: u32 = 31;
pub const DPORT_APP_TIMER_INT1_MAP_S: u32 = 0;
pub const DPORT_APP_TIMER_INT2_MAP_REG: u32 = 1072694012;
pub const DPORT_APP_TIMER_INT2_MAP: u32 = 31;
pub const DPORT_APP_TIMER_INT2_MAP_V: u32 = 31;
pub const DPORT_APP_TIMER_INT2_MAP_S: u32 = 0;
pub const DPORT_APP_TG_T0_EDGE_INT_MAP_REG: u32 = 1072694016;
pub const DPORT_APP_TG_T0_EDGE_INT_MAP: u32 = 31;
pub const DPORT_APP_TG_T0_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG_T0_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG_T1_EDGE_INT_MAP_REG: u32 = 1072694020;
pub const DPORT_APP_TG_T1_EDGE_INT_MAP: u32 = 31;
pub const DPORT_APP_TG_T1_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG_T1_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG_WDT_EDGE_INT_MAP_REG: u32 = 1072694024;
pub const DPORT_APP_TG_WDT_EDGE_INT_MAP: u32 = 31;
pub const DPORT_APP_TG_WDT_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG_WDT_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG_LACT_EDGE_INT_MAP_REG: u32 = 1072694028;
pub const DPORT_APP_TG_LACT_EDGE_INT_MAP: u32 = 31;
pub const DPORT_APP_TG_LACT_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG_LACT_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG1_T0_EDGE_INT_MAP_REG: u32 = 1072694032;
pub const DPORT_APP_TG1_T0_EDGE_INT_MAP: u32 = 31;
pub const DPORT_APP_TG1_T0_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG1_T0_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG1_T1_EDGE_INT_MAP_REG: u32 = 1072694036;
pub const DPORT_APP_TG1_T1_EDGE_INT_MAP: u32 = 31;
pub const DPORT_APP_TG1_T1_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG1_T1_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG1_WDT_EDGE_INT_MAP_REG: u32 = 1072694040;
pub const DPORT_APP_TG1_WDT_EDGE_INT_MAP: u32 = 31;
pub const DPORT_APP_TG1_WDT_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG1_WDT_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_APP_TG1_LACT_EDGE_INT_MAP_REG: u32 = 1072694044;
pub const DPORT_APP_TG1_LACT_EDGE_INT_MAP: u32 = 31;
pub const DPORT_APP_TG1_LACT_EDGE_INT_MAP_V: u32 = 31;
pub const DPORT_APP_TG1_LACT_EDGE_INT_MAP_S: u32 = 0;
pub const DPORT_APP_MMU_IA_INT_MAP_REG: u32 = 1072694048;
pub const DPORT_APP_MMU_IA_INT_MAP: u32 = 31;
pub const DPORT_APP_MMU_IA_INT_MAP_V: u32 = 31;
pub const DPORT_APP_MMU_IA_INT_MAP_S: u32 = 0;
pub const DPORT_APP_MPU_IA_INT_MAP_REG: u32 = 1072694052;
pub const DPORT_APP_MPU_IA_INT_MAP: u32 = 31;
pub const DPORT_APP_MPU_IA_INT_MAP_V: u32 = 31;
pub const DPORT_APP_MPU_IA_INT_MAP_S: u32 = 0;
pub const DPORT_APP_CACHE_IA_INT_MAP_REG: u32 = 1072694056;
pub const DPORT_APP_CACHE_IA_INT_MAP: u32 = 31;
pub const DPORT_APP_CACHE_IA_INT_MAP_V: u32 = 31;
pub const DPORT_APP_CACHE_IA_INT_MAP_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_UART_REG: u32 = 1072694060;
pub const DPORT_UART_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_UART_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_UART_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_SPI1_REG: u32 = 1072694064;
pub const DPORT_SPI1_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_SPI1_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_SPI1_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_SPI0_REG: u32 = 1072694068;
pub const DPORT_SPI0_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_SPI0_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_SPI0_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_GPIO_REG: u32 = 1072694072;
pub const DPORT_GPIO_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_GPIO_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_GPIO_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_FE2_REG: u32 = 1072694076;
pub const DPORT_FE2_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_FE2_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_FE2_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_FE_REG: u32 = 1072694080;
pub const DPORT_FE_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_FE_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_FE_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_TIMER_REG: u32 = 1072694084;
pub const DPORT_TIMER_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_TIMER_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_TIMER_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_RTC_REG: u32 = 1072694088;
pub const DPORT_RTC_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_RTC_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_RTC_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_IO_MUX_REG: u32 = 1072694092;
pub const DPORT_IOMUX_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_IOMUX_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_IOMUX_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_WDG_REG: u32 = 1072694096;
pub const DPORT_WDG_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_WDG_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_WDG_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_HINF_REG: u32 = 1072694100;
pub const DPORT_HINF_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_HINF_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_HINF_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_UHCI1_REG: u32 = 1072694104;
pub const DPORT_UHCI1_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_UHCI1_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_UHCI1_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_MISC_REG: u32 = 1072694108;
pub const DPORT_MISC_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_MISC_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_MISC_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_I2C_REG: u32 = 1072694112;
pub const DPORT_I2C_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_I2C_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_I2C_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_I2S0_REG: u32 = 1072694116;
pub const DPORT_I2S0_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_I2S0_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_I2S0_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_UART1_REG: u32 = 1072694120;
pub const DPORT_UART1_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_UART1_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_UART1_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_BT_REG: u32 = 1072694124;
pub const DPORT_BT_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_BT_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_BT_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_BT_BUFFER_REG: u32 = 1072694128;
pub const DPORT_BTBUFFER_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_BTBUFFER_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_BTBUFFER_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_I2C_EXT0_REG: u32 = 1072694132;
pub const DPORT_I2CEXT0_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_I2CEXT0_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_I2CEXT0_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_UHCI0_REG: u32 = 1072694136;
pub const DPORT_UHCI0_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_UHCI0_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_UHCI0_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_SLCHOST_REG: u32 = 1072694140;
pub const DPORT_SLCHOST_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_SLCHOST_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_SLCHOST_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_RMT_REG: u32 = 1072694144;
pub const DPORT_RMT_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_RMT_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_RMT_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_PCNT_REG: u32 = 1072694148;
pub const DPORT_PCNT_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_PCNT_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_PCNT_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_SLC_REG: u32 = 1072694152;
pub const DPORT_SLC_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_SLC_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_SLC_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_LEDC_REG: u32 = 1072694156;
pub const DPORT_LEDC_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_LEDC_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_LEDC_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_EFUSE_REG: u32 = 1072694160;
pub const DPORT_EFUSE_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_EFUSE_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_EFUSE_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_SPI_ENCRYPT_REG: u32 = 1072694164;
pub const DPORT_SPI_ENCRYPY_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_SPI_ENCRYPY_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_SPI_ENCRYPY_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_BB_REG: u32 = 1072694168;
pub const DPORT_BB_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_BB_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_BB_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_PWM0_REG: u32 = 1072694172;
pub const DPORT_PWM0_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_PWM0_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_PWM0_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_TIMERGROUP_REG: u32 = 1072694176;
pub const DPORT_TIMERGROUP_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_TIMERGROUP_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_TIMERGROUP_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_TIMERGROUP1_REG: u32 = 1072694180;
pub const DPORT_TIMERGROUP1_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_TIMERGROUP1_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_TIMERGROUP1_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_SPI2_REG: u32 = 1072694184;
pub const DPORT_SPI2_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_SPI2_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_SPI2_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_SPI3_REG: u32 = 1072694188;
pub const DPORT_SPI3_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_SPI3_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_SPI3_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_APB_CTRL_REG: u32 = 1072694192;
pub const DPORT_APBCTRL_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_APBCTRL_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_APBCTRL_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_I2C_EXT1_REG: u32 = 1072694196;
pub const DPORT_I2CEXT1_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_I2CEXT1_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_I2CEXT1_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_SDIO_HOST_REG: u32 = 1072694200;
pub const DPORT_SDIOHOST_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_SDIOHOST_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_SDIOHOST_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_EMAC_REG: u32 = 1072694204;
pub const DPORT_EMAC_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_EMAC_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_EMAC_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_CAN_REG: u32 = 1072694208;
pub const DPORT_CAN_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_CAN_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_CAN_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_PWM1_REG: u32 = 1072694212;
pub const DPORT_PWM1_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_PWM1_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_PWM1_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_I2S1_REG: u32 = 1072694216;
pub const DPORT_I2S1_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_I2S1_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_I2S1_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_UART2_REG: u32 = 1072694220;
pub const DPORT_UART2_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_UART2_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_UART2_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_PWM2_REG: u32 = 1072694224;
pub const DPORT_PWM2_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_PWM2_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_PWM2_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_PWM3_REG: u32 = 1072694228;
pub const DPORT_PWM3_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_PWM3_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_PWM3_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_RWBT_REG: u32 = 1072694232;
pub const DPORT_RWBT_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_RWBT_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_RWBT_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_BTMAC_REG: u32 = 1072694236;
pub const DPORT_BTMAC_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_BTMAC_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_BTMAC_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_WIFIMAC_REG: u32 = 1072694240;
pub const DPORT_WIFIMAC_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_WIFIMAC_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_WIFIMAC_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_AHBLITE_MPU_TABLE_PWR_REG: u32 = 1072694244;
pub const DPORT_PWR_ACCESS_GRANT_CONFIG: u32 = 63;
pub const DPORT_PWR_ACCESS_GRANT_CONFIG_V: u32 = 63;
pub const DPORT_PWR_ACCESS_GRANT_CONFIG_S: u32 = 0;
pub const DPORT_MEM_ACCESS_DBUG0_REG: u32 = 1072694248;
pub const DPORT_INTERNAL_SRAM_MMU_MULTI_HIT: u32 = 15;
pub const DPORT_INTERNAL_SRAM_MMU_MULTI_HIT_V: u32 = 15;
pub const DPORT_INTERNAL_SRAM_MMU_MULTI_HIT_S: u32 = 26;
pub const DPORT_INTERNAL_SRAM_IA: u32 = 4095;
pub const DPORT_INTERNAL_SRAM_IA_V: u32 = 4095;
pub const DPORT_INTERNAL_SRAM_IA_S: u32 = 14;
pub const DPORT_INTERNAL_SRAM_MMU_AD: u32 = 15;
pub const DPORT_INTERNAL_SRAM_MMU_AD_V: u32 = 15;
pub const DPORT_INTERNAL_SRAM_MMU_AD_S: u32 = 10;
pub const DPORT_SHARE_ROM_IA: u32 = 15;
pub const DPORT_SHARE_ROM_IA_V: u32 = 15;
pub const DPORT_SHARE_ROM_IA_S: u32 = 6;
pub const DPORT_SHARE_ROM_MPU_AD: u32 = 3;
pub const DPORT_SHARE_ROM_MPU_AD_V: u32 = 3;
pub const DPORT_SHARE_ROM_MPU_AD_S: u32 = 4;
pub const DPORT_APP_ROM_IA_V: u32 = 1;
pub const DPORT_APP_ROM_IA_S: u32 = 3;
pub const DPORT_APP_ROM_MPU_AD_V: u32 = 1;
pub const DPORT_APP_ROM_MPU_AD_S: u32 = 2;
pub const DPORT_PRO_ROM_IA_V: u32 = 1;
pub const DPORT_PRO_ROM_IA_S: u32 = 1;
pub const DPORT_PRO_ROM_MPU_AD_V: u32 = 1;
pub const DPORT_PRO_ROM_MPU_AD_S: u32 = 0;
pub const DPORT_MEM_ACCESS_DBUG1_REG: u32 = 1072694252;
pub const DPORT_AHBLITE_IA_V: u32 = 1;
pub const DPORT_AHBLITE_IA_S: u32 = 10;
pub const DPORT_AHBLITE_ACCESS_DENY_V: u32 = 1;
pub const DPORT_AHBLITE_ACCESS_DENY_S: u32 = 9;
pub const DPORT_AHB_ACCESS_DENY_V: u32 = 1;
pub const DPORT_AHB_ACCESS_DENY_S: u32 = 8;
pub const DPORT_PIDGEN_IA: u32 = 3;
pub const DPORT_PIDGEN_IA_V: u32 = 3;
pub const DPORT_PIDGEN_IA_S: u32 = 6;
pub const DPORT_ARB_IA: u32 = 3;
pub const DPORT_ARB_IA_V: u32 = 3;
pub const DPORT_ARB_IA_S: u32 = 4;
pub const DPORT_INTERNAL_SRAM_MMU_MISS: u32 = 15;
pub const DPORT_INTERNAL_SRAM_MMU_MISS_V: u32 = 15;
pub const DPORT_INTERNAL_SRAM_MMU_MISS_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG0_REG: u32 = 1072694256;
pub const DPORT_PRO_RX_END_V: u32 = 1;
pub const DPORT_PRO_RX_END_S: u32 = 23;
pub const DPORT_PRO_SLAVE_WDATA_V_V: u32 = 1;
pub const DPORT_PRO_SLAVE_WDATA_V_S: u32 = 22;
pub const DPORT_PRO_SLAVE_WR_V: u32 = 1;
pub const DPORT_PRO_SLAVE_WR_S: u32 = 21;
pub const DPORT_PRO_TX_END_V: u32 = 1;
pub const DPORT_PRO_TX_END_S: u32 = 20;
pub const DPORT_PRO_WR_BAK_TO_READ_V: u32 = 1;
pub const DPORT_PRO_WR_BAK_TO_READ_S: u32 = 19;
pub const DPORT_PRO_CACHE_STATE: u32 = 4095;
pub const DPORT_PRO_CACHE_STATE_V: u32 = 4095;
pub const DPORT_PRO_CACHE_STATE_S: u32 = 7;
pub const DPORT_PRO_CACHE_IA: u32 = 63;
pub const DPORT_PRO_CACHE_IA_V: u32 = 63;
pub const DPORT_PRO_CACHE_IA_S: u32 = 1;
pub const DPORT_PRO_CACHE_MMU_IA_V: u32 = 1;
pub const DPORT_PRO_CACHE_MMU_IA_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG1_REG: u32 = 1072694260;
pub const DPORT_PRO_CTAG_RAM_RDATA: u32 = 4294967295;
pub const DPORT_PRO_CTAG_RAM_RDATA_V: u32 = 4294967295;
pub const DPORT_PRO_CTAG_RAM_RDATA_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG2_REG: u32 = 1072694264;
pub const DPORT_PRO_CACHE_VADDR: u32 = 134217727;
pub const DPORT_PRO_CACHE_VADDR_V: u32 = 134217727;
pub const DPORT_PRO_CACHE_VADDR_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG3_REG: u32 = 1072694268;
pub const DPORT_PRO_CACHE_IRAM0_PID_ERROR_V: u32 = 1;
pub const DPORT_PRO_CACHE_IRAM0_PID_ERROR_S: u32 = 15;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA: u32 = 63;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_V: u32 = 63;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_S: u32 = 9;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_OPPOSITE_V: u32 = 1;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_OPPOSITE_S: u32 = 9;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_DRAM1_V: u32 = 1;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_DRAM1_S: u32 = 10;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_IROM0_V: u32 = 1;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_IROM0_S: u32 = 11;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_IRAM1_V: u32 = 1;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_IRAM1_S: u32 = 12;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_IRAM0_V: u32 = 1;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_IRAM0_S: u32 = 13;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_DROM0_V: u32 = 1;
pub const DPORT_PRO_CPU_DISABLED_CACHE_IA_DROM0_S: u32 = 14;
pub const DPORT_PRO_MMU_RDATA: u32 = 511;
pub const DPORT_PRO_MMU_RDATA_V: u32 = 511;
pub const DPORT_PRO_MMU_RDATA_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG4_REG: u32 = 1072694272;
pub const DPORT_PRO_DRAM1ADDR0_IA: u32 = 1048575;
pub const DPORT_PRO_DRAM1ADDR0_IA_V: u32 = 1048575;
pub const DPORT_PRO_DRAM1ADDR0_IA_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG5_REG: u32 = 1072694276;
pub const DPORT_PRO_DROM0ADDR0_IA: u32 = 1048575;
pub const DPORT_PRO_DROM0ADDR0_IA_V: u32 = 1048575;
pub const DPORT_PRO_DROM0ADDR0_IA_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG6_REG: u32 = 1072694280;
pub const DPORT_PRO_IRAM0ADDR_IA: u32 = 1048575;
pub const DPORT_PRO_IRAM0ADDR_IA_V: u32 = 1048575;
pub const DPORT_PRO_IRAM0ADDR_IA_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG7_REG: u32 = 1072694284;
pub const DPORT_PRO_IRAM1ADDR_IA: u32 = 1048575;
pub const DPORT_PRO_IRAM1ADDR_IA_V: u32 = 1048575;
pub const DPORT_PRO_IRAM1ADDR_IA_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG8_REG: u32 = 1072694288;
pub const DPORT_PRO_IROM0ADDR_IA: u32 = 1048575;
pub const DPORT_PRO_IROM0ADDR_IA_V: u32 = 1048575;
pub const DPORT_PRO_IROM0ADDR_IA_S: u32 = 0;
pub const DPORT_PRO_DCACHE_DBUG9_REG: u32 = 1072694292;
pub const DPORT_PRO_OPSDRAMADDR_IA: u32 = 1048575;
pub const DPORT_PRO_OPSDRAMADDR_IA_V: u32 = 1048575;
pub const DPORT_PRO_OPSDRAMADDR_IA_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG0_REG: u32 = 1072694296;
pub const DPORT_APP_RX_END_V: u32 = 1;
pub const DPORT_APP_RX_END_S: u32 = 23;
pub const DPORT_APP_SLAVE_WDATA_V_V: u32 = 1;
pub const DPORT_APP_SLAVE_WDATA_V_S: u32 = 22;
pub const DPORT_APP_SLAVE_WR_V: u32 = 1;
pub const DPORT_APP_SLAVE_WR_S: u32 = 21;
pub const DPORT_APP_TX_END_V: u32 = 1;
pub const DPORT_APP_TX_END_S: u32 = 20;
pub const DPORT_APP_WR_BAK_TO_READ_V: u32 = 1;
pub const DPORT_APP_WR_BAK_TO_READ_S: u32 = 19;
pub const DPORT_APP_CACHE_STATE: u32 = 4095;
pub const DPORT_APP_CACHE_STATE_V: u32 = 4095;
pub const DPORT_APP_CACHE_STATE_S: u32 = 7;
pub const DPORT_APP_CACHE_IA: u32 = 63;
pub const DPORT_APP_CACHE_IA_V: u32 = 63;
pub const DPORT_APP_CACHE_IA_S: u32 = 1;
pub const DPORT_APP_CACHE_MMU_IA_V: u32 = 1;
pub const DPORT_APP_CACHE_MMU_IA_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG1_REG: u32 = 1072694300;
pub const DPORT_APP_CTAG_RAM_RDATA: u32 = 4294967295;
pub const DPORT_APP_CTAG_RAM_RDATA_V: u32 = 4294967295;
pub const DPORT_APP_CTAG_RAM_RDATA_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG2_REG: u32 = 1072694304;
pub const DPORT_APP_CACHE_VADDR: u32 = 134217727;
pub const DPORT_APP_CACHE_VADDR_V: u32 = 134217727;
pub const DPORT_APP_CACHE_VADDR_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG3_REG: u32 = 1072694308;
pub const DPORT_APP_CACHE_IRAM0_PID_ERROR_V: u32 = 1;
pub const DPORT_APP_CACHE_IRAM0_PID_ERROR_S: u32 = 15;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA: u32 = 63;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_V: u32 = 63;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_S: u32 = 9;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_OPPOSITE_V: u32 = 1;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_OPPOSITE_S: u32 = 9;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_DRAM1_V: u32 = 1;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_DRAM1_S: u32 = 10;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_IROM0_V: u32 = 1;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_IROM0_S: u32 = 11;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_IRAM1_V: u32 = 1;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_IRAM1_S: u32 = 12;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_IRAM0_V: u32 = 1;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_IRAM0_S: u32 = 13;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_DROM0_V: u32 = 1;
pub const DPORT_APP_CPU_DISABLED_CACHE_IA_DROM0_S: u32 = 14;
pub const DPORT_APP_MMU_RDATA: u32 = 511;
pub const DPORT_APP_MMU_RDATA_V: u32 = 511;
pub const DPORT_APP_MMU_RDATA_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG4_REG: u32 = 1072694312;
pub const DPORT_APP_DRAM1ADDR0_IA: u32 = 1048575;
pub const DPORT_APP_DRAM1ADDR0_IA_V: u32 = 1048575;
pub const DPORT_APP_DRAM1ADDR0_IA_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG5_REG: u32 = 1072694316;
pub const DPORT_APP_DROM0ADDR0_IA: u32 = 1048575;
pub const DPORT_APP_DROM0ADDR0_IA_V: u32 = 1048575;
pub const DPORT_APP_DROM0ADDR0_IA_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG6_REG: u32 = 1072694320;
pub const DPORT_APP_IRAM0ADDR_IA: u32 = 1048575;
pub const DPORT_APP_IRAM0ADDR_IA_V: u32 = 1048575;
pub const DPORT_APP_IRAM0ADDR_IA_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG7_REG: u32 = 1072694324;
pub const DPORT_APP_IRAM1ADDR_IA: u32 = 1048575;
pub const DPORT_APP_IRAM1ADDR_IA_V: u32 = 1048575;
pub const DPORT_APP_IRAM1ADDR_IA_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG8_REG: u32 = 1072694328;
pub const DPORT_APP_IROM0ADDR_IA: u32 = 1048575;
pub const DPORT_APP_IROM0ADDR_IA_V: u32 = 1048575;
pub const DPORT_APP_IROM0ADDR_IA_S: u32 = 0;
pub const DPORT_APP_DCACHE_DBUG9_REG: u32 = 1072694332;
pub const DPORT_APP_OPSDRAMADDR_IA: u32 = 1048575;
pub const DPORT_APP_OPSDRAMADDR_IA_V: u32 = 1048575;
pub const DPORT_APP_OPSDRAMADDR_IA_S: u32 = 0;
pub const DPORT_PRO_CPU_RECORD_CTRL_REG: u32 = 1072694336;
pub const DPORT_PRO_CPU_PDEBUG_ENABLE_V: u32 = 1;
pub const DPORT_PRO_CPU_PDEBUG_ENABLE_S: u32 = 8;
pub const DPORT_PRO_CPU_RECORD_DISABLE_V: u32 = 1;
pub const DPORT_PRO_CPU_RECORD_DISABLE_S: u32 = 4;
pub const DPORT_PRO_CPU_RECORD_ENABLE_V: u32 = 1;
pub const DPORT_PRO_CPU_RECORD_ENABLE_S: u32 = 0;
pub const DPORT_PRO_CPU_RECORD_STATUS_REG: u32 = 1072694340;
pub const DPORT_PRO_CPU_RECORDING_V: u32 = 1;
pub const DPORT_PRO_CPU_RECORDING_S: u32 = 0;
pub const DPORT_PRO_CPU_RECORD_PID_REG: u32 = 1072694344;
pub const DPORT_RECORD_PRO_PID: u32 = 7;
pub const DPORT_RECORD_PRO_PID_V: u32 = 7;
pub const DPORT_RECORD_PRO_PID_S: u32 = 0;
pub const DPORT_PRO_CPU_RECORD_PDEBUGINST_REG: u32 = 1072694348;
pub const DPORT_RECORD_PRO_PDEBUGINST: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGINST_V: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGINST_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGINST_SZ_V: u32 = 255;
pub const DPORT_RECORD_PDEBUGINST_SZ_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGINST_ISRC_V: u32 = 7;
pub const DPORT_RECORD_PDEBUGINST_ISRC_S: u32 = 12;
pub const DPORT_RECORD_PDEBUGINST_CINTL_V: u32 = 15;
pub const DPORT_RECORD_PDEBUGINST_CINTL_S: u32 = 24;
pub const DPORT_PRO_CPU_RECORD_PDEBUGSTATUS_REG: u32 = 1072694352;
pub const DPORT_RECORD_PRO_PDEBUGSTATUS: u32 = 255;
pub const DPORT_RECORD_PRO_PDEBUGSTATUS_V: u32 = 255;
pub const DPORT_RECORD_PRO_PDEBUGSTATUS_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_V: u32 = 63;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_PSO: u32 = 0;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_DEP: u32 = 2;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_CTL: u32 = 4;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_ICM: u32 = 8;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_DCM: u32 = 12;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_EXC0: u32 = 16;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_EXC1: u32 = 17;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_RPL: u32 = 20;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_ITLB: u32 = 24;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_ITLBM: u32 = 26;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_DTLB: u32 = 28;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_DTLBM: u32 = 30;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_STALL: u32 = 32;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_HWMEC: u32 = 36;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_WAITI: u32 = 40;
pub const DPORT_RECORD_PDEBUGSTATUS_BBCAUSE_OTHER: u32 = 60;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_V: u32 = 63;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_JX: u32 = 0;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_CALLX: u32 = 4;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_CRET: u32 = 8;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_ERET: u32 = 12;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_B: u32 = 16;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_J: u32 = 20;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_CALL: u32 = 24;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_BN: u32 = 28;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_LOOP: u32 = 32;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_S32C1I: u32 = 36;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_WXSR2LB: u32 = 40;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_WSR2MMID: u32 = 44;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_RWXSR: u32 = 48;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_RWER: u32 = 52;
pub const DPORT_RECORD_PDEBUGSTATUS_INSNTYPE_DEF: u32 = 60;
pub const DPORT_PRO_CPU_RECORD_PDEBUGDATA_REG: u32 = 1072694356;
pub const DPORT_RECORD_PRO_PDEBUGDATA: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGDATA_V: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGDATA_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGDATA_EXCCAUSE_V: u32 = 63;
pub const DPORT_RECORD_PDEBUGDATA_EXCCAUSE_S: u32 = 16;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_M: u32 = 4128768;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_V: u32 = 31;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_NONE: u32 = 0;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_RST: u32 = 1;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_DBG: u32 = 2;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_NMI: u32 = 3;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_USR: u32 = 4;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_KRNL: u32 = 5;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_DBL: u32 = 6;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_EMEM: u32 = 7;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_OVF4: u32 = 10;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_UNF4: u32 = 11;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_OVF8: u32 = 12;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_UNF8: u32 = 13;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_OVF12: u32 = 14;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_UNF12: u32 = 15;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_INT2: u32 = 16;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_INT3: u32 = 17;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_INT4: u32 = 18;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_INT5: u32 = 19;
pub const DPORT_RECORD_PDEBUGDATA_EXCVEC_INT6: u32 = 20;
pub const DPORT_RECORD_PDEBUGDATA_INSNTYPE_SR_V: u32 = 255;
pub const DPORT_RECORD_PDEBUGDATA_INSNTYPE_SR_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGDATA_INSNTYPE_ER_V: u32 = 4095;
pub const DPORT_RECORD_PDEBUGDATA_INSNTYPE_ER_S: u32 = 2;
pub const DPORT_PRO_CPU_RECORD_PDEBUGPC_REG: u32 = 1072694360;
pub const DPORT_RECORD_PRO_PDEBUGPC: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGPC_V: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGPC_S: u32 = 0;
pub const DPORT_PRO_CPU_RECORD_PDEBUGLS0STAT_REG: u32 = 1072694364;
pub const DPORT_RECORD_PRO_PDEBUGLS0STAT: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGLS0STAT_V: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGLS0STAT_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_V: u32 = 15;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_S: u32 = 0;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_NONE: u32 = 0;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_ITLBR: u32 = 1;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_DTLBR: u32 = 2;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_LD: u32 = 5;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_STR: u32 = 6;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_L32R: u32 = 8;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_S32CLI1: u32 = 10;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_CTI: u32 = 12;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_RWXSR: u32 = 14;
pub const DPORT_RECORD_PDEBUGLS0STAT_TYPE_RWER: u32 = 15;
pub const DPORT_RECORD_PDEBUGLS0STAT_SZ_V: u32 = 15;
pub const DPORT_RECORD_PDEBUGLS0STAT_SZ_S: u32 = 4;
pub const DPORT_RECORD_PDEBUGLS0STAT_STCOH_V: u32 = 3;
pub const DPORT_RECORD_PDEBUGLS0STAT_STCOH_S: u32 = 17;
pub const DPORT_RECORD_PDEBUGLS0STAT_STCOH_NONE: u32 = 0;
pub const DPORT_RECORD_PDEBUGLS0STAT_STCOH_SHARED: u32 = 1;
pub const DPORT_RECORD_PDEBUGLS0STAT_STCOH_EXCL: u32 = 2;
pub const DPORT_RECORD_PDEBUGLS0STAT_STCOH_MOD: u32 = 3;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_V: u32 = 15;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_S: u32 = 20;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_EXT: u32 = 0;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_IRAM0: u32 = 2;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_IRAM1: u32 = 3;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_IROM0: u32 = 4;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_IROM1: u32 = 5;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_DRAM0: u32 = 10;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_DRAM1: u32 = 11;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_DROM0: u32 = 14;
pub const DPORT_RECORD_PDEBUGLS0STAT_TGT_DROM1: u32 = 15;
pub const DPORT_PRO_CPU_RECORD_PDEBUGLS0ADDR_REG: u32 = 1072694368;
pub const DPORT_RECORD_PRO_PDEBUGLS0ADDR: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGLS0ADDR_V: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGLS0ADDR_S: u32 = 0;
pub const DPORT_PRO_CPU_RECORD_PDEBUGLS0DATA_REG: u32 = 1072694372;
pub const DPORT_RECORD_PRO_PDEBUGLS0DATA: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGLS0DATA_V: u32 = 4294967295;
pub const DPORT_RECORD_PRO_PDEBUGLS0DATA_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_CTRL_REG: u32 = 1072694376;
pub const DPORT_APP_CPU_PDEBUG_ENABLE_V: u32 = 1;
pub const DPORT_APP_CPU_PDEBUG_ENABLE_S: u32 = 8;
pub const DPORT_APP_CPU_RECORD_DISABLE_V: u32 = 1;
pub const DPORT_APP_CPU_RECORD_DISABLE_S: u32 = 4;
pub const DPORT_APP_CPU_RECORD_ENABLE_V: u32 = 1;
pub const DPORT_APP_CPU_RECORD_ENABLE_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_STATUS_REG: u32 = 1072694380;
pub const DPORT_APP_CPU_RECORDING_V: u32 = 1;
pub const DPORT_APP_CPU_RECORDING_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_PID_REG: u32 = 1072694384;
pub const DPORT_RECORD_APP_PID: u32 = 7;
pub const DPORT_RECORD_APP_PID_V: u32 = 7;
pub const DPORT_RECORD_APP_PID_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_PDEBUGINST_REG: u32 = 1072694388;
pub const DPORT_RECORD_APP_PDEBUGINST: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGINST_V: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGINST_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_PDEBUGSTATUS_REG: u32 = 1072694392;
pub const DPORT_RECORD_APP_PDEBUGSTATUS: u32 = 255;
pub const DPORT_RECORD_APP_PDEBUGSTATUS_V: u32 = 255;
pub const DPORT_RECORD_APP_PDEBUGSTATUS_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_PDEBUGDATA_REG: u32 = 1072694396;
pub const DPORT_RECORD_APP_PDEBUGDATA: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGDATA_V: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGDATA_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_PDEBUGPC_REG: u32 = 1072694400;
pub const DPORT_RECORD_APP_PDEBUGPC: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGPC_V: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGPC_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_PDEBUGLS0STAT_REG: u32 = 1072694404;
pub const DPORT_RECORD_APP_PDEBUGLS0STAT: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGLS0STAT_V: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGLS0STAT_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_PDEBUGLS0ADDR_REG: u32 = 1072694408;
pub const DPORT_RECORD_APP_PDEBUGLS0ADDR: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGLS0ADDR_V: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGLS0ADDR_S: u32 = 0;
pub const DPORT_APP_CPU_RECORD_PDEBUGLS0DATA_REG: u32 = 1072694412;
pub const DPORT_RECORD_APP_PDEBUGLS0DATA: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGLS0DATA_V: u32 = 4294967295;
pub const DPORT_RECORD_APP_PDEBUGLS0DATA_S: u32 = 0;
pub const DPORT_RSA_PD_CTRL_REG: u32 = 1072694416;
pub const DPORT_RSA_PD_V: u32 = 1;
pub const DPORT_RSA_PD_S: u32 = 0;
pub const DPORT_ROM_MPU_TABLE0_REG: u32 = 1072694420;
pub const DPORT_ROM_MPU_TABLE0: u32 = 3;
pub const DPORT_ROM_MPU_TABLE0_V: u32 = 3;
pub const DPORT_ROM_MPU_TABLE0_S: u32 = 0;
pub const DPORT_ROM_MPU_TABLE1_REG: u32 = 1072694424;
pub const DPORT_ROM_MPU_TABLE1: u32 = 3;
pub const DPORT_ROM_MPU_TABLE1_V: u32 = 3;
pub const DPORT_ROM_MPU_TABLE1_S: u32 = 0;
pub const DPORT_ROM_MPU_TABLE2_REG: u32 = 1072694428;
pub const DPORT_ROM_MPU_TABLE2: u32 = 3;
pub const DPORT_ROM_MPU_TABLE2_V: u32 = 3;
pub const DPORT_ROM_MPU_TABLE2_S: u32 = 0;
pub const DPORT_ROM_MPU_TABLE3_REG: u32 = 1072694432;
pub const DPORT_ROM_MPU_TABLE3: u32 = 3;
pub const DPORT_ROM_MPU_TABLE3_V: u32 = 3;
pub const DPORT_ROM_MPU_TABLE3_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE0_REG: u32 = 1072694436;
pub const DPORT_SHROM_MPU_TABLE0: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE0_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE0_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE1_REG: u32 = 1072694440;
pub const DPORT_SHROM_MPU_TABLE1: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE1_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE1_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE2_REG: u32 = 1072694444;
pub const DPORT_SHROM_MPU_TABLE2: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE2_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE2_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE3_REG: u32 = 1072694448;
pub const DPORT_SHROM_MPU_TABLE3: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE3_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE3_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE4_REG: u32 = 1072694452;
pub const DPORT_SHROM_MPU_TABLE4: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE4_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE4_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE5_REG: u32 = 1072694456;
pub const DPORT_SHROM_MPU_TABLE5: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE5_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE5_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE6_REG: u32 = 1072694460;
pub const DPORT_SHROM_MPU_TABLE6: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE6_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE6_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE7_REG: u32 = 1072694464;
pub const DPORT_SHROM_MPU_TABLE7: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE7_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE7_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE8_REG: u32 = 1072694468;
pub const DPORT_SHROM_MPU_TABLE8: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE8_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE8_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE9_REG: u32 = 1072694472;
pub const DPORT_SHROM_MPU_TABLE9: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE9_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE9_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE10_REG: u32 = 1072694476;
pub const DPORT_SHROM_MPU_TABLE10: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE10_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE10_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE11_REG: u32 = 1072694480;
pub const DPORT_SHROM_MPU_TABLE11: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE11_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE11_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE12_REG: u32 = 1072694484;
pub const DPORT_SHROM_MPU_TABLE12: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE12_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE12_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE13_REG: u32 = 1072694488;
pub const DPORT_SHROM_MPU_TABLE13: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE13_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE13_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE14_REG: u32 = 1072694492;
pub const DPORT_SHROM_MPU_TABLE14: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE14_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE14_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE15_REG: u32 = 1072694496;
pub const DPORT_SHROM_MPU_TABLE15: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE15_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE15_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE16_REG: u32 = 1072694500;
pub const DPORT_SHROM_MPU_TABLE16: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE16_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE16_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE17_REG: u32 = 1072694504;
pub const DPORT_SHROM_MPU_TABLE17: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE17_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE17_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE18_REG: u32 = 1072694508;
pub const DPORT_SHROM_MPU_TABLE18: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE18_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE18_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE19_REG: u32 = 1072694512;
pub const DPORT_SHROM_MPU_TABLE19: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE19_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE19_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE20_REG: u32 = 1072694516;
pub const DPORT_SHROM_MPU_TABLE20: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE20_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE20_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE21_REG: u32 = 1072694520;
pub const DPORT_SHROM_MPU_TABLE21: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE21_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE21_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE22_REG: u32 = 1072694524;
pub const DPORT_SHROM_MPU_TABLE22: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE22_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE22_S: u32 = 0;
pub const DPORT_SHROM_MPU_TABLE23_REG: u32 = 1072694528;
pub const DPORT_SHROM_MPU_TABLE23: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE23_V: u32 = 3;
pub const DPORT_SHROM_MPU_TABLE23_S: u32 = 0;
pub const DPORT_IMMU_TABLE0_REG: u32 = 1072694532;
pub const DPORT_IMMU_TABLE0: u32 = 127;
pub const DPORT_IMMU_TABLE0_V: u32 = 127;
pub const DPORT_IMMU_TABLE0_S: u32 = 0;
pub const DPORT_IMMU_TABLE1_REG: u32 = 1072694536;
pub const DPORT_IMMU_TABLE1: u32 = 127;
pub const DPORT_IMMU_TABLE1_V: u32 = 127;
pub const DPORT_IMMU_TABLE1_S: u32 = 0;
pub const DPORT_IMMU_TABLE2_REG: u32 = 1072694540;
pub const DPORT_IMMU_TABLE2: u32 = 127;
pub const DPORT_IMMU_TABLE2_V: u32 = 127;
pub const DPORT_IMMU_TABLE2_S: u32 = 0;
pub const DPORT_IMMU_TABLE3_REG: u32 = 1072694544;
pub const DPORT_IMMU_TABLE3: u32 = 127;
pub const DPORT_IMMU_TABLE3_V: u32 = 127;
pub const DPORT_IMMU_TABLE3_S: u32 = 0;
pub const DPORT_IMMU_TABLE4_REG: u32 = 1072694548;
pub const DPORT_IMMU_TABLE4: u32 = 127;
pub const DPORT_IMMU_TABLE4_V: u32 = 127;
pub const DPORT_IMMU_TABLE4_S: u32 = 0;
pub const DPORT_IMMU_TABLE5_REG: u32 = 1072694552;
pub const DPORT_IMMU_TABLE5: u32 = 127;
pub const DPORT_IMMU_TABLE5_V: u32 = 127;
pub const DPORT_IMMU_TABLE5_S: u32 = 0;
pub const DPORT_IMMU_TABLE6_REG: u32 = 1072694556;
pub const DPORT_IMMU_TABLE6: u32 = 127;
pub const DPORT_IMMU_TABLE6_V: u32 = 127;
pub const DPORT_IMMU_TABLE6_S: u32 = 0;
pub const DPORT_IMMU_TABLE7_REG: u32 = 1072694560;
pub const DPORT_IMMU_TABLE7: u32 = 127;
pub const DPORT_IMMU_TABLE7_V: u32 = 127;
pub const DPORT_IMMU_TABLE7_S: u32 = 0;
pub const DPORT_IMMU_TABLE8_REG: u32 = 1072694564;
pub const DPORT_IMMU_TABLE8: u32 = 127;
pub const DPORT_IMMU_TABLE8_V: u32 = 127;
pub const DPORT_IMMU_TABLE8_S: u32 = 0;
pub const DPORT_IMMU_TABLE9_REG: u32 = 1072694568;
pub const DPORT_IMMU_TABLE9: u32 = 127;
pub const DPORT_IMMU_TABLE9_V: u32 = 127;
pub const DPORT_IMMU_TABLE9_S: u32 = 0;
pub const DPORT_IMMU_TABLE10_REG: u32 = 1072694572;
pub const DPORT_IMMU_TABLE10: u32 = 127;
pub const DPORT_IMMU_TABLE10_V: u32 = 127;
pub const DPORT_IMMU_TABLE10_S: u32 = 0;
pub const DPORT_IMMU_TABLE11_REG: u32 = 1072694576;
pub const DPORT_IMMU_TABLE11: u32 = 127;
pub const DPORT_IMMU_TABLE11_V: u32 = 127;
pub const DPORT_IMMU_TABLE11_S: u32 = 0;
pub const DPORT_IMMU_TABLE12_REG: u32 = 1072694580;
pub const DPORT_IMMU_TABLE12: u32 = 127;
pub const DPORT_IMMU_TABLE12_V: u32 = 127;
pub const DPORT_IMMU_TABLE12_S: u32 = 0;
pub const DPORT_IMMU_TABLE13_REG: u32 = 1072694584;
pub const DPORT_IMMU_TABLE13: u32 = 127;
pub const DPORT_IMMU_TABLE13_V: u32 = 127;
pub const DPORT_IMMU_TABLE13_S: u32 = 0;
pub const DPORT_IMMU_TABLE14_REG: u32 = 1072694588;
pub const DPORT_IMMU_TABLE14: u32 = 127;
pub const DPORT_IMMU_TABLE14_V: u32 = 127;
pub const DPORT_IMMU_TABLE14_S: u32 = 0;
pub const DPORT_IMMU_TABLE15_REG: u32 = 1072694592;
pub const DPORT_IMMU_TABLE15: u32 = 127;
pub const DPORT_IMMU_TABLE15_V: u32 = 127;
pub const DPORT_IMMU_TABLE15_S: u32 = 0;
pub const DPORT_DMMU_TABLE0_REG: u32 = 1072694596;
pub const DPORT_DMMU_TABLE0: u32 = 127;
pub const DPORT_DMMU_TABLE0_V: u32 = 127;
pub const DPORT_DMMU_TABLE0_S: u32 = 0;
pub const DPORT_DMMU_TABLE1_REG: u32 = 1072694600;
pub const DPORT_DMMU_TABLE1: u32 = 127;
pub const DPORT_DMMU_TABLE1_V: u32 = 127;
pub const DPORT_DMMU_TABLE1_S: u32 = 0;
pub const DPORT_DMMU_TABLE2_REG: u32 = 1072694604;
pub const DPORT_DMMU_TABLE2: u32 = 127;
pub const DPORT_DMMU_TABLE2_V: u32 = 127;
pub const DPORT_DMMU_TABLE2_S: u32 = 0;
pub const DPORT_DMMU_TABLE3_REG: u32 = 1072694608;
pub const DPORT_DMMU_TABLE3: u32 = 127;
pub const DPORT_DMMU_TABLE3_V: u32 = 127;
pub const DPORT_DMMU_TABLE3_S: u32 = 0;
pub const DPORT_DMMU_TABLE4_REG: u32 = 1072694612;
pub const DPORT_DMMU_TABLE4: u32 = 127;
pub const DPORT_DMMU_TABLE4_V: u32 = 127;
pub const DPORT_DMMU_TABLE4_S: u32 = 0;
pub const DPORT_DMMU_TABLE5_REG: u32 = 1072694616;
pub const DPORT_DMMU_TABLE5: u32 = 127;
pub const DPORT_DMMU_TABLE5_V: u32 = 127;
pub const DPORT_DMMU_TABLE5_S: u32 = 0;
pub const DPORT_DMMU_TABLE6_REG: u32 = 1072694620;
pub const DPORT_DMMU_TABLE6: u32 = 127;
pub const DPORT_DMMU_TABLE6_V: u32 = 127;
pub const DPORT_DMMU_TABLE6_S: u32 = 0;
pub const DPORT_DMMU_TABLE7_REG: u32 = 1072694624;
pub const DPORT_DMMU_TABLE7: u32 = 127;
pub const DPORT_DMMU_TABLE7_V: u32 = 127;
pub const DPORT_DMMU_TABLE7_S: u32 = 0;
pub const DPORT_DMMU_TABLE8_REG: u32 = 1072694628;
pub const DPORT_DMMU_TABLE8: u32 = 127;
pub const DPORT_DMMU_TABLE8_V: u32 = 127;
pub const DPORT_DMMU_TABLE8_S: u32 = 0;
pub const DPORT_DMMU_TABLE9_REG: u32 = 1072694632;
pub const DPORT_DMMU_TABLE9: u32 = 127;
pub const DPORT_DMMU_TABLE9_V: u32 = 127;
pub const DPORT_DMMU_TABLE9_S: u32 = 0;
pub const DPORT_DMMU_TABLE10_REG: u32 = 1072694636;
pub const DPORT_DMMU_TABLE10: u32 = 127;
pub const DPORT_DMMU_TABLE10_V: u32 = 127;
pub const DPORT_DMMU_TABLE10_S: u32 = 0;
pub const DPORT_DMMU_TABLE11_REG: u32 = 1072694640;
pub const DPORT_DMMU_TABLE11: u32 = 127;
pub const DPORT_DMMU_TABLE11_V: u32 = 127;
pub const DPORT_DMMU_TABLE11_S: u32 = 0;
pub const DPORT_DMMU_TABLE12_REG: u32 = 1072694644;
pub const DPORT_DMMU_TABLE12: u32 = 127;
pub const DPORT_DMMU_TABLE12_V: u32 = 127;
pub const DPORT_DMMU_TABLE12_S: u32 = 0;
pub const DPORT_DMMU_TABLE13_REG: u32 = 1072694648;
pub const DPORT_DMMU_TABLE13: u32 = 127;
pub const DPORT_DMMU_TABLE13_V: u32 = 127;
pub const DPORT_DMMU_TABLE13_S: u32 = 0;
pub const DPORT_DMMU_TABLE14_REG: u32 = 1072694652;
pub const DPORT_DMMU_TABLE14: u32 = 127;
pub const DPORT_DMMU_TABLE14_V: u32 = 127;
pub const DPORT_DMMU_TABLE14_S: u32 = 0;
pub const DPORT_DMMU_TABLE15_REG: u32 = 1072694656;
pub const DPORT_DMMU_TABLE15: u32 = 127;
pub const DPORT_DMMU_TABLE15_V: u32 = 127;
pub const DPORT_DMMU_TABLE15_S: u32 = 0;
pub const DPORT_PRO_INTRUSION_CTRL_REG: u32 = 1072694660;
pub const DPORT_PRO_INTRUSION_RECORD_RESET_N_V: u32 = 1;
pub const DPORT_PRO_INTRUSION_RECORD_RESET_N_S: u32 = 0;
pub const DPORT_PRO_INTRUSION_STATUS_REG: u32 = 1072694664;
pub const DPORT_PRO_INTRUSION_RECORD: u32 = 15;
pub const DPORT_PRO_INTRUSION_RECORD_V: u32 = 15;
pub const DPORT_PRO_INTRUSION_RECORD_S: u32 = 0;
pub const DPORT_APP_INTRUSION_CTRL_REG: u32 = 1072694668;
pub const DPORT_APP_INTRUSION_RECORD_RESET_N_V: u32 = 1;
pub const DPORT_APP_INTRUSION_RECORD_RESET_N_S: u32 = 0;
pub const DPORT_APP_INTRUSION_STATUS_REG: u32 = 1072694672;
pub const DPORT_APP_INTRUSION_RECORD: u32 = 15;
pub const DPORT_APP_INTRUSION_RECORD_V: u32 = 15;
pub const DPORT_APP_INTRUSION_RECORD_S: u32 = 0;
pub const DPORT_FRONT_END_MEM_PD_REG: u32 = 1072694676;
pub const DPORT_PBUS_MEM_FORCE_PD_V: u32 = 1;
pub const DPORT_PBUS_MEM_FORCE_PD_S: u32 = 3;
pub const DPORT_PBUS_MEM_FORCE_PU_V: u32 = 1;
pub const DPORT_PBUS_MEM_FORCE_PU_S: u32 = 2;
pub const DPORT_AGC_MEM_FORCE_PD_V: u32 = 1;
pub const DPORT_AGC_MEM_FORCE_PD_S: u32 = 1;
pub const DPORT_AGC_MEM_FORCE_PU_V: u32 = 1;
pub const DPORT_AGC_MEM_FORCE_PU_S: u32 = 0;
pub const DPORT_MMU_IA_INT_EN_REG: u32 = 1072694680;
pub const DPORT_MMU_IA_INT_EN: u32 = 16777215;
pub const DPORT_MMU_IA_INT_EN_V: u32 = 16777215;
pub const DPORT_MMU_IA_INT_EN_S: u32 = 0;
pub const DPORT_MPU_IA_INT_EN_REG: u32 = 1072694684;
pub const DPORT_MPU_IA_INT_EN: u32 = 131071;
pub const DPORT_MPU_IA_INT_EN_V: u32 = 131071;
pub const DPORT_MPU_IA_INT_EN_S: u32 = 0;
pub const DPORT_CACHE_IA_INT_EN_REG: u32 = 1072694688;
pub const DPORT_CACHE_IA_INT_EN: u32 = 268435455;
pub const DPORT_CACHE_IA_INT_EN_V: u32 = 268435455;
pub const DPORT_CACHE_IA_INT_EN_S: u32 = 0;
pub const DPORT_CACHE_IA_INT_PRO_OPPOSITE_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_PRO_OPPOSITE_S: u32 = 19;
pub const DPORT_CACHE_IA_INT_PRO_DRAM1_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_PRO_DRAM1_S: u32 = 18;
pub const DPORT_CACHE_IA_INT_PRO_IROM0_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_PRO_IROM0_S: u32 = 17;
pub const DPORT_CACHE_IA_INT_PRO_IRAM1_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_PRO_IRAM1_S: u32 = 16;
pub const DPORT_CACHE_IA_INT_PRO_IRAM0_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_PRO_IRAM0_S: u32 = 15;
pub const DPORT_CACHE_IA_INT_PRO_DROM0_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_PRO_DROM0_S: u32 = 14;
pub const DPORT_CACHE_IA_INT_APP_OPPOSITE_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_APP_OPPOSITE_S: u32 = 5;
pub const DPORT_CACHE_IA_INT_APP_DRAM1_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_APP_DRAM1_S: u32 = 4;
pub const DPORT_CACHE_IA_INT_APP_IROM0_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_APP_IROM0_S: u32 = 3;
pub const DPORT_CACHE_IA_INT_APP_IRAM1_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_APP_IRAM1_S: u32 = 2;
pub const DPORT_CACHE_IA_INT_APP_IRAM0_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_APP_IRAM0_S: u32 = 1;
pub const DPORT_CACHE_IA_INT_APP_DROM0_V: u32 = 1;
pub const DPORT_CACHE_IA_INT_APP_DROM0_S: u32 = 0;
pub const DPORT_SECURE_BOOT_CTRL_REG: u32 = 1072694692;
pub const DPORT_SW_BOOTLOADER_SEL_V: u32 = 1;
pub const DPORT_SW_BOOTLOADER_SEL_S: u32 = 0;
pub const DPORT_SPI_DMA_CHAN_SEL_REG: u32 = 1072694696;
pub const DPORT_SPI3_DMA_CHAN_SEL: u32 = 3;
pub const DPORT_SPI3_DMA_CHAN_SEL_V: u32 = 3;
pub const DPORT_SPI3_DMA_CHAN_SEL_S: u32 = 4;
pub const DPORT_SPI2_DMA_CHAN_SEL: u32 = 3;
pub const DPORT_SPI2_DMA_CHAN_SEL_V: u32 = 3;
pub const DPORT_SPI2_DMA_CHAN_SEL_S: u32 = 2;
pub const DPORT_SPI1_DMA_CHAN_SEL: u32 = 3;
pub const DPORT_SPI1_DMA_CHAN_SEL_V: u32 = 3;
pub const DPORT_SPI1_DMA_CHAN_SEL_S: u32 = 0;
pub const DPORT_PRO_VECBASE_CTRL_REG: u32 = 1072694700;
pub const DPORT_PRO_OUT_VECBASE_SEL: u32 = 3;
pub const DPORT_PRO_OUT_VECBASE_SEL_V: u32 = 3;
pub const DPORT_PRO_OUT_VECBASE_SEL_S: u32 = 0;
pub const DPORT_PRO_VECBASE_SET_REG: u32 = 1072694704;
pub const DPORT_PRO_OUT_VECBASE_REG: u32 = 4194303;
pub const DPORT_PRO_OUT_VECBASE_REG_V: u32 = 4194303;
pub const DPORT_PRO_OUT_VECBASE_REG_S: u32 = 0;
pub const DPORT_APP_VECBASE_CTRL_REG: u32 = 1072694708;
pub const DPORT_APP_OUT_VECBASE_SEL: u32 = 3;
pub const DPORT_APP_OUT_VECBASE_SEL_V: u32 = 3;
pub const DPORT_APP_OUT_VECBASE_SEL_S: u32 = 0;
pub const DPORT_APP_VECBASE_SET_REG: u32 = 1072694712;
pub const DPORT_APP_OUT_VECBASE_REG: u32 = 4194303;
pub const DPORT_APP_OUT_VECBASE_REG_V: u32 = 4194303;
pub const DPORT_APP_OUT_VECBASE_REG_S: u32 = 0;
pub const DPORT_DATE_REG: u32 = 1072697340;
pub const DPORT_DATE: u32 = 268435455;
pub const DPORT_DATE_V: u32 = 268435455;
pub const DPORT_DATE_S: u32 = 0;
pub const DPORT_DPORT_DATE_VERSION: u32 = 23089552;
pub const DPORT_FLASH_MMU_TABLE_SIZE: u32 = 256;
pub const DPORT_FLASH_MMU_TABLE_INVALID_VAL: u32 = 256;
pub const UART_NUM_0_TXD_DIRECT_GPIO_NUM: u32 = 1;
pub const UART_NUM_0_RXD_DIRECT_GPIO_NUM: u32 = 3;
pub const UART_NUM_0_CTS_DIRECT_GPIO_NUM: u32 = 19;
pub const UART_NUM_0_RTS_DIRECT_GPIO_NUM: u32 = 22;
pub const UART_NUM_1_TXD_DIRECT_GPIO_NUM: u32 = 10;
pub const UART_NUM_1_RXD_DIRECT_GPIO_NUM: u32 = 9;
pub const UART_NUM_1_CTS_DIRECT_GPIO_NUM: u32 = 6;
pub const UART_NUM_1_RTS_DIRECT_GPIO_NUM: u32 = 11;
pub const UART_NUM_2_TXD_DIRECT_GPIO_NUM: u32 = 17;
pub const UART_NUM_2_RXD_DIRECT_GPIO_NUM: u32 = 16;
pub const UART_NUM_2_CTS_DIRECT_GPIO_NUM: u32 = 8;
pub const UART_NUM_2_RTS_DIRECT_GPIO_NUM: u32 = 7;
pub const UART_FIFO_LEN: u32 = 128;
pub const UART_INTR_MASK: u32 = 511;
pub const UART_LINE_INV_MASK: u32 = 33030144;
pub const UART_BITRATE_MAX: u32 = 5000000;
pub const UART_PIN_NO_CHANGE: i32 = -1;
pub const UART_INVERSE_DISABLE: u32 = 0;
pub const HTTP_PARSER_VERSION_MAJOR: u32 = 2;
pub const HTTP_PARSER_VERSION_MINOR: u32 = 7;
pub const HTTP_PARSER_VERSION_PATCH: u32 = 0;
pub const HTTP_PARSER_STRICT: u32 = 1;
pub const HTTP_MAX_HEADER_SIZE: u32 = 81920;
pub const DEFAULT_HTTP_BUF_SIZE: u32 = 512;
pub const ESP_ERR_HTTP_BASE: u32 = 28672;
pub const ESP_ERR_HTTP_MAX_REDIRECT: u32 = 28673;
pub const ESP_ERR_HTTP_CONNECT: u32 = 28674;
pub const ESP_ERR_HTTP_WRITE_DATA: u32 = 28675;
pub const ESP_ERR_HTTP_FETCH_HEADER: u32 = 28676;
pub const ESP_ERR_HTTP_INVALID_TRANSPORT: u32 = 28677;
pub const ESP_ERR_HTTP_CONNECTING: u32 = 28678;
pub const ESP_ERR_HTTP_EAGAIN: u32 = 28679;
pub const SYS_ARCH_TIMEOUT: u32 = 4294967295;
pub const SYS_MBOX_EMPTY: u32 = 4294967295;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const SIN_ZERO_LEN: u32 = 8;
pub const LWIP_SETGETSOCKOPT_MAXOPTLEN: u32 = 16;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_BROADCAST: u32 = 32;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_CONTIMEO: u32 = 4105;
pub const SO_NO_CHECK: u32 = 4106;
pub const SOL_SOCKET: u32 = 4095;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const AF_INET6: u32 = 10;
pub const PF_INET: u32 = 2;
pub const PF_INET6: u32 = 10;
pub const PF_UNSPEC: u32 = 0;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_UDPLITE: u32 = 136;
pub const IPPROTO_RAW: u32 = 255;
pub const MSG_PEEK: u32 = 1;
pub const MSG_WAITALL: u32 = 2;
pub const MSG_OOB: u32 = 4;
pub const MSG_DONTWAIT: u32 = 8;
pub const MSG_MORE: u32 = 16;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_KEEPALIVE: u32 = 2;
pub const TCP_KEEPIDLE: u32 = 3;
pub const TCP_KEEPINTVL: u32 = 4;
pub const TCP_KEEPCNT: u32 = 5;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_MULTICAST_IF: u32 = 768;
pub const IPV6_MULTICAST_HOPS: u32 = 769;
pub const IPV6_MULTICAST_LOOP: u32 = 770;
pub const IPV6_ADD_MEMBERSHIP: u32 = 771;
pub const IPV6_DROP_MEMBERSHIP: u32 = 772;
pub const IPV6_JOIN_GROUP: u32 = 771;
pub const IPV6_LEAVE_GROUP: u32 = 772;
pub const IP_MULTICAST_TTL: u32 = 5;
pub const IP_MULTICAST_IF: u32 = 6;
pub const IP_MULTICAST_LOOP: u32 = 7;
pub const IP_ADD_MEMBERSHIP: u32 = 3;
pub const IP_DROP_MEMBERSHIP: u32 = 4;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IOCPARM_MASK: u32 = 127;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const O_NDELAY: u32 = 1;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const MBEDTLS_PLATFORM_STD_EXIT_SUCCESS: u32 = 0;
pub const MBEDTLS_PLATFORM_STD_EXIT_FAILURE: u32 = 1;
pub const MBEDTLS_PLATFORM_STD_NV_SEED_FILE: &'static [u8; 9usize] = b"seedfile\0";
pub const MBEDTLS_EXIT_SUCCESS: u32 = 0;
pub const MBEDTLS_EXIT_FAILURE: u32 = 1;
pub const MBEDTLS_ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const MBEDTLS_ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const MBEDTLS_ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const MBEDTLS_ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const MBEDTLS_ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const MBEDTLS_ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MBEDTLS_MPI_MAX_LIMBS: u32 = 10000;
pub const MBEDTLS_MPI_WINDOW_SIZE: u32 = 6;
pub const MBEDTLS_MPI_MAX_SIZE: u32 = 1024;
pub const MBEDTLS_MPI_MAX_BITS: u32 = 8192;
pub const MBEDTLS_MPI_MAX_BITS_SCALE100: u32 = 819200;
pub const MBEDTLS_LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MBEDTLS_MPI_RW_BUFFER_SIZE: u32 = 2484;
pub const MBEDTLS_ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const MBEDTLS_ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const MBEDTLS_ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const MBEDTLS_ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const MBEDTLS_ERR_ECP_INVALID_KEY: i32 = -19584;
pub const MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const MBEDTLS_ERR_ECP_HW_ACCEL_FAILED: i32 = -19328;
pub const MBEDTLS_ECP_DP_MAX: u32 = 12;
pub const MBEDTLS_ECP_MAX_BITS: u32 = 521;
pub const MBEDTLS_ECP_MAX_BYTES: u32 = 66;
pub const MBEDTLS_ECP_MAX_PT_LEN: u32 = 133;
pub const MBEDTLS_ECP_WINDOW_SIZE: u32 = 6;
pub const MBEDTLS_ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const MBEDTLS_ECP_PF_UNCOMPRESSED: u32 = 0;
pub const MBEDTLS_ECP_PF_COMPRESSED: u32 = 1;
pub const MBEDTLS_ECP_TLS_NAMED_CURVE: u32 = 3;
pub const MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const MBEDTLS_ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const MBEDTLS_ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const MBEDTLS_ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const MBEDTLS_ERR_MD_HW_ACCEL_FAILED: i32 = -21120;
pub const MBEDTLS_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_ERR_RSA_BAD_INPUT_DATA: i32 = -16512;
pub const MBEDTLS_ERR_RSA_INVALID_PADDING: i32 = -16640;
pub const MBEDTLS_ERR_RSA_KEY_GEN_FAILED: i32 = -16768;
pub const MBEDTLS_ERR_RSA_KEY_CHECK_FAILED: i32 = -16896;
pub const MBEDTLS_ERR_RSA_PUBLIC_FAILED: i32 = -17024;
pub const MBEDTLS_ERR_RSA_PRIVATE_FAILED: i32 = -17152;
pub const MBEDTLS_ERR_RSA_VERIFY_FAILED: i32 = -17280;
pub const MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE: i32 = -17408;
pub const MBEDTLS_ERR_RSA_RNG_FAILED: i32 = -17536;
pub const MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION: i32 = -17664;
pub const MBEDTLS_ERR_RSA_HW_ACCEL_FAILED: i32 = -17792;
pub const MBEDTLS_RSA_PUBLIC: u32 = 0;
pub const MBEDTLS_RSA_PRIVATE: u32 = 1;
pub const MBEDTLS_RSA_PKCS_V15: u32 = 0;
pub const MBEDTLS_RSA_PKCS_V21: u32 = 1;
pub const MBEDTLS_RSA_SIGN: u32 = 1;
pub const MBEDTLS_RSA_CRYPT: u32 = 2;
pub const MBEDTLS_RSA_SALT_LEN_ANY: i32 = -1;
pub const MBEDTLS_ECDSA_MAX_LEN: u32 = 141;
pub const MBEDTLS_ERR_PK_ALLOC_FAILED: i32 = -16256;
pub const MBEDTLS_ERR_PK_TYPE_MISMATCH: i32 = -16128;
pub const MBEDTLS_ERR_PK_BAD_INPUT_DATA: i32 = -16000;
pub const MBEDTLS_ERR_PK_FILE_IO_ERROR: i32 = -15872;
pub const MBEDTLS_ERR_PK_KEY_INVALID_VERSION: i32 = -15744;
pub const MBEDTLS_ERR_PK_KEY_INVALID_FORMAT: i32 = -15616;
pub const MBEDTLS_ERR_PK_UNKNOWN_PK_ALG: i32 = -15488;
pub const MBEDTLS_ERR_PK_PASSWORD_REQUIRED: i32 = -15360;
pub const MBEDTLS_ERR_PK_PASSWORD_MISMATCH: i32 = -15232;
pub const MBEDTLS_ERR_PK_INVALID_PUBKEY: i32 = -15104;
pub const MBEDTLS_ERR_PK_INVALID_ALG: i32 = -14976;
pub const MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE: i32 = -14848;
pub const MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE: i32 = -14720;
pub const MBEDTLS_ERR_PK_SIG_LEN_MISMATCH: i32 = -14592;
pub const MBEDTLS_ERR_PK_HW_ACCEL_FAILED: i32 = -14464;
pub const MBEDTLS_PK_DEBUG_MAX_ITEMS: u32 = 3;
pub const MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const MBEDTLS_ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const MBEDTLS_ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const MBEDTLS_ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const MBEDTLS_ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const MBEDTLS_ERR_CIPHER_HW_ACCEL_FAILED: i32 = -25600;
pub const MBEDTLS_CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const MBEDTLS_CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MBEDTLS_MAX_IV_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_BLOCK_LENGTH: u32 = 16;
pub const MBEDTLS_TLS_RSA_WITH_NULL_MD5: u32 = 1;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA: u32 = 2;
pub const MBEDTLS_TLS_RSA_WITH_RC4_128_MD5: u32 = 4;
pub const MBEDTLS_TLS_RSA_WITH_RC4_128_SHA: u32 = 5;
pub const MBEDTLS_TLS_RSA_WITH_DES_CBC_SHA: u32 = 9;
pub const MBEDTLS_TLS_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 10;
pub const MBEDTLS_TLS_DHE_RSA_WITH_DES_CBC_SHA: u32 = 21;
pub const MBEDTLS_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 22;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA: u32 = 44;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA: u32 = 45;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA: u32 = 46;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA: u32 = 47;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA: u32 = 51;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA: u32 = 53;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA: u32 = 57;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA256: u32 = 59;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256: u32 = 60;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256: u32 = 61;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 65;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 69;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 103;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: u32 = 107;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 132;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 136;
pub const MBEDTLS_TLS_PSK_WITH_RC4_128_SHA: u32 = 138;
pub const MBEDTLS_TLS_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 139;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA: u32 = 140;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA: u32 = 141;
pub const MBEDTLS_TLS_DHE_PSK_WITH_RC4_128_SHA: u32 = 142;
pub const MBEDTLS_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 143;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 144;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 145;
pub const MBEDTLS_TLS_RSA_PSK_WITH_RC4_128_SHA: u32 = 146;
pub const MBEDTLS_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 147;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 148;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 149;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256: u32 = 156;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384: u32 = 157;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 158;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 159;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256: u32 = 168;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384: u32 = 169;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: u32 = 170;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: u32 = 171;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: u32 = 172;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: u32 = 173;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256: u32 = 174;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384: u32 = 175;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA256: u32 = 176;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA384: u32 = 177;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 178;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 179;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA256: u32 = 180;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA384: u32 = 181;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 182;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 183;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA256: u32 = 184;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA384: u32 = 185;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 186;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 190;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 192;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_NULL_SHA: u32 = 49153;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_RC4_128_SHA: u32 = 49154;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49155;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49156;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49157;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 49158;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA: u32 = 49159;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49160;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49161;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49162;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_NULL_SHA: u32 = 49163;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_RC4_128_SHA: u32 = 49164;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49165;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 49166;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 49167;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_NULL_SHA: u32 = 49168;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_RC4_128_SHA: u32 = 49169;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49170;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 49171;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 49172;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49187;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49188;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49189;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49190;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 49191;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: u32 = 49192;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: u32 = 49193;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: u32 = 49194;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49195;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49197;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49198;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 49199;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 49200;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 49201;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 49202;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_RC4_128_SHA: u32 = 49203;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 49204;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 49205;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 49206;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 49207;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 49208;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA: u32 = 49209;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA256: u32 = 49210;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA384: u32 = 49211;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49212;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49213;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49220;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49221;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49224;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49225;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49226;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49227;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49228;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49229;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49230;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49231;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49232;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49233;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49234;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49235;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49244;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49245;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49246;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49247;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49248;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49249;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49250;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49251;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49252;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49253;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49254;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49255;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49256;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49257;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49258;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49259;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49260;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49261;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49262;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49263;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49264;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49265;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49266;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49267;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49268;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49269;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49270;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49271;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49272;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49273;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49274;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49275;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49276;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49277;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49286;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49287;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49288;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49289;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49290;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49291;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49292;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49293;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49294;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49295;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49296;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49297;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49298;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49299;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49300;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49301;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49302;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49303;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49304;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49305;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49306;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49307;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM: u32 = 49308;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM: u32 = 49309;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM: u32 = 49310;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM: u32 = 49311;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM_8: u32 = 49312;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM_8: u32 = 49313;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM_8: u32 = 49314;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM_8: u32 = 49315;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM: u32 = 49316;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM: u32 = 49317;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM: u32 = 49318;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM: u32 = 49319;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM_8: u32 = 49320;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM_8: u32 = 49321;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM_8: u32 = 49322;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM_8: u32 = 49323;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 49324;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 49325;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 49326;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 49327;
pub const MBEDTLS_TLS_ECJPAKE_WITH_AES_128_CCM_8: u32 = 49407;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52392;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52393;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52394;
pub const MBEDTLS_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52395;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52396;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52397;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52398;
pub const MBEDTLS_CIPHERSUITE_WEAK: u32 = 1;
pub const MBEDTLS_CIPHERSUITE_SHORT_TAG: u32 = 2;
pub const MBEDTLS_CIPHERSUITE_NODTLS: u32 = 4;
pub const MBEDTLS_ERR_ASN1_OUT_OF_DATA: i32 = -96;
pub const MBEDTLS_ERR_ASN1_UNEXPECTED_TAG: i32 = -98;
pub const MBEDTLS_ERR_ASN1_INVALID_LENGTH: i32 = -100;
pub const MBEDTLS_ERR_ASN1_LENGTH_MISMATCH: i32 = -102;
pub const MBEDTLS_ERR_ASN1_INVALID_DATA: i32 = -104;
pub const MBEDTLS_ERR_ASN1_ALLOC_FAILED: i32 = -106;
pub const MBEDTLS_ERR_ASN1_BUF_TOO_SMALL: i32 = -108;
pub const MBEDTLS_ASN1_BOOLEAN: u32 = 1;
pub const MBEDTLS_ASN1_INTEGER: u32 = 2;
pub const MBEDTLS_ASN1_BIT_STRING: u32 = 3;
pub const MBEDTLS_ASN1_OCTET_STRING: u32 = 4;
pub const MBEDTLS_ASN1_NULL: u32 = 5;
pub const MBEDTLS_ASN1_OID: u32 = 6;
pub const MBEDTLS_ASN1_UTF8_STRING: u32 = 12;
pub const MBEDTLS_ASN1_SEQUENCE: u32 = 16;
pub const MBEDTLS_ASN1_SET: u32 = 17;
pub const MBEDTLS_ASN1_PRINTABLE_STRING: u32 = 19;
pub const MBEDTLS_ASN1_T61_STRING: u32 = 20;
pub const MBEDTLS_ASN1_IA5_STRING: u32 = 22;
pub const MBEDTLS_ASN1_UTC_TIME: u32 = 23;
pub const MBEDTLS_ASN1_GENERALIZED_TIME: u32 = 24;
pub const MBEDTLS_ASN1_UNIVERSAL_STRING: u32 = 28;
pub const MBEDTLS_ASN1_BMP_STRING: u32 = 30;
pub const MBEDTLS_ASN1_PRIMITIVE: u32 = 0;
pub const MBEDTLS_ASN1_CONSTRUCTED: u32 = 32;
pub const MBEDTLS_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const MBEDTLS_ASN1_TAG_CLASS_MASK: u32 = 192;
pub const MBEDTLS_ASN1_TAG_PC_MASK: u32 = 32;
pub const MBEDTLS_ASN1_TAG_VALUE_MASK: u32 = 31;
pub const MBEDTLS_X509_MAX_INTERMEDIATE_CA: u32 = 8;
pub const MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE: i32 = -8320;
pub const MBEDTLS_ERR_X509_UNKNOWN_OID: i32 = -8448;
pub const MBEDTLS_ERR_X509_INVALID_FORMAT: i32 = -8576;
pub const MBEDTLS_ERR_X509_INVALID_VERSION: i32 = -8704;
pub const MBEDTLS_ERR_X509_INVALID_SERIAL: i32 = -8832;
pub const MBEDTLS_ERR_X509_INVALID_ALG: i32 = -8960;
pub const MBEDTLS_ERR_X509_INVALID_NAME: i32 = -9088;
pub const MBEDTLS_ERR_X509_INVALID_DATE: i32 = -9216;
pub const MBEDTLS_ERR_X509_INVALID_SIGNATURE: i32 = -9344;
pub const MBEDTLS_ERR_X509_INVALID_EXTENSIONS: i32 = -9472;
pub const MBEDTLS_ERR_X509_UNKNOWN_VERSION: i32 = -9600;
pub const MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG: i32 = -9728;
pub const MBEDTLS_ERR_X509_SIG_MISMATCH: i32 = -9856;
pub const MBEDTLS_ERR_X509_CERT_VERIFY_FAILED: i32 = -9984;
pub const MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT: i32 = -10112;
pub const MBEDTLS_ERR_X509_BAD_INPUT_DATA: i32 = -10240;
pub const MBEDTLS_ERR_X509_ALLOC_FAILED: i32 = -10368;
pub const MBEDTLS_ERR_X509_FILE_IO_ERROR: i32 = -10496;
pub const MBEDTLS_ERR_X509_BUFFER_TOO_SMALL: i32 = -10624;
pub const MBEDTLS_ERR_X509_FATAL_ERROR: i32 = -12288;
pub const MBEDTLS_X509_BADCERT_EXPIRED: u32 = 1;
pub const MBEDTLS_X509_BADCERT_REVOKED: u32 = 2;
pub const MBEDTLS_X509_BADCERT_CN_MISMATCH: u32 = 4;
pub const MBEDTLS_X509_BADCERT_NOT_TRUSTED: u32 = 8;
pub const MBEDTLS_X509_BADCRL_NOT_TRUSTED: u32 = 16;
pub const MBEDTLS_X509_BADCRL_EXPIRED: u32 = 32;
pub const MBEDTLS_X509_BADCERT_MISSING: u32 = 64;
pub const MBEDTLS_X509_BADCERT_SKIP_VERIFY: u32 = 128;
pub const MBEDTLS_X509_BADCERT_OTHER: u32 = 256;
pub const MBEDTLS_X509_BADCERT_FUTURE: u32 = 512;
pub const MBEDTLS_X509_BADCRL_FUTURE: u32 = 1024;
pub const MBEDTLS_X509_BADCERT_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_X509_BADCERT_EXT_KEY_USAGE: u32 = 4096;
pub const MBEDTLS_X509_BADCERT_NS_CERT_TYPE: u32 = 8192;
pub const MBEDTLS_X509_BADCERT_BAD_MD: u32 = 16384;
pub const MBEDTLS_X509_BADCERT_BAD_PK: u32 = 32768;
pub const MBEDTLS_X509_BADCERT_BAD_KEY: u32 = 65536;
pub const MBEDTLS_X509_BADCRL_BAD_MD: u32 = 131072;
pub const MBEDTLS_X509_BADCRL_BAD_PK: u32 = 262144;
pub const MBEDTLS_X509_BADCRL_BAD_KEY: u32 = 524288;
pub const MBEDTLS_X509_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const MBEDTLS_X509_KU_NON_REPUDIATION: u32 = 64;
pub const MBEDTLS_X509_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const MBEDTLS_X509_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const MBEDTLS_X509_KU_KEY_AGREEMENT: u32 = 8;
pub const MBEDTLS_X509_KU_KEY_CERT_SIGN: u32 = 4;
pub const MBEDTLS_X509_KU_CRL_SIGN: u32 = 2;
pub const MBEDTLS_X509_KU_ENCIPHER_ONLY: u32 = 1;
pub const MBEDTLS_X509_KU_DECIPHER_ONLY: u32 = 32768;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT: u32 = 128;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER: u32 = 64;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL: u32 = 32;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING: u32 = 16;
pub const MBEDTLS_X509_NS_CERT_TYPE_RESERVED: u32 = 8;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CA: u32 = 4;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA: u32 = 2;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: u32 = 1;
pub const MBEDTLS_X509_EXT_AUTHORITY_KEY_IDENTIFIER: u32 = 1;
pub const MBEDTLS_X509_EXT_SUBJECT_KEY_IDENTIFIER: u32 = 2;
pub const MBEDTLS_X509_EXT_KEY_USAGE: u32 = 4;
pub const MBEDTLS_X509_EXT_CERTIFICATE_POLICIES: u32 = 8;
pub const MBEDTLS_X509_EXT_POLICY_MAPPINGS: u32 = 16;
pub const MBEDTLS_X509_EXT_SUBJECT_ALT_NAME: u32 = 32;
pub const MBEDTLS_X509_EXT_ISSUER_ALT_NAME: u32 = 64;
pub const MBEDTLS_X509_EXT_SUBJECT_DIRECTORY_ATTRS: u32 = 128;
pub const MBEDTLS_X509_EXT_BASIC_CONSTRAINTS: u32 = 256;
pub const MBEDTLS_X509_EXT_NAME_CONSTRAINTS: u32 = 512;
pub const MBEDTLS_X509_EXT_POLICY_CONSTRAINTS: u32 = 1024;
pub const MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_X509_EXT_CRL_DISTRIBUTION_POINTS: u32 = 4096;
pub const MBEDTLS_X509_EXT_INIHIBIT_ANYPOLICY: u32 = 8192;
pub const MBEDTLS_X509_EXT_FRESHEST_CRL: u32 = 16384;
pub const MBEDTLS_X509_EXT_NS_CERT_TYPE: u32 = 65536;
pub const MBEDTLS_X509_FORMAT_DER: u32 = 1;
pub const MBEDTLS_X509_FORMAT_PEM: u32 = 2;
pub const MBEDTLS_X509_MAX_DN_NAME_SIZE: u32 = 256;
pub const MBEDTLS_X509_CRT_VERSION_1: u32 = 0;
pub const MBEDTLS_X509_CRT_VERSION_2: u32 = 1;
pub const MBEDTLS_X509_CRT_VERSION_3: u32 = 2;
pub const MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN: u32 = 32;
pub const MBEDTLS_X509_RFC5280_UTC_TIME_LEN: u32 = 15;
pub const MBEDTLS_X509_MAX_FILE_PATH_LEN: u32 = 512;
pub const MBEDTLS_ERR_DHM_BAD_INPUT_DATA: i32 = -12416;
pub const MBEDTLS_ERR_DHM_READ_PARAMS_FAILED: i32 = -12544;
pub const MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED: i32 = -12672;
pub const MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED: i32 = -12800;
pub const MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED: i32 = -12928;
pub const MBEDTLS_ERR_DHM_CALC_SECRET_FAILED: i32 = -13056;
pub const MBEDTLS_ERR_DHM_INVALID_FORMAT: i32 = -13184;
pub const MBEDTLS_ERR_DHM_ALLOC_FAILED: i32 = -13312;
pub const MBEDTLS_ERR_DHM_FILE_IO_ERROR: i32 = -13440;
pub const MBEDTLS_ERR_DHM_HW_ACCEL_FAILED: i32 = -13568;
pub const MBEDTLS_ERR_DHM_SET_GROUP_FAILED: i32 = -13696;
pub const MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE: i32 = -28800;
pub const MBEDTLS_ERR_SSL_BAD_INPUT_DATA: i32 = -28928;
pub const MBEDTLS_ERR_SSL_INVALID_MAC: i32 = -29056;
pub const MBEDTLS_ERR_SSL_INVALID_RECORD: i32 = -29184;
pub const MBEDTLS_ERR_SSL_CONN_EOF: i32 = -29312;
pub const MBEDTLS_ERR_SSL_UNKNOWN_CIPHER: i32 = -29440;
pub const MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN: i32 = -29568;
pub const MBEDTLS_ERR_SSL_NO_RNG: i32 = -29696;
pub const MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE: i32 = -29824;
pub const MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE: i32 = -29952;
pub const MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED: i32 = -30080;
pub const MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED: i32 = -30208;
pub const MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED: i32 = -30336;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE: i32 = -30464;
pub const MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE: i32 = -30592;
pub const MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED: i32 = -30720;
pub const MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY: i32 = -30848;
pub const MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO: i32 = -30976;
pub const MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO: i32 = -31104;
pub const MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE: i32 = -31232;
pub const MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST: i32 = -31360;
pub const MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE: i32 = -31488;
pub const MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE: i32 = -31616;
pub const MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE: i32 = -31744;
pub const MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP: i32 = -31872;
pub const MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS: i32 = -32000;
pub const MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY: i32 = -32128;
pub const MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC: i32 = -32256;
pub const MBEDTLS_ERR_SSL_BAD_HS_FINISHED: i32 = -32384;
pub const MBEDTLS_ERR_SSL_ALLOC_FAILED: i32 = -32512;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FAILED: i32 = -32640;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH: i32 = -28544;
pub const MBEDTLS_ERR_SSL_COMPRESSION_FAILED: i32 = -28416;
pub const MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION: i32 = -28288;
pub const MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET: i32 = -28160;
pub const MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED: i32 = -28032;
pub const MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH: i32 = -27904;
pub const MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY: i32 = -27776;
pub const MBEDTLS_ERR_SSL_INTERNAL_ERROR: i32 = -27648;
pub const MBEDTLS_ERR_SSL_COUNTER_WRAPPING: i32 = -27520;
pub const MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO: i32 = -27392;
pub const MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED: i32 = -27264;
pub const MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL: i32 = -27136;
pub const MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE: i32 = -27008;
pub const MBEDTLS_ERR_SSL_WANT_READ: i32 = -26880;
pub const MBEDTLS_ERR_SSL_WANT_WRITE: i32 = -26752;
pub const MBEDTLS_ERR_SSL_TIMEOUT: i32 = -26624;
pub const MBEDTLS_ERR_SSL_CLIENT_RECONNECT: i32 = -26496;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_RECORD: i32 = -26368;
pub const MBEDTLS_ERR_SSL_NON_FATAL: i32 = -26240;
pub const MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH: i32 = -26112;
pub const MBEDTLS_ERR_SSL_CONTINUE_PROCESSING: i32 = -25984;
pub const MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS: i32 = -25856;
pub const MBEDTLS_ERR_SSL_EARLY_MESSAGE: i32 = -25728;
pub const MBEDTLS_SSL_MAJOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_MINOR_VERSION_0: u32 = 0;
pub const MBEDTLS_SSL_MINOR_VERSION_1: u32 = 1;
pub const MBEDTLS_SSL_MINOR_VERSION_2: u32 = 2;
pub const MBEDTLS_SSL_MINOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_TRANSPORT_STREAM: u32 = 0;
pub const MBEDTLS_SSL_TRANSPORT_DATAGRAM: u32 = 1;
pub const MBEDTLS_SSL_MAX_HOST_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_NONE: u32 = 0;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_512: u32 = 1;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_1024: u32 = 2;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_2048: u32 = 3;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_4096: u32 = 4;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_INVALID: u32 = 5;
pub const MBEDTLS_SSL_IS_CLIENT: u32 = 0;
pub const MBEDTLS_SSL_IS_SERVER: u32 = 1;
pub const MBEDTLS_SSL_IS_NOT_FALLBACK: u32 = 0;
pub const MBEDTLS_SSL_IS_FALLBACK: u32 = 1;
pub const MBEDTLS_SSL_EXTENDED_MS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EXTENDED_MS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ETM_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ETM_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_COMPRESS_NULL: u32 = 0;
pub const MBEDTLS_SSL_COMPRESS_DEFLATE: u32 = 1;
pub const MBEDTLS_SSL_VERIFY_NONE: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_OPTIONAL: u32 = 1;
pub const MBEDTLS_SSL_VERIFY_REQUIRED: u32 = 2;
pub const MBEDTLS_SSL_VERIFY_UNSET: u32 = 3;
pub const MBEDTLS_SSL_LEGACY_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_SECURE_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_RENEGOTIATION_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ANTI_REPLAY_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ANTI_REPLAY_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED: i32 = -1;
pub const MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT: u32 = 16;
pub const MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE: u32 = 2;
pub const MBEDTLS_SSL_TRUNC_HMAC_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_TRUNC_HMAC_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_TRUNCATED_HMAC_LEN: u32 = 10;
pub const MBEDTLS_SSL_SESSION_TICKETS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_SESSION_TICKETS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ARC4_ENABLED: u32 = 0;
pub const MBEDTLS_SSL_ARC4_DISABLED: u32 = 1;
pub const MBEDTLS_SSL_PRESET_DEFAULT: u32 = 0;
pub const MBEDTLS_SSL_PRESET_SUITEB: u32 = 2;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN: u32 = 1000;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX: u32 = 60000;
pub const MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME: u32 = 86400;
pub const MBEDTLS_SSL_MAX_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_DTLS_MAX_BUFFERING: u32 = 32768;
pub const MBEDTLS_SSL_VERIFY_DATA_MAX_LEN: u32 = 12;
pub const MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO: u32 = 255;
pub const MBEDTLS_SSL_FALLBACK_SCSV_VALUE: u32 = 22016;
pub const MBEDTLS_SSL_HASH_NONE: u32 = 0;
pub const MBEDTLS_SSL_HASH_MD5: u32 = 1;
pub const MBEDTLS_SSL_HASH_SHA1: u32 = 2;
pub const MBEDTLS_SSL_HASH_SHA224: u32 = 3;
pub const MBEDTLS_SSL_HASH_SHA256: u32 = 4;
pub const MBEDTLS_SSL_HASH_SHA384: u32 = 5;
pub const MBEDTLS_SSL_HASH_SHA512: u32 = 6;
pub const MBEDTLS_SSL_SIG_ANON: u32 = 0;
pub const MBEDTLS_SSL_SIG_RSA: u32 = 1;
pub const MBEDTLS_SSL_SIG_ECDSA: u32 = 3;
pub const MBEDTLS_SSL_CERT_TYPE_RSA_SIGN: u32 = 1;
pub const MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN: u32 = 64;
pub const MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC: u32 = 20;
pub const MBEDTLS_SSL_MSG_ALERT: u32 = 21;
pub const MBEDTLS_SSL_MSG_HANDSHAKE: u32 = 22;
pub const MBEDTLS_SSL_MSG_APPLICATION_DATA: u32 = 23;
pub const MBEDTLS_SSL_ALERT_LEVEL_WARNING: u32 = 1;
pub const MBEDTLS_SSL_ALERT_LEVEL_FATAL: u32 = 2;
pub const MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY: u32 = 0;
pub const MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE: u32 = 10;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC: u32 = 20;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPTION_FAILED: u32 = 21;
pub const MBEDTLS_SSL_ALERT_MSG_RECORD_OVERFLOW: u32 = 22;
pub const MBEDTLS_SSL_ALERT_MSG_DECOMPRESSION_FAILURE: u32 = 30;
pub const MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE: u32 = 40;
pub const MBEDTLS_SSL_ALERT_MSG_NO_CERT: u32 = 41;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_CERT: u32 = 42;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT: u32 = 43;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED: u32 = 44;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED: u32 = 45;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN: u32 = 46;
pub const MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER: u32 = 47;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA: u32 = 48;
pub const MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED: u32 = 49;
pub const MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR: u32 = 50;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR: u32 = 51;
pub const MBEDTLS_SSL_ALERT_MSG_EXPORT_RESTRICTION: u32 = 60;
pub const MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION: u32 = 70;
pub const MBEDTLS_SSL_ALERT_MSG_INSUFFICIENT_SECURITY: u32 = 71;
pub const MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR: u32 = 80;
pub const MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK: u32 = 86;
pub const MBEDTLS_SSL_ALERT_MSG_USER_CANCELED: u32 = 90;
pub const MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION: u32 = 100;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT: u32 = 110;
pub const MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME: u32 = 112;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const MBEDTLS_SSL_HS_HELLO_REQUEST: u32 = 0;
pub const MBEDTLS_SSL_HS_CLIENT_HELLO: u32 = 1;
pub const MBEDTLS_SSL_HS_SERVER_HELLO: u32 = 2;
pub const MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST: u32 = 3;
pub const MBEDTLS_SSL_HS_NEW_SESSION_TICKET: u32 = 4;
pub const MBEDTLS_SSL_HS_CERTIFICATE: u32 = 11;
pub const MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE: u32 = 12;
pub const MBEDTLS_SSL_HS_CERTIFICATE_REQUEST: u32 = 13;
pub const MBEDTLS_SSL_HS_SERVER_HELLO_DONE: u32 = 14;
pub const MBEDTLS_SSL_HS_CERTIFICATE_VERIFY: u32 = 15;
pub const MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const MBEDTLS_SSL_HS_FINISHED: u32 = 20;
pub const MBEDTLS_TLS_EXT_SERVERNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH: u32 = 1;
pub const MBEDTLS_TLS_EXT_TRUNCATED_HMAC: u32 = 4;
pub const MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS: u32 = 11;
pub const MBEDTLS_TLS_EXT_SIG_ALG: u32 = 13;
pub const MBEDTLS_TLS_EXT_ALPN: u32 = 16;
pub const MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC: u32 = 22;
pub const MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET: u32 = 23;
pub const MBEDTLS_TLS_EXT_SESSION_TICKET: u32 = 35;
pub const MBEDTLS_TLS_EXT_ECJPAKE_KKPP: u32 = 256;
pub const MBEDTLS_TLS_EXT_RENEGOTIATION_INFO: u32 = 65281;
pub const MBEDTLS_PSK_MAX_LEN: u32 = 32;
pub const MBEDTLS_ERR_NET_SOCKET_FAILED: i32 = -66;
pub const MBEDTLS_ERR_NET_CONNECT_FAILED: i32 = -68;
pub const MBEDTLS_ERR_NET_BIND_FAILED: i32 = -70;
pub const MBEDTLS_ERR_NET_LISTEN_FAILED: i32 = -72;
pub const MBEDTLS_ERR_NET_ACCEPT_FAILED: i32 = -74;
pub const MBEDTLS_ERR_NET_RECV_FAILED: i32 = -76;
pub const MBEDTLS_ERR_NET_SEND_FAILED: i32 = -78;
pub const MBEDTLS_ERR_NET_CONN_RESET: i32 = -80;
pub const MBEDTLS_ERR_NET_UNKNOWN_HOST: i32 = -82;
pub const MBEDTLS_ERR_NET_BUFFER_TOO_SMALL: i32 = -67;
pub const MBEDTLS_ERR_NET_INVALID_CONTEXT: i32 = -69;
pub const MBEDTLS_ERR_NET_POLL_FAILED: i32 = -71;
pub const MBEDTLS_ERR_NET_BAD_INPUT_DATA: i32 = -73;
pub const MBEDTLS_NET_LISTEN_BACKLOG: u32 = 10;
pub const MBEDTLS_NET_PROTO_TCP: u32 = 0;
pub const MBEDTLS_NET_PROTO_UDP: u32 = 1;
pub const MBEDTLS_NET_POLL_READ: u32 = 1;
pub const MBEDTLS_NET_POLL_WRITE: u32 = 2;
pub const MBEDTLS_ERR_SHA512_HW_ACCEL_FAILED: i32 = -57;
pub const MBEDTLS_ERR_ENTROPY_SOURCE_FAILED: i32 = -60;
pub const MBEDTLS_ERR_ENTROPY_MAX_SOURCES: i32 = -62;
pub const MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED: i32 = -64;
pub const MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE: i32 = -61;
pub const MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR: i32 = -63;
pub const MBEDTLS_ENTROPY_MAX_SOURCES: u32 = 20;
pub const MBEDTLS_ENTROPY_MAX_GATHER: u32 = 128;
pub const MBEDTLS_ENTROPY_BLOCK_SIZE: u32 = 64;
pub const MBEDTLS_ENTROPY_MAX_SEED_SIZE: u32 = 1024;
pub const MBEDTLS_ENTROPY_SOURCE_MANUAL: u32 = 20;
pub const MBEDTLS_ENTROPY_SOURCE_STRONG: u32 = 1;
pub const MBEDTLS_ENTROPY_SOURCE_WEAK: u32 = 0;
pub const MBEDTLS_AES_ENCRYPT: u32 = 1;
pub const MBEDTLS_AES_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_AES_INVALID_KEY_LENGTH: i32 = -32;
pub const MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH: i32 = -34;
pub const MBEDTLS_ERR_AES_BAD_INPUT_DATA: i32 = -33;
pub const MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE: i32 = -35;
pub const MBEDTLS_ERR_AES_HW_ACCEL_FAILED: i32 = -37;
pub const MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED: i32 = -52;
pub const MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG: i32 = -54;
pub const MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG: i32 = -56;
pub const MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR: i32 = -58;
pub const MBEDTLS_CTR_DRBG_BLOCKSIZE: u32 = 16;
pub const MBEDTLS_CTR_DRBG_KEYSIZE: u32 = 32;
pub const MBEDTLS_CTR_DRBG_KEYBITS: u32 = 256;
pub const MBEDTLS_CTR_DRBG_SEEDLEN: u32 = 48;
pub const MBEDTLS_CTR_DRBG_ENTROPY_LEN: u32 = 48;
pub const MBEDTLS_CTR_DRBG_RESEED_INTERVAL: u32 = 10000;
pub const MBEDTLS_CTR_DRBG_MAX_INPUT: u32 = 256;
pub const MBEDTLS_CTR_DRBG_MAX_REQUEST: u32 = 1024;
pub const MBEDTLS_CTR_DRBG_MAX_SEED_INPUT: u32 = 384;
pub const MBEDTLS_CTR_DRBG_PR_OFF: u32 = 0;
pub const MBEDTLS_CTR_DRBG_PR_ON: u32 = 1;
pub const SNTP_MAX_SERVERS: u32 = 1;
pub const SNTP_GET_SERVERS_FROM_DHCP: u32 = 0;
pub const SNTP_SERVER_DNS: u32 = 1;
pub const SNTP_DEBUG: u32 = 0;
pub const SNTP_PORT: u32 = 123;
pub const SNTP_CHECK_RESPONSE: u32 = 0;
pub const SNTP_STARTUP_DELAY: u32 = 0;
pub const SNTP_STARTUP_DELAY_FUNC: u32 = 0;
pub const SNTP_RECV_TIMEOUT: u32 = 3000;
pub const SNTP_UPDATE_DELAY: u32 = 3600000;
pub const SNTP_RETRY_TIMEOUT: u32 = 3000;
pub const SNTP_RETRY_TIMEOUT_MAX: u32 = 30000;
pub const SNTP_RETRY_TIMEOUT_EXP: u32 = 1;
pub const SNTP_OPMODE_POLL: u32 = 0;
pub const SNTP_OPMODE_LISTENONLY: u32 = 1;
pub type _off_t = cty::c_long;
pub type __dev_t = cty::c_short;
pub type __uid_t = cty::c_ushort;
pub type __gid_t = cty::c_ushort;
pub type _ssize_t = cty::c_int;
pub type _lock_t = cty::c_int;
pub type _LOCK_RECURSIVE_T = _lock_t;
pub type _LOCK_T = _lock_t;
pub type _data = *mut _reent;
pub type wchar_t = cty::c_uchar;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __intptr_t = cty::c_int;
pub type __uintptr_t = cty::c_uint;
pub type __off_t = cty::c_long;
pub type __pid_t = cty::c_int;
pub type __loff_t = cty::c_longlong;
pub type u_char = cty::c_uchar;
pub type u_short = cty::c_ushort;
pub type u_int = cty::c_uint;
pub type u_long = cty::c_ulong;
pub type ushort = cty::c_ushort;
pub type uint = cty::c_uint;
pub type ulong = cty::c_ulong;
pub type clock_t = cty::c_ulong;
pub type time_t = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type daddr_t = cty::c_long;
pub type caddr_t = *mut cty::c_char;
pub type ino_t = cty::c_ushort;
pub type off_t = _off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = cty::c_int;
pub type key_t = cty::c_long;
pub type mode_t = cty::c_uint;
pub type nlink_t = cty::c_ushort;
pub type fd_mask = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
pub type clockid_t = cty::c_ulong;
pub type timer_t = cty::c_ulong;
pub type useconds_t = cty::c_ulong;
pub type suseconds_t = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: cty::c_int,
}
extern "C" {
    pub fn sched_yield() -> cty::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: cty::c_int,
    pub stackaddr: *mut cty::c_void,
    pub stacksize: cty::c_int,
    pub contentionscope: cty::c_int,
    pub inheritsched: cty::c_int,
    pub schedpolicy: cty::c_int,
    pub schedparam: sched_param,
    pub detachstate: cty::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: cty::c_int,
    pub type_: cty::c_int,
    pub recursive: cty::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: cty::c_int,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: cty::c_int,
    pub init_executed: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: cty::c_int,
    pub tm_min: cty::c_int,
    pub tm_hour: cty::c_int,
    pub tm_mday: cty::c_int,
    pub tm_mon: cty::c_int,
    pub tm_year: cty::c_int,
    pub tm_wday: cty::c_int,
    pub tm_yday: cty::c_int,
    pub tm_isdst: cty::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut cty::c_char,
        _maxsize: usize,
        _fmt: *const cty::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn strptime(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut tm,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzrule_struct {
    pub ch: cty::c_char,
    pub m: cty::c_int,
    pub n: cty::c_int,
    pub d: cty::c_int,
    pub s: cty::c_int,
    pub change: time_t,
    pub offset: cty::c_long,
}
pub type __tzrule_type = __tzrule_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzinfo_struct {
    pub __tznorth: cty::c_int,
    pub __tzyear: cty::c_int,
    pub __tzrule: [__tzrule_type; 2usize],
}
pub type __tzinfo_type = __tzinfo_struct;
extern "C" {
    pub fn __gettzinfo() -> *mut __tzinfo_type;
}
extern "C" {
    pub static mut _timezone: cty::c_long;
}
extern "C" {
    pub static mut _daylight: cty::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut cty::c_char; 2usize];
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn _lock_acquire(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_init(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_release(lock: *mut _lock_t);
}
pub type _off64_t = cty::c_longlong;
pub type _fpos_t = cty::c_long;
pub type wint_t = cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: cty::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [cty::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut cty::c_void;
pub type __ULong = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: cty::c_int,
    pub _maxwds: cty::c_int,
    pub _sign: cty::c_int,
    pub _wds: cty::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: cty::c_int,
    pub __tm_min: cty::c_int,
    pub __tm_hour: cty::c_int,
    pub __tm_mday: cty::c_int,
    pub __tm_mon: cty::c_int,
    pub __tm_year: cty::c_int,
    pub __tm_wday: cty::c_int,
    pub __tm_yday: cty::c_int,
    pub __tm_isdst: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut cty::c_void; 32usize],
    pub _dso_handle: [*mut cty::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: cty::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut cty::c_uchar,
    pub _size: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE_fake {
    pub _p: *mut cty::c_uchar,
    pub _r: cty::c_int,
    pub _w: cty::c_int,
    pub _flags: cty::c_short,
    pub _file: cty::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: cty::c_int,
    pub _data: *mut _reent,
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut cty::c_uchar,
    pub _r: cty::c_int,
    pub _w: cty::c_int,
    pub _flags: cty::c_short,
    pub _file: cty::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: cty::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut cty::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *mut cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *const cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: _fpos_t,
            arg4: cty::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut cty::c_void) -> cty::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut cty::c_uchar,
    pub _ur: cty::c_int,
    pub _ubuf: [cty::c_uchar; 3usize],
    pub _nbuf: [cty::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: cty::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: cty::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: cty::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [cty::c_ushort; 3usize],
    pub _mult: [cty::c_ushort; 3usize],
    pub _add: cty::c_ushort,
    pub _rand_next: cty::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: cty::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut cty::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [cty::c_char; 8usize],
    pub _getdate_err: cty::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
pub type intmax_t = cty::c_longlong;
pub type uintmax_t = cty::c_ulonglong;
extern "C" {
    #[doc = " This function is defined to provide a deprecation warning whenever"]
    #[doc = " XT_CLOCK_FREQ macro is used."]
    #[doc = " Update the code to use esp_clk_cpu_freq function instead."]
    #[doc = " @return current CPU clock frequency, in Hz"]
    pub fn xt_clock_freq() -> cty::c_int;
}
extern "C" {
    pub static Xthal_rev_no: cty::c_uint;
}
extern "C" {
    pub fn xthal_save_extra(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_restore_extra(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_save_cpregs(base: *mut cty::c_void, arg1: cty::c_int);
}
extern "C" {
    pub fn xthal_restore_cpregs(base: *mut cty::c_void, arg1: cty::c_int);
}
extern "C" {
    pub fn xthal_save_cp0(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_save_cp1(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_save_cp2(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_save_cp3(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_save_cp4(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_save_cp5(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_save_cp6(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_save_cp7(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_restore_cp0(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_restore_cp1(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_restore_cp2(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_restore_cp3(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_restore_cp4(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_restore_cp5(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_restore_cp6(base: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_restore_cp7(base: *mut cty::c_void);
}
extern "C" {
    pub static mut Xthal_cpregs_save_fn: [*mut cty::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_fn: [*mut cty::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_save_nw_fn: [*mut cty::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_nw_fn: [*mut cty::c_void; 8usize];
}
extern "C" {
    pub static Xthal_extra_size: cty::c_uint;
}
extern "C" {
    pub static Xthal_extra_align: cty::c_uint;
}
extern "C" {
    pub static mut Xthal_cpregs_size: [cty::c_uint; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_align: [cty::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_all_extra_size: cty::c_uint;
}
extern "C" {
    pub static Xthal_all_extra_align: cty::c_uint;
}
extern "C" {
    pub static mut Xthal_cp_names: [*const cty::c_char; 8usize];
}
extern "C" {
    pub fn xthal_init_mem_extra(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_init_mem_cp(arg1: *mut cty::c_void, arg2: cty::c_int);
}
extern "C" {
    pub static Xthal_num_coprocessors: cty::c_uint;
}
extern "C" {
    pub static Xthal_cp_num: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_max: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask: cty::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs: cty::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs_log2: cty::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linewidth: cty::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_linewidth: cty::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linesize: cty::c_ushort;
}
extern "C" {
    pub static Xthal_dcache_linesize: cty::c_ushort;
}
extern "C" {
    pub static Xthal_icache_size: cty::c_uint;
}
extern "C" {
    pub static Xthal_dcache_size: cty::c_uint;
}
extern "C" {
    pub static Xthal_dcache_is_writeback: cty::c_uchar;
}
extern "C" {
    pub fn xthal_icache_region_invalidate(addr: *mut cty::c_void, size: cty::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_invalidate(addr: *mut cty::c_void, size: cty::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_invalidate(addr: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_invalidate(addr: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback(addr: *mut cty::c_void, size: cty::c_uint);
}
extern "C" {
    pub fn xthal_dcache_line_writeback(addr: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback_inv(addr: *mut cty::c_void, size: cty::c_uint);
}
extern "C" {
    pub fn xthal_dcache_line_writeback_inv(addr: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_icache_sync();
}
extern "C" {
    pub fn xthal_dcache_sync();
}
extern "C" {
    pub fn xthal_icache_get_ways() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_icache_set_ways(ways: cty::c_uint);
}
extern "C" {
    pub fn xthal_dcache_get_ways() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_dcache_set_ways(ways: cty::c_uint);
}
extern "C" {
    pub fn xthal_cache_coherence_on();
}
extern "C" {
    pub fn xthal_cache_coherence_off();
}
extern "C" {
    pub fn xthal_cache_coherence_optin();
}
extern "C" {
    pub fn xthal_cache_coherence_optout();
}
extern "C" {
    pub fn xthal_get_cache_prefetch() -> cty::c_int;
}
extern "C" {
    pub fn xthal_set_cache_prefetch(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn xthal_set_cache_prefetch_long(arg1: cty::c_ulonglong) -> cty::c_int;
}
extern "C" {
    pub static Xthal_debug_configured: cty::c_int;
}
extern "C" {
    pub fn xthal_set_soft_break(addr: *mut cty::c_void) -> cty::c_uint;
}
extern "C" {
    pub fn xthal_remove_soft_break(addr: *mut cty::c_void, arg1: cty::c_uint);
}
extern "C" {
    pub fn xthal_disassemble(
        instr_buf: *mut cty::c_uchar,
        tgt_addr: *mut cty::c_void,
        buffer: *mut cty::c_char,
        buflen: cty::c_uint,
        options: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xthal_disassemble_size(instr_buf: *mut cty::c_uchar) -> cty::c_int;
}
extern "C" {
    pub fn xthal_memcpy(
        dst: *mut cty::c_void,
        src: *const cty::c_void,
        len: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn xthal_bcopy(
        src: *const cty::c_void,
        dst: *mut cty::c_void,
        len: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn xthal_compare_and_set(
        addr: *mut cty::c_int,
        test_val: cty::c_int,
        compare_val: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub static Xthal_release_major: cty::c_uint;
}
extern "C" {
    pub static Xthal_release_minor: cty::c_uint;
}
extern "C" {
    pub static Xthal_release_name: *const cty::c_char;
}
extern "C" {
    pub static Xthal_release_internal: *const cty::c_char;
}
extern "C" {
    pub static Xthal_memory_order: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_windowed: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_density: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_booleans: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_loops: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_nsa: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_minmax: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_sext: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_clamps: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_mac16: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_mul16: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_fp: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_speculation: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_threadptr: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_pif: cty::c_uchar;
}
extern "C" {
    pub static Xthal_num_writebuffer_entries: cty::c_ushort;
}
extern "C" {
    pub static Xthal_build_unique_id: cty::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid0: cty::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid1: cty::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_major: cty::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_minor: cty::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_name: *const cty::c_char;
}
extern "C" {
    pub static Xthal_hw_release_internal: *const cty::c_char;
}
extern "C" {
    pub fn xthal_clear_regcached_code();
}
extern "C" {
    pub fn xthal_window_spill();
}
extern "C" {
    pub fn xthal_validate_cp(arg1: cty::c_int);
}
extern "C" {
    pub fn xthal_invalidate_cp(arg1: cty::c_int);
}
extern "C" {
    pub fn xthal_set_cpenable(arg1: cty::c_uint);
}
extern "C" {
    pub fn xthal_get_cpenable() -> cty::c_uint;
}
extern "C" {
    pub static Xthal_num_intlevels: cty::c_uchar;
}
extern "C" {
    pub static Xthal_num_interrupts: cty::c_uchar;
}
extern "C" {
    pub static Xthal_excm_level: cty::c_uchar;
}
extern "C" {
    pub static mut Xthal_intlevel_mask: [cty::c_uint; 16usize];
}
extern "C" {
    pub static mut Xthal_intlevel_andbelow_mask: [cty::c_uint; 16usize];
}
extern "C" {
    pub static mut Xthal_intlevel: [cty::c_uchar; 32usize];
}
extern "C" {
    pub static mut Xthal_inttype: [cty::c_uchar; 32usize];
}
extern "C" {
    pub static mut Xthal_inttype_mask: [cty::c_uint; 8usize];
}
extern "C" {
    pub static mut Xthal_timer_interrupt: [cty::c_int; 4usize];
}
extern "C" {
    pub fn xthal_get_intenable() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_set_intenable(arg1: cty::c_uint);
}
extern "C" {
    pub fn xthal_get_interrupt() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_set_intset(arg1: cty::c_uint);
}
extern "C" {
    pub fn xthal_set_intclear(arg1: cty::c_uint);
}
extern "C" {
    pub static Xthal_num_ibreak: cty::c_int;
}
extern "C" {
    pub static Xthal_num_dbreak: cty::c_int;
}
extern "C" {
    pub static Xthal_have_ccount: cty::c_uchar;
}
extern "C" {
    pub static Xthal_num_ccompare: cty::c_uchar;
}
extern "C" {
    pub fn xthal_get_ccount() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_set_ccompare(arg1: cty::c_int, arg2: cty::c_uint);
}
extern "C" {
    pub fn xthal_get_ccompare(arg1: cty::c_int) -> cty::c_uint;
}
extern "C" {
    pub static Xthal_have_prid: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_exceptions: cty::c_uchar;
}
extern "C" {
    pub static Xthal_xea_version: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_interrupts: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_highlevel_interrupts: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_nmi: cty::c_uchar;
}
extern "C" {
    pub fn xthal_get_prid() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_vpri_to_intlevel(vpri: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn xthal_intlevel_to_vpri(intlevel: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn xthal_int_enable(arg1: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn xthal_int_disable(arg1: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn xthal_set_int_vpri(intnum: cty::c_int, vpri: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn xthal_get_int_vpri(intnum: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn xthal_set_vpri_locklevel(intlevel: cty::c_uint);
}
extern "C" {
    pub fn xthal_get_vpri_locklevel() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri(vpri: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn xthal_get_vpri() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_intlevel(intlevel: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_lock() -> cty::c_uint;
}
pub type XtHalVoidFunc = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut Xthal_tram_pending: cty::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_enabled: cty::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_sync: cty::c_uint;
}
extern "C" {
    pub fn xthal_tram_pending_to_service() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_tram_done(serviced_mask: cty::c_uint);
}
extern "C" {
    pub fn xthal_tram_set_sync(intnum: cty::c_int, sync: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn xthal_set_tram_trigger_func(trigger_fn: XtHalVoidFunc) -> XtHalVoidFunc;
}
extern "C" {
    pub static Xthal_num_instrom: cty::c_uchar;
}
extern "C" {
    pub static Xthal_num_instram: cty::c_uchar;
}
extern "C" {
    pub static Xthal_num_datarom: cty::c_uchar;
}
extern "C" {
    pub static Xthal_num_dataram: cty::c_uchar;
}
extern "C" {
    pub static Xthal_num_xlmi: cty::c_uchar;
}
extern "C" {
    pub static mut Xthal_instrom_vaddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_paddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_size: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_vaddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_paddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_size: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_vaddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_paddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_size: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_vaddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_paddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_size: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_vaddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_paddr: [cty::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_size: [cty::c_uint; 0usize];
}
extern "C" {
    pub static Xthal_icache_setwidth: cty::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_setwidth: cty::c_uchar;
}
extern "C" {
    pub static Xthal_icache_ways: cty::c_uint;
}
extern "C" {
    pub static Xthal_dcache_ways: cty::c_uint;
}
extern "C" {
    pub static Xthal_icache_line_lockable: cty::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_line_lockable: cty::c_uchar;
}
extern "C" {
    pub fn xthal_get_cacheattr() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_get_icacheattr() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_get_dcacheattr() -> cty::c_uint;
}
extern "C" {
    pub fn xthal_set_cacheattr(arg1: cty::c_uint);
}
extern "C" {
    pub fn xthal_set_icacheattr(arg1: cty::c_uint);
}
extern "C" {
    pub fn xthal_set_dcacheattr(arg1: cty::c_uint);
}
extern "C" {
    pub fn xthal_set_region_attribute(
        addr: *mut cty::c_void,
        size: cty::c_uint,
        cattr: cty::c_uint,
        flags: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xthal_icache_enable();
}
extern "C" {
    pub fn xthal_dcache_enable();
}
extern "C" {
    pub fn xthal_icache_disable();
}
extern "C" {
    pub fn xthal_dcache_disable();
}
extern "C" {
    pub fn xthal_icache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_writeback();
}
extern "C" {
    pub fn xthal_dcache_all_writeback_inv();
}
extern "C" {
    pub fn xthal_icache_region_lock(addr: *mut cty::c_void, size: cty::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_lock(addr: *mut cty::c_void, size: cty::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_lock(addr: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_lock(addr: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_icache_all_unlock();
}
extern "C" {
    pub fn xthal_dcache_all_unlock();
}
extern "C" {
    pub fn xthal_icache_region_unlock(addr: *mut cty::c_void, size: cty::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_unlock(addr: *mut cty::c_void, size: cty::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_unlock(addr: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_unlock(addr: *mut cty::c_void);
}
extern "C" {
    pub fn xthal_memep_inject_error(addr: *mut cty::c_void, size: cty::c_int, flags: cty::c_int);
}
extern "C" {
    pub static Xthal_have_spanning_way: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_identity_map: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_mimic_cacheattr: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_xlt_cacheattr: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_cacheattr: cty::c_uchar;
}
extern "C" {
    pub static Xthal_have_tlbs: cty::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_bits: cty::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_kernel: cty::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_rings: cty::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ring_bits: cty::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_sr_bits: cty::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ca_bits: cty::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_max_pte_page_size: cty::c_uint;
}
extern "C" {
    pub static Xthal_mmu_min_pte_page_size: cty::c_uint;
}
extern "C" {
    pub static Xthal_itlb_way_bits: cty::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_ways: cty::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_arf_ways: cty::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_way_bits: cty::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_ways: cty::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_arf_ways: cty::c_uchar;
}
extern "C" {
    #[doc = " WARNING: these two functions may go away in a future release; don't depend on them!"]
    pub fn xthal_static_v2p(vaddr: cty::c_uint, paddrp: *mut cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn xthal_static_p2v(
        paddr: cty::c_uint,
        vaddrp: *mut cty::c_uint,
        cached: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xthal_set_region_translation(
        vaddr: *mut cty::c_void,
        paddr: *mut cty::c_void,
        size: cty::c_uint,
        cache_atr: cty::c_uint,
        flags: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xthal_v2p(
        arg1: *mut cty::c_void,
        arg2: *mut *mut cty::c_void,
        arg3: *mut cty::c_uint,
        arg4: *mut cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xthal_invalidate_region(addr: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xthal_set_region_translation_raw(
        vaddr: *mut cty::c_void,
        paddr: *mut cty::c_void,
        cattr: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub static Xthal_cp_id_FPU: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_FPU: cty::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP1_IDENT: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP1_IDENT: cty::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP2_IDENT: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP2_IDENT: cty::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP3_IDENT: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP3_IDENT: cty::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP4_IDENT: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP4_IDENT: cty::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP5_IDENT: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP5_IDENT: cty::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP6_IDENT: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP6_IDENT: cty::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP7_IDENT: cty::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP7_IDENT: cty::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelFrame {
    pub pc: cty::c_long,
    pub ps: cty::c_long,
    pub areg: [cty::c_long; 4usize],
    pub sar: cty::c_long,
    pub lcount: cty::c_long,
    pub lbeg: cty::c_long,
    pub lend: cty::c_long,
    pub acclo: cty::c_long,
    pub acchi: cty::c_long,
    pub mr: [cty::c_long; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserFrame {
    pub pc: cty::c_long,
    pub ps: cty::c_long,
    pub sar: cty::c_long,
    pub vpri: cty::c_long,
    pub a2: cty::c_long,
    pub a3: cty::c_long,
    pub a4: cty::c_long,
    pub a5: cty::c_long,
    pub exccause: cty::c_long,
    pub lcount: cty::c_long,
    pub lbeg: cty::c_long,
    pub lend: cty::c_long,
    pub acclo: cty::c_long,
    pub acchi: cty::c_long,
    pub mr: [cty::c_long; 4usize],
    pub pad: [cty::c_long; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtExcFrame {
    pub exit: cty::c_long,
    pub pc: cty::c_long,
    pub ps: cty::c_long,
    pub a0: cty::c_long,
    pub a1: cty::c_long,
    pub a2: cty::c_long,
    pub a3: cty::c_long,
    pub a4: cty::c_long,
    pub a5: cty::c_long,
    pub a6: cty::c_long,
    pub a7: cty::c_long,
    pub a8: cty::c_long,
    pub a9: cty::c_long,
    pub a10: cty::c_long,
    pub a11: cty::c_long,
    pub a12: cty::c_long,
    pub a13: cty::c_long,
    pub a14: cty::c_long,
    pub a15: cty::c_long,
    pub sar: cty::c_long,
    pub exccause: cty::c_long,
    pub excvaddr: cty::c_long,
    pub lbeg: cty::c_long,
    pub lend: cty::c_long,
    pub lcount: cty::c_long,
    pub tmp0: cty::c_long,
    pub tmp1: cty::c_long,
    pub tmp2: cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtSolFrame {
    pub exit: cty::c_long,
    pub pc: cty::c_long,
    pub ps: cty::c_long,
    pub next: cty::c_long,
    pub a0: cty::c_long,
    pub a1: cty::c_long,
    pub a2: cty::c_long,
    pub a3: cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: cty::c_int,
    pub rem: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: cty::c_longlong,
    pub rem: cty::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> cty::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const cty::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const cty::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const cty::c_void,
        __base: *const cty::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: cty::c_uint, __size: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn div(__numer: cty::c_int, __denom: cty::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: cty::c_int);
}
extern "C" {
    pub fn free(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn getenv(__string: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _getenv_r(arg1: *mut _reent, __string: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _findenv(arg1: *const cty::c_char, arg2: *mut cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut cty::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut cty::c_char,
        arg2: *const *mut cty::c_char,
        arg3: *mut *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn labs(arg1: cty::c_long) -> cty::c_long;
}
extern "C" {
    pub fn ldiv(__numer: cty::c_long, __denom: cty::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(__size: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const cty::c_char, arg2: usize) -> cty::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const cty::c_char, arg3: usize) -> cty::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const cty::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut cty::c_char, arg2: wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const cty::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const cty::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut cty::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn mkostemp(arg1: *mut cty::c_char, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn mkostemps(arg1: *mut cty::c_char, arg2: cty::c_int, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn mkstemp(arg1: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut cty::c_char, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _mkostemp_r(arg1: *mut _reent, arg2: *mut cty::c_char, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _mkstemps_r(arg1: *mut _reent, arg2: *mut cty::c_char, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn qsort(__base: *mut cty::c_void, __nmemb: usize, __size: usize, _compar: __compar_fn_t);
}
extern "C" {
    pub fn rand() -> cty::c_int;
}
extern "C" {
    pub fn realloc(__r: *mut cty::c_void, __size: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn reallocf(__r: *mut cty::c_void, __size: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn realpath(path: *const cty::c_char, resolved_path: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn srand(__seed: cty::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const cty::c_char, __end_PTR: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const cty::c_char, __end_PTR: *mut *mut cty::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn system(__string: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn a64l(__input: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn l64a(__input: cty::c_long) -> *mut cty::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: cty::c_long) -> *mut cty::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: cty::c_int, arg2: *mut cty::c_void),
        >,
        __arg: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _Exit(__status: cty::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _reallocf_r(arg1: *mut _reent, arg2: *mut cty::c_void, arg3: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const cty::c_char,
        __value: *const cty::c_char,
        __overwrite: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const cty::c_char,
        __value: *const cty::c_char,
        __overwrite: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn gcvt(arg1: f64, arg2: cty::c_int, arg3: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn gcvtf(arg1: f32, arg2: cty::c_int, arg3: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: cty::c_int,
        arg3: *mut cty::c_int,
        arg4: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn fcvtf(
        arg1: f32,
        arg2: cty::c_int,
        arg3: *mut cty::c_int,
        arg4: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: cty::c_int,
        arg3: *mut cty::c_int,
        arg4: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn ecvtbuf(
        arg1: f64,
        arg2: cty::c_int,
        arg3: *mut cty::c_int,
        arg4: *mut cty::c_int,
        arg5: *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn fcvtbuf(
        arg1: f64,
        arg2: cty::c_int,
        arg3: *mut cty::c_int,
        arg4: *mut cty::c_int,
        arg5: *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn ecvtf(
        arg1: f32,
        arg2: cty::c_int,
        arg3: *mut cty::c_int,
        arg4: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn dtoa(
        arg1: f64,
        arg2: cty::c_int,
        arg3: cty::c_int,
        arg4: *mut cty::c_int,
        arg5: *mut cty::c_int,
        arg6: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn __itoa(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn __utoa(arg1: cty::c_uint, arg2: *mut cty::c_char, arg3: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn itoa(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn utoa(arg1: cty::c_uint, arg2: *mut cty::c_char, arg3: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut cty::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut cty::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort);
}
extern "C" {
    pub fn lrand48() -> cty::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> cty::c_long;
}
extern "C" {
    pub fn mrand48() -> cty::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> cty::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn _seed48_r(arg1: *mut _reent, arg2: *mut cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: cty::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: cty::c_long);
}
extern "C" {
    pub fn atoll(__nptr: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    pub fn _atoll_r(arg1: *mut _reent, __nptr: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: cty::c_longlong) -> cty::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: cty::c_longlong, __denom: cty::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const cty::c_char,
        __end_PTR: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _unsetenv_r(arg1: *mut _reent, __string: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: cty::c_int,
        arg4: cty::c_int,
        arg5: *mut cty::c_int,
        arg6: *mut cty::c_int,
        arg7: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut cty::c_void);
}
extern "C" {
    pub fn _realloc_r(arg1: *mut _reent, arg2: *mut cty::c_void, arg3: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut cty::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
        arg4: *const cty::c_char,
    );
}
extern "C" {
    pub fn strtold(arg1: *const cty::c_char, arg2: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn __assert(arg1: *const cty::c_char, arg2: cty::c_int, arg3: *const cty::c_char);
}
extern "C" {
    pub fn __assert_func(
        arg1: *const cty::c_char,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: *const cty::c_char,
    );
}
#[doc = "< return successful in ets"]
pub const ETS_STATUS_ETS_OK: ETS_STATUS = 0;
#[doc = "< return failed in ets"]
pub const ETS_STATUS_ETS_FAILED: ETS_STATUS = 1;
#[doc = " @addtogroup ets_apis"]
#[doc = " @{"]
pub type ETS_STATUS = u32;
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ETSEventTag {
    #[doc = "< Event signal, in same task, different Event with different signal"]
    pub sig: ETSSignal,
    #[doc = "< Event parameter, sometimes without usage, then will be set as 0"]
    pub par: ETSParam,
}
pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut ETSEvent)>;
pub type ets_idle_cb_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>;
extern "C" {
    #[doc = " @brief  Start the Espressif Task Scheduler, which is an infinit loop. Please do not add code after it."]
    #[doc = ""]
    #[doc = " @param  none"]
    #[doc = ""]
    #[doc = " @return none"]
    pub fn ets_run();
}
extern "C" {
    #[doc = " @brief  Set the Idle callback, when Tasks are processed, will call the callback before CPU goto sleep."]
    #[doc = ""]
    #[doc = " @param  ets_idle_cb_t func : The callback function."]
    #[doc = ""]
    #[doc = " @param  void *arg : Argument of the callback."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_set_idle_cb(func: ets_idle_cb_t, arg: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief  Init a task with processer, priority, queue to receive Event, queue length."]
    #[doc = ""]
    #[doc = " @param  ETSTask task : The task processer."]
    #[doc = ""]
    #[doc = " @param  uint8_t prio : Task priority, 0-31, bigger num with high priority, one priority with one task."]
    #[doc = ""]
    #[doc = " @param  ETSEvent *queue : Queue belongs to the task, task always receives Events, Queue is circular used."]
    #[doc = ""]
    #[doc = " @param  uint8_t qlen : Queue length."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_task(task: ETSTask, prio: u8, queue: *mut ETSEvent, qlen: u8);
}
extern "C" {
    #[doc = " @brief  Post an event to an Task."]
    #[doc = ""]
    #[doc = " @param  uint8_t prio : Priority of the Task."]
    #[doc = ""]
    #[doc = " @param  ETSSignal sig : Event signal."]
    #[doc = ""]
    #[doc = " @param  ETSParam  par : Event parameter"]
    #[doc = ""]
    #[doc = " @return ETS_OK     : post successful"]
    #[doc = " @return ETS_FAILED : post failed"]
    pub fn ets_post(prio: u8, sig: ETSSignal, par: ETSParam) -> ETS_STATUS;
}
extern "C" {
    pub static mut exc_cause_table: [*const cty::c_char; 40usize];
}
extern "C" {
    #[doc = " @brief  Set Pro cpu Entry code, code can be called in PRO CPU when booting is not completed."]
    #[doc = "         When Pro CPU booting is completed, Pro CPU will call the Entry code if not NULL."]
    #[doc = ""]
    #[doc = " @param  uint32_t start : the PRO Entry code address value in uint32_t"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_set_user_start(start: u32);
}
extern "C" {
    #[doc = " @brief  Set Pro cpu Startup code, code can be called when booting is not completed, or in Entry code."]
    #[doc = "         When Entry code completed, CPU will call the Startup code if not NULL, else call ets_run."]
    #[doc = ""]
    #[doc = " @param  uint32_t callback : the Startup code address value in uint32_t"]
    #[doc = ""]
    #[doc = " @return None     : post successful"]
    pub fn ets_set_startup_callback(callback: u32);
}
extern "C" {
    #[doc = " @brief  Set App cpu Entry code, code can be called in PRO CPU."]
    #[doc = "         When APP booting is completed, APP CPU will call the Entry code if not NULL."]
    #[doc = ""]
    #[doc = " @param  uint32_t start : the APP Entry code address value in uint32_t, stored in register APPCPU_CTRL_REG_D."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_set_appcpu_boot_addr(start: u32);
}
extern "C" {
    #[doc = " @brief  unpack the image in flash to iram and dram, no using cache."]
    #[doc = ""]
    #[doc = " @param  uint32_t pos : Flash physical address."]
    #[doc = ""]
    #[doc = " @param  uint32_t *entry_addr: the pointer of an variable that can store Entry code address."]
    #[doc = ""]
    #[doc = " @param  bool jump : Jump into the code in the function or not."]
    #[doc = ""]
    #[doc = " @param  bool config : Config the flash when unpacking the image, config should be done only once."]
    #[doc = ""]
    #[doc = " @return ETS_OK     : unpack successful"]
    #[doc = " @return ETS_FAILED : unpack failed"]
    pub fn ets_unpack_flash_code_legacy(
        pos: u32,
        entry_addr: *mut u32,
        jump: bool,
        config: bool,
    ) -> ETS_STATUS;
}
extern "C" {
    #[doc = " @brief  unpack the image in flash to iram and dram, using cache, maybe decrypting."]
    #[doc = ""]
    #[doc = " @param  uint32_t pos : Flash physical address."]
    #[doc = ""]
    #[doc = " @param  uint32_t *entry_addr: the pointer of an variable that can store Entry code address."]
    #[doc = ""]
    #[doc = " @param  bool jump : Jump into the code in the function or not."]
    #[doc = ""]
    #[doc = " @param  bool sb_need_check : Do security boot check or not."]
    #[doc = ""]
    #[doc = " @param  bool config : Config the flash when unpacking the image, config should be done only once."]
    #[doc = ""]
    #[doc = " @return ETS_OK     : unpack successful"]
    #[doc = " @return ETS_FAILED : unpack failed"]
    pub fn ets_unpack_flash_code(
        pos: u32,
        entry_addr: *mut u32,
        jump: bool,
        sb_need_check: bool,
        config: bool,
    ) -> ETS_STATUS;
}
extern "C" {
    #[doc = " @brief  Printf the strings to uart or other devices, similar with printf, simple than printf."]
    #[doc = "         Can not print float point data format, or longlong data format."]
    #[doc = "         So we maybe only use this in ROM."]
    #[doc = ""]
    #[doc = " @param  const char *fmt : See printf."]
    #[doc = ""]
    #[doc = " @param  ... : See printf."]
    #[doc = ""]
    #[doc = " @return int : the length printed to the output device."]
    pub fn ets_printf(fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief  Output a char to uart, which uart to output(which is in uart module in ROM) is not in scope of the function."]
    #[doc = "         Can not print float point data format, or longlong data format"]
    #[doc = ""]
    #[doc = " @param  char c : char to output."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_write_char_uart(c: cty::c_char);
}
extern "C" {
    #[doc = " @brief  Ets_printf have two output functions\u{ff1a} putc1 and putc2, both of which will be called if need ouput."]
    #[doc = "         To install putc1, which is defaulted installed as ets_write_char_uart in none silent boot mode, as NULL in silent mode."]
    #[doc = ""]
    #[doc = " @param  void (*)(char) p: Output function to install."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_install_putc1(p: ::core::option::Option<unsafe extern "C" fn(c: cty::c_char)>);
}
extern "C" {
    #[doc = " @brief  Ets_printf have two output functions\u{ff1a} putc1 and putc2, both of which will be called if need ouput."]
    #[doc = "         To install putc2, which is defaulted installed as NULL."]
    #[doc = ""]
    #[doc = " @param  void (*)(char) p: Output function to install."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_install_putc2(p: ::core::option::Option<unsafe extern "C" fn(c: cty::c_char)>);
}
extern "C" {
    #[doc = " @brief  Install putc1 as ets_write_char_uart."]
    #[doc = "         In silent boot mode(to void interfere the UART attached MCU), we can call this function, after booting ok."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_install_uart_printf();
}
#[doc = " @addtogroup ets_timer_apis"]
#[doc = " @{"]
pub type ETSTimerFunc = ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETSTIMER_ {
    #[doc = "< timer linker"]
    pub timer_next: *mut _ETSTIMER_,
    #[doc = "< abstruct time when timer expire"]
    pub timer_expire: u32,
    #[doc = "< timer period, 0 means timer is not periodic repeated"]
    pub timer_period: u32,
    #[doc = "< timer handler"]
    pub timer_func: ETSTimerFunc,
    #[doc = "< timer handler argument"]
    pub timer_arg: *mut cty::c_void,
}
pub type ETSTimer = _ETSTIMER_;
extern "C" {
    #[doc = " @brief  Init ets timer, this timer range is 640 us to 429496 ms"]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_init();
}
extern "C" {
    #[doc = " @brief  In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_deinit();
}
extern "C" {
    #[doc = " @brief  Arm an ets timer, this timer range is 640 us to 429496 ms."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @param  uint32_t tmout : Timer value in ms, range is 1 to 429496."]
    #[doc = ""]
    #[doc = " @param  bool repeat : Timer is periodic repeated."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_arm(timer: *mut ETSTimer, tmout: u32, repeat: bool);
}
extern "C" {
    #[doc = " @brief  Arm an ets timer, this timer range is 640 us to 429496 ms."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @param  uint32_t tmout : Timer value in us, range is 1 to 429496729."]
    #[doc = ""]
    #[doc = " @param  bool repeat : Timer is periodic repeated."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_arm_us(ptimer: *mut ETSTimer, us: u32, repeat: bool);
}
extern "C" {
    #[doc = " @brief  Disarm an ets timer."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_disarm(timer: *mut ETSTimer);
}
extern "C" {
    #[doc = " @brief  Set timer callback and argument."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @param  ETSTimerFunc *pfunction : Timer callback."]
    #[doc = ""]
    #[doc = " @param  void *parg : Timer callback argument."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_setfn(ptimer: *mut ETSTimer, pfunction: ETSTimerFunc, parg: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief  Unset timer callback and argument to NULL."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_done(ptimer: *mut ETSTimer);
}
extern "C" {
    #[doc = " @brief  CPU do while loop for some time."]
    #[doc = "         In FreeRTOS task, please call FreeRTOS apis."]
    #[doc = ""]
    #[doc = " @param  uint32_t us : Delay time in us."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_delay_us(us: u32);
}
extern "C" {
    #[doc = " @brief  Set the real CPU ticks per us to the ets, so that ets_delay_us will be accurate."]
    #[doc = "         Call this function when CPU frequency is changed."]
    #[doc = ""]
    #[doc = " @param  uint32_t ticks_per_us : CPU ticks per us."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_update_cpu_frequency(ticks_per_us: u32);
}
extern "C" {
    #[doc = " @brief  Set the real CPU ticks per us to the ets, so that ets_delay_us will be accurate."]
    #[doc = ""]
    #[doc = " @note This function only sets the tick rate for the current CPU. It is located in ROM,"]
    #[doc = "       so the deep sleep stub can use it even if IRAM is not initialized yet."]
    #[doc = ""]
    #[doc = " @param  uint32_t ticks_per_us : CPU ticks per us."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_update_cpu_frequency_rom(ticks_per_us: u32);
}
extern "C" {
    #[doc = " @brief  Get the real CPU ticks per us to the ets."]
    #[doc = "         This function do not return real CPU ticks per us, just the record in ets. It can be used to check with the real CPU frequency."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return uint32_t : CPU ticks per us record in ets."]
    pub fn ets_get_cpu_frequency() -> u32;
}
extern "C" {
    #[doc = " @brief  Get xtal_freq/analog_8M*256 value calibrated in rtc module."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return uint32_t : xtal_freq/analog_8M*256."]
    pub fn ets_get_xtal_scale() -> u32;
}
extern "C" {
    #[doc = " @brief  Get xtal_freq value, If value not stored in RTC_STORE5, than store."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return uint32_t : if rtc store the value (RTC_STORE5 high 16 bits and low 16 bits with same value), read from rtc register."]
    #[doc = "                         clock = (REG_READ(RTC_STORE5) & 0xffff) << 12;"]
    #[doc = "            else if analog_8M in efuse"]
    #[doc = "                         clock = ets_get_xtal_scale() * 15625 * ets_efuse_get_8M_clock() / 40;"]
    #[doc = "                    else clock = 26M."]
    pub fn ets_get_detected_xtal_freq() -> u32;
}
#[doc = " @addtogroup ets_intr_apis"]
#[doc = " @{"]
pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
extern "C" {
    #[doc = " @brief  Attach a interrupt handler to a CPU interrupt number."]
    #[doc = "         This function equals to _xtos_set_interrupt_handler_arg(i, func, arg)."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  int i : CPU interrupt number."]
    #[doc = ""]
    #[doc = " @param  ets_isr_t func : Interrupt handler."]
    #[doc = ""]
    #[doc = " @param  void *arg : argument of the handler."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_isr_attach(i: cty::c_int, func: ets_isr_t, arg: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief  Mask the interrupts which show in mask bits."]
    #[doc = "         This function equals to _xtos_ints_off(mask)."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  uint32_t mask : BIT(i) means mask CPU interrupt number i."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_isr_mask(mask: u32);
}
extern "C" {
    #[doc = " @brief  Unmask the interrupts which show in mask bits."]
    #[doc = "         This function equals to _xtos_ints_on(mask)."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  uint32_t mask : BIT(i) means mask CPU interrupt number i."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_isr_unmask(unmask: u32);
}
extern "C" {
    #[doc = " @brief  Lock the interrupt to level 2."]
    #[doc = "         This function direct set the CPU registers."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_intr_lock();
}
extern "C" {
    #[doc = " @brief  Unlock the interrupt to level 0."]
    #[doc = "         This function direct set the CPU registers."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_intr_unlock();
}
extern "C" {
    #[doc = " @brief  Unlock the interrupt to level 0, and CPU will go into power save mode(wait interrupt)."]
    #[doc = "         This function direct set the CPU registers."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_waiti0();
}
extern "C" {
    #[doc = " @brief  Attach an CPU interrupt to a hardware source."]
    #[doc = "         We have 4 steps to use an interrupt:"]
    #[doc = "         1.Attach hardware interrupt source to CPU.  intr_matrix_set(0, ETS_WIFI_MAC_INTR_SOURCE, ETS_WMAC_INUM);"]
    #[doc = "         2.Set interrupt handler.                    xt_set_interrupt_handler(ETS_WMAC_INUM, func, NULL);"]
    #[doc = "         3.Enable interrupt for CPU.                 xt_ints_on(1 << ETS_WMAC_INUM);"]
    #[doc = "         4.Enable interrupt in the module."]
    #[doc = ""]
    #[doc = " @param  int cpu_no : The CPU which the interrupt number belongs."]
    #[doc = ""]
    #[doc = " @param  uint32_t model_num : The interrupt hardware source number, please see the interrupt hardware source table."]
    #[doc = ""]
    #[doc = " @param  uint32_t intr_num : The interrupt number CPU, please see the interrupt cpu using table."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn intr_matrix_set(cpu_no: cty::c_int, model_num: u32, intr_num: u32);
}
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = u32;
pub type TaskFunction_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
#[repr(C)]
pub struct XtosCoreState {
    pub signature: cty::c_long,
    pub restore_label: cty::c_long,
    pub aftersave_label: cty::c_long,
    pub areg: [cty::c_long; 64usize],
    pub caller_regs: [cty::c_long; 16usize],
    pub caller_regs_saved: cty::c_long,
    pub windowbase: cty::c_long,
    pub windowstart: cty::c_long,
    pub sar: cty::c_long,
    pub epc1: cty::c_long,
    pub ps: cty::c_long,
    pub excsave1: cty::c_long,
    pub depc: cty::c_long,
    pub epc: [cty::c_long; 6usize],
    pub eps: [cty::c_long; 6usize],
    pub excsave: [cty::c_long; 6usize],
    pub lcount: cty::c_long,
    pub lbeg: cty::c_long,
    pub lend: cty::c_long,
    pub vecbase: cty::c_long,
    pub atomctl: cty::c_long,
    pub memctl: cty::c_long,
    pub ccount: cty::c_long,
    pub ccompare: [cty::c_long; 3usize],
    pub intenable: cty::c_long,
    pub interrupt: cty::c_long,
    pub icount: cty::c_long,
    pub icountlevel: cty::c_long,
    pub debugcause: cty::c_long,
    pub dbreakc: [cty::c_long; 2usize],
    pub dbreaka: [cty::c_long; 2usize],
    pub ibreaka: [cty::c_long; 2usize],
    pub ibreakenable: cty::c_long,
    pub misc: [cty::c_long; 4usize],
    pub cpenable: cty::c_long,
    pub tlbs: [cty::c_long; 16usize],
    pub ncp: [cty::c_char; 48usize],
    pub cp0: [cty::c_char; 72usize],
    pub cp1: __IncompleteArrayField<cty::c_char>,
    pub cp2: __IncompleteArrayField<cty::c_char>,
    pub cp3: __IncompleteArrayField<cty::c_char>,
    pub cp4: __IncompleteArrayField<cty::c_char>,
    pub cp5: __IncompleteArrayField<cty::c_char>,
    pub cp6: __IncompleteArrayField<cty::c_char>,
    pub cp7: __IncompleteArrayField<cty::c_char>,
}
pub type _xtos_handler_func = ::core::option::Option<unsafe extern "C" fn()>;
pub type _xtos_handler = _xtos_handler_func;
extern "C" {
    pub fn _xtos_ints_off(mask: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn _xtos_ints_on(mask: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn _xtos_set_intlevel(intlevel: cty::c_int) -> cty::c_uint;
}
extern "C" {
    pub fn _xtos_set_min_intlevel(intlevel: cty::c_int) -> cty::c_uint;
}
extern "C" {
    pub fn _xtos_restore_intlevel(restoreval: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn _xtos_restore_just_intlevel(restoreval: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler(n: cty::c_int, f: _xtos_handler) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler_arg(
        n: cty::c_int,
        f: _xtos_handler,
        arg: *mut cty::c_void,
    ) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_exception_handler(n: cty::c_int, f: _xtos_handler) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_memep_initrams();
}
extern "C" {
    pub fn _xtos_memep_enable(flags: cty::c_int);
}
extern "C" {
    pub fn _xtos_dispatch_level1_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level2_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level3_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level4_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level5_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level6_interrupts();
}
extern "C" {
    pub fn _xtos_read_ints() -> cty::c_uint;
}
extern "C" {
    pub fn _xtos_clear_ints(mask: cty::c_uint);
}
extern "C" {
    pub fn _xtos_core_shutoff(flags: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn _xtos_core_save(
        flags: cty::c_uint,
        savearea: *mut XtosCoreState,
        code: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _xtos_core_restore(retvalue: cty::c_uint, savearea: *mut XtosCoreState);
}
extern "C" {
    pub fn _xtos_timer_0_delta(cycles: cty::c_int);
}
extern "C" {
    pub fn _xtos_timer_1_delta(cycles: cty::c_int);
}
extern "C" {
    pub fn _xtos_timer_2_delta(cycles: cty::c_int);
}
extern "C" {
    #[doc = " Initialize the crosscore interrupt system for this CPU."]
    #[doc = " This needs to be called once on every CPU that is used"]
    #[doc = " by FreeRTOS."]
    #[doc = ""]
    #[doc = " If multicore FreeRTOS support is enabled, this will be"]
    #[doc = " called automatically by the startup code and should not"]
    #[doc = " be called manually."]
    pub fn esp_crosscore_int_init();
}
extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it should yield its"]
    #[doc = " currently running task in favour of a higher-priority task"]
    #[doc = " that presumably just woke up."]
    #[doc = ""]
    #[doc = " This is used internally by FreeRTOS in multicore mode"]
    #[doc = " and should not be called by the user."]
    #[doc = ""]
    #[doc = " @param core_id Core that should do the yielding"]
    pub fn esp_crosscore_int_send_yield(core_id: cty::c_int);
}
extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it should update its"]
    #[doc = " CCOMPARE1 value due to a frequency switch."]
    #[doc = ""]
    #[doc = " This is used internally when dynamic frequency switching is"]
    #[doc = " enabled, and should not be called from application code."]
    #[doc = ""]
    #[doc = " @param core_id Core that should update its CCOMPARE1 value"]
    pub fn esp_crosscore_int_send_freq_switch(core_id: cty::c_int);
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tempnam(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn printf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const cty::c_char,
        arg3: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const cty::c_char, arg2: __builtin_va_list) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut cty::c_char, arg2: cty::c_int, arg3: *mut FILE) -> *mut cty::c_char;
}
extern "C" {
    pub fn fputc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const cty::c_char, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn putc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn puts(arg1: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn ungetc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread(arg1: *mut cty::c_void, _size: usize, _n: usize, arg2: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(arg1: *const cty::c_void, _size: usize, _n: usize, arg2: *mut FILE) -> usize;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: cty::c_long, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn perror(arg1: *const cty::c_char);
}
extern "C" {
    pub fn fopen(_name: *const cty::c_char, _type: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn remove(arg1: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn asiprintf(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn diprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn siprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn siscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut cty::c_char,
        arg2: usize,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vdiprintf(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vfiprintf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
extern "C" {
    pub fn vfiscanf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const cty::c_char,
        arg3: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const cty::c_char, arg2: __builtin_va_list) -> cty::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut cty::c_char,
        arg2: usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        arg4: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fdopen(arg1: cty::c_int, arg2: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn popen(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn putw(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut cty::c_char, arg3: cty::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> cty::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn dprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fmemopen(arg1: *mut cty::c_void, arg2: usize, arg3: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut cty::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn renameat(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: cty::c_int,
        arg4: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: cty::c_int, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _fdopen_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        arg3: usize,
        arg4: *const cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputs_r(arg1: *mut _reent, arg2: *const cty::c_char, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: cty::c_long,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const cty::c_char);
}
extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const cty::c_char,
        _new: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut cty::c_char,
        arg2: *mut usize,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(arg1: *mut *mut cty::c_char, arg2: *mut usize, arg3: *mut FILE) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(__cookie: *mut cty::c_void, __buf: *mut cty::c_char, __n: usize) -> isize,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut cty::c_void,
        __buf: *const cty::c_char,
        __n: usize,
    ) -> isize,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut cty::c_void,
        __off: *mut off_t,
        __whence: cty::c_int,
    ) -> cty::c_int,
>;
pub type cookie_close_function_t =
    ::core::option::Option<unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
extern "C" {
    pub fn fopencookie(
        __cookie: *mut cty::c_void,
        __mode: *const cty::c_char,
        __functions: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopencookie_r(
        arg1: *mut _reent,
        __cookie: *mut cty::c_void,
        __mode: *const cty::c_char,
        __functions: cookie_io_functions_t,
    ) -> *mut FILE;
}
pub type esp_err_t = i32;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table and"]
    #[doc = " returns its string representation."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table of"]
    #[doc = " esp_err_t errors and returns its string representation. If the error code"]
    #[doc = " is not found then it is attempted to be found among system errors."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @param[out] buf buffer where the error message should be written"]
    #[doc = " @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte)."]
    #[doc = " @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut cty::c_char,
        buflen: usize,
    ) -> *const cty::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const cty::c_char,
        line: cty::c_int,
        function: *const cty::c_char,
        expression: *const cty::c_char,
    );
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const cty::c_char,
        line: cty::c_int,
        function: *const cty::c_char,
        expression: *const cty::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type representing a single esp_timer"]
pub type esp_timer_handle_t = *mut esp_timer;
#[doc = " @brief Timer callback function type"]
#[doc = " @param arg pointer to opaque user-specific data"]
pub type esp_timer_cb_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>;
#[doc = "!< Callback is called from timer task"]
pub const esp_timer_dispatch_t_ESP_TIMER_TASK: esp_timer_dispatch_t = 0;
#[doc = " @brief Method for dispatching timer callback"]
pub type esp_timer_dispatch_t = u32;
#[doc = " @brief Timer configuration passed to esp_timer_create"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer_create_args_t {
    #[doc = "!< Function to call when timer expires"]
    pub callback: esp_timer_cb_t,
    #[doc = "!< Argument to pass to the callback"]
    pub arg: *mut cty::c_void,
    #[doc = "!< Call the callback from task or from ISR"]
    pub dispatch_method: esp_timer_dispatch_t,
    #[doc = "!< Timer name, used in esp_timer_dump function"]
    pub name: *const cty::c_char,
}
extern "C" {
    #[doc = " @brief Initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note This function is called from startup code. Applications do not need"]
    #[doc = " to call this function before using other esp_timer APIs."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if allocation has failed"]
    #[doc = "      - ESP_ERR_INVALID_STATE if already initialized"]
    #[doc = "      - other errors from interrupt allocator"]
    pub fn esp_timer_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note Normally this function should not be called from applications"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if not yet initialized"]
    pub fn esp_timer_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create an esp_timer instance"]
    #[doc = ""]
    #[doc = " @note When done using the timer, delete it with esp_timer_delete function."]
    #[doc = ""]
    #[doc = " @param create_args   Pointer to a structure with timer creation arguments."]
    #[doc = "                      Not saved by the library, can be allocated on the stack."]
    #[doc = " @param[out] out_handle  Output, pointer to esp_timer_handle_t variable which"]
    #[doc = "                         will hold the created timer handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if some of the create_args are not valid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if esp_timer library is not initialized yet"]
    #[doc = "      - ESP_ERR_NO_MEM if memory allocation fails"]
    pub fn esp_timer_create(
        create_args: *const esp_timer_create_args_t,
        out_handle: *mut esp_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start one-shot timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param timeout_us timer timeout, in microseconds relative to the current moment"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_once(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a periodic timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called. This function will"]
    #[doc = " start the timer which will trigger every 'period' microseconds."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param period timer period, in microseconds"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_periodic(timer: esp_timer_handle_t, period: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop the timer"]
    #[doc = ""]
    #[doc = " This function stops the timer previously started using esp_timer_start_once"]
    #[doc = " or esp_timer_start_periodic."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_stop(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an esp_timer instance"]
    #[doc = ""]
    #[doc = " The timer must be stopped before deleting. A one-shot timer which has expired"]
    #[doc = " does not need to be stopped."]
    #[doc = ""]
    #[doc = " @param timer timer handle allocated using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_delete(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get time in microseconds since boot"]
    #[doc = " @return number of microseconds since esp_timer_init was called (this normally"]
    #[doc = "          happens early during application startup)."]
    pub fn esp_timer_get_time() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp when the next timeout is expected to occur"]
    #[doc = " @return Timestamp of the nearest timer event, in microseconds."]
    #[doc = "         The timebase is the same as for the values returned by esp_timer_get_time."]
    pub fn esp_timer_get_next_alarm() -> i64;
}
extern "C" {
    #[doc = " @brief Dump the list of timers to a stream"]
    #[doc = ""]
    #[doc = " If CONFIG_ESP_TIMER_PROFILING option is enabled, this prints the list of all"]
    #[doc = " the existing timers. Otherwise, only the list active timers is printed."]
    #[doc = ""]
    #[doc = " The format is:"]
    #[doc = ""]
    #[doc = "   name  period  alarm  times_armed  times_triggered  total_callback_run_time"]
    #[doc = ""]
    #[doc = " where:"]
    #[doc = ""]
    #[doc = " name \u{2014} timer name (if CONFIG_ESP_TIMER_PROFILING is defined), or timer pointer"]
    #[doc = " period \u{2014} period of timer, in microseconds, or 0 for one-shot timer"]
    #[doc = " alarm - time of the next alarm, in microseconds since boot, or 0 if the timer"]
    #[doc = "         is not started"]
    #[doc = ""]
    #[doc = " The following fields are printed if CONFIG_ESP_TIMER_PROFILING is defined:"]
    #[doc = ""]
    #[doc = " times_armed \u{2014} number of times the timer was armed via esp_timer_start_X"]
    #[doc = " times_triggered - number of times the callback was called"]
    #[doc = " total_callback_run_time - total time taken by callback to execute, across all calls"]
    #[doc = ""]
    #[doc = " @param stream stream (such as stdout) to dump the information to"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if can not allocate temporary buffer for the output"]
    pub fn esp_timer_dump(stream: *mut FILE) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque handle to a registered heap"]
pub type multi_heap_handle_t = *mut multi_heap_info;
extern "C" {
    #[doc = " @brief malloc() a buffer in a given heap"]
    #[doc = ""]
    #[doc = " Semantics are the same as standard malloc(), only the returned buffer will be allocated in the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param size Size of desired buffer."]
    #[doc = ""]
    #[doc = " @return Pointer to new memory, or NULL if allocation fails."]
    pub fn multi_heap_malloc(heap: multi_heap_handle_t, size: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief free() a buffer in a given heap."]
    #[doc = ""]
    #[doc = " Semantics are the same as standard free(), only the argument 'p' must be NULL or have been allocated in the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    pub fn multi_heap_free(heap: multi_heap_handle_t, p: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief realloc() a buffer in a given heap."]
    #[doc = ""]
    #[doc = " Semantics are the same as standard realloc(), only the argument 'p' must be NULL or have been allocated in the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    #[doc = " @param size Desired new size for buffer."]
    #[doc = ""]
    #[doc = " @return New buffer of 'size' containing contents of 'p', or NULL if reallocation failed."]
    pub fn multi_heap_realloc(
        heap: multi_heap_handle_t,
        p: *mut cty::c_void,
        size: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Return the size that a particular pointer was allocated with."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p Pointer, must have been previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    #[doc = ""]
    #[doc = " @return Size of the memory allocated at this block. May be more than the original size argument, due"]
    #[doc = " to padding and minimum block sizes."]
    pub fn multi_heap_get_allocated_size(heap: multi_heap_handle_t, p: *mut cty::c_void) -> usize;
}
extern "C" {
    #[doc = " @brief Register a new heap for use"]
    #[doc = ""]
    #[doc = " This function initialises a heap at the specified address, and returns a handle for future heap operations."]
    #[doc = ""]
    #[doc = " There is no equivalent function for deregistering a heap - if all blocks in the heap are free, you can immediately start using the memory for other purposes."]
    #[doc = ""]
    #[doc = " @param start Start address of the memory to use for a new heap."]
    #[doc = " @param size Size (in bytes) of the new heap."]
    #[doc = ""]
    #[doc = " @return Handle of a new heap ready for use, or NULL if the heap region was too small to be initialised."]
    pub fn multi_heap_register(start: *mut cty::c_void, size: usize) -> multi_heap_handle_t;
}
extern "C" {
    #[doc = " @brief Associate a private lock pointer with a heap"]
    #[doc = ""]
    #[doc = " The lock argument is supplied to the MULTI_HEAP_LOCK() and MULTI_HEAP_UNLOCK() macros, defined in multi_heap_platform.h."]
    #[doc = ""]
    #[doc = " The lock in question must be recursive."]
    #[doc = ""]
    #[doc = " When the heap is first registered, the associated lock is NULL."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param lock Optional pointer to a locking structure to associate with this heap."]
    pub fn multi_heap_set_lock(heap: multi_heap_handle_t, lock: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Dump heap information to stdout"]
    #[doc = ""]
    #[doc = " For debugging purposes, this function dumps information about every block in the heap to stdout."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    pub fn multi_heap_dump(heap: multi_heap_handle_t);
}
extern "C" {
    #[doc = " @brief Check heap integrity"]
    #[doc = ""]
    #[doc = " Walks the heap and checks all heap data structures are valid. If any errors are detected, an error-specific message"]
    #[doc = " can be optionally printed to stderr. Print behaviour can be overriden at compile time by defining"]
    #[doc = " MULTI_CHECK_FAIL_PRINTF in multi_heap_platform.h."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param print_errors If true, errors will be printed to stderr."]
    #[doc = " @return true if heap is valid, false otherwise."]
    pub fn multi_heap_check(heap: multi_heap_handle_t, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Return free heap size"]
    #[doc = ""]
    #[doc = " Returns the number of bytes available in the heap."]
    #[doc = ""]
    #[doc = " Equivalent to the total_free_bytes member returned by multi_heap_get_heap_info()."]
    #[doc = ""]
    #[doc = " Note that the heap may be fragmented, so the actual maximum size for a single malloc() may be lower. To know this"]
    #[doc = " size, see the largest_free_block member returned by multi_heap_get_heap_info()."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @return Number of free bytes."]
    pub fn multi_heap_free_size(heap: multi_heap_handle_t) -> usize;
}
extern "C" {
    #[doc = " @brief Return the lifetime minimum free heap size"]
    #[doc = ""]
    #[doc = " Equivalent to the minimum_free_bytes member returned by multi_heap_get_info()."]
    #[doc = ""]
    #[doc = " Returns the lifetime \"low water mark\" of possible values returned from multi_free_heap_size(), for the specified"]
    #[doc = " heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @return Number of free bytes."]
    pub fn multi_heap_minimum_free_size(heap: multi_heap_handle_t) -> usize;
}
#[doc = " @brief Structure to access heap metadata via multi_heap_get_info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info_t {
    #[doc = "<  Total free bytes in the heap. Equivalent to multi_free_heap_size()."]
    pub total_free_bytes: usize,
    #[doc = "<  Total bytes allocated to data in the heap."]
    pub total_allocated_bytes: usize,
    #[doc = "<  Size of largest free block in the heap. This is the largest malloc-able size."]
    pub largest_free_block: usize,
    #[doc = "<  Lifetime minimum free heap size. Equivalent to multi_minimum_free_heap_size()."]
    pub minimum_free_bytes: usize,
    #[doc = "<  Number of (variable size) blocks allocated in the heap."]
    pub allocated_blocks: usize,
    #[doc = "<  Number of (variable size) free blocks in the heap."]
    pub free_blocks: usize,
    #[doc = "<  Total number of (variable size) blocks in the heap."]
    pub total_blocks: usize,
}
extern "C" {
    #[doc = " @brief Return metadata about a given heap"]
    #[doc = ""]
    #[doc = " Fills a multi_heap_info_t structure with information about the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param info Pointer to a structure to fill with heap metadata."]
    pub fn multi_heap_get_info(heap: multi_heap_handle_t, info: *mut multi_heap_info_t);
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities"]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc malloc(), for capability-aware memory."]
    #[doc = ""]
    #[doc = " In IDF, ``malloc(p)`` is equivalent to ``heap_caps_malloc(p, MALLOC_CAP_8BIT)``."]
    #[doc = ""]
    #[doc = " @param size Size, in bytes, of the amount of memory to allocate"]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory to be returned"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc(size: usize, caps: u32) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Free memory previously allocated via heap_caps_malloc() or heap_caps_realloc()."]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc free(), for capability-aware memory."]
    #[doc = ""]
    #[doc = "  In IDF, ``free(p)`` is equivalent to ``heap_caps_free(p)``."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to memory previously returned from heap_caps_malloc() or heap_caps_realloc(). Can be NULL."]
    pub fn heap_caps_free(ptr: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Reallocate memory previously allocated via heap_caps_malloc() or heap_caps_realloc()."]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc realloc(), for capability-aware memory."]
    #[doc = ""]
    #[doc = " In IDF, ``realloc(p, s)`` is equivalent to ``heap_caps_realloc(p, s, MALLOC_CAP_8BIT)``."]
    #[doc = ""]
    #[doc = " 'caps' parameter can be different to the capabilities that any original 'ptr' was allocated with. In this way,"]
    #[doc = " realloc can be used to \"move\" a buffer if necessary to ensure it meets a new set of capabilities."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to previously allocated memory, or NULL for a new allocation."]
    #[doc = " @param size Size of the new buffer requested, or 0 to free the buffer."]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory desired for the new allocation."]
    #[doc = ""]
    #[doc = " @return Pointer to a new buffer of size 'size' with capabilities 'caps', or NULL if allocation failed."]
    pub fn heap_caps_realloc(
        ptr: *mut cty::c_void,
        size: usize,
        caps: cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities. The initialized value in the memory is set to zero."]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc calloc(), for capability-aware memory."]
    #[doc = ""]
    #[doc = " In IDF, ``calloc(p)`` is equivalent to ``heap_caps_calloc(p, MALLOC_CAP_8BIT)``."]
    #[doc = ""]
    #[doc = " @param n    Number of continuing chunks of memory to allocate"]
    #[doc = " @param size Size, in bytes, of a chunk of memory to allocate"]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory to be returned"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc(n: usize, size: usize, caps: u32) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Get the total free size of all the regions that have the given capabilities"]
    #[doc = ""]
    #[doc = " This function takes all regions capable of having the given capabilities allocated in them"]
    #[doc = " and adds up the free space they have."]
    #[doc = ""]
    #[doc = " Note that because of heap fragmentation it is probably not possible to allocate a single block of memory"]
    #[doc = " of this size. Use heap_caps_get_largest_free_block() for this purpose."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_free_size(caps: u32) -> usize;
}
extern "C" {
    #[doc = " @brief Get the total minimum free memory of all regions with the given capabilities"]
    #[doc = ""]
    #[doc = " This adds all the low water marks of the regions capable of delivering the memory"]
    #[doc = " with the given capabilities."]
    #[doc = ""]
    #[doc = " Note the result may be less than the global all-time minimum available heap of this kind, as \"low water marks\" are"]
    #[doc = " tracked per-region. Individual regions' heaps may have reached their \"low water marks\" at different points in time. However"]
    #[doc = " this result still gives a \"worst case\" indication for all-time minimum free heap."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_minimum_free_size(caps: u32) -> usize;
}
extern "C" {
    #[doc = " @brief Get the largest free block of memory able to be allocated with the given capabilities."]
    #[doc = ""]
    #[doc = " Returns the largest value of ``s`` for which ``heap_caps_malloc(s, caps)`` will succeed."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return Size of largest free block in bytes."]
    pub fn heap_caps_get_largest_free_block(caps: u32) -> usize;
}
extern "C" {
    #[doc = " @brief Get heap info for all regions with the given capabilities."]
    #[doc = ""]
    #[doc = " Calls multi_heap_info() on all heaps which share the given capabilities.  The information returned is an aggregate"]
    #[doc = " across all matching heaps.  The meanings of fields are the same as defined for multi_heap_info_t, except that"]
    #[doc = " ``minimum_free_bytes`` has the same caveats described in heap_caps_get_minimum_free_size()."]
    #[doc = ""]
    #[doc = " @param info        Pointer to a structure which will be filled with relevant"]
    #[doc = "                    heap metadata."]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    pub fn heap_caps_get_info(info: *mut multi_heap_info_t, caps: u32);
}
extern "C" {
    #[doc = " @brief Print a summary of all memory with the given capabilities."]
    #[doc = ""]
    #[doc = " Calls multi_heap_info on all heaps which share the given capabilities, and"]
    #[doc = " prints a two-line summary for each, then a total summary."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    pub fn heap_caps_print_heap_info(caps: u32);
}
extern "C" {
    #[doc = " @brief Check integrity of all heap memory in the system."]
    #[doc = ""]
    #[doc = " Calls multi_heap_check on all heaps. Optionally print errors if heaps are corrupt."]
    #[doc = ""]
    #[doc = " Calling this function is equivalent to calling heap_caps_check_integrity"]
    #[doc = " with the caps argument set to MALLOC_CAP_INVALID."]
    #[doc = ""]
    #[doc = " @param print_errors Print specific errors if heap corruption is found."]
    #[doc = ""]
    #[doc = " @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity_all(print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Check integrity of all heaps with the given capabilities."]
    #[doc = ""]
    #[doc = " Calls multi_heap_check on all heaps which share the given capabilities. Optionally"]
    #[doc = " print errors if the heaps are corrupt."]
    #[doc = ""]
    #[doc = " See also heap_caps_check_integrity_all to check all heap memory"]
    #[doc = " in the system and heap_caps_check_integrity_addr to check memory"]
    #[doc = " around a single address."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = " @param print_errors Print specific errors if heap corruption is found."]
    #[doc = ""]
    #[doc = " @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity(caps: u32, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Check integrity of heap memory around a given address."]
    #[doc = ""]
    #[doc = " This function can be used to check the integrity of a single region of heap memory,"]
    #[doc = " which contains the given address."]
    #[doc = ""]
    #[doc = " This can be useful if debugging heap integrity for corruption at a known address,"]
    #[doc = " as it has a lower overhead than checking all heap regions. Note that if the corrupt"]
    #[doc = " address moves around between runs (due to timing or other factors) then this approach"]
    #[doc = " won't work and you should call heap_caps_check_integrity or"]
    #[doc = " heap_caps_check_integrity_all instead."]
    #[doc = ""]
    #[doc = " @note The entire heap region around the address is checked, not only the adjacent"]
    #[doc = " heap blocks."]
    #[doc = ""]
    #[doc = " @param addr Address in memory. Check for corruption in region containing this address."]
    #[doc = " @param print_errors Print specific errors if heap corruption is found."]
    #[doc = ""]
    #[doc = " @return True if the heap containing the specified address is valid,"]
    #[doc = " False if at least one heap is corrupt or the address doesn't belong to a heap region."]
    pub fn heap_caps_check_integrity_addr(addr: isize, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Enable malloc() in external memory and set limit below which"]
    #[doc = "        malloc() attempts are placed in internal memory."]
    #[doc = ""]
    #[doc = " When external memory is in use, the allocation strategy is to initially try to"]
    #[doc = " satisfy smaller allocation requests with internal memory and larger requests"]
    #[doc = " with external memory. This sets the limit between the two, as well as generally"]
    #[doc = " enabling allocation in external memory."]
    #[doc = ""]
    #[doc = " @param limit       Limit, in bytes."]
    pub fn heap_caps_malloc_extmem_enable(limit: usize);
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order."]
    #[doc = ""]
    #[doc = " @attention The variable parameters are bitwise OR of MALLOC_CAP_* flags indicating the type of memory."]
    #[doc = "            This API prefers to allocate memory with the first parameter. If failed, allocate memory with"]
    #[doc = "            the next parameter. It will try in this order until allocating a chunk of memory successfully"]
    #[doc = "            or fail to allocate memories with any of the parameters."]
    #[doc = ""]
    #[doc = " @param size Size, in bytes, of the amount of memory to allocate"]
    #[doc = " @param num Number of variable paramters"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc_prefer(size: usize, num: usize, ...) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to previously allocated memory, or NULL for a new allocation."]
    #[doc = " @param size Size of the new buffer requested, or 0 to free the buffer."]
    #[doc = " @param num Number of variable paramters"]
    #[doc = ""]
    #[doc = " @return Pointer to a new buffer of size 'size', or NULL if allocation failed."]
    pub fn heap_caps_realloc_prefer(
        ptr: *mut cty::c_void,
        size: usize,
        num: usize,
        ...
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order."]
    #[doc = ""]
    #[doc = " @param n    Number of continuing chunks of memory to allocate"]
    #[doc = " @param size Size, in bytes, of a chunk of memory to allocate"]
    #[doc = " @param num  Number of variable paramters"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc_prefer(n: usize, size: usize, num: usize, ...) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Dump the full structure of all heaps with matching capabilities."]
    #[doc = ""]
    #[doc = " Prints a large amount of output to serial (because of locking limitations,"]
    #[doc = " the output bypasses stdout/stderr). For each (variable sized) block"]
    #[doc = " in each matching heap, the following output is printed on a single line:"]
    #[doc = ""]
    #[doc = " - Block address (the data buffer returned by malloc is 4 bytes after this"]
    #[doc = "   if heap debugging is set to Basic, or 8 bytes otherwise)."]
    #[doc = " - Data size (the data size may be larger than the size requested by malloc,"]
    #[doc = "   either due to heap fragmentation or because of heap debugging level)."]
    #[doc = " - Address of next block in the heap."]
    #[doc = " - If the block is free, the address of the next free block is also printed."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    pub fn heap_caps_dump(caps: u32);
}
extern "C" {
    #[doc = " @brief Dump the full structure of all heaps."]
    #[doc = ""]
    #[doc = " Covers all registered heaps. Prints a large amount of output to serial."]
    #[doc = ""]
    #[doc = " Output is the same as for heap_caps_dump."]
    #[doc = ""]
    pub fn heap_caps_dump_all();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct soc_memory_type_desc_t {
    #[doc = "< Name of this memory type"]
    pub name: *const cty::c_char,
    #[doc = "< Capabilities for this memory type (as a prioritised set)"]
    pub caps: [u32; 3usize],
    #[doc = "< If true, this is data memory that is is also mapped in IRAM"]
    pub aliased_iram: bool,
    #[doc = "< If true, memory of this type is used for ROM stack during startup"]
    pub startup_stack: bool,
}
extern "C" {
    pub static mut soc_memory_types: [soc_memory_type_desc_t; 0usize];
}
extern "C" {
    pub static soc_memory_type_count: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct soc_memory_region_t {
    #[doc = "< Start address of the region"]
    pub start: isize,
    #[doc = "< Size of the region in bytes"]
    pub size: usize,
    #[doc = "< Type of the region (index into soc_memory_types array)"]
    pub type_: usize,
    #[doc = "< If non-zero, is equivalent address in IRAM"]
    pub iram_address: isize,
}
extern "C" {
    pub static mut soc_memory_regions: [soc_memory_region_t; 0usize];
}
extern "C" {
    pub static soc_memory_region_count: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct soc_reserved_region_t {
    pub start: isize,
    pub end: isize,
}
extern "C" {
    pub fn soc_get_available_memory_regions(regions: *mut soc_memory_region_t) -> usize;
}
extern "C" {
    pub fn soc_get_available_memory_region_max_count() -> usize;
}
pub type StackType_t = u8;
pub type BaseType_t = cty::c_int;
pub type UBaseType_t = cty::c_uint;
pub type TickType_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct portMUX_TYPE {
    pub owner: u32,
    pub count: u32,
}
extern "C" {
    pub fn vPortAssertIfInISR();
}
extern "C" {
    pub fn vPortCPUInitializeMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vTaskExitCritical(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vTaskEnterCritical(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vPortCPUAcquireMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    #[doc = " @brief Acquire a portmux spinlock with a timeout"]
    #[doc = ""]
    #[doc = " @param mux Pointer to portmux to acquire."]
    #[doc = " @param timeout_cycles Timeout to spin, in CPU cycles. Pass portMUX_NO_TIMEOUT to wait forever,"]
    #[doc = " portMUX_TRY_LOCK to try a single time to acquire the lock."]
    #[doc = ""]
    #[doc = " @return true if mutex is successfully acquired, false on timeout."]
    pub fn vPortCPUAcquireMutexTimeout(mux: *mut portMUX_TYPE, timeout_cycles: cty::c_int) -> bool;
}
extern "C" {
    pub fn vPortCPUReleaseMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vPortYield();
}
extern "C" {
    pub fn _frxt_setup_switch();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMPU_SETTINGS {
    pub coproc_area: *mut StackType_t,
}
extern "C" {
    pub fn esp_vApplicationIdleHook();
}
extern "C" {
    pub fn esp_vApplicationTickHook();
}
extern "C" {
    pub fn _xt_coproc_release(coproc_sa_base: *mut cty::c_void);
}
extern "C" {
    pub fn vApplicationSleep(xExpectedIdleTime: TickType_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub bt_select: u32,
    pub out: u32,
    pub out_w1ts: u32,
    pub out_w1tc: u32,
    pub out1: _bindgen_ty_1__bindgen_ty_1,
    pub out1_w1ts: _bindgen_ty_1__bindgen_ty_2,
    pub out1_w1tc: _bindgen_ty_1__bindgen_ty_3,
    pub sdio_select: _bindgen_ty_1__bindgen_ty_4,
    pub enable: u32,
    pub enable_w1ts: u32,
    pub enable_w1tc: u32,
    pub enable1: _bindgen_ty_1__bindgen_ty_5,
    pub enable1_w1ts: _bindgen_ty_1__bindgen_ty_6,
    pub enable1_w1tc: _bindgen_ty_1__bindgen_ty_7,
    pub strap: _bindgen_ty_1__bindgen_ty_8,
    pub in_: u32,
    pub in1: _bindgen_ty_1__bindgen_ty_9,
    pub status: u32,
    pub status_w1ts: u32,
    pub status_w1tc: u32,
    pub status1: _bindgen_ty_1__bindgen_ty_10,
    pub status1_w1ts: _bindgen_ty_1__bindgen_ty_11,
    pub status1_w1tc: _bindgen_ty_1__bindgen_ty_12,
    pub reserved_5c: u32,
    pub acpu_int: u32,
    pub acpu_nmi_int: u32,
    pub pcpu_int: u32,
    pub pcpu_nmi_int: u32,
    pub cpusdio_int: u32,
    pub acpu_int1: _bindgen_ty_1__bindgen_ty_13,
    pub acpu_nmi_int1: _bindgen_ty_1__bindgen_ty_14,
    pub pcpu_int1: _bindgen_ty_1__bindgen_ty_15,
    pub pcpu_nmi_int1: _bindgen_ty_1__bindgen_ty_16,
    pub cpusdio_int1: _bindgen_ty_1__bindgen_ty_17,
    pub pin: [_bindgen_ty_1__bindgen_ty_18; 40usize],
    pub cali_conf: _bindgen_ty_1__bindgen_ty_19,
    pub cali_data: _bindgen_ty_1__bindgen_ty_20,
    pub func_in_sel_cfg: [_bindgen_ty_1__bindgen_ty_21; 256usize],
    pub func_out_sel_cfg: [_bindgen_ty_1__bindgen_ty_22; 40usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_2 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_3 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_4 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sel: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sel: u32 = unsafe { ::core::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_5 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_6 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_7 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_8 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_1__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn strapping(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_strapping(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        strapping: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let strapping: u32 = unsafe { ::core::mem::transmute(strapping) };
            strapping as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_9 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_10 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_11 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_12 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_13 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_14 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_15 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_16 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_17 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_18 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_1__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_driver(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_driver(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn config(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_config(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn int_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_int_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pad_driver: u32,
        reserved3: u32,
        int_type: u32,
        wakeup_enable: u32,
        config: u32,
        int_ena: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pad_driver: u32 = unsafe { ::core::mem::transmute(pad_driver) };
            pad_driver as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let int_type: u32 = unsafe { ::core::mem::transmute(int_type) };
            int_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wakeup_enable: u32 = unsafe { ::core::mem::transmute(wakeup_enable) };
            wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let config: u32 = unsafe { ::core::mem::transmute(config) };
            config as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let int_ena: u32 = unsafe { ::core::mem::transmute(int_ena) };
            int_ena as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_19 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn rtc_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_max: u32,
        reserved10: u32,
        start: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let rtc_max: u32 = unsafe { ::core::mem::transmute(rtc_max) };
            rtc_max as u64
        });
        __bindgen_bitfield_unit.set(10usize, 21u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_20 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn value_sync2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_value_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_real(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_real(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_sync2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value_sync2: u32,
        reserved20: u32,
        rdy_real: u32,
        rdy_sync2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let value_sync2: u32 = unsafe { ::core::mem::transmute(value_sync2) };
            value_sync2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rdy_real: u32 = unsafe { ::core::mem::transmute(rdy_real) };
            rdy_real as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rdy_sync2: u32 = unsafe { ::core::mem::transmute(rdy_sync2) };
            rdy_sync2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_21 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        sig_in_inv: u32,
        sig_in_sel: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sig_in_inv: u32 = unsafe { ::core::mem::transmute(sig_in_inv) };
            sig_in_inv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sig_in_sel: u32 = unsafe { ::core::mem::transmute(sig_in_sel) };
            sig_in_sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_1__bindgen_ty_22 {
    pub __bindgen_anon_1: _bindgen_ty_1__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_1__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        inv_sel: u32,
        oen_sel: u32,
        oen_inv_sel: u32,
        reserved12: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inv_sel: u32 = unsafe { ::core::mem::transmute(inv_sel) };
            inv_sel as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let oen_sel: u32 = unsafe { ::core::mem::transmute(oen_sel) };
            oen_sel as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let oen_inv_sel: u32 = unsafe { ::core::mem::transmute(oen_inv_sel) };
            oen_inv_sel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpio_dev_t = _bindgen_ty_1;
extern "C" {
    pub static mut GPIO: gpio_dev_t;
}
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_DISABLE: GPIO_INT_TYPE = 0;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_POSEDGE: GPIO_INT_TYPE = 1;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_NEGEDGE: GPIO_INT_TYPE = 2;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_ANYEDGE: GPIO_INT_TYPE = 3;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_LOLEVEL: GPIO_INT_TYPE = 4;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_HILEVEL: GPIO_INT_TYPE = 5;
pub type GPIO_INT_TYPE = u32;
pub type gpio_intr_handler_fn_t =
    ::core::option::Option<unsafe extern "C" fn(intr_mask: u32, high: bool, arg: *mut cty::c_void)>;
extern "C" {
    #[doc = " @brief Initialize GPIO. This includes reading the GPIO Configuration DataSet"]
    #[doc = "        to initialize \"output enables\" and pin configurations for each gpio pin."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_init();
}
extern "C" {
    #[doc = " @brief Change GPIO(0-31) pin output by setting, clearing, or disabling pins, GPIO0<->BIT(0)."]
    #[doc = "         There is no particular ordering guaranteed; so if the order of writes is significant,"]
    #[doc = "         calling code should divide a single call into multiple calls."]
    #[doc = ""]
    #[doc = " @param  uint32_t set_mask : the gpios that need high level."]
    #[doc = ""]
    #[doc = " @param  uint32_t clear_mask : the gpios that need low level."]
    #[doc = ""]
    #[doc = " @param  uint32_t enable_mask : the gpios that need be changed."]
    #[doc = ""]
    #[doc = " @param  uint32_t disable_mask : the gpios that need diable output."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_output_set(set_mask: u32, clear_mask: u32, enable_mask: u32, disable_mask: u32);
}
extern "C" {
    #[doc = " @brief Change GPIO(32-39) pin output by setting, clearing, or disabling pins, GPIO32<->BIT(0)."]
    #[doc = "         There is no particular ordering guaranteed; so if the order of writes is significant,"]
    #[doc = "         calling code should divide a single call into multiple calls."]
    #[doc = ""]
    #[doc = " @param  uint32_t set_mask : the gpios that need high level."]
    #[doc = ""]
    #[doc = " @param  uint32_t clear_mask : the gpios that need low level."]
    #[doc = ""]
    #[doc = " @param  uint32_t enable_mask : the gpios that need be changed."]
    #[doc = ""]
    #[doc = " @param  uint32_t disable_mask : the gpios that need diable output."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_output_set_high(
        set_mask: u32,
        clear_mask: u32,
        enable_mask: u32,
        disable_mask: u32,
    );
}
extern "C" {
    #[doc = " @brief Sample the value of GPIO input pins(0-31) and returns a bitmask."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO input pins, BIT(0) for GPIO0."]
    pub fn gpio_input_get() -> u32;
}
extern "C" {
    #[doc = " @brief Sample the value of GPIO input pins(32-39) and returns a bitmask."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO input pins, BIT(0) for GPIO32."]
    pub fn gpio_input_get_high() -> u32;
}
extern "C" {
    #[doc = " @brief Register an application-specific interrupt handler for GPIO pin interrupts."]
    #[doc = "        Once the interrupt handler is called, it will not be called again until after a call to gpio_intr_ack."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param gpio_intr_handler_fn_t fn : gpio application-specific interrupt handler"]
    #[doc = ""]
    #[doc = " @param void *arg : gpio application-specific interrupt handler argument."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_intr_handler_register(fn_: gpio_intr_handler_fn_t, arg: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Get gpio interrupts which happens but not processed."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO pending interrupts, BIT(0) for GPIO0."]
    pub fn gpio_intr_pending() -> u32;
}
extern "C" {
    #[doc = " @brief Get gpio interrupts which happens but not processed."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO pending interrupts, BIT(0) for GPIO32."]
    pub fn gpio_intr_pending_high() -> u32;
}
extern "C" {
    #[doc = " @brief Ack gpio interrupts to process pending interrupts."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param uint32_t ack_mask: bitmask for GPIO ack interrupts, BIT(0) for GPIO0."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_intr_ack(ack_mask: u32);
}
extern "C" {
    #[doc = " @brief Ack gpio interrupts to process pending interrupts."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param uint32_t ack_mask: bitmask for GPIO ack interrupts, BIT(0) for GPIO32."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_intr_ack_high(ack_mask: u32);
}
extern "C" {
    #[doc = " @brief Set GPIO to wakeup the ESP32."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param uint32_t i: gpio number."]
    #[doc = ""]
    #[doc = " @param GPIO_INT_TYPE intr_state : only GPIO_PIN_INTR_LOLEVEL\\GPIO_PIN_INTR_HILEVEL can be used"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pin_wakeup_enable(i: u32, intr_state: GPIO_INT_TYPE);
}
extern "C" {
    #[doc = " @brief disable GPIOs to wakeup the ESP32."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pin_wakeup_disable();
}
extern "C" {
    #[doc = " @brief set gpio input to a signal, one gpio can input to several signals."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio : gpio number, 0~0x27"]
    #[doc = "                        gpio == 0x30, input 0 to signal"]
    #[doc = "                        gpio == 0x34, ???"]
    #[doc = "                        gpio == 0x38, input 1 to signal"]
    #[doc = ""]
    #[doc = " @param uint32_t signal_idx : signal index."]
    #[doc = ""]
    #[doc = " @param bool inv : the signal is inv or not"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_matrix_in(gpio: u32, signal_idx: u32, inv: bool);
}
extern "C" {
    #[doc = " @brief set signal output to gpio, one signal can output to several gpios."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @param uint32_t signal_idx : signal index."]
    #[doc = "                        signal_idx == 0x100, cancel output put to the gpio"]
    #[doc = ""]
    #[doc = " @param bool out_inv : the signal output is inv or not"]
    #[doc = ""]
    #[doc = " @param bool oen_inv : the signal output enable is inv or not"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_matrix_out(gpio: u32, signal_idx: u32, out_inv: bool, oen_inv: bool);
}
extern "C" {
    #[doc = " @brief Select pad as a gpio function from IOMUX."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_select_gpio(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Set pad driver capability."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @param uint8_t drv : 0-3"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_set_drv(gpio_num: u8, drv: u8);
}
extern "C" {
    #[doc = " @brief Pull up the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_pullup(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Pull down the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_pulldown(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Unhold the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_unhold(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Hold the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_hold(gpio_num: u8);
}
pub type intr_handler_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intr_handle_data_t {
    _unused: [u8; 0],
}
pub type intr_handle_t = *mut intr_handle_data_t;
extern "C" {
    #[doc = " @brief Mark an interrupt as a shared interrupt"]
    #[doc = ""]
    #[doc = " This will mark a certain interrupt on the specified CPU as"]
    #[doc = " an interrupt that can be used to hook shared interrupt handlers"]
    #[doc = " to."]
    #[doc = ""]
    #[doc = " @param intno The number of the interrupt (0-31)"]
    #[doc = " @param cpu CPU on which the interrupt should be marked as shared (0 or 1)"]
    #[doc = " @param is_in_iram Shared interrupt is for handlers that reside in IRAM and"]
    #[doc = "                   the int can be left enabled while the flash cache is disabled."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if cpu or intno is invalid"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_mark_shared(intno: cty::c_int, cpu: cty::c_int, is_in_iram: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reserve an interrupt to be used outside of this framework"]
    #[doc = ""]
    #[doc = " This will mark a certain interrupt on the specified CPU as"]
    #[doc = " reserved, not to be allocated for any reason."]
    #[doc = ""]
    #[doc = " @param intno The number of the interrupt (0-31)"]
    #[doc = " @param cpu CPU on which the interrupt should be marked as shared (0 or 1)"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if cpu or intno is invalid"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_reserve(intno: cty::c_int, cpu: cty::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters."]
    #[doc = ""]
    #[doc = " This finds an interrupt that matches the restrictions as given in the flags"]
    #[doc = " parameter, maps the given interrupt source to it and hooks up the given"]
    #[doc = " interrupt handler (with optional argument) as well. If needed, it can return"]
    #[doc = " a handle for the interrupt as well."]
    #[doc = ""]
    #[doc = " The interrupt will always be allocated on the core that runs this function."]
    #[doc = ""]
    #[doc = " If ESP_INTR_FLAG_IRAM flag is used, and handler address is not in IRAM or"]
    #[doc = " RTC_FAST_MEM, then ESP_ERR_INVALID_ARG is returned."]
    #[doc = ""]
    #[doc = " @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux"]
    #[doc = "               sources, as defined in soc/soc.h, or one of the internal"]
    #[doc = "               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header."]
    #[doc = " @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the"]
    #[doc = "               choice of interrupts that this routine can choose from. If this value"]
    #[doc = "               is 0, it will default to allocating a non-shared interrupt of level"]
    #[doc = "               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared"]
    #[doc = "               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return"]
    #[doc = "               from this function with the interrupt disabled."]
    #[doc = " @param handler The interrupt handler. Must be NULL when an interrupt of level >3"]
    #[doc = "               is requested, because these types of interrupts aren't C-callable."]
    #[doc = " @param arg    Optional argument for passed to the interrupt handler"]
    #[doc = " @param ret_handle Pointer to an intr_handle_t to store a handle that can later be"]
    #[doc = "               used to request details or free the interrupt. Can be NULL if no handle"]
    #[doc = "               is required."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_alloc(
        source: cty::c_int,
        flags: cty::c_int,
        handler: intr_handler_t,
        arg: *mut cty::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " This essentially does the same as esp_intr_alloc, but allows specifying a register and mask"]
    #[doc = " combo. For shared interrupts, the handler is only called if a read from the specified"]
    #[doc = " register, ANDed with the mask, returns non-zero. By passing an interrupt status register"]
    #[doc = " address and a fitting mask, this can be used to accelerate interrupt handling in the case"]
    #[doc = " a shared interrupt is triggered; by checking the interrupt statuses first, the code can"]
    #[doc = " decide which ISRs can be skipped"]
    #[doc = ""]
    #[doc = " @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux"]
    #[doc = "               sources, as defined in soc/soc.h, or one of the internal"]
    #[doc = "               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header."]
    #[doc = " @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the"]
    #[doc = "               choice of interrupts that this routine can choose from. If this value"]
    #[doc = "               is 0, it will default to allocating a non-shared interrupt of level"]
    #[doc = "               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared"]
    #[doc = "               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return"]
    #[doc = "               from this function with the interrupt disabled."]
    #[doc = " @param intrstatusreg The address of an interrupt status register"]
    #[doc = " @param intrstatusmask A mask. If a read of address intrstatusreg has any of the bits"]
    #[doc = "               that are 1 in the mask set, the ISR will be called. If not, it will be"]
    #[doc = "               skipped."]
    #[doc = " @param handler The interrupt handler. Must be NULL when an interrupt of level >3"]
    #[doc = "               is requested, because these types of interrupts aren't C-callable."]
    #[doc = " @param arg    Optional argument for passed to the interrupt handler"]
    #[doc = " @param ret_handle Pointer to an intr_handle_t to store a handle that can later be"]
    #[doc = "               used to request details or free the interrupt. Can be NULL if no handle"]
    #[doc = "               is required."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_alloc_intrstatus(
        source: cty::c_int,
        flags: cty::c_int,
        intrstatusreg: u32,
        intrstatusmask: u32,
        handler: intr_handler_t,
        arg: *mut cty::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable and free an interrupt."]
    #[doc = ""]
    #[doc = " Use an interrupt handle to disable the interrupt and release the resources associated with it."]
    #[doc = " If the current core is not the core that registered this interrupt, this routine will be assigned to"]
    #[doc = " the core that allocated this interrupt, blocking and waiting until the resource is successfully released."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " When the handler shares its source with other handlers, the interrupt status"]
    #[doc = " bits it's responsible for should be managed properly before freeing it. see"]
    #[doc = " ``esp_intr_disable`` for more details. Please do not call this function in ``esp_ipc_call_blocking``."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG the handle is NULL"]
    #[doc = "         ESP_FAIL failed to release this handle"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_free(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get CPU number an interrupt is tied to"]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return The core number where the interrupt is allocated"]
    pub fn esp_intr_get_cpu(handle: intr_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Get the allocated interrupt for a certain handle"]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return The interrupt number"]
    pub fn esp_intr_get_intno(handle: intr_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Disable the interrupt associated with the handle"]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " 1. For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the"]
    #[doc = " CPU the interrupt is allocated on. Other interrupts have no such restriction."]
    #[doc = " 2. When several handlers sharing a same interrupt source, interrupt status bits, which are"]
    #[doc = " handled in the handler to be disabled, should be masked before the disabling, or handled"]
    #[doc = " in other enabled interrupts properly. Miss of interrupt status handling will cause infinite"]
    #[doc = " interrupt calls and finally system crash."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_disable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the interrupt associated with the handle"]
    #[doc = ""]
    #[doc = " @note For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the"]
    #[doc = "       CPU the interrupt is allocated on. Other interrupts have no such restriction."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_enable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the \"in IRAM\" status of the handler."]
    #[doc = ""]
    #[doc = " @note Does not work on shared interrupts."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = " @param is_in_iram Whether the handler associated with this handle resides in IRAM."]
    #[doc = "                   Handlers residing in IRAM can be called when cache is disabled."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_set_in_iram(handle: intr_handle_t, is_in_iram: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable interrupts that aren't specifically marked as running from IRAM"]
    pub fn esp_intr_noniram_disable();
}
extern "C" {
    #[doc = " @brief Re-enable interrupts disabled by esp_intr_noniram_disable"]
    pub fn esp_intr_noniram_enable();
}
extern "C" {
    pub static mut GPIO_PIN_MUX_REG: [u32; 40usize];
}
#[doc = "< GPIO0, input and output"]
pub const gpio_num_t_GPIO_NUM_0: gpio_num_t = 0;
#[doc = "< GPIO1, input and output"]
pub const gpio_num_t_GPIO_NUM_1: gpio_num_t = 1;
#[doc = "< GPIO2, input and output"]
#[doc = "@note There are more enumerations like that"]
#[doc = "up to GPIO39, excluding GPIO20, GPIO24 and GPIO28..31."]
#[doc = "They are not shown here to reduce redundant information."]
#[doc = "@note GPIO34..39 are input mode only."]
pub const gpio_num_t_GPIO_NUM_2: gpio_num_t = 2;
#[doc = "< GPIO3, input and output"]
pub const gpio_num_t_GPIO_NUM_3: gpio_num_t = 3;
#[doc = "< GPIO4, input and output"]
pub const gpio_num_t_GPIO_NUM_4: gpio_num_t = 4;
#[doc = "< GPIO5, input and output"]
pub const gpio_num_t_GPIO_NUM_5: gpio_num_t = 5;
#[doc = "< GPIO6, input and output"]
pub const gpio_num_t_GPIO_NUM_6: gpio_num_t = 6;
#[doc = "< GPIO7, input and output"]
pub const gpio_num_t_GPIO_NUM_7: gpio_num_t = 7;
#[doc = "< GPIO8, input and output"]
pub const gpio_num_t_GPIO_NUM_8: gpio_num_t = 8;
#[doc = "< GPIO9, input and output"]
pub const gpio_num_t_GPIO_NUM_9: gpio_num_t = 9;
#[doc = "< GPIO10, input and output"]
pub const gpio_num_t_GPIO_NUM_10: gpio_num_t = 10;
#[doc = "< GPIO11, input and output"]
pub const gpio_num_t_GPIO_NUM_11: gpio_num_t = 11;
#[doc = "< GPIO12, input and output"]
pub const gpio_num_t_GPIO_NUM_12: gpio_num_t = 12;
#[doc = "< GPIO13, input and output"]
pub const gpio_num_t_GPIO_NUM_13: gpio_num_t = 13;
#[doc = "< GPIO14, input and output"]
pub const gpio_num_t_GPIO_NUM_14: gpio_num_t = 14;
#[doc = "< GPIO15, input and output"]
pub const gpio_num_t_GPIO_NUM_15: gpio_num_t = 15;
#[doc = "< GPIO16, input and output"]
pub const gpio_num_t_GPIO_NUM_16: gpio_num_t = 16;
#[doc = "< GPIO17, input and output"]
pub const gpio_num_t_GPIO_NUM_17: gpio_num_t = 17;
#[doc = "< GPIO18, input and output"]
pub const gpio_num_t_GPIO_NUM_18: gpio_num_t = 18;
#[doc = "< GPIO19, input and output"]
pub const gpio_num_t_GPIO_NUM_19: gpio_num_t = 19;
#[doc = "< GPIO21, input and output"]
pub const gpio_num_t_GPIO_NUM_21: gpio_num_t = 21;
#[doc = "< GPIO22, input and output"]
pub const gpio_num_t_GPIO_NUM_22: gpio_num_t = 22;
#[doc = "< GPIO23, input and output"]
pub const gpio_num_t_GPIO_NUM_23: gpio_num_t = 23;
#[doc = "< GPIO25, input and output"]
pub const gpio_num_t_GPIO_NUM_25: gpio_num_t = 25;
#[doc = "< GPIO26, input and output"]
pub const gpio_num_t_GPIO_NUM_26: gpio_num_t = 26;
#[doc = "< GPIO27, input and output"]
pub const gpio_num_t_GPIO_NUM_27: gpio_num_t = 27;
#[doc = "< GPIO32, input and output"]
pub const gpio_num_t_GPIO_NUM_32: gpio_num_t = 32;
#[doc = "< GPIO33, input and output"]
pub const gpio_num_t_GPIO_NUM_33: gpio_num_t = 33;
#[doc = "< GPIO34, input mode only"]
pub const gpio_num_t_GPIO_NUM_34: gpio_num_t = 34;
#[doc = "< GPIO35, input mode only"]
pub const gpio_num_t_GPIO_NUM_35: gpio_num_t = 35;
#[doc = "< GPIO36, input mode only"]
pub const gpio_num_t_GPIO_NUM_36: gpio_num_t = 36;
#[doc = "< GPIO37, input mode only"]
pub const gpio_num_t_GPIO_NUM_37: gpio_num_t = 37;
#[doc = "< GPIO38, input mode only"]
pub const gpio_num_t_GPIO_NUM_38: gpio_num_t = 38;
#[doc = "< GPIO39, input mode only"]
pub const gpio_num_t_GPIO_NUM_39: gpio_num_t = 39;
pub const gpio_num_t_GPIO_NUM_MAX: gpio_num_t = 40;
pub type gpio_num_t = u32;
#[doc = "< Disable GPIO interrupt"]
pub const gpio_int_type_t_GPIO_INTR_DISABLE: gpio_int_type_t = 0;
#[doc = "< GPIO interrupt type : rising edge"]
pub const gpio_int_type_t_GPIO_INTR_POSEDGE: gpio_int_type_t = 1;
#[doc = "< GPIO interrupt type : falling edge"]
pub const gpio_int_type_t_GPIO_INTR_NEGEDGE: gpio_int_type_t = 2;
#[doc = "< GPIO interrupt type : both rising and falling edge"]
pub const gpio_int_type_t_GPIO_INTR_ANYEDGE: gpio_int_type_t = 3;
#[doc = "< GPIO interrupt type : input low level trigger"]
pub const gpio_int_type_t_GPIO_INTR_LOW_LEVEL: gpio_int_type_t = 4;
#[doc = "< GPIO interrupt type : input high level trigger"]
pub const gpio_int_type_t_GPIO_INTR_HIGH_LEVEL: gpio_int_type_t = 5;
pub const gpio_int_type_t_GPIO_INTR_MAX: gpio_int_type_t = 6;
pub type gpio_int_type_t = u32;
#[doc = "< GPIO mode : disable input and output"]
pub const gpio_mode_t_GPIO_MODE_DISABLE: gpio_mode_t = 0;
#[doc = "< GPIO mode : input only"]
pub const gpio_mode_t_GPIO_MODE_INPUT: gpio_mode_t = 1;
#[doc = "< GPIO mode : output only mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT: gpio_mode_t = 2;
#[doc = "< GPIO mode : output only with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT_OD: gpio_mode_t = 6;
#[doc = "< GPIO mode : output and input with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT_OD: gpio_mode_t = 7;
#[doc = "< GPIO mode : output and input mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT: gpio_mode_t = 3;
pub type gpio_mode_t = u32;
#[doc = "< Disable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_DISABLE: gpio_pullup_t = 0;
#[doc = "< Enable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_ENABLE: gpio_pullup_t = 1;
pub type gpio_pullup_t = u32;
#[doc = "< Disable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_DISABLE: gpio_pulldown_t = 0;
#[doc = "< Enable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_ENABLE: gpio_pulldown_t = 1;
pub type gpio_pulldown_t = u32;
#[doc = " @brief Configuration parameters of GPIO pad for gpio_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_config_t {
    #[doc = "< GPIO pin: set with bit mask, each bit maps to a GPIO"]
    pub pin_bit_mask: u64,
    #[doc = "< GPIO mode: set input/output mode"]
    pub mode: gpio_mode_t,
    #[doc = "< GPIO pull-up"]
    pub pull_up_en: gpio_pullup_t,
    #[doc = "< GPIO pull-down"]
    pub pull_down_en: gpio_pulldown_t,
    #[doc = "< GPIO interrupt type"]
    pub intr_type: gpio_int_type_t,
}
#[doc = "< Pad pull up"]
pub const gpio_pull_mode_t_GPIO_PULLUP_ONLY: gpio_pull_mode_t = 0;
#[doc = "< Pad pull down"]
pub const gpio_pull_mode_t_GPIO_PULLDOWN_ONLY: gpio_pull_mode_t = 1;
#[doc = "< Pad pull up + pull down"]
pub const gpio_pull_mode_t_GPIO_PULLUP_PULLDOWN: gpio_pull_mode_t = 2;
#[doc = "< Pad floating"]
pub const gpio_pull_mode_t_GPIO_FLOATING: gpio_pull_mode_t = 3;
pub type gpio_pull_mode_t = u32;
#[doc = "< Pad drive capability: weak"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_0: gpio_drive_cap_t = 0;
#[doc = "< Pad drive capability: stronger"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_1: gpio_drive_cap_t = 1;
#[doc = "< Pad drive capability: default value"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_2: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: default value"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_DEFAULT: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: strongest"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_3: gpio_drive_cap_t = 3;
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_MAX: gpio_drive_cap_t = 4;
pub type gpio_drive_cap_t = u32;
pub type gpio_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
pub type gpio_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief GPIO common configuration"]
    #[doc = ""]
    #[doc = "        Configure GPIO's Mode,pull-up,PullDown,IntrType"]
    #[doc = ""]
    #[doc = " @param  pGPIOConfig Pointer to GPIO configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_config(pGPIOConfig: *const gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset an gpio to default state (select gpio function, enable pullup and disable input and output)."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @note This function also configures the IOMUX for this pin to the GPIO"]
    #[doc = "       function, and disconnects any other peripheral output configured via GPIO"]
    #[doc = "       Matrix."]
    #[doc = ""]
    #[doc = " @return Always return ESP_OK."]
    pub fn gpio_reset_pin(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set interrupt trigger type"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the trigger type of e.g. of GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  intr_type Interrupt type, select from gpio_int_type_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK  Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_set_intr_type(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Enable GPIO module interrupt signal"]
    #[doc = ""]
    #[doc = " @note Please do not use the interrupt of GPIO36 and GPIO39 when using ADC."]
    #[doc = "       Please refer to the comments of `adc1_get_raw`."]
    #[doc = "       Please refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to enable an interrupt on e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_intr_enable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable GPIO module interrupt signal"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to disable the interrupt of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_intr_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set output level"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the output level of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  level Output level. 0: low ; 1: high"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO number error"]
    #[doc = ""]
    pub fn gpio_set_level(gpio_num: gpio_num_t, level: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO get input level"]
    #[doc = ""]
    #[doc = " @warning If the pad is not configured for input (or input and output) the returned value is always 0."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to get the logic level of e.g. pin GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0 the GPIO input level is 0"]
    #[doc = "     - 1 the GPIO input level is 1"]
    #[doc = ""]
    pub fn gpio_get_level(gpio_num: gpio_num_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief\t GPIO set direction"]
    #[doc = ""]
    #[doc = " Configure GPIO direction,such as output_only,input_only,output_and_input"]
    #[doc = ""]
    #[doc = " @param  gpio_num  Configure GPIO pins number, it should be GPIO number. If you want to set direction of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  mode GPIO direction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = ""]
    pub fn gpio_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Configure GPIO pull-up/pull-down resistors"]
    #[doc = ""]
    #[doc = " Only pins that support both input & output have integrated pull-up and pull-down resistors. Input-only GPIOs 34-39 do not."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set pull up or down mode for e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  pull GPIO pull up/down mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG : Parameter error"]
    #[doc = ""]
    pub fn gpio_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @param intr_type GPIO wake-up type. Only GPIO_INTR_LOW_LEVEL or GPIO_INTR_HIGH_LEVEL can be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_enable(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register GPIO interrupt handler, the handler is an ISR."]
    #[doc = "          The handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " This ISR function is called whenever any GPIO interrupt occurs. See"]
    #[doc = " the alternative gpio_install_isr_service() and"]
    #[doc = " gpio_isr_handler_add() API in order to have the driver support"]
    #[doc = " per-GPIO ISRs."]
    #[doc = ""]
    #[doc = " @param  fn  Interrupt handler function."]
    #[doc = " @param  intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param  arg  Parameter for handler function"]
    #[doc = " @param  handle Pointer to return handle. If non-NULL, a handle for the interrupt will be returned here."]
    #[doc = ""]
    #[doc = " \\verbatim embed:rst:leading-asterisk"]
    #[doc = " To disable or remove the ISR, pass the returned handle to the :doc:`interrupt allocation functions </api-reference/system/intr_alloc>`."]
    #[doc = " \\endverbatim"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success ;"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    pub fn gpio_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg: *mut cty::c_void,
        intr_alloc_flags: cty::c_int,
        handle: *mut gpio_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers."]
    #[doc = ""]
    #[doc = " This function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function."]
    #[doc = ""]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM No memory to install this service"]
    #[doc = "     - ESP_ERR_INVALID_STATE ISR service already installed."]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_install_isr_service(intr_alloc_flags: cty::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall the driver's GPIO ISR service, freeing related resources."]
    pub fn gpio_uninstall_isr_service();
}
extern "C" {
    #[doc = " @brief Add ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " Call this function after using gpio_install_isr_service() to"]
    #[doc = " install the driver's GPIO ISR handler service."]
    #[doc = ""]
    #[doc = " The pin ISR handlers no longer need to be declared with IRAM_ATTR,"]
    #[doc = " unless you pass the ESP_INTR_FLAG_IRAM flag when allocating the"]
    #[doc = " ISR in gpio_install_isr_service()."]
    #[doc = ""]
    #[doc = " This ISR handler will be called from an ISR. So there is a stack"]
    #[doc = " size limit (configurable as \"ISR stack size\" in menuconfig). This"]
    #[doc = " limit is smaller compared to a global GPIO interrupt handler due"]
    #[doc = " to the additional level of indirection."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = " @param isr_handler ISR handler function for the corresponding GPIO number."]
    #[doc = " @param args parameter for ISR handler."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_add(
        gpio_num: gpio_num_t,
        isr_handler: gpio_isr_t,
        args: *mut cty::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_remove(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_set_drive_capability(gpio_num: gpio_num_t, strength: gpio_drive_cap_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Pointer to accept drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_get_drive_capability(
        gpio_num: gpio_num_t,
        strength: *mut gpio_drive_cap_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable gpio pad hold function."]
    #[doc = ""]
    #[doc = " The gpio pad hold function works in both input and output modes, but must be output-capable gpios."]
    #[doc = " If pad hold enabled:"]
    #[doc = "   in output mode: the output level of the pad will be force locked and can not be changed."]
    #[doc = "   in input mode: the input value read will not change, regardless the changes of input signal."]
    #[doc = ""]
    #[doc = " The state of digital gpio cannot be held during Deep-sleep, and it will resume the hold function"]
    #[doc = " when the chip wakes up from Deep-sleep. If the digital gpio also needs to be held during Deep-sleep,"]
    #[doc = " `gpio_deep_sleep_hold_en` should also be called."]
    #[doc = ""]
    #[doc = " Power down or call gpio_hold_dis will disable this function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output-capable GPIOs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable gpio pad hold function."]
    #[doc = ""]
    #[doc = " When the chip is woken up from Deep-sleep, the gpio will be set to the default mode, so, the gpio will output"]
    #[doc = " the default level if this function is called. If you dont't want the level changes, the gpio should be configured to"]
    #[doc = " a known state before this function is called."]
    #[doc = "  e.g."]
    #[doc = "     If you hold gpio18 high during Deep-sleep, after the chip is woken up and `gpio_hold_dis` is called,"]
    #[doc = "     gpio18 will output low level(because gpio18 is input mode by default). If you don't want this behavior,"]
    #[doc = "     you should configure gpio18 as output mode and set it to hight level before calling `gpio_hold_dis`."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output-capable GPIOs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable all digital gpio pad hold function during Deep-sleep."]
    #[doc = ""]
    #[doc = " When the chip is in Deep-sleep mode, all digital gpio will hold the state before sleep, and when the chip is woken up,"]
    #[doc = " the status of digital gpio will not be held. Note that the pad hold feature only works when the chip is in Deep-sleep mode,"]
    #[doc = " when not in sleep mode, the digital gpio state can be changed even you have called this function."]
    #[doc = ""]
    #[doc = " Power down or call gpio_hold_dis will disable this function, otherwise, the digital gpio hold feature works as long as the chip enter Deep-sleep."]
    pub fn gpio_deep_sleep_hold_en();
}
extern "C" {
    #[doc = " @brief Disable all digital gpio pad hold function during Deep-sleep."]
    #[doc = ""]
    pub fn gpio_deep_sleep_hold_dis();
}
extern "C" {
    #[doc = " @brief Set pad input to a peripheral signal through the IOMUX."]
    #[doc = " @param gpio_num GPIO number of the pad."]
    #[doc = " @param signal_idx Peripheral signal id to input. One of the ``*_IN_IDX`` signals in ``soc/gpio_sig_map.h``."]
    pub fn gpio_iomux_in(gpio_num: u32, signal_idx: u32);
}
extern "C" {
    #[doc = " @brief Set peripheral output to an GPIO pad through the IOMUX."]
    #[doc = " @param gpio_num gpio_num GPIO number of the pad."]
    #[doc = " @param func The function number of the peripheral pin to output pin."]
    #[doc = "        One of the ``FUNC_X_*`` of specified pin (X) in ``soc/io_mux_reg.h``."]
    #[doc = " @param oen_inv True if the output enable needs to be inversed, otherwise False."]
    pub fn gpio_iomux_out(gpio_num: u8, func: cty::c_int, oen_inv: bool);
}
pub type xt_handler = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
pub type xt_exc_handler = ::core::option::Option<unsafe extern "C" fn(arg1: *mut XtExcFrame)>;
extern "C" {
    pub fn xt_set_exception_handler(n: cty::c_int, f: xt_exc_handler) -> xt_exc_handler;
}
extern "C" {
    pub fn xt_set_interrupt_handler(
        n: cty::c_int,
        f: xt_handler,
        arg: *mut cty::c_void,
    ) -> xt_handler;
}
extern "C" {
    pub fn xt_ints_on(mask: cty::c_uint);
}
extern "C" {
    pub fn xt_ints_off(mask: cty::c_uint);
}
extern "C" {
    pub fn xt_get_interrupt_handler_arg(n: cty::c_int) -> *mut cty::c_void;
}
#[doc = "< Touch pad channel 0 is GPIO4"]
pub const touch_pad_t_TOUCH_PAD_NUM0: touch_pad_t = 0;
#[doc = "< Touch pad channel 1 is GPIO0"]
pub const touch_pad_t_TOUCH_PAD_NUM1: touch_pad_t = 1;
#[doc = "< Touch pad channel 2 is GPIO2"]
pub const touch_pad_t_TOUCH_PAD_NUM2: touch_pad_t = 2;
#[doc = "< Touch pad channel 3 is GPIO15"]
pub const touch_pad_t_TOUCH_PAD_NUM3: touch_pad_t = 3;
#[doc = "< Touch pad channel 4 is GPIO13"]
pub const touch_pad_t_TOUCH_PAD_NUM4: touch_pad_t = 4;
#[doc = "< Touch pad channel 5 is GPIO12"]
pub const touch_pad_t_TOUCH_PAD_NUM5: touch_pad_t = 5;
#[doc = "< Touch pad channel 6 is GPIO14"]
pub const touch_pad_t_TOUCH_PAD_NUM6: touch_pad_t = 6;
#[doc = "< Touch pad channel 7 is GPIO27"]
pub const touch_pad_t_TOUCH_PAD_NUM7: touch_pad_t = 7;
#[doc = "< Touch pad channel 8 is GPIO33"]
pub const touch_pad_t_TOUCH_PAD_NUM8: touch_pad_t = 8;
#[doc = "< Touch pad channel 9 is GPIO32"]
pub const touch_pad_t_TOUCH_PAD_NUM9: touch_pad_t = 9;
pub const touch_pad_t_TOUCH_PAD_MAX: touch_pad_t = 10;
pub type touch_pad_t = u32;
#[doc = "<Touch sensor high reference voltage, no change"]
pub const touch_high_volt_t_TOUCH_HVOLT_KEEP: touch_high_volt_t = -1;
#[doc = "<Touch sensor high reference voltage, 2.4V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V4: touch_high_volt_t = 0;
#[doc = "<Touch sensor high reference voltage, 2.5V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V5: touch_high_volt_t = 1;
#[doc = "<Touch sensor high reference voltage, 2.6V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V6: touch_high_volt_t = 2;
#[doc = "<Touch sensor high reference voltage, 2.7V"]
pub const touch_high_volt_t_TOUCH_HVOLT_2V7: touch_high_volt_t = 3;
pub const touch_high_volt_t_TOUCH_HVOLT_MAX: touch_high_volt_t = 4;
pub type touch_high_volt_t = i32;
#[doc = "<Touch sensor low reference voltage, no change"]
pub const touch_low_volt_t_TOUCH_LVOLT_KEEP: touch_low_volt_t = -1;
#[doc = "<Touch sensor low reference voltage, 0.5V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V5: touch_low_volt_t = 0;
#[doc = "<Touch sensor low reference voltage, 0.6V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V6: touch_low_volt_t = 1;
#[doc = "<Touch sensor low reference voltage, 0.7V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V7: touch_low_volt_t = 2;
#[doc = "<Touch sensor low reference voltage, 0.8V"]
pub const touch_low_volt_t_TOUCH_LVOLT_0V8: touch_low_volt_t = 3;
pub const touch_low_volt_t_TOUCH_LVOLT_MAX: touch_low_volt_t = 4;
pub type touch_low_volt_t = i32;
#[doc = "<Touch sensor high reference voltage attenuation, no change"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_KEEP: touch_volt_atten_t = -1;
#[doc = "<Touch sensor high reference voltage attenuation, 1.5V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_1V5: touch_volt_atten_t = 0;
#[doc = "<Touch sensor high reference voltage attenuation, 1.0V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_1V: touch_volt_atten_t = 1;
#[doc = "<Touch sensor high reference voltage attenuation, 0.5V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_0V5: touch_volt_atten_t = 2;
#[doc = "<Touch sensor high reference voltage attenuation,   0V attenuation"]
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_0V: touch_volt_atten_t = 3;
pub const touch_volt_atten_t_TOUCH_HVOLT_ATTEN_MAX: touch_volt_atten_t = 4;
pub type touch_volt_atten_t = i32;
#[doc = "<Touch sensor charge / discharge speed, always zero"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_0: touch_cnt_slope_t = 0;
#[doc = "<Touch sensor charge / discharge speed, slowest"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_1: touch_cnt_slope_t = 1;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_2: touch_cnt_slope_t = 2;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_3: touch_cnt_slope_t = 3;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_4: touch_cnt_slope_t = 4;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_5: touch_cnt_slope_t = 5;
#[doc = "<Touch sensor charge / discharge speed"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_6: touch_cnt_slope_t = 6;
#[doc = "<Touch sensor charge / discharge speed, fast"]
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_7: touch_cnt_slope_t = 7;
pub const touch_cnt_slope_t_TOUCH_PAD_SLOPE_MAX: touch_cnt_slope_t = 8;
pub type touch_cnt_slope_t = u32;
#[doc = "<Touch interrupt will happen if counter value is less than threshold."]
pub const touch_trigger_mode_t_TOUCH_TRIGGER_BELOW: touch_trigger_mode_t = 0;
#[doc = "<Touch interrupt will happen if counter value is larger than threshold."]
pub const touch_trigger_mode_t_TOUCH_TRIGGER_ABOVE: touch_trigger_mode_t = 1;
pub const touch_trigger_mode_t_TOUCH_TRIGGER_MAX: touch_trigger_mode_t = 2;
pub type touch_trigger_mode_t = u32;
#[doc = "< wakeup interrupt is generated if both SET1 and SET2 are \"touched\""]
pub const touch_trigger_src_t_TOUCH_TRIGGER_SOURCE_BOTH: touch_trigger_src_t = 0;
#[doc = "< wakeup interrupt is generated if SET1 is \"touched\""]
pub const touch_trigger_src_t_TOUCH_TRIGGER_SOURCE_SET1: touch_trigger_src_t = 1;
pub const touch_trigger_src_t_TOUCH_TRIGGER_SOURCE_MAX: touch_trigger_src_t = 2;
pub type touch_trigger_src_t = u32;
#[doc = "<Initial level of charging voltage, low level"]
pub const touch_tie_opt_t_TOUCH_PAD_TIE_OPT_LOW: touch_tie_opt_t = 0;
#[doc = "<Initial level of charging voltage, high level"]
pub const touch_tie_opt_t_TOUCH_PAD_TIE_OPT_HIGH: touch_tie_opt_t = 1;
pub const touch_tie_opt_t_TOUCH_PAD_TIE_OPT_MAX: touch_tie_opt_t = 2;
pub type touch_tie_opt_t = u32;
#[doc = "<To start touch FSM by timer"]
pub const touch_fsm_mode_t_TOUCH_FSM_MODE_TIMER: touch_fsm_mode_t = 0;
#[doc = "<To start touch FSM by software trigger"]
pub const touch_fsm_mode_t_TOUCH_FSM_MODE_SW: touch_fsm_mode_t = 1;
pub const touch_fsm_mode_t_TOUCH_FSM_MODE_MAX: touch_fsm_mode_t = 2;
pub type touch_fsm_mode_t = u32;
pub type touch_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief Initialize touch module."]
    #[doc = " @note  The default FSM mode is 'TOUCH_FSM_MODE_SW'. If you want to use interrupt trigger mode,"]
    #[doc = "        then set it using function 'touch_pad_set_fsm_mode' to 'TOUCH_FSM_MODE_TIMER' after calling 'touch_pad_init'."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Touch pad init error"]
    pub fn touch_pad_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Un-install touch pad driver."]
    #[doc = " @note  After this function is called, other touch functions are prohibited from being called."]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Touch pad driver not initialized"]
    pub fn touch_pad_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure touch pad interrupt threshold."]
    #[doc = ""]
    #[doc = " @note  If FSM mode is set to TOUCH_FSM_MODE_TIMER, this function will be blocked for one measurement cycle and wait for data to be valid."]
    #[doc = ""]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param threshold interrupt threshold,"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG if argument wrong"]
    #[doc = "     - ESP_FAIL if touch pad not initialized"]
    pub fn touch_pad_config(touch_num: touch_pad_t, threshold: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get touch sensor counter value."]
    #[doc = "        Each touch sensor has a counter to count the number of charge/discharge cycles."]
    #[doc = "        When the pad is not 'touched', we can get a number of the counter."]
    #[doc = "        When the pad is 'touched', the value in counter will get smaller because of the larger equivalent capacitance."]
    #[doc = ""]
    #[doc = " @note This API requests hardware measurement once. If IIR filter mode is enabled,"]
    #[doc = "       please use 'touch_pad_read_raw_data' interface instead."]
    #[doc = ""]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param touch_value pointer to accept touch sensor value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Touch pad parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE This touch pad hardware connection is error, the value of \"touch_value\" is 0."]
    #[doc = "     - ESP_FAIL Touch pad not initialized"]
    pub fn touch_pad_read(touch_num: touch_pad_t, touch_value: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get filtered touch sensor counter value by IIR filter."]
    #[doc = ""]
    #[doc = " @note touch_pad_filter_start has to be called before calling touch_pad_read_filtered."]
    #[doc = "       This function can be called from ISR"]
    #[doc = ""]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param touch_value pointer to accept touch sensor value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Touch pad parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE This touch pad hardware connection is error, the value of \"touch_value\" is 0."]
    #[doc = "     - ESP_FAIL Touch pad not initialized"]
    pub fn touch_pad_read_filtered(touch_num: touch_pad_t, touch_value: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get raw data (touch sensor counter value) from IIR filter process."]
    #[doc = "        Need not request hardware measurements."]
    #[doc = ""]
    #[doc = " @note touch_pad_filter_start has to be called before calling touch_pad_read_raw_data."]
    #[doc = "       This function can be called from ISR"]
    #[doc = ""]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param touch_value pointer to accept touch sensor value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Touch pad parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE This touch pad hardware connection is error, the value of \"touch_value\" is 0."]
    #[doc = "     - ESP_FAIL Touch pad not initialized"]
    pub fn touch_pad_read_raw_data(touch_num: touch_pad_t, touch_value: *mut u16) -> esp_err_t;
}
#[doc = " @brief Callback function that is called after each IIR filter calculation."]
#[doc = " @note This callback is called in timer task in each filtering cycle."]
#[doc = " @note This callback should not be blocked."]
#[doc = " @param raw_value  The latest raw data(touch sensor counter value) that"]
#[doc = "        points to all channels(raw_value[0..TOUCH_PAD_MAX-1])."]
#[doc = " @param filtered_value  The latest IIR filtered data(calculated from raw data) that"]
#[doc = "        points to all channels(filtered_value[0..TOUCH_PAD_MAX-1])."]
#[doc = ""]
pub type filter_cb_t =
    ::core::option::Option<unsafe extern "C" fn(raw_value: *mut u16, filtered_value: *mut u16)>;
extern "C" {
    #[doc = " @brief Register the callback function that is called after each IIR filter calculation."]
    #[doc = " @note The 'read_cb' callback is called in timer task in each filtering cycle."]
    #[doc = " @param read_cb  Pointer to filtered callback function."]
    #[doc = "                 If the argument passed in is NULL, the callback will stop."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG set error"]
    pub fn touch_pad_set_filter_read_cb(read_cb: filter_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register touch-pad ISR,"]
    #[doc = " @note Deprecated function, users should replace this with touch_pad_isr_register,"]
    #[doc = "       because RTC modules share a same interrupt index."]
    #[doc = " @param fn  Pointer to ISR handler"]
    #[doc = " @param arg  Parameter for ISR"]
    #[doc = " @param unused Reserved, not used"]
    #[doc = " @param handle_unused Reserved, not used"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success ;"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = "     - ESP_ERR_NO_MEM No memory"]
    pub fn touch_pad_isr_handler_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg: *mut cty::c_void,
        unused: cty::c_int,
        handle_unused: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register touch-pad ISR."]
    #[doc = "          The handler will be attached to the same CPU core that this function is running on."]
    #[doc = " @param fn  Pointer to ISR handler"]
    #[doc = " @param arg  Parameter for ISR"]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success ;"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = "     - ESP_ERR_NO_MEM No memory"]
    pub fn touch_pad_isr_register(fn_: intr_handler_t, arg: *mut cty::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deregister the handler previously registered using touch_pad_isr_handler_register"]
    #[doc = " @param fn  handler function to call (as passed to touch_pad_isr_handler_register)"]
    #[doc = " @param arg  argument of the handler (as passed to touch_pad_isr_handler_register)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if a handler matching both fn and"]
    #[doc = "        arg isn't registered"]
    pub fn touch_pad_isr_deregister(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg: *mut cty::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor measurement and sleep time"]
    #[doc = " @param sleep_cycle  The touch sensor will sleep after each measurement."]
    #[doc = "                     sleep_cycle decide the interval between each measurement."]
    #[doc = "                     t_sleep = sleep_cycle / (RTC_SLOW_CLK frequency)."]
    #[doc = "                     The approximate frequency value of RTC_SLOW_CLK can be obtained using rtc_clk_slow_freq_get_hz function."]
    #[doc = " @param meas_cycle The duration of the touch sensor measurement."]
    #[doc = "                   t_meas = meas_cycle / 8M, the maximum measure time is 0xffff / 8M = 8.19 ms"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_set_meas_time(sleep_cycle: u16, meas_cycle: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor measurement and sleep time"]
    #[doc = " @param sleep_cycle  Pointer to accept sleep cycle number"]
    #[doc = " @param meas_cycle Pointer to accept measurement cycle count."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_meas_time(sleep_cycle: *mut u16, meas_cycle: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor reference voltage, if the voltage gap between high and low reference voltage get less,"]
    #[doc = "        the charging and discharging time would be faster, accordingly, the counter value would be larger."]
    #[doc = "        In the case of detecting very slight change of capacitance, we can narrow down the gap so as to increase"]
    #[doc = "        the sensitivity. On the other hand, narrow voltage gap would also introduce more noise, but we can use a"]
    #[doc = "        software filter to pre-process the counter value."]
    #[doc = " @param refh the value of DREFH"]
    #[doc = " @param refl the value of DREFL"]
    #[doc = " @param atten the attenuation on DREFH"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_voltage(
        refh: touch_high_volt_t,
        refl: touch_low_volt_t,
        atten: touch_volt_atten_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor reference voltage,"]
    #[doc = " @param refh pointer to accept DREFH value"]
    #[doc = " @param refl pointer to accept DREFL value"]
    #[doc = " @param atten pointer to accept the attenuation on DREFH"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_voltage(
        refh: *mut touch_high_volt_t,
        refl: *mut touch_low_volt_t,
        atten: *mut touch_volt_atten_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor charge/discharge speed for each pad."]
    #[doc = "        If the slope is 0, the counter would always be zero."]
    #[doc = "        If the slope is 1, the charging and discharging would be slow, accordingly, the counter value would be small."]
    #[doc = "        If the slope is set 7, which is the maximum value, the charging and discharging would be fast, accordingly, the"]
    #[doc = "        counter value would be larger."]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param slope touch pad charge/discharge speed"]
    #[doc = " @param opt the initial voltage"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_cnt_mode(
        touch_num: touch_pad_t,
        slope: touch_cnt_slope_t,
        opt: touch_tie_opt_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor charge/discharge speed for each pad"]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param slope pointer to accept touch pad charge/discharge slope"]
    #[doc = " @param opt pointer to accept the initial voltage"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_get_cnt_mode(
        touch_num: touch_pad_t,
        slope: *mut touch_cnt_slope_t,
        opt: *mut touch_tie_opt_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize touch pad GPIO"]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_io_init(touch_num: touch_pad_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor FSM mode, the test action can be triggered by the timer,"]
    #[doc = "        as well as by the software."]
    #[doc = " @param mode FSM mode"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_fsm_mode(mode: touch_fsm_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor FSM mode"]
    #[doc = " @param mode pointer to accept FSM mode"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_fsm_mode(mode: *mut touch_fsm_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Trigger a touch sensor measurement, only support in SW mode of FSM"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_sw_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor interrupt threshold"]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param threshold threshold of touchpad count, refer to touch_pad_set_trigger_mode to see how to set trigger mode."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_thresh(touch_num: touch_pad_t, threshold: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor interrupt threshold"]
    #[doc = " @param touch_num touch pad index"]
    #[doc = " @param threshold pointer to accept threshold"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_get_thresh(touch_num: touch_pad_t, threshold: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor interrupt trigger mode."]
    #[doc = "        Interrupt can be triggered either when counter result is less than"]
    #[doc = "        threshold or when counter result is more than threshold."]
    #[doc = " @param mode touch sensor interrupt trigger mode"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_trigger_mode(mode: touch_trigger_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor interrupt trigger mode"]
    #[doc = " @param mode pointer to accept touch sensor interrupt trigger mode"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_trigger_mode(mode: *mut touch_trigger_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor interrupt trigger source. There are two sets of touch signals."]
    #[doc = "        Set1 and set2 can be mapped to several touch signals. Either set will be triggered"]
    #[doc = "        if at least one of its touch signal is 'touched'. The interrupt can be configured to be generated"]
    #[doc = "        if set1 is triggered, or only if both sets are triggered."]
    #[doc = " @param src touch sensor interrupt trigger source"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_trigger_source(src: touch_trigger_src_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor interrupt trigger source"]
    #[doc = " @param src pointer to accept touch sensor interrupt trigger source"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_trigger_source(src: *mut touch_trigger_src_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set touch sensor group mask."]
    #[doc = "        Touch pad module has two sets of signals, 'Touched' signal is triggered only if"]
    #[doc = "        at least one of touch pad in this group is \"touched\"."]
    #[doc = "        This function will set the register bits according to the given bitmask."]
    #[doc = " @param set1_mask bitmask of touch sensor signal group1, it's a 10-bit value"]
    #[doc = " @param set2_mask bitmask of touch sensor signal group2, it's a 10-bit value"]
    #[doc = " @param en_mask bitmask of touch sensor work enable, it's a 10-bit value"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_set_group_mask(set1_mask: u16, set2_mask: u16, en_mask: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get touch sensor group mask."]
    #[doc = " @param set1_mask pointer to accept bitmask of touch sensor signal group1, it's a 10-bit value"]
    #[doc = " @param set2_mask pointer to accept bitmask of touch sensor signal group2, it's a 10-bit value"]
    #[doc = " @param en_mask pointer to accept bitmask of touch sensor work enable, it's a 10-bit value"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_get_group_mask(
        set1_mask: *mut u16,
        set2_mask: *mut u16,
        en_mask: *mut u16,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear touch sensor group mask."]
    #[doc = "        Touch pad module has two sets of signals, Interrupt is triggered only if"]
    #[doc = "        at least one of touch pad in this group is \"touched\"."]
    #[doc = "        This function will clear the register bits according to the given bitmask."]
    #[doc = " @param set1_mask bitmask touch sensor signal group1, it's a 10-bit value"]
    #[doc = " @param set2_mask bitmask touch sensor signal group2, it's a 10-bit value"]
    #[doc = " @param en_mask bitmask of touch sensor work enable, it's a 10-bit value"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if argument is wrong"]
    pub fn touch_pad_clear_group_mask(set1_mask: u16, set2_mask: u16, en_mask: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief To clear the touch status register, usually use this function in touch ISR to clear status."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_clear_status() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the touch sensor status, usually used in ISR to decide which pads are 'touched'."]
    #[doc = " @return"]
    #[doc = "      - touch status"]
    pub fn touch_pad_get_status() -> u32;
}
extern "C" {
    #[doc = " @brief To enable touch pad interrupt"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_intr_enable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief To disable touch pad interrupt"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    pub fn touch_pad_intr_disable() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief set touch pad filter calibration period, in ms."]
    #[doc = "        Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = " @param new_period_ms filter period, in ms"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    #[doc = "      - ESP_ERR_INVALID_ARG parameter error"]
    pub fn touch_pad_set_filter_period(new_period_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief get touch pad filter calibration period, in ms"]
    #[doc = "        Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = " @param p_period_ms pointer to accept period"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    #[doc = "      - ESP_ERR_INVALID_ARG parameter error"]
    pub fn touch_pad_get_filter_period(p_period_ms: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief start touch pad filter function"]
    #[doc = "      This API will start a filter to process the noise in order to prevent false triggering"]
    #[doc = "      when detecting slight change of capacitance."]
    #[doc = "      Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = ""]
    #[doc = " @note This filter uses FreeRTOS timer, which is dispatched from a task with"]
    #[doc = "       priority 1 by default on CPU 0. So if some application task with higher priority"]
    #[doc = "       takes a lot of CPU0 time, then the quality of data obtained from this filter will be affected."]
    #[doc = "       You can adjust FreeRTOS timer task priority in menuconfig."]
    #[doc = " @param filter_period_ms filter calibration period, in ms"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_ARG parameter error"]
    #[doc = "      - ESP_ERR_NO_MEM No memory for driver"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    pub fn touch_pad_filter_start(filter_period_ms: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief stop touch pad filter function"]
    #[doc = "        Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    pub fn touch_pad_filter_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief delete touch pad filter driver and release the memory"]
    #[doc = "        Need to call touch_pad_filter_start before all touch filter APIs"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_ERR_INVALID_STATE driver state error"]
    pub fn touch_pad_filter_delete() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the touch pad which caused wakeup from sleep"]
    #[doc = " @param pad_num pointer to touch pad which caused wakeup"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK Success"]
    #[doc = "      - ESP_FAIL get status err"]
    pub fn touch_pad_get_wakeup_status(pad_num: *mut touch_pad_t) -> esp_err_t;
}
#[doc = "!< Wake the chip when all selected GPIOs go low"]
pub const esp_sleep_ext1_wakeup_mode_t_ESP_EXT1_WAKEUP_ALL_LOW: esp_sleep_ext1_wakeup_mode_t = 0;
#[doc = "!< Wake the chip when any of the selected GPIOs go high"]
pub const esp_sleep_ext1_wakeup_mode_t_ESP_EXT1_WAKEUP_ANY_HIGH: esp_sleep_ext1_wakeup_mode_t = 1;
#[doc = " @brief Logic function used for EXT1 wakeup mode."]
pub type esp_sleep_ext1_wakeup_mode_t = u32;
#[doc = "!< RTC IO, sensors and ULP co-processor"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_RTC_PERIPH: esp_sleep_pd_domain_t = 0;
#[doc = "!< RTC slow memory"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_RTC_SLOW_MEM: esp_sleep_pd_domain_t = 1;
#[doc = "!< RTC fast memory"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_RTC_FAST_MEM: esp_sleep_pd_domain_t = 2;
#[doc = "!< XTAL oscillator"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_XTAL: esp_sleep_pd_domain_t = 3;
#[doc = "!< Number of domains"]
pub const esp_sleep_pd_domain_t_ESP_PD_DOMAIN_MAX: esp_sleep_pd_domain_t = 4;
#[doc = " @brief Power domains which can be powered down in sleep mode"]
pub type esp_sleep_pd_domain_t = u32;
#[doc = "!< Power down the power domain in sleep mode"]
pub const esp_sleep_pd_option_t_ESP_PD_OPTION_OFF: esp_sleep_pd_option_t = 0;
#[doc = "!< Keep power domain enabled during sleep mode"]
pub const esp_sleep_pd_option_t_ESP_PD_OPTION_ON: esp_sleep_pd_option_t = 1;
#[doc = "!< Keep power domain enabled in sleep mode, if it is needed by one of the wakeup options. Otherwise power it down."]
pub const esp_sleep_pd_option_t_ESP_PD_OPTION_AUTO: esp_sleep_pd_option_t = 2;
#[doc = " @brief Power down options"]
pub type esp_sleep_pd_option_t = u32;
#[doc = "!< In case of deep sleep, reset was not caused by exit from deep sleep"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_UNDEFINED: esp_sleep_source_t = 0;
#[doc = "!< Not a wakeup cause, used to disable all wakeup sources with esp_sleep_disable_wakeup_source"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_ALL: esp_sleep_source_t = 1;
#[doc = "!< Wakeup caused by external signal using RTC_IO"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_EXT0: esp_sleep_source_t = 2;
#[doc = "!< Wakeup caused by external signal using RTC_CNTL"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_EXT1: esp_sleep_source_t = 3;
#[doc = "!< Wakeup caused by timer"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_TIMER: esp_sleep_source_t = 4;
#[doc = "!< Wakeup caused by touchpad"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_TOUCHPAD: esp_sleep_source_t = 5;
#[doc = "!< Wakeup caused by ULP program"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_ULP: esp_sleep_source_t = 6;
#[doc = "!< Wakeup caused by GPIO (light sleep only)"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_GPIO: esp_sleep_source_t = 7;
#[doc = "!< Wakeup caused by UART (light sleep only)"]
pub const esp_sleep_source_t_ESP_SLEEP_WAKEUP_UART: esp_sleep_source_t = 8;
#[doc = " @brief Sleep wakeup cause"]
pub type esp_sleep_source_t = u32;
pub use self::esp_sleep_source_t as esp_sleep_wakeup_cause_t;
extern "C" {
    #[doc = " @brief Disable wakeup source"]
    #[doc = ""]
    #[doc = " This function is used to deactivate wake up trigger for source"]
    #[doc = " defined as parameter of the function."]
    #[doc = ""]
    #[doc = " @note This function does not modify wake up configuration in RTC."]
    #[doc = "       It will be performed in esp_sleep_start function."]
    #[doc = ""]
    #[doc = " See docs/sleep-modes.rst for details."]
    #[doc = ""]
    #[doc = " @param source - number of source to disable of type esp_sleep_source_t"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if trigger was not active"]
    pub fn esp_sleep_disable_wakeup_source(source: esp_sleep_source_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup by ULP coprocessor"]
    #[doc = " @note In revisions 0 and 1 of the ESP32, ULP wakeup source"]
    #[doc = "       can not be used when RTC_PERIPH power domain is forced"]
    #[doc = "       to be powered on (ESP_PD_OPTION_ON) or when ext0 wakeup"]
    #[doc = "       source is used."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if additional current by touch (CONFIG_ESP32_RTC_EXTERNAL_CRYSTAL_ADDITIONAL_CURRENT) is enabled."]
    #[doc = "      - ESP_ERR_INVALID_STATE if ULP co-processor is not enabled or if wakeup triggers conflict"]
    pub fn esp_sleep_enable_ulp_wakeup() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup by timer"]
    #[doc = " @param time_in_us  time before wakeup, in microseconds"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if value is out of range (TBD)"]
    pub fn esp_sleep_enable_timer_wakeup(time_in_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup by touch sensor"]
    #[doc = ""]
    #[doc = " @note In revisions 0 and 1 of the ESP32, touch wakeup source"]
    #[doc = "       can not be used when RTC_PERIPH power domain is forced"]
    #[doc = "       to be powered on (ESP_PD_OPTION_ON) or when ext0 wakeup"]
    #[doc = "       source is used."]
    #[doc = ""]
    #[doc = " @note The FSM mode of the touch button should be configured"]
    #[doc = "       as the timer trigger mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_SUPPORTED if additional current by touch (CONFIG_ESP32_RTC_EXTERNAL_CRYSTAL_ADDITIONAL_CURRENT) is enabled."]
    #[doc = "      - ESP_ERR_INVALID_STATE if wakeup triggers conflict"]
    pub fn esp_sleep_enable_touchpad_wakeup() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the touch pad which caused wakeup"]
    #[doc = ""]
    #[doc = " If wakeup was caused by another source, this function will return TOUCH_PAD_MAX;"]
    #[doc = ""]
    #[doc = " @return touch pad which caused wakeup"]
    pub fn esp_sleep_get_touchpad_wakeup_status() -> touch_pad_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup using a pin"]
    #[doc = ""]
    #[doc = " This function uses external wakeup feature of RTC_IO peripheral."]
    #[doc = " It will work only if RTC peripherals are kept on during sleep."]
    #[doc = ""]
    #[doc = " This feature can monitor any pin which is an RTC IO. Once the pin transitions"]
    #[doc = " into the state given by level argument, the chip will be woken up."]
    #[doc = ""]
    #[doc = " @note This function does not modify pin configuration. The pin is"]
    #[doc = "       configured in esp_sleep_start, immediately before entering sleep mode."]
    #[doc = ""]
    #[doc = " @note In revisions 0 and 1 of the ESP32, ext0 wakeup source"]
    #[doc = "       can not be used together with touch or ULP wakeup sources."]
    #[doc = ""]
    #[doc = " @param gpio_num  GPIO number used as wakeup source. Only GPIOs which are have RTC"]
    #[doc = "             functionality can be used: 0,2,4,12-15,25-27,32-39."]
    #[doc = " @param level  input level which will trigger wakeup (0=low, 1=high)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the selected GPIO is not an RTC GPIO,"]
    #[doc = "        or the mode is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if wakeup triggers conflict"]
    pub fn esp_sleep_enable_ext0_wakeup(gpio_num: gpio_num_t, level: cty::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup using multiple pins"]
    #[doc = ""]
    #[doc = " This function uses external wakeup feature of RTC controller."]
    #[doc = " It will work even if RTC peripherals are shut down during sleep."]
    #[doc = ""]
    #[doc = " This feature can monitor any number of pins which are in RTC IOs."]
    #[doc = " Once any of the selected pins goes into the state given by mode argument,"]
    #[doc = " the chip will be woken up."]
    #[doc = ""]
    #[doc = " @note This function does not modify pin configuration. The pins are"]
    #[doc = "       configured in esp_sleep_start, immediately before"]
    #[doc = "       entering sleep mode."]
    #[doc = ""]
    #[doc = " @note internal pullups and pulldowns don't work when RTC peripherals are"]
    #[doc = "       shut down. In this case, external resistors need to be added."]
    #[doc = "       Alternatively, RTC peripherals (and pullups/pulldowns) may be"]
    #[doc = "       kept enabled using esp_sleep_pd_config function."]
    #[doc = ""]
    #[doc = " @param mask  bit mask of GPIO numbers which will cause wakeup. Only GPIOs"]
    #[doc = "              which are have RTC functionality can be used in this bit map:"]
    #[doc = "              0,2,4,12-15,25-27,32-39."]
    #[doc = " @param mode select logic function used to determine wakeup condition:"]
    #[doc = "            - ESP_EXT1_WAKEUP_ALL_LOW: wake up when all selected GPIOs are low"]
    #[doc = "            - ESP_EXT1_WAKEUP_ANY_HIGH: wake up when any of the selected GPIOs is high"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if any of the selected GPIOs is not an RTC GPIO,"]
    #[doc = "        or mode is invalid"]
    pub fn esp_sleep_enable_ext1_wakeup(mask: u64, mode: esp_sleep_ext1_wakeup_mode_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup from light sleep using GPIOs"]
    #[doc = ""]
    #[doc = " Each GPIO supports wakeup function, which can be triggered on either low level"]
    #[doc = " or high level. Unlike EXT0 and EXT1 wakeup sources, this method can be used"]
    #[doc = " both for all IOs: RTC IOs and digital IOs. It can only be used to wakeup from"]
    #[doc = " light sleep though."]
    #[doc = ""]
    #[doc = " To enable wakeup, first call gpio_wakeup_enable, specifying gpio number and"]
    #[doc = " wakeup level, for each GPIO which is used for wakeup."]
    #[doc = " Then call this function to enable wakeup feature."]
    #[doc = ""]
    #[doc = " @note In revisions 0 and 1 of the ESP32, GPIO wakeup source"]
    #[doc = "       can not be used together with touch or ULP wakeup sources."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if wakeup triggers conflict"]
    pub fn esp_sleep_enable_gpio_wakeup() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable wakeup from light sleep using UART"]
    #[doc = ""]
    #[doc = " Use uart_set_wakeup_threshold function to configure UART wakeup threshold."]
    #[doc = ""]
    #[doc = " Wakeup from light sleep takes some time, so not every character sent"]
    #[doc = " to the UART can be received by the application."]
    #[doc = ""]
    #[doc = " @note ESP32 does not support wakeup from UART2."]
    #[doc = ""]
    #[doc = " @param uart_num  UART port to wake up from"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if wakeup from given UART is not supported"]
    pub fn esp_sleep_enable_uart_wakeup(uart_num: cty::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the bit mask of GPIOs which caused wakeup (ext1)"]
    #[doc = ""]
    #[doc = " If wakeup was caused by another source, this function will return 0."]
    #[doc = ""]
    #[doc = " @return bit mask, if GPIOn caused wakeup, BIT(n) will be set"]
    pub fn esp_sleep_get_ext1_wakeup_status() -> u64;
}
extern "C" {
    #[doc = " @brief Set power down mode for an RTC power domain in sleep mode"]
    #[doc = ""]
    #[doc = " If not set set using this API, all power domains default to ESP_PD_OPTION_AUTO."]
    #[doc = ""]
    #[doc = " @param domain  power domain to configure"]
    #[doc = " @param option  power down option (ESP_PD_OPTION_OFF, ESP_PD_OPTION_ON, or ESP_PD_OPTION_AUTO)"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if either of the arguments is out of range"]
    pub fn esp_sleep_pd_config(
        domain: esp_sleep_pd_domain_t,
        option: esp_sleep_pd_option_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enter deep sleep with the configured wakeup options"]
    #[doc = ""]
    #[doc = " This function does not return."]
    pub fn esp_deep_sleep_start();
}
extern "C" {
    #[doc = " @brief Enter light sleep with the configured wakeup options"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on success (returned after wakeup)"]
    #[doc = "  - ESP_ERR_INVALID_STATE if WiFi or BT is not stopped"]
    pub fn esp_light_sleep_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enter deep-sleep mode"]
    #[doc = ""]
    #[doc = " The device will automatically wake up after the deep-sleep time"]
    #[doc = " Upon waking up, the device calls deep sleep wake stub, and then proceeds"]
    #[doc = " to load application."]
    #[doc = ""]
    #[doc = " Call to this function is equivalent to a call to esp_deep_sleep_enable_timer_wakeup"]
    #[doc = " followed by a call to esp_deep_sleep_start."]
    #[doc = ""]
    #[doc = " esp_deep_sleep does not shut down WiFi, BT, and higher level protocol"]
    #[doc = " connections gracefully."]
    #[doc = " Make sure relevant WiFi and BT stack functions are called to close any"]
    #[doc = " connections and deinitialize the peripherals. These include:"]
    #[doc = "     - esp_bluedroid_disable"]
    #[doc = "     - esp_bt_controller_disable"]
    #[doc = "     - esp_wifi_stop"]
    #[doc = ""]
    #[doc = " This function does not return."]
    #[doc = ""]
    #[doc = " @param time_in_us  deep-sleep time, unit: microsecond"]
    pub fn esp_deep_sleep(time_in_us: u64);
}
extern "C" {
    #[doc = " @brief Enter deep-sleep mode"]
    #[doc = ""]
    #[doc = " Function has been renamed to esp_deep_sleep."]
    #[doc = " This name is deprecated and will be removed in a future version."]
    #[doc = ""]
    #[doc = " @param time_in_us  deep-sleep time, unit: microsecond"]
    pub fn system_deep_sleep(time_in_us: u64);
}
extern "C" {
    #[doc = " @brief Get the wakeup source which caused wakeup from sleep"]
    #[doc = ""]
    #[doc = " @return cause of wake up from last sleep (deep sleep or light sleep)"]
    pub fn esp_sleep_get_wakeup_cause() -> esp_sleep_wakeup_cause_t;
}
extern "C" {
    #[doc = " @brief Default stub to run on wake from deep sleep."]
    #[doc = ""]
    #[doc = " Allows for executing code immediately on wake from sleep, before"]
    #[doc = " the software bootloader or ESP-IDF app has started up."]
    #[doc = ""]
    #[doc = " This function is weak-linked, so you can implement your own version"]
    #[doc = " to run code immediately when the chip wakes from"]
    #[doc = " sleep."]
    #[doc = ""]
    #[doc = " See docs/deep-sleep-stub.rst for details."]
    pub fn esp_wake_deep_sleep();
}
#[doc = " @brief Function type for stub to run on wake from sleep."]
#[doc = ""]
pub type esp_deep_sleep_wake_stub_fn_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " @brief Install a new stub at runtime to run on wake from deep sleep"]
    #[doc = ""]
    #[doc = " If implementing esp_wake_deep_sleep() then it is not necessary to"]
    #[doc = " call this function."]
    #[doc = ""]
    #[doc = " However, it is possible to call this function to substitute a"]
    #[doc = " different deep sleep stub. Any function used as a deep sleep stub"]
    #[doc = " must be marked RTC_IRAM_ATTR, and must obey the same rules given"]
    #[doc = " for esp_wake_deep_sleep()."]
    pub fn esp_set_deep_sleep_wake_stub(new_stub: esp_deep_sleep_wake_stub_fn_t);
}
extern "C" {
    #[doc = " @brief Get current wake from deep sleep stub"]
    #[doc = " @return Return current wake from deep sleep stub, or NULL if"]
    #[doc = "         no stub is installed."]
    pub fn esp_get_deep_sleep_wake_stub() -> esp_deep_sleep_wake_stub_fn_t;
}
extern "C" {
    #[doc = "  @brief The default esp-idf-provided esp_wake_deep_sleep() stub."]
    #[doc = ""]
    #[doc = "  See docs/deep-sleep-stub.rst for details."]
    pub fn esp_default_wake_deep_sleep();
}
extern "C" {
    #[doc = "  @brief Disable logging from the ROM code after deep sleep."]
    #[doc = ""]
    #[doc = "  Using LSB of RTC_STORE4."]
    pub fn esp_deep_sleep_disable_rom_logging();
}
pub const esp_mac_type_t_ESP_MAC_WIFI_STA: esp_mac_type_t = 0;
pub const esp_mac_type_t_ESP_MAC_WIFI_SOFTAP: esp_mac_type_t = 1;
pub const esp_mac_type_t_ESP_MAC_BT: esp_mac_type_t = 2;
pub const esp_mac_type_t_ESP_MAC_ETH: esp_mac_type_t = 3;
pub type esp_mac_type_t = u32;
#[doc = "!< Reset reason can not be determined"]
pub const esp_reset_reason_t_ESP_RST_UNKNOWN: esp_reset_reason_t = 0;
#[doc = "!< Reset due to power-on event"]
pub const esp_reset_reason_t_ESP_RST_POWERON: esp_reset_reason_t = 1;
#[doc = "!< Reset by external pin (not applicable for ESP32)"]
pub const esp_reset_reason_t_ESP_RST_EXT: esp_reset_reason_t = 2;
#[doc = "!< Software reset via esp_restart"]
pub const esp_reset_reason_t_ESP_RST_SW: esp_reset_reason_t = 3;
#[doc = "!< Software reset due to exception/panic"]
pub const esp_reset_reason_t_ESP_RST_PANIC: esp_reset_reason_t = 4;
#[doc = "!< Reset (software or hardware) due to interrupt watchdog"]
pub const esp_reset_reason_t_ESP_RST_INT_WDT: esp_reset_reason_t = 5;
#[doc = "!< Reset due to task watchdog"]
pub const esp_reset_reason_t_ESP_RST_TASK_WDT: esp_reset_reason_t = 6;
#[doc = "!< Reset due to other watchdogs"]
pub const esp_reset_reason_t_ESP_RST_WDT: esp_reset_reason_t = 7;
#[doc = "!< Reset after exiting deep sleep mode"]
pub const esp_reset_reason_t_ESP_RST_DEEPSLEEP: esp_reset_reason_t = 8;
#[doc = "!< Brownout reset (software or hardware)"]
pub const esp_reset_reason_t_ESP_RST_BROWNOUT: esp_reset_reason_t = 9;
#[doc = "!< Reset over SDIO"]
pub const esp_reset_reason_t_ESP_RST_SDIO: esp_reset_reason_t = 10;
#[doc = " @brief Reset reasons"]
pub type esp_reset_reason_t = u32;
extern "C" {
    #[doc = " @cond */"]
    #[doc = " @attention  Applications don't need to call this function anymore. It does nothing and will"]
    #[doc = "             be removed in future version."]
    pub fn system_init();
}
extern "C" {
    #[doc = " @brief  Reset to default settings."]
    #[doc = ""]
    #[doc = " Function has been deprecated, please use esp_wifi_restore instead."]
    #[doc = " This name will be removed in a future release."]
    pub fn system_restore();
}
#[doc = " Shutdown handler type"]
pub type shutdown_handler_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " @brief  Register shutdown handler"]
    #[doc = ""]
    #[doc = " This function allows you to register a handler that gets invoked before"]
    #[doc = " the application is restarted using esp_restart function."]
    pub fn esp_register_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Restart PRO and APP CPUs."]
    #[doc = ""]
    #[doc = " This function can be called both from PRO and APP CPUs."]
    #[doc = " After successful restart, CPU reset reason will be SW_CPU_RESET."]
    #[doc = " Peripherals (except for WiFi, BT, UART0, SPI1, and legacy timers) are not reset."]
    #[doc = " This function does not return."]
    pub fn esp_restart();
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " @brief  Restart system."]
    #[doc = ""]
    #[doc = " Function has been renamed to esp_restart."]
    #[doc = " This name will be removed in a future release."]
    pub fn system_restart();
}
extern "C" {
    #[doc = " @brief  Get reason of last reset"]
    #[doc = " @return See description of esp_reset_reason_t for explanation of each value."]
    pub fn esp_reset_reason() -> esp_reset_reason_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " @brief  Get system time, unit: microsecond."]
    #[doc = ""]
    #[doc = " This function is deprecated. Use 'gettimeofday' function for 64-bit precision."]
    #[doc = " This definition will be removed in a future release."]
    pub fn system_get_time() -> u32;
}
extern "C" {
    #[doc = " @brief  Get the size of available heap."]
    #[doc = ""]
    #[doc = " Note that the returned value may be larger than the maximum contiguous block"]
    #[doc = " which can be allocated."]
    #[doc = ""]
    #[doc = " @return Available heap size, in bytes."]
    pub fn esp_get_free_heap_size() -> u32;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " @brief  Get the size of available heap."]
    #[doc = ""]
    #[doc = " Function has been renamed to esp_get_free_heap_size."]
    #[doc = " This name will be removed in a future release."]
    #[doc = ""]
    #[doc = " @return Available heap size, in bytes."]
    pub fn system_get_free_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief Get the minimum heap that has ever been available"]
    #[doc = ""]
    #[doc = " @return Minimum free heap ever available"]
    pub fn esp_get_minimum_free_heap_size() -> u32;
}
extern "C" {
    #[doc = " @brief  Get one random 32-bit word from hardware RNG"]
    #[doc = ""]
    #[doc = " The hardware RNG is fully functional whenever an RF subsystem is running (ie Bluetooth or WiFi is enabled). For"]
    #[doc = " random values, call this function after WiFi or Bluetooth are started."]
    #[doc = ""]
    #[doc = " If the RF subsystem is not used by the program, the function bootloader_random_enable() can be called to enable an"]
    #[doc = " entropy source. bootloader_random_disable() must be called before RF subsystem or I2S peripheral are used. See these functions'"]
    #[doc = " documentation for more details."]
    #[doc = ""]
    #[doc = " Any time the app is running without an RF subsystem (or bootloader_random) enabled, RNG hardware should be"]
    #[doc = " considered a PRNG. A very small amount of entropy is available due to pre-seeding while the IDF"]
    #[doc = " bootloader is running, but this should not be relied upon for any use."]
    #[doc = ""]
    #[doc = " @return Random value between 0 and UINT32_MAX"]
    pub fn esp_random() -> u32;
}
extern "C" {
    #[doc = " @brief Fill a buffer with random bytes from hardware RNG"]
    #[doc = ""]
    #[doc = " @note This function has the same restrictions regarding available entropy as esp_random()"]
    #[doc = ""]
    #[doc = " @param buf Pointer to buffer to fill with random numbers."]
    #[doc = " @param len Length of buffer in bytes"]
    pub fn esp_fill_random(buf: *mut cty::c_void, len: usize);
}
extern "C" {
    #[doc = " @brief  Set base MAC address with the MAC address which is stored in BLK3 of EFUSE or"]
    #[doc = "         external storage e.g. flash and EEPROM."]
    #[doc = ""]
    #[doc = " Base MAC address is used to generate the MAC addresses used by the networking interfaces."]
    #[doc = " If using base MAC address stored in BLK3 of EFUSE or external storage, call this API to set base MAC"]
    #[doc = " address with the MAC address which is stored in BLK3 of EFUSE or external storage before initializing"]
    #[doc = " WiFi/BT/Ethernet."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_base_mac_addr_set(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which is set using esp_base_mac_addr_set."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    #[doc = "         ESP_ERR_INVALID_MAC base MAC address has not been set"]
    pub fn esp_base_mac_addr_get(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which was previously written to BLK3 of EFUSE."]
    #[doc = ""]
    #[doc = " Base MAC address is used to generate the MAC addresses used by the networking interfaces."]
    #[doc = " This API returns the custom base MAC address which was previously written to BLK3 of EFUSE."]
    #[doc = " Writing this EFUSE allows setting of a different (non-Espressif) base MAC address. It is also"]
    #[doc = " possible to store a custom base MAC address elsewhere, see esp_base_mac_addr_set() for details."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    #[doc = "         ESP_ERR_INVALID_VERSION An invalid MAC version field was read from BLK3 of EFUSE"]
    #[doc = "         ESP_ERR_INVALID_CRC An invalid MAC CRC was read from BLK3 of EFUSE"]
    pub fn esp_efuse_mac_get_custom(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Return base MAC address which is factory-programmed by Espressif in BLK0 of EFUSE."]
    #[doc = ""]
    #[doc = " @param  mac  base MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_efuse_mac_get_default(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " @brief  Read hardware MAC address from efuse."]
    #[doc = ""]
    #[doc = " Function has been renamed to esp_efuse_mac_get_default."]
    #[doc = " This name will be removed in a future release."]
    #[doc = ""]
    #[doc = " @param  mac  hardware MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_efuse_read_mac(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Read hardware MAC address."]
    #[doc = ""]
    #[doc = " Function has been renamed to esp_efuse_mac_get_default."]
    #[doc = " This name will be removed in a future release."]
    #[doc = ""]
    #[doc = " @param  mac  hardware MAC address, length: 6 bytes."]
    #[doc = " @return ESP_OK on success"]
    pub fn system_efuse_read_mac(mac: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Read base MAC address and set MAC address of the interface."]
    #[doc = ""]
    #[doc = " This function first get base MAC address using esp_base_mac_addr_get or reads base MAC address"]
    #[doc = " from BLK0 of EFUSE. Then set the MAC address of the interface including wifi station, wifi softap,"]
    #[doc = " bluetooth and ethernet."]
    #[doc = ""]
    #[doc = " @param  mac  MAC address of the interface, length: 6 bytes."]
    #[doc = " @param  type  type of MAC address, 0:wifi station, 1:wifi softap, 2:bluetooth, 3:ethernet."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_read_mac(mac: *mut u8, type_: esp_mac_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Derive local MAC address from universal MAC address."]
    #[doc = ""]
    #[doc = " This function derives a local MAC address from an universal MAC address."]
    #[doc = " A `definition of local vs universal MAC address can be found on Wikipedia"]
    #[doc = " <https://en.wikipedia.org/wiki/MAC_address#Universal_vs._local>`."]
    #[doc = " In ESP32, universal MAC address is generated from base MAC address in EFUSE or other external storage."]
    #[doc = " Local MAC address is derived from the universal MAC address."]
    #[doc = ""]
    #[doc = " @param  local_mac  Derived local MAC address, length: 6 bytes."]
    #[doc = " @param  universal_mac  Source universal MAC address, length: 6 bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK on success"]
    pub fn esp_derive_local_mac(local_mac: *mut u8, universal_mac: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " Get SDK version"]
    #[doc = ""]
    #[doc = " This function is deprecated and will be removed in a future release."]
    #[doc = ""]
    #[doc = " @return constant string \"master\""]
    pub fn system_get_sdk_version() -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get IDF version"]
    #[doc = ""]
    #[doc = " @return constant string from IDF_VER"]
    pub fn esp_get_idf_version() -> *const cty::c_char;
}
#[doc = "!< ESP32"]
pub const esp_chip_model_t_CHIP_ESP32: esp_chip_model_t = 1;
#[doc = " @brief Chip models"]
pub type esp_chip_model_t = u32;
#[doc = " @brief The structure represents information about the chip"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_chip_info_t {
    #[doc = "!< chip model, one of esp_chip_model_t"]
    pub model: esp_chip_model_t,
    #[doc = "!< bit mask of CHIP_FEATURE_x feature flags"]
    pub features: u32,
    #[doc = "!< number of CPU cores"]
    pub cores: u8,
    #[doc = "!< chip revision number"]
    pub revision: u8,
}
extern "C" {
    #[doc = " @brief Fill an esp_chip_info_t structure with information about the chip"]
    #[doc = " @param[out] out_info structure to be filled"]
    pub fn esp_chip_info(out_info: *mut esp_chip_info_t);
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut cty::c_void,
        xRunPrivileged: BaseType_t,
    ) -> *mut StackType_t;
}
extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    pub fn vPortEndScheduler();
}
extern "C" {
    pub fn vPortYieldOtherCore(coreid: BaseType_t);
}
extern "C" {
    pub fn vPortSetStackWatchpoint(pxStackStart: *mut cty::c_void);
}
extern "C" {
    pub fn xPortInIsrContext() -> BaseType_t;
}
extern "C" {
    pub fn xPortInterruptedFromISRContext() -> BaseType_t;
}
extern "C" {
    pub fn vPortStoreTaskMPUSettings(
        xMPUSettings: *mut xMPU_SETTINGS,
        xRegions: *const xMEMORY_REGION,
        pxBottomOfStack: *mut StackType_t,
        usStackDepth: u32,
    );
}
extern "C" {
    pub fn vPortReleaseTaskMPUSettings(xMPUSettings: *mut xMPU_SETTINGS);
}
extern "C" {
    pub fn xPortGetTickRateHz() -> u32;
}
extern "C" {
    pub fn uxPortCompareSetExtram(addr: *mut u32, compare: u32, set: *mut u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut cty::c_void; 4usize],
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut cty::c_void; 2usize],
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy1: UBaseType_t,
    pub pvDummy2: *mut cty::c_void,
    pub xDummy3: StaticMiniListItem_t,
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut cty::c_void,
    pub xDummy2: xMPU_SETTINGS,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut cty::c_void,
    pub ucDummy7: [u8; 16usize],
    pub uxDummyCoreId: UBaseType_t,
    pub pxDummy8: *mut cty::c_void,
    pub uxDummy9: UBaseType_t,
    pub OldInterruptState: u32,
    pub uxDummy12: [UBaseType_t; 2usize],
    pub pvDummy15: [*mut cty::c_void; 1usize],
    pub pvDummyLocalStorageCallBack: [*mut cty::c_void; 1usize],
    pub xDummy17: _reent,
    pub ulDummy18: u32,
    pub ucDummy19: u32,
    pub uxDummy20: u8,
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut cty::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub pvDummy7: *mut cty::c_void,
    pub muxDummy: portMUX_TYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut cty::c_void,
    pub uxDummy2: UBaseType_t,
    _bindgen_union_align: u32,
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub muxDummy: portMUX_TYPE,
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut cty::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub uxDummy4: UBaseType_t,
    pub pvDummy5: [*mut cty::c_void; 2usize],
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut cty::c_void,
    pub pvContainer: *mut cty::c_void,
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
pub type List_t = xLIST;
extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[doc = " task. h"]
#[doc = ""]
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate"]
#[doc = " returns (via a pointer parameter) an TaskHandle_t variable that can then"]
#[doc = " be used as a parameter to vTaskDelete to delete the task."]
#[doc = ""]
#[doc = " \\ingroup Tasks"]
pub type TaskHandle_t = *mut cty::c_void;
#[doc = " Defines the prototype to which the application task hook function must"]
#[doc = " conform."]
pub type TaskHookFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void) -> BaseType_t>;
#[doc = "< A task is querying the state of itself, so must be running."]
pub const eTaskState_eRunning: eTaskState = 0;
#[doc = "< The task being queried is in a read or pending ready list."]
pub const eTaskState_eReady: eTaskState = 1;
#[doc = "< The task being queried is in the Blocked state."]
pub const eTaskState_eBlocked: eTaskState = 2;
#[doc = "< The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out."]
pub const eTaskState_eSuspended: eTaskState = 3;
#[doc = "< The task being queried has been deleted, but its TCB has not yet been freed."]
pub const eTaskState_eDeleted: eTaskState = 4;
#[doc = " Task states returned by eTaskGetState."]
pub type eTaskState = u32;
#[doc = "< Notify the task without updating its notify value."]
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
#[doc = "< Set bits in the task's notification value."]
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
#[doc = "< Increment the task's notification value."]
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
#[doc = "< Set the task's notification value to a specific value even if the previous value has not yet been read by the task."]
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
#[doc = "< Set the task's notification value if the previous value has been read by the task."]
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
#[doc = " Actions that can be performed when vTaskNotify() is called."]
pub type eNotifyAction = u32;
#[doc = " @cond */"]
#[doc = " Used internally only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
pub type TimeOut_t = xTIME_OUT;
#[doc = " Defines the memory ranges allocated to the task when an MPU is used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut cty::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[doc = " Parameters required to create an MPU protected task."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const cty::c_char,
    pub usStackDepth: u32,
    pub pvParameters: *mut cty::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
pub type TaskParameters_t = xTASK_PARAMETERS;
#[doc = "  Used with the uxTaskGetSystemState() function to return the state of each task in the system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    #[doc = "< The handle of the task to which the rest of the information in the structure relates."]
    pub xHandle: TaskHandle_t,
    #[doc = "< A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated!"]
    pub pcTaskName: *const cty::c_char,
    #[doc = "< A number unique to the task."]
    pub xTaskNumber: UBaseType_t,
    #[doc = "< The state in which the task existed when the structure was populated."]
    pub eCurrentState: eTaskState,
    #[doc = "< The priority at which the task was running (may be inherited) when the structure was populated."]
    pub uxCurrentPriority: UBaseType_t,
    #[doc = "< The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h."]
    pub uxBasePriority: UBaseType_t,
    #[doc = "< The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h."]
    pub ulRunTimeCounter: u32,
    #[doc = "< Points to the lowest address of the task's stack area."]
    pub pxStackBase: *mut StackType_t,
    #[doc = "< The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack."]
    pub usStackHighWaterMark: u32,
}
pub type TaskStatus_t = xTASK_STATUS;
#[doc = " Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system."]
#[doc = " We need this struct because TCB_t is defined (hidden) in tasks.c."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_SNAPSHOT {
    #[doc = "< Address of task control block."]
    pub pxTCB: *mut cty::c_void,
    #[doc = "< Points to the location of the last item placed on the tasks stack."]
    pub pxTopOfStack: *mut StackType_t,
    #[doc = "< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo"]
    #[doc = "pxTopOfStack > pxEndOfStack, stack grows lo2hi"]
    pub pxEndOfStack: *mut StackType_t,
}
pub type TaskSnapshot_t = xTASK_SNAPSHOT;
#[doc = "< A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode."]
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
#[doc = "< Enter a sleep mode that will not last any longer than the expected idle time."]
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
#[doc = "< No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt."]
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
#[doc = " Possible return values for eTaskConfirmSleepModeStatus()."]
pub type eSleepModeStatus = u32;
extern "C" {
    pub fn xTaskCreatePinnedToCore(
        pvTaskCode: TaskFunction_t,
        pcName: *const cty::c_char,
        usStackDepth: u32,
        pvParameters: *mut cty::c_void,
        uxPriority: UBaseType_t,
        pvCreatedTask: *mut TaskHandle_t,
        xCoreID: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskCreateRestricted(
        pxTaskDefinition: *const TaskParameters_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Memory regions are assigned to a restricted task when the task is created by"]
    #[doc = " a call to xTaskCreateRestricted().  These regions can be redefined using"]
    #[doc = " vTaskAllocateMPURegions()."]
    #[doc = ""]
    #[doc = " @param xTask The handle of the task being updated."]
    #[doc = ""]
    #[doc = " @param xRegions A pointer to an MemoryRegion_t structure that contains the"]
    #[doc = " new memory region definitions."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = ""]
    #[doc = " @code{c}"]
    #[doc = " // Define an array of MemoryRegion_t structures that configures an MPU region"]
    #[doc = " // allowing read/write access for 1024 bytes starting at the beginning of the"]
    #[doc = " // ucOneKByte array.  The other two of the maximum 3 definable regions are"]
    #[doc = " // unused so set to zero."]
    #[doc = " static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] ="]
    #[doc = " {"]
    #[doc = " \t// Base address\t\tLength\t\tParameters"]
    #[doc = " \t{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },"]
    #[doc = " \t{ 0,\t\t\t\t0,\t\t\t0 },"]
    #[doc = " \t{ 0,\t\t\t\t0,\t\t\t0 }"]
    #[doc = " };"]
    #[doc = ""]
    #[doc = " void vATask( void *pvParameters )"]
    #[doc = " {"]
    #[doc = " \t// This task was created such that it has access to certain regions of"]
    #[doc = " \t// memory as defined by the MPU configuration.  At some point it is"]
    #[doc = " \t// desired that these MPU regions are replaced with that defined in the"]
    #[doc = " \t// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()"]
    #[doc = " \t// for this purpose.  NULL is used as the task handle to indicate that this"]
    #[doc = " \t// function should modify the MPU regions of the calling task."]
    #[doc = " \tvTaskAllocateMPURegions( NULL, xAltRegions );"]
    #[doc = ""]
    #[doc = " \t// Now the task can continue its function, but from this point on can only"]
    #[doc = " \t// access its stack and the ucOneKByte array (unless any other statically"]
    #[doc = " \t// defined or shared regions have been declared elsewhere)."]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
    #[doc = " Remove a task from the RTOS real time kernel's management."]
    #[doc = ""]
    #[doc = " The task being deleted will be removed from all ready, blocked, suspended"]
    #[doc = " and event lists."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelete must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " @note The idle task is responsible for freeing the kernel allocated"]
    #[doc = " memory from tasks that have been deleted.  It is therefore important that"]
    #[doc = " the idle task is not starved of microcontroller processing time if your"]
    #[doc = " application makes any calls to vTaskDelete ().  Memory allocated by the"]
    #[doc = " task code is not automatically freed, and should be freed before the task"]
    #[doc = " is deleted."]
    #[doc = ""]
    #[doc = " See the demo application file death.c for sample code that utilises"]
    #[doc = " vTaskDelete ()."]
    #[doc = ""]
    #[doc = " @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will"]
    #[doc = " cause the calling task to be deleted."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vOtherFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = " \t // Create the task, storing the handle."]
    #[doc = " \t xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = " \t // Use the handle to delete the task."]
    #[doc = " \t vTaskDelete( xHandle );"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
    #[doc = " Delay a task for a given number of ticks."]
    #[doc = ""]
    #[doc = " The actual time that the task remains blocked depends on the tick rate."]
    #[doc = " The constant portTICK_PERIOD_MS can be used to calculate real time from"]
    #[doc = " the tick rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelay must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " vTaskDelay() specifies a time at which the task wishes to unblock relative to"]
    #[doc = " the time at which vTaskDelay() is called.  For example, specifying a block"]
    #[doc = " period of 100 ticks will cause the task to unblock 100 ticks after"]
    #[doc = " vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method"]
    #[doc = " of controlling the frequency of a periodic task as the path taken through the"]
    #[doc = " code, as well as other task and interrupt activity, will effect the frequency"]
    #[doc = " at which vTaskDelay() gets called and therefore the time at which the task"]
    #[doc = " next executes.  See vTaskDelayUntil() for an alternative API function designed"]
    #[doc = " to facilitate fixed frequency execution.  It does this by specifying an"]
    #[doc = " absolute time (rather than a relative time) at which the calling task should"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " @param xTicksToDelay The amount of time, in tick periods, that"]
    #[doc = " the calling task should block."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTaskFunction( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "  // Block for 500ms."]
    #[doc = "  const TickType_t xDelay = 500 / portTICK_PERIOD_MS;"]
    #[doc = ""]
    #[doc = " \t for( ;; )"]
    #[doc = " \t {"]
    #[doc = " \t\t // Simply toggle the LED every 500ms, blocking between each toggle."]
    #[doc = " \t\t vToggleLED();"]
    #[doc = " \t\t vTaskDelay( xDelay );"]
    #[doc = " \t }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
    #[doc = " Delay a task until a specified time."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " This function can be used by periodic tasks to ensure a constant execution frequency."]
    #[doc = ""]
    #[doc = " This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will"]
    #[doc = " cause a task to block for the specified number of ticks from the time vTaskDelay () is"]
    #[doc = " called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed"]
    #[doc = " execution frequency as the time between a task starting to execute and that task"]
    #[doc = " calling vTaskDelay () may not be fixed [the task may take a different path though the"]
    #[doc = " code between calls, or may get interrupted or preempted a different number of times"]
    #[doc = " each time it executes]."]
    #[doc = ""]
    #[doc = " Whereas vTaskDelay () specifies a wake time relative to the time at which the function"]
    #[doc = " is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " The constant portTICK_PERIOD_MS can be used to calculate real time from the tick"]
    #[doc = " rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " @param pxPreviousWakeTime Pointer to a variable that holds the time at which the"]
    #[doc = " task was last unblocked.  The variable must be initialised with the current time"]
    #[doc = " prior to its first use (see the example below).  Following this the variable is"]
    #[doc = " automatically updated within vTaskDelayUntil ()."]
    #[doc = ""]
    #[doc = " @param xTimeIncrement The cycle time period.  The task will be unblocked at"]
    #[doc = " time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the"]
    #[doc = " same xTimeIncrement parameter value will cause the task to execute with"]
    #[doc = " a fixed interface period."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  // Perform an action every 10 ticks."]
    #[doc = "  void vTaskFunction( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "  TickType_t xLastWakeTime;"]
    #[doc = "  const TickType_t xFrequency = 10;"]
    #[doc = ""]
    #[doc = " \t // Initialise the xLastWakeTime variable with the current time."]
    #[doc = " \t xLastWakeTime = xTaskGetTickCount ();"]
    #[doc = " \t for( ;; )"]
    #[doc = " \t {"]
    #[doc = " \t\t // Wait for the next cycle."]
    #[doc = " \t\t vTaskDelayUntil( &xLastWakeTime, xFrequency );"]
    #[doc = ""]
    #[doc = " \t\t // Perform action here."]
    #[doc = " \t }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelayUntil(pxPreviousWakeTime: *mut TickType_t, xTimeIncrement: TickType_t);
}
extern "C" {
    #[doc = " Obtain the priority of any task."]
    #[doc = ""]
    #[doc = " INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried.  Passing a NULL"]
    #[doc = " handle results in the priority of the calling task being returned."]
    #[doc = ""]
    #[doc = " @return The priority of xTask."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to obtain the priority of the created task."]
    #[doc = "   // It was created with tskIDLE_PRIORITY, but may have changed"]
    #[doc = "   // it itself."]
    #[doc = "   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )"]
    #[doc = "   {"]
    #[doc = "       // The task has changed it's priority."]
    #[doc = "   }"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Is our priority higher than the created task?"]
    #[doc = "   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )"]
    #[doc = "   {"]
    #[doc = "       // Our priority (obtained using NULL handle) is higher."]
    #[doc = "   }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " A version of uxTaskPriorityGet() that can be used from an ISR."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried.  Passing a NULL"]
    #[doc = " handle results in the priority of the calling task being returned."]
    #[doc = ""]
    #[doc = " @return The priority of xTask."]
    #[doc = ""]
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Obtain the state of any task."]
    #[doc = ""]
    #[doc = " States are encoded by the eTaskState enumerated type."]
    #[doc = ""]
    #[doc = " INCLUDE_eTaskGetState must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried."]
    #[doc = ""]
    #[doc = " @return The state of xTask at the time the function was called.  Note the"]
    #[doc = " state of the task might change between the function being called, and the"]
    #[doc = " functions return value being tested by the calling task."]
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
    #[doc = " Set the priority of any task."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " A context switch will occur before the function returns if the priority"]
    #[doc = " being set is higher than the currently executing task."]
    #[doc = ""]
    #[doc = " @param xTask Handle to the task for which the priority is being set."]
    #[doc = " Passing a NULL handle results in the priority of the calling task being set."]
    #[doc = ""]
    #[doc = " @param uxNewPriority The priority to which the task will be set."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to raise the priority of the created task."]
    #[doc = "   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use a NULL handle to raise our priority to the same value."]
    #[doc = "   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    #[doc = " Suspend a task."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " When suspended, a task will never get any microcontroller processing time,"]
    #[doc = " no matter what its priority."]
    #[doc = ""]
    #[doc = " Calls to vTaskSuspend are not accumulative -"]
    #[doc = " i.e. calling vTaskSuspend () twice on the same task still only requires one"]
    #[doc = " call to vTaskResume () to ready the suspended task."]
    #[doc = ""]
    #[doc = " @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL"]
    #[doc = " handle will cause the calling task to be suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to suspend the created task."]
    #[doc = "   vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // The created task will not run during this period, unless"]
    #[doc = "   // another task calls vTaskResume( xHandle )."]
    #[doc = ""]
    #[doc = "   //..."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "   // Suspend ourselves."]
    #[doc = "   vTaskSuspend( NULL );"]
    #[doc = ""]
    #[doc = "   // We cannot get here unless another task calls vTaskResume"]
    #[doc = "   // with our handle as the parameter."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
    #[doc = " Resumes a suspended task."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " vTaskResume ()."]
    #[doc = ""]
    #[doc = " @param xTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to suspend the created task."]
    #[doc = "   vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // The created task will not run during this period, unless"]
    #[doc = "   // another task calls vTaskResume( xHandle )."]
    #[doc = ""]
    #[doc = "   //..."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "   // Resume the suspended task ourselves."]
    #[doc = "   vTaskResume( xHandle );"]
    #[doc = ""]
    #[doc = "   // The created task will once again get microcontroller processing"]
    #[doc = "   // time in accordance with its priority within the system."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
    #[doc = " An implementation of vTaskResume() that can be called from within an ISR."]
    #[doc = ""]
    #[doc = " INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be"]
    #[doc = " available.  See the configuration section for more information."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " xTaskResumeFromISR ()."]
    #[doc = ""]
    #[doc = " xTaskResumeFromISR() should not be used to synchronise a task with an"]
    #[doc = " interrupt if there is a chance that the interrupt could arrive prior to the"]
    #[doc = " task being suspended - as this can lead to interrupts being missed. Use of a"]
    #[doc = " semaphore as a synchronisation mechanism would avoid this eventuality."]
    #[doc = ""]
    #[doc = " @param xTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " @return pdTRUE if resuming the task should result in a context switch,"]
    #[doc = " otherwise pdFALSE. This is used by the ISR to determine if a context switch"]
    #[doc = " may be required following the ISR."]
    #[doc = ""]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " Starts the real time kernel tick processing."]
    #[doc = ""]
    #[doc = " After calling the kernel has control over which tasks are executed and when."]
    #[doc = ""]
    #[doc = " See the demo application file main.c for an example of creating"]
    #[doc = " tasks and starting the kernel."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "   // Create at least one task before starting the kernel."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "   // Start the real time kernel with preemption."]
    #[doc = "   vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "   // Will not get here unless a task calls vTaskEndScheduler ()"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskStartScheduler();
}
extern "C" {
    #[doc = " Stops the real time kernel tick."]
    #[doc = ""]
    #[doc = " @note At the time of writing only the x86 real mode port, which runs on a PC"]
    #[doc = " in place of DOS, implements this function."]
    #[doc = ""]
    #[doc = " All created tasks will be automatically deleted and multitasking"]
    #[doc = " (either preemptive or cooperative) will stop."]
    #[doc = " Execution then resumes from the point where vTaskStartScheduler ()"]
    #[doc = " was called, as if vTaskStartScheduler () had just returned."]
    #[doc = ""]
    #[doc = " See the demo application file main. c in the demo/PC directory for an"]
    #[doc = " example that uses vTaskEndScheduler ()."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () requires an exit function to be defined within the"]
    #[doc = " portable layer (see vPortEndScheduler () in port. c for the PC port).  This"]
    #[doc = " performs hardware specific operations such as stopping the kernel tick."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () will cause all of the resources allocated by the"]
    #[doc = " kernel to be freed - but will not free resources allocated by application"]
    #[doc = " tasks."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTaskCode( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "   for( ;; )"]
    #[doc = "   {"]
    #[doc = "       // Task code goes here."]
    #[doc = ""]
    #[doc = "       // At some point we want to end the real time kernel processing"]
    #[doc = "       // so call ..."]
    #[doc = "       vTaskEndScheduler ();"]
    #[doc = "   }"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "   // Create at least one task before starting the kernel."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "   // Start the real time kernel with preemption."]
    #[doc = "   vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "   // Will only get here when the vTaskCode () task has called"]
    #[doc = "   // vTaskEndScheduler ().  When we get here we are back to single task"]
    #[doc = "   // execution."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskEndScheduler();
}
extern "C" {
    #[doc = " Suspends the scheduler without disabling interrupts."]
    #[doc = ""]
    #[doc = " Context switches will not occur while the scheduler is suspended."]
    #[doc = ""]
    #[doc = " After calling vTaskSuspendAll () the calling task will continue to execute"]
    #[doc = " without risk of being swapped out until a call to xTaskResumeAll () has been"]
    #[doc = " made."]
    #[doc = ""]
    #[doc = " API functions that have the potential to cause a context switch (for example,"]
    #[doc = " vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler"]
    #[doc = " is suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTask1( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "   for( ;; )"]
    #[doc = "   {"]
    #[doc = "       // Task code goes here."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // At some point the task wants to perform a long operation during"]
    #[doc = "       // which it does not want to get swapped out.  It cannot use"]
    #[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
    #[doc = "       // operation may cause interrupts to be missed - including the"]
    #[doc = "       // ticks."]
    #[doc = ""]
    #[doc = "       // Prevent the real time kernel swapping out the task."]
    #[doc = "       vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = "       // Perform the operation here.  There is no need to use critical"]
    #[doc = "       // sections as we have all the microcontroller processing time."]
    #[doc = "       // During this time interrupts will still operate and the kernel"]
    #[doc = "       // tick count will be maintained."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // The operation is complete.  Restart the kernel."]
    #[doc = "       xTaskResumeAll ();"]
    #[doc = "   }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskSuspendAll();
}
extern "C" {
    #[doc = " Resumes scheduler activity after it was suspended by a call to"]
    #[doc = " vTaskSuspendAll()."]
    #[doc = ""]
    #[doc = " xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks"]
    #[doc = " that were previously suspended by a call to vTaskSuspend()."]
    #[doc = ""]
    #[doc = " @return If resuming the scheduler caused a context switch then pdTRUE is"]
    #[doc = "\t\t  returned, otherwise pdFALSE is returned."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTask1( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "   for( ;; )"]
    #[doc = "   {"]
    #[doc = "       // Task code goes here."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // At some point the task wants to perform a long operation during"]
    #[doc = "       // which it does not want to get swapped out.  It cannot use"]
    #[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
    #[doc = "       // operation may cause interrupts to be missed - including the"]
    #[doc = "       // ticks."]
    #[doc = ""]
    #[doc = "       // Prevent the real time kernel swapping out the task."]
    #[doc = "       vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = "       // Perform the operation here.  There is no need to use critical"]
    #[doc = "       // sections as we have all the microcontroller processing time."]
    #[doc = "       // During this time interrupts will still operate and the real"]
    #[doc = "       // time kernel tick count will be maintained."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // The operation is complete.  Restart the kernel.  We want to force"]
    #[doc = "       // a context switch - but there is no point if resuming the scheduler"]
    #[doc = "       // caused a context switch already."]
    #[doc = "       if( !xTaskResumeAll () )"]
    #[doc = "       {"]
    #[doc = "            taskYIELD ();"]
    #[doc = "       }"]
    #[doc = "   }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
    #[doc = " Get tick count"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    #[doc = " Get tick count from ISR"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " This is a version of xTaskGetTickCount() that is safe to be called from an"]
    #[doc = " ISR - provided that TickType_t is the natural word size of the"]
    #[doc = " microcontroller being used or interrupt nesting is either not supported or"]
    #[doc = " not being used."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
    #[doc = " Get current number of tasks"]
    #[doc = ""]
    #[doc = " @return The number of tasks that the real time kernel is currently managing."]
    #[doc = " This includes all ready, blocked and suspended tasks.  A task that"]
    #[doc = " has been deleted but not yet freed by the idle task will also be"]
    #[doc = " included in the count."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
    #[doc = " Get task name"]
    #[doc = ""]
    #[doc = " @return The text (human readable) name of the task referenced by the handle"]
    #[doc = " xTaskToQuery.  A task can query its own name by either passing in its own"]
    #[doc = " handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be"]
    #[doc = " set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn pcTaskGetTaskName(xTaskToQuery: TaskHandle_t) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Returns the high water mark of the stack associated with xTask."]
    #[doc = ""]
    #[doc = " INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for"]
    #[doc = " this function to be available."]
    #[doc = ""]
    #[doc = " High water mark is the minimum free stack space there has been (in bytes"]
    #[doc = " rather than words as found in vanilla FreeRTOS) since the task started."]
    #[doc = " The smaller the returned number the closer the task has come to overflowing its stack."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task associated with the stack to be checked."]
    #[doc = " Set xTask to NULL to check the stack of the calling task."]
    #[doc = ""]
    #[doc = " @return The smallest amount of free stack space there has been (in bytes"]
    #[doc = " rather than words as found in vanilla FreeRTOS) since the task referenced by"]
    #[doc = " xTask was created."]
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Returns the start of the stack associated with xTask."]
    #[doc = ""]
    #[doc = " INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for"]
    #[doc = " this function to be available."]
    #[doc = ""]
    #[doc = " Returns the highest stack memory address on architectures where the stack grows down"]
    #[doc = " from high memory, and the lowest memory address on architectures where the"]
    #[doc = " stack grows up from low memory."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task associated with the stack returned."]
    #[doc = " Set xTask to NULL to return the stack of the calling task."]
    #[doc = ""]
    #[doc = " @return A pointer to the start of the stack."]
    pub fn pxTaskGetStackStart(xTask: TaskHandle_t) -> *mut u8;
}
extern "C" {
    #[doc = " Set local storage pointer specific to the given task."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " @param xTaskToSet  Task to set thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to set, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @param pvValue  Pointer value to set."]
    pub fn vTaskSetThreadLocalStoragePointer(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Get local storage pointer specific to the given task."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " @param xTaskToQuery  Task to get thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to get, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @return  Pointer value"]
    pub fn pvTaskGetThreadLocalStoragePointer(
        xTaskToQuery: TaskHandle_t,
        xIndex: BaseType_t,
    ) -> *mut cty::c_void;
}
#[doc = " Prototype of local storage pointer deletion callback."]
pub type TlsDeleteCallbackFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int, arg2: *mut cty::c_void)>;
extern "C" {
    #[doc = " Set local storage pointer and deletion callback."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " Local storage pointers set for a task can reference dynamically"]
    #[doc = " allocated resources. This function is similar to"]
    #[doc = " vTaskSetThreadLocalStoragePointer, but provides a way to release"]
    #[doc = " these resources when the task gets deleted. For each pointer,"]
    #[doc = " a callback function can be set. This function will be called"]
    #[doc = " when task is deleted, with the local storage pointer index"]
    #[doc = " and value as arguments."]
    #[doc = ""]
    #[doc = " @param xTaskToSet  Task to set thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to set, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @param pvValue  Pointer value to set."]
    #[doc = " @param pvDelCallback  Function to call to dispose of the local"]
    #[doc = "                       storage pointer when the task is deleted."]
    pub fn vTaskSetThreadLocalStoragePointerAndDelCallback(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut cty::c_void,
        pvDelCallback: TlsDeleteCallbackFunction_t,
    );
}
extern "C" {
    #[doc = " Calls the hook function associated with xTask. Passing xTask as NULL has"]
    #[doc = " the effect of calling the Running tasks (the calling task) hook function."]
    #[doc = ""]
    #[doc = " @param xTask  Handle of the task to call the hook for."]
    #[doc = " @param pvParameter  Parameter passed to the hook function for the task to interpret as it"]
    #[doc = " wants.  The return value is the value returned by the task hook function"]
    #[doc = " registered by the user."]
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut cty::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Get the handle of idle task for the current CPU."]
    #[doc = ""]
    #[doc = " xTaskGetIdleTaskHandle() is only available if"]
    #[doc = " INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h."]
    #[doc = ""]
    #[doc = " @return The handle of the idle task.  It is not valid to call"]
    #[doc = " xTaskGetIdleTaskHandle() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
    #[doc = " Get the handle of idle task for the given CPU."]
    #[doc = ""]
    #[doc = " xTaskGetIdleTaskHandleForCPU() is only available if"]
    #[doc = " INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h."]
    #[doc = ""]
    #[doc = " @param cpuid The CPU to get the handle for"]
    #[doc = ""]
    #[doc = " @return Idle task handle of a given cpu. It is not valid to call"]
    #[doc = " xTaskGetIdleTaskHandleForCPU() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandleForCPU(cpuid: UBaseType_t) -> TaskHandle_t;
}
extern "C" {
    #[doc = " Get the state of tasks in the system."]
    #[doc = ""]
    #[doc = " configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for"]
    #[doc = " uxTaskGetSystemState() to be available."]
    #[doc = ""]
    #[doc = " uxTaskGetSystemState() populates an TaskStatus_t structure for each task in"]
    #[doc = " the system.  TaskStatus_t structures contain, among other things, members"]
    #[doc = " for the task handle, task name, task priority, task state, and total amount"]
    #[doc = " of run time consumed by the task.  See the TaskStatus_t structure"]
    #[doc = " definition in this file for the full member list."]
    #[doc = ""]
    #[doc = " @note  This function is intended for debugging use only as its use results in"]
    #[doc = " the scheduler remaining suspended for an extended period."]
    #[doc = ""]
    #[doc = " @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures."]
    #[doc = " The array must contain at least one TaskStatus_t structure for each task"]
    #[doc = " that is under the control of the RTOS.  The number of tasks under the control"]
    #[doc = " of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function."]
    #[doc = ""]
    #[doc = " @param uxArraySize The size of the array pointed to by the pxTaskStatusArray"]
    #[doc = " parameter.  The size is specified as the number of indexes in the array, or"]
    #[doc = " the number of TaskStatus_t structures contained in the array, not by the"]
    #[doc = " number of bytes in the array."]
    #[doc = ""]
    #[doc = " @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in"]
    #[doc = " FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the"]
    #[doc = " total run time (as defined by the run time stats clock, see"]
    #[doc = " http://www.freertos.org/rtos-run-time-stats.html) since the target booted."]
    #[doc = " pulTotalRunTime can be set to NULL to omit the total run time information."]
    #[doc = ""]
    #[doc = " @return The number of TaskStatus_t structures that were populated by"]
    #[doc = " uxTaskGetSystemState().  This should equal the number returned by the"]
    #[doc = " uxTaskGetNumberOfTasks() API function, but will be zero if the value passed"]
    #[doc = " in the uxArraySize parameter was too small."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = " // This example demonstrates how a human readable table of run time stats"]
    #[doc = " // information is generated from raw data provided by uxTaskGetSystemState()."]
    #[doc = " // The human readable table is written to pcWriteBuffer"]
    #[doc = " void vTaskGetRunTimeStats( char *pcWriteBuffer )"]
    #[doc = " {"]
    #[doc = " TaskStatus_t *pxTaskStatusArray;"]
    #[doc = " volatile UBaseType_t uxArraySize, x;"]
    #[doc = " uint32_t ulTotalRunTime, ulStatsAsPercentage;"]
    #[doc = ""]
    #[doc = "  // Make sure the write buffer does not contain a string."]
    #[doc = "  *pcWriteBuffer = 0x00;"]
    #[doc = ""]
    #[doc = "  // Take a snapshot of the number of tasks in case it changes while this"]
    #[doc = "  // function is executing."]
    #[doc = "  uxArraySize = uxTaskGetNumberOfTasks();"]
    #[doc = ""]
    #[doc = "  // Allocate a TaskStatus_t structure for each task.  An array could be"]
    #[doc = "  // allocated statically at compile time."]
    #[doc = "  pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );"]
    #[doc = ""]
    #[doc = "  if( pxTaskStatusArray != NULL )"]
    #[doc = "  {"]
    #[doc = "      // Generate raw status information about each task."]
    #[doc = "      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );"]
    #[doc = ""]
    #[doc = "      // For percentage calculations."]
    #[doc = "      ulTotalRunTime /= 100UL;"]
    #[doc = ""]
    #[doc = "      // Avoid divide by zero errors."]
    #[doc = "      if( ulTotalRunTime > 0 )"]
    #[doc = "      {"]
    #[doc = "          // For each populated position in the pxTaskStatusArray array,"]
    #[doc = "          // format the raw data as human readable ASCII data"]
    #[doc = "          for( x = 0; x < uxArraySize; x++ )"]
    #[doc = "          {"]
    #[doc = "              // What percentage of the total run time has the task used?"]
    #[doc = "              // This will always be rounded down to the nearest integer."]
    #[doc = "              // ulTotalRunTimeDiv100 has already been divided by 100."]
    #[doc = "              ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;"]
    #[doc = ""]
    #[doc = "              if( ulStatsAsPercentage > 0UL )"]
    #[doc = "              {"]
    #[doc = "                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );"]
    #[doc = "              }"]
    #[doc = "              else"]
    #[doc = "              {"]
    #[doc = "                  // If the percentage is zero here then the task has"]
    #[doc = "                  // consumed less than 1% of the total run time."]
    #[doc = "                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );"]
    #[doc = "              }"]
    #[doc = ""]
    #[doc = "              pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );"]
    #[doc = "          }"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = "      // The array is no longer needed, free the memory it consumes."]
    #[doc = "      vPortFree( pxTaskStatusArray );"]
    #[doc = "  }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
extern "C" {
    #[doc = " List all the current tasks."]
    #[doc = ""]
    #[doc = " configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must"]
    #[doc = " both be defined as 1 for this function to be available.  See the"]
    #[doc = " configuration section of the FreeRTOS.org website for more information."]
    #[doc = ""]
    #[doc = " @note This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Lists all the current tasks, along with their current state and stack"]
    #[doc = " usage high water mark."]
    #[doc = ""]
    #[doc = " Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or"]
    #[doc = " suspended ('S')."]
    #[doc = ""]
    #[doc = " @note This function is provided for convenience only, and is used by many of the"]
    #[doc = " demo applications.  Do not consider it to be part of the scheduler."]
    #[doc = ""]
    #[doc = " vTaskList() calls uxTaskGetSystemState(), then formats part of the"]
    #[doc = " uxTaskGetSystemState() output into a human readable table that displays task"]
    #[doc = " names, states and stack usage."]
    #[doc = ""]
    #[doc = " vTaskList() has a dependency on the sprintf() C library function that might"]
    #[doc = " bloat the code size, use a lot of stack, and provide different results on"]
    #[doc = " different platforms.  An alternative, tiny, third party, and limited"]
    #[doc = " functionality implementation of sprintf() is provided in many of the"]
    #[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
    #[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
    #[doc = ""]
    #[doc = " It is recommended that production systems call uxTaskGetSystemState()"]
    #[doc = " directly to get access to raw stats data, rather than indirectly through a"]
    #[doc = " call to vTaskList()."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the above mentioned details"]
    #[doc = " will be written, in ASCII form.  This buffer is assumed to be large"]
    #[doc = " enough to contain the generated report.  Approximately 40 bytes per"]
    #[doc = " task should be sufficient."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskList(pcWriteBuffer: *mut cty::c_char);
}
extern "C" {
    #[doc = " Get the state of running tasks as a string"]
    #[doc = ""]
    #[doc = " configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS"]
    #[doc = " must both be defined as 1 for this function to be available.  The application"]
    #[doc = " must also then provide definitions for"]
    #[doc = " portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()"]
    #[doc = " to configure a peripheral timer/counter and return the timers current count"]
    #[doc = " value respectively.  The counter should be at least 10 times the frequency of"]
    #[doc = " the tick count."]
    #[doc = ""]
    #[doc = " @note This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total"]
    #[doc = " accumulated execution time being stored for each task.  The resolution"]
    #[doc = " of the accumulated time value depends on the frequency of the timer"]
    #[doc = " configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro."]
    #[doc = " Calling vTaskGetRunTimeStats() writes the total execution time of each"]
    #[doc = " task into a buffer, both as an absolute count value and as a percentage"]
    #[doc = " of the total system execution time."]
    #[doc = ""]
    #[doc = " @note This function is provided for convenience only, and is used by many of the"]
    #[doc = " demo applications.  Do not consider it to be part of the scheduler."]
    #[doc = ""]
    #[doc = " vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the"]
    #[doc = " uxTaskGetSystemState() output into a human readable table that displays the"]
    #[doc = " amount of time each task has spent in the Running state in both absolute and"]
    #[doc = " percentage terms."]
    #[doc = ""]
    #[doc = " vTaskGetRunTimeStats() has a dependency on the sprintf() C library function"]
    #[doc = " that might bloat the code size, use a lot of stack, and provide different"]
    #[doc = " results on different platforms.  An alternative, tiny, third party, and"]
    #[doc = " limited functionality implementation of sprintf() is provided in many of the"]
    #[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
    #[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
    #[doc = ""]
    #[doc = " It is recommended that production systems call uxTaskGetSystemState() directly"]
    #[doc = " to get access to raw stats data, rather than indirectly through a call to"]
    #[doc = " vTaskGetRunTimeStats()."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the execution times will be"]
    #[doc = " written, in ASCII form.  This buffer is assumed to be large enough to"]
    #[doc = " contain the generated report.  Approximately 40 bytes per task should"]
    #[doc = " be sufficient."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut cty::c_char);
}
extern "C" {
    #[doc = " Send task notification."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
    #[doc = " used depends on the value of the eAction parameter."]
    #[doc = ""]
    #[doc = " @param eAction Specifies how the notification updates the task's notification"]
    #[doc = " value, if at all.  Valid values for eAction are as follows:"]
    #[doc = "\t- eSetBits:"]
    #[doc = "\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()"]
    #[doc = " \t  always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eIncrement:"]
    #[doc = "\t  The task's notification value is incremented.  ulValue is not used and"]
    #[doc = "\t  xTaskNotify() always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithOverwrite:"]
    #[doc = "\t  The task's notification value is set to the value of ulValue, even if the"]
    #[doc = "\t  task being notified had not yet processed the previous notification (the"]
    #[doc = "\t  task already had a notification pending).  xTaskNotify() always returns"]
    #[doc = "\t  pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithoutOverwrite:"]
    #[doc = "\t  If the task being notified did not already have a notification pending then"]
    #[doc = "\t  the task's notification value is set to ulValue and xTaskNotify() will"]
    #[doc = "\t  return pdPASS.  If the task being notified already had a notification"]
    #[doc = "\t  pending then no action is performed and pdFAIL is returned."]
    #[doc = ""]
    #[doc = "\t- eNoAction:"]
    #[doc = "\t  The task receives a notification without its notification value being"]
    #[doc = "\t\u{a0}\u{a0}updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
    #[doc = "\t  this case."]
    #[doc = ""]
    #[doc = " @return Dependent on the value of eAction.  See the description of the"]
    #[doc = " eAction parameter."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotify(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Send task notification from an ISR."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " A version of xTaskNotify() that can be used from an interrupt service routine"]
    #[doc = " (ISR)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
    #[doc = " used depends on the value of the eAction parameter."]
    #[doc = ""]
    #[doc = " @param eAction Specifies how the notification updates the task's notification"]
    #[doc = " value, if at all.  Valid values for eAction are as follows:"]
    #[doc = "\t- eSetBits:"]
    #[doc = "\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()"]
    #[doc = " \t  always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eIncrement:"]
    #[doc = "\t  The task's notification value is incremented.  ulValue is not used and"]
    #[doc = "\t  xTaskNotify() always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithOverwrite:"]
    #[doc = "\t  The task's notification value is set to the value of ulValue, even if the"]
    #[doc = "\t  task being notified had not yet processed the previous notification (the"]
    #[doc = "\t  task already had a notification pending).  xTaskNotify() always returns"]
    #[doc = "\t  pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithoutOverwrite:"]
    #[doc = "\t  If the task being notified did not already have a notification pending then"]
    #[doc = "\t  the task's notification value is set to ulValue and xTaskNotify() will"]
    #[doc = "\t  return pdPASS.  If the task being notified already had a notification"]
    #[doc = "\t  pending then no action is performed and pdFAIL is returned."]
    #[doc = ""]
    #[doc = "\t- eNoAction:"]
    #[doc = "\t  The task receives a notification without its notification value being"]
    #[doc = "\t  updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
    #[doc = "\t  this case."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
    #[doc = " task to which the notification was sent to leave the Blocked state, and the"]
    #[doc = " unblocked task has a priority higher than the currently running task.  If"]
    #[doc = " xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should"]
    #[doc = " be requested before the interrupt is exited.  How a context switch is"]
    #[doc = " requested from an ISR is dependent on the port - see the documentation page"]
    #[doc = " for the port in use."]
    #[doc = ""]
    #[doc = " @return Dependent on the value of eAction.  See the description of the"]
    #[doc = " eAction parameter."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Wait for task notification"]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value"]
    #[doc = " will be cleared in the calling task's notification value before the task"]
    #[doc = " checks to see if any notifications are pending, and optionally blocks if no"]
    #[doc = " notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if"]
    #[doc = " limits.h is included) or 0xffffffffUL (if limits.h is not included) will have"]
    #[doc = " the effect of resetting the task's notification value to 0.  Setting"]
    #[doc = " ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged."]
    #[doc = ""]
    #[doc = " @param ulBitsToClearOnExit If a notification is pending or received before"]
    #[doc = " the calling task exits the xTaskNotifyWait() function then the task's"]
    #[doc = " notification value (see the xTaskNotify() API function) is passed out using"]
    #[doc = " the pulNotificationValue parameter.  Then any bits that are set in"]
    #[doc = " ulBitsToClearOnExit will be cleared in the task's notification value (note"]
    #[doc = " *pulNotificationValue is set before any bits are cleared).  Setting"]
    #[doc = " ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL"]
    #[doc = " (if limits.h is not included) will have the effect of resetting the task's"]
    #[doc = " notification value to 0 before the function exits.  Setting"]
    #[doc = " ulBitsToClearOnExit to 0 will leave the task's notification value unchanged"]
    #[doc = " when the function exits (in which case the value passed out in"]
    #[doc = " pulNotificationValue will match the task's notification value)."]
    #[doc = ""]
    #[doc = " @param pulNotificationValue Used to pass the task's notification value out"]
    #[doc = " of the function.  Note the value passed out will not be effected by the"]
    #[doc = " clearing of any bits caused by ulBitsToClearOnExit being non-zero."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
    #[doc = " the Blocked state for a notification to be received, should a notification"]
    #[doc = " not already be pending when xTaskNotifyWait() was called.  The task"]
    #[doc = " will not consume any processing time while it is in the Blocked state.  This"]
    #[doc = " is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be"]
    #[doc = " used to convert a time specified in milliseconds to a time specified in"]
    #[doc = " ticks."]
    #[doc = ""]
    #[doc = " @return If a notification was received (including notifications that were"]
    #[doc = " already pending when xTaskNotifyWait was called) then pdPASS is"]
    #[doc = " returned.  Otherwise pdFAIL is returned."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotifyWait(
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Simplified macro for sending task notification from ISR."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro"]
    #[doc = " to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " A version of xTaskNotifyGive() that can be called from an interrupt service"]
    #[doc = " routine (ISR)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " vTaskNotifyGiveFromISR() is intended for use when task notifications are"]
    #[doc = " used as light weight and faster binary or counting semaphore equivalents."]
    #[doc = " Actual FreeRTOS semaphores are given from an ISR using the"]
    #[doc = " xSemaphoreGiveFromISR() API function, the equivalent action that instead uses"]
    #[doc = " a task notification is vTaskNotifyGiveFromISR()."]
    #[doc = ""]
    #[doc = " When task notifications are being used as a binary or counting semaphore"]
    #[doc = " equivalent then the task being notified should wait for the notification"]
    #[doc = " using the ulTaskNotificationTake() API function rather than the"]
    #[doc = " xTaskNotifyWait() API function."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
    #[doc = " task to which the notification was sent to leave the Blocked state, and the"]
    #[doc = " unblocked task has a priority higher than the currently running task.  If"]
    #[doc = " vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch"]
    #[doc = " should be requested before the interrupt is exited.  How a context switch is"]
    #[doc = " requested from an ISR is dependent on the port - see the documentation page"]
    #[doc = " for the port in use."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn vTaskNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    #[doc = " Simplified macro for receiving task notification."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " ulTaskNotifyTake() is intended for use when a task notification is used as a"]
    #[doc = " faster and lighter weight binary or counting semaphore alternative.  Actual"]
    #[doc = " FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the"]
    #[doc = " equivalent action that instead uses a task notification is"]
    #[doc = " ulTaskNotifyTake()."]
    #[doc = ""]
    #[doc = " When a task is using its notification value as a binary or counting semaphore"]
    #[doc = " other tasks should send notifications to it using the xTaskNotifyGive()"]
    #[doc = " macro, or xTaskNotify() function with the eAction parameter set to"]
    #[doc = " eIncrement."]
    #[doc = ""]
    #[doc = " ulTaskNotifyTake() can either clear the task's notification value to"]
    #[doc = " zero on exit, in which case the notification value acts like a binary"]
    #[doc = " semaphore, or decrement the task's notification value on exit, in which case"]
    #[doc = " the notification value acts like a counting semaphore."]
    #[doc = ""]
    #[doc = " A task can use ulTaskNotifyTake() to [optionally] block to wait for a"]
    #[doc = " the task's notification value to be non-zero.  The task does not consume any"]
    #[doc = " CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " Where as xTaskNotifyWait() will return when a notification is pending,"]
    #[doc = " ulTaskNotifyTake() will return when the task's notification value is"]
    #[doc = " not zero."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's"]
    #[doc = " notification value is decremented when the function exits.  In this way the"]
    #[doc = " notification value acts like a counting semaphore.  If xClearCountOnExit is"]
    #[doc = " not pdFALSE then the task's notification value is cleared to zero when the"]
    #[doc = " function exits.  In this way the notification value acts like a binary"]
    #[doc = " semaphore."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
    #[doc = " the Blocked state for the task's notification value to be greater than zero,"]
    #[doc = " should the count not already be greater than zero when"]
    #[doc = " ulTaskNotifyTake() was called.  The task will not consume any processing"]
    #[doc = " time while it is in the Blocked state.  This is specified in kernel ticks,"]
    #[doc = " the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time"]
    #[doc = " specified in milliseconds to a time specified in ticks."]
    #[doc = ""]
    #[doc = " @return The task's notification count before it is either cleared to zero or"]
    #[doc = " decremented (see the xClearCountOnExit parameter)."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn ulTaskNotifyTake(xClearCountOnExit: BaseType_t, xTicksToWait: TickType_t) -> u32;
}
extern "C" {
    #[doc = " @cond"]
    pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandleForCPU(cpuid: BaseType_t) -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPriorityInherit(pxMutexHolder: TaskHandle_t);
}
extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn xTaskGetAffinity(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> *mut cty::c_void;
}
extern "C" {
    pub fn uxTaskGetSnapshotAll(
        pxTaskSnapshotArray: *mut TaskSnapshot_t,
        uxArraySize: UBaseType_t,
        pxTcbSz: *mut UBaseType_t,
    ) -> UBaseType_t;
}
#[doc = " Type by which software timers are referenced.  For example, a call to"]
#[doc = " xTimerCreate() returns an TimerHandle_t variable that can then be used to"]
#[doc = " reference the subject timer in calls to other software timer API functions"]
#[doc = " (for example, xTimerStart(), xTimerReset(), etc.)."]
pub type TimerHandle_t = *mut cty::c_void;
#[doc = " Defines the prototype to which timer callback functions must conform."]
pub type TimerCallbackFunction_t =
    ::core::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
#[doc = " Defines the prototype to which functions used with the"]
#[doc = " xTimerPendFunctionCallFromISR() function must conform."]
pub type PendedFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: u32)>;
extern "C" {
    pub fn xTimerCreate(
        pcTimerName: *const cty::c_char,
        xTimerPeriodInTicks: TickType_t,
        uxAutoReload: UBaseType_t,
        pvTimerID: *mut cty::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
extern "C" {
    #[doc = " Returns the ID assigned to the timer."]
    #[doc = ""]
    #[doc = " IDs are assigned to timers using the pvTimerID parameter of the call to"]
    #[doc = " xTimerCreated() that was used to create the timer."]
    #[doc = ""]
    #[doc = " If the same callback function is assigned to multiple timers then the timer"]
    #[doc = " ID can be used within the callback function to identify which timer actually"]
    #[doc = " expired."]
    #[doc = ""]
    #[doc = " @param xTimer The timer being queried."]
    #[doc = ""]
    #[doc = " @return The ID assigned to the timer being queried."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = ""]
    #[doc = " See the xTimerCreate() API function example usage scenario."]
    pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Sets the ID assigned to the timer."]
    #[doc = ""]
    #[doc = " IDs are assigned to timers using the pvTimerID parameter of the call to"]
    #[doc = " xTimerCreated() that was used to create the timer."]
    #[doc = ""]
    #[doc = " If the same callback function is assigned to multiple timers then the timer"]
    #[doc = " ID can be used as time specific (timer local) storage."]
    #[doc = ""]
    #[doc = " @param xTimer The timer being updated."]
    #[doc = ""]
    #[doc = " @param pvNewID The ID to assign to the timer."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = ""]
    #[doc = " See the xTimerCreate() API function example usage scenario."]
    pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut cty::c_void);
}
extern "C" {
    #[doc = " Queries a timer to see if it is active or dormant."]
    #[doc = ""]
    #[doc = " A timer will be dormant if:"]
    #[doc = ""]
    #[doc = "     1) It has been created but not started, or"]
    #[doc = ""]
    #[doc = "     2) It is an expired one-shot timer that has not been restarted."]
    #[doc = ""]
    #[doc = " Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),"]
    #[doc = " xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and"]
    #[doc = " xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the"]
    #[doc = " active state."]
    #[doc = ""]
    #[doc = " @param xTimer The timer being queried."]
    #[doc = ""]
    #[doc = " @return pdFALSE will be returned if the timer is dormant.  A value other than"]
    #[doc = " pdFALSE will be returned if the timer is active."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = " // This function assumes xTimer has already been created."]
    #[doc = " void vAFunction( TimerHandle_t xTimer )"]
    #[doc = " {"]
    #[doc = "     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently \"if( xTimerIsTimerActive( xTimer ) )\""]
    #[doc = "     {"]
    #[doc = "         // xTimer is active, do something."]
    #[doc = "     }"]
    #[doc = "     else"]
    #[doc = "     {"]
    #[doc = "         // xTimer is not active, do something else."]
    #[doc = "     }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " xTimerGetTimerDaemonTaskHandle() is only available if"]
    #[doc = " INCLUDE_xTimerGetTimerDaemonTaskHandle is set to 1 in FreeRTOSConfig.h."]
    #[doc = ""]
    #[doc = " Simply returns the handle of the timer service/daemon task.  It it not valid"]
    #[doc = " to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started."]
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
extern "C" {
    #[doc = " Returns the period of a timer."]
    #[doc = ""]
    #[doc = " @param xTimer The handle of the timer being queried."]
    #[doc = ""]
    #[doc = " @return The period of the timer in ticks."]
    pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    #[doc = " Returns the time in ticks at which the timer will expire.  If this is less"]
    #[doc = " than the current tick count then the expiry time has overflowed from the"]
    #[doc = " current time."]
    #[doc = ""]
    #[doc = " @param xTimer The handle of the timer being queried."]
    #[doc = ""]
    #[doc = " @return If the timer is running then the time in ticks at which the timer"]
    #[doc = " will next expire is returned.  If the timer is not running then the return"]
    #[doc = " value is undefined."]
    pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    #[doc = " Used from application interrupt service routines to defer the execution of a"]
    #[doc = " function to the RTOS daemon task (the timer service task, hence this function"]
    #[doc = " is implemented in timers.c and is prefixed with 'Timer')."]
    #[doc = ""]
    #[doc = " Ideally an interrupt service routine (ISR) is kept as short as possible, but"]
    #[doc = " sometimes an ISR either has a lot of processing to do, or needs to perform"]
    #[doc = " processing that is not deterministic.  In these cases"]
    #[doc = " xTimerPendFunctionCallFromISR() can be used to defer processing of a function"]
    #[doc = " to the RTOS daemon task."]
    #[doc = ""]
    #[doc = " A mechanism is provided that allows the interrupt to return directly to the"]
    #[doc = " task that will subsequently execute the pended callback function.  This"]
    #[doc = " allows the callback function to execute contiguously in time with the"]
    #[doc = " interrupt - just as if the callback had executed in the interrupt itself."]
    #[doc = ""]
    #[doc = " @param xFunctionToPend The function to execute from the timer service/"]
    #[doc = " daemon task.  The function must conform to the PendedFunction_t"]
    #[doc = " prototype."]
    #[doc = ""]
    #[doc = " @param pvParameter1 The value of the callback function's first parameter."]
    #[doc = " The parameter has a void * type to allow it to be used to pass any type."]
    #[doc = " For example, unsigned longs can be cast to a void *, or the void * can be"]
    #[doc = " used to point to a structure."]
    #[doc = ""]
    #[doc = " @param ulParameter2 The value of the callback function's second parameter."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken As mentioned above, calling this function"]
    #[doc = " will result in a message being sent to the timer daemon task.  If the"]
    #[doc = " priority of the timer daemon task (which is set using"]
    #[doc = " configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of"]
    #[doc = " the currently running task (the task the interrupt interrupted) then"]
    #[doc = " *pxHigherPriorityTaskWoken will be set to pdTRUE within"]
    #[doc = " xTimerPendFunctionCallFromISR(), indicating that a context switch should be"]
    #[doc = " requested before the interrupt exits.  For that reason"]
    #[doc = " *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the"]
    #[doc = " example code below."]
    #[doc = ""]
    #[doc = " @return pdPASS is returned if the message was successfully sent to the"]
    #[doc = " timer daemon task, otherwise pdFALSE is returned."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = ""]
    #[doc = "\t// The callback function that will execute in the context of the daemon task."]
    #[doc = "  // Note callback functions must all use this same prototype."]
    #[doc = "  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )"]
    #[doc = "\t{"]
    #[doc = "\t\tBaseType_t xInterfaceToService;"]
    #[doc = ""]
    #[doc = "\t\t// The interface that requires servicing is passed in the second"]
    #[doc = "      // parameter.  The first parameter is not used in this case."]
    #[doc = "\t\txInterfaceToService = ( BaseType_t ) ulParameter2;"]
    #[doc = ""]
    #[doc = "\t\t// ...Perform the processing here..."]
    #[doc = "\t}"]
    #[doc = ""]
    #[doc = "\t// An ISR that receives data packets from multiple interfaces"]
    #[doc = "  void vAnISR( void )"]
    #[doc = "\t{"]
    #[doc = "\t\tBaseType_t xInterfaceToService, xHigherPriorityTaskWoken;"]
    #[doc = ""]
    #[doc = "\t\t// Query the hardware to determine which interface needs processing."]
    #[doc = "\t\txInterfaceToService = prvCheckInterfaces();"]
    #[doc = ""]
    #[doc = "      // The actual processing is to be deferred to a task.  Request the"]
    #[doc = "      // vProcessInterface() callback function is executed, passing in the"]
    #[doc = "\t\t// number of the interface that needs processing.  The interface to"]
    #[doc = "\t\t// service is passed in the second parameter.  The first parameter is"]
    #[doc = "\t\t// not used in this case."]
    #[doc = "\t\txHigherPriorityTaskWoken = pdFALSE;"]
    #[doc = "\t\txTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );"]
    #[doc = ""]
    #[doc = "\t\t// If xHigherPriorityTaskWoken is now set to pdTRUE then a context"]
    #[doc = "\t\t// switch should be requested.  The macro used is port specific and will"]
    #[doc = "\t\t// be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to"]
    #[doc = "\t\t// the documentation page for the port being used."]
    #[doc = "\t\tportYIELD_FROM_ISR( xHigherPriorityTaskWoken );"]
    #[doc = ""]
    #[doc = "\t}"]
    #[doc = " @endcode"]
    pub fn xTimerPendFunctionCallFromISR(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut cty::c_void,
        ulParameter2: u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Used to defer the execution of a function to the RTOS daemon task (the timer"]
    #[doc = " service task, hence this function is implemented in timers.c and is prefixed"]
    #[doc = " with 'Timer')."]
    #[doc = ""]
    #[doc = " @param xFunctionToPend The function to execute from the timer service/"]
    #[doc = " daemon task.  The function must conform to the PendedFunction_t"]
    #[doc = " prototype."]
    #[doc = ""]
    #[doc = " @param pvParameter1 The value of the callback function's first parameter."]
    #[doc = " The parameter has a void * type to allow it to be used to pass any type."]
    #[doc = " For example, unsigned longs can be cast to a void *, or the void * can be"]
    #[doc = " used to point to a structure."]
    #[doc = ""]
    #[doc = " @param ulParameter2 The value of the callback function's second parameter."]
    #[doc = ""]
    #[doc = " @param xTicksToWait Calling this function will result in a message being"]
    #[doc = " sent to the timer daemon task on a queue.  xTicksToWait is the amount of"]
    #[doc = " time the calling task should remain in the Blocked state (so not using any"]
    #[doc = " processing time) for space to become available on the timer queue if the"]
    #[doc = " queue is found to be full."]
    #[doc = ""]
    #[doc = " @return pdPASS is returned if the message was successfully sent to the"]
    #[doc = " timer daemon task, otherwise pdFALSE is returned."]
    #[doc = ""]
    pub fn xTimerPendFunctionCall(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut cty::c_void,
        ulParameter2: u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Returns the name that was assigned to a timer when the timer was created."]
    #[doc = ""]
    #[doc = " @param xTimer The handle of the timer being queried."]
    #[doc = ""]
    #[doc = " @return The name assigned to the timer specified by the xTimer parameter."]
    pub fn pcTimerGetTimerName(xTimer: TimerHandle_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
extern "C" {
    pub fn xTimerGenericCommand(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
#[doc = " event_groups.h"]
#[doc = ""]
#[doc = " Type by which event groups are referenced.  For example, a call to"]
#[doc = " xEventGroupCreate() returns an EventGroupHandle_t variable that can then"]
#[doc = " be used as a parameter to other event group functions."]
#[doc = ""]
#[doc = " \\ingroup EventGroup"]
pub type EventGroupHandle_t = *mut cty::c_void;
pub type EventBits_t = TickType_t;
extern "C" {
    pub fn xEventGroupCreate() -> EventGroupHandle_t;
}
extern "C" {
    #[doc = " [Potentially] block to wait for one or more bits to be set within a"]
    #[doc = " previously created event group."]
    #[doc = ""]
    #[doc = " This function cannot be called from an interrupt."]
    #[doc = ""]
    #[doc = " @param xEventGroup The event group in which the bits are being tested.  The"]
    #[doc = " event group must have previously been created using a call to"]
    #[doc = " xEventGroupCreate()."]
    #[doc = ""]
    #[doc = " @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test"]
    #[doc = " inside the event group.  For example, to wait for bit 0 and/or bit 2 set"]
    #[doc = " uxBitsToWaitFor to 0x05.  To wait for bits 0 and/or bit 1 and/or bit 2 set"]
    #[doc = " uxBitsToWaitFor to 0x07.  Etc."]
    #[doc = ""]
    #[doc = " @param xClearOnExit If xClearOnExit is set to pdTRUE then any bits within"]
    #[doc = " uxBitsToWaitFor that are set within the event group will be cleared before"]
    #[doc = " xEventGroupWaitBits() returns if the wait condition was met (if the function"]
    #[doc = " returns for a reason other than a timeout).  If xClearOnExit is set to"]
    #[doc = " pdFALSE then the bits set in the event group are not altered when the call to"]
    #[doc = " xEventGroupWaitBits() returns."]
    #[doc = ""]
    #[doc = " @param xWaitForAllBits If xWaitForAllBits is set to pdTRUE then"]
    #[doc = " xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor"]
    #[doc = " are set or the specified block time expires.  If xWaitForAllBits is set to"]
    #[doc = " pdFALSE then xEventGroupWaitBits() will return when any one of the bits set"]
    #[doc = " in uxBitsToWaitFor is set or the specified block time expires.  The block"]
    #[doc = " time is specified by the xTicksToWait parameter."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait"]
    #[doc = " for one/all (depending on the xWaitForAllBits value) of the bits specified by"]
    #[doc = " uxBitsToWaitFor to become set."]
    #[doc = ""]
    #[doc = " @return The value of the event group at the time either the bits being waited"]
    #[doc = " for became set, or the block time expired.  Test the return value to know"]
    #[doc = " which bits were set.  If xEventGroupWaitBits() returned because its timeout"]
    #[doc = " expired then not all the bits being waited for will be set.  If"]
    #[doc = " xEventGroupWaitBits() returned because the bits it was waiting for were set"]
    #[doc = " then the returned value is the event group value before any bits were"]
    #[doc = " automatically cleared in the case that xClearOnExit parameter was set to"]
    #[doc = " pdTRUE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "    #define BIT_0\t( 1 << 0 )"]
    #[doc = "    #define BIT_4\t( 1 << 4 )"]
    #[doc = ""]
    #[doc = "    void aFunction( EventGroupHandle_t xEventGroup )"]
    #[doc = "    {"]
    #[doc = "    EventBits_t uxBits;"]
    #[doc = "    const TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;"]
    #[doc = ""]
    #[doc = " \t\t// Wait a maximum of 100ms for either bit 0 or bit 4 to be set within"]
    #[doc = " \t\t// the event group.  Clear the bits before exiting."]
    #[doc = " \t\tuxBits = xEventGroupWaitBits("]
    #[doc = " \t\t\t\t\txEventGroup,\t// The event group being tested."]
    #[doc = " \t\t\t\t\tBIT_0 | BIT_4,\t// The bits within the event group to wait for."]
    #[doc = " \t\t\t\t\tpdTRUE,\t\t\t// BIT_0 and BIT_4 should be cleared before returning."]
    #[doc = " \t\t\t\t\tpdFALSE,\t\t// Don't wait for both bits, either bit will do."]
    #[doc = " \t\t\t\t\txTicksToWait );\t// Wait a maximum of 100ms for either bit to be set."]
    #[doc = ""]
    #[doc = " \t\tif( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// xEventGroupWaitBits() returned because both bits were set."]
    #[doc = " \t\t}"]
    #[doc = " \t\telse if( ( uxBits & BIT_0 ) != 0 )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// xEventGroupWaitBits() returned because just BIT_0 was set."]
    #[doc = " \t\t}"]
    #[doc = " \t\telse if( ( uxBits & BIT_4 ) != 0 )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// xEventGroupWaitBits() returned because just BIT_4 was set."]
    #[doc = " \t\t}"]
    #[doc = " \t\telse"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// xEventGroupWaitBits() returned because xTicksToWait ticks passed"]
    #[doc = " \t\t\t// without either BIT_0 or BIT_4 becoming set."]
    #[doc = " \t\t}"]
    #[doc = "    }"]
    #[doc = " @endcode{c}"]
    #[doc = " \\ingroup EventGroup"]
    pub fn xEventGroupWaitBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToWaitFor: EventBits_t,
        xClearOnExit: BaseType_t,
        xWaitForAllBits: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
extern "C" {
    #[doc = " Clear bits within an event group.  This function cannot be called from an"]
    #[doc = " interrupt."]
    #[doc = ""]
    #[doc = " @param xEventGroup The event group in which the bits are to be cleared."]
    #[doc = ""]
    #[doc = " @param uxBitsToClear A bitwise value that indicates the bit or bits to clear"]
    #[doc = " in the event group.  For example, to clear bit 3 only, set uxBitsToClear to"]
    #[doc = " 0x08.  To clear bit 3 and bit 0 set uxBitsToClear to 0x09."]
    #[doc = ""]
    #[doc = " @return The value of the event group before the specified bits were cleared."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "    #define BIT_0\t( 1 << 0 )"]
    #[doc = "    #define BIT_4\t( 1 << 4 )"]
    #[doc = ""]
    #[doc = "    void aFunction( EventGroupHandle_t xEventGroup )"]
    #[doc = "    {"]
    #[doc = "    EventBits_t uxBits;"]
    #[doc = ""]
    #[doc = " \t\t// Clear bit 0 and bit 4 in xEventGroup."]
    #[doc = " \t\tuxBits = xEventGroupClearBits("]
    #[doc = " \t\t\t\t\t\t\t\txEventGroup,\t// The event group being updated."]
    #[doc = " \t\t\t\t\t\t\t\tBIT_0 | BIT_4 );// The bits being cleared."]
    #[doc = ""]
    #[doc = " \t\tif( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// Both bit 0 and bit 4 were set before xEventGroupClearBits() was"]
    #[doc = " \t\t\t// called.  Both will now be clear (not set)."]
    #[doc = " \t\t}"]
    #[doc = " \t\telse if( ( uxBits & BIT_0 ) != 0 )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// Bit 0 was set before xEventGroupClearBits() was called.  It will"]
    #[doc = " \t\t\t// now be clear."]
    #[doc = " \t\t}"]
    #[doc = " \t\telse if( ( uxBits & BIT_4 ) != 0 )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// Bit 4 was set before xEventGroupClearBits() was called.  It will"]
    #[doc = " \t\t\t// now be clear."]
    #[doc = " \t\t}"]
    #[doc = " \t\telse"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// Neither bit 0 nor bit 4 were set in the first place."]
    #[doc = " \t\t}"]
    #[doc = "    }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup EventGroup"]
    pub fn xEventGroupClearBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> EventBits_t;
}
extern "C" {
    #[doc = " Set bits within an event group."]
    #[doc = " This function cannot be called from an interrupt.  xEventGroupSetBitsFromISR()"]
    #[doc = " is a version that can be called from an interrupt."]
    #[doc = ""]
    #[doc = " Setting bits in an event group will automatically unblock tasks that are"]
    #[doc = " blocked waiting for the bits."]
    #[doc = ""]
    #[doc = " @param xEventGroup The event group in which the bits are to be set."]
    #[doc = ""]
    #[doc = " @param uxBitsToSet A bitwise value that indicates the bit or bits to set."]
    #[doc = " For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3"]
    #[doc = " and bit 0 set uxBitsToSet to 0x09."]
    #[doc = ""]
    #[doc = " @return The value of the event group at the time the call to"]
    #[doc = " xEventGroupSetBits() returns.  There are two reasons why the returned value"]
    #[doc = " might have the bits specified by the uxBitsToSet parameter cleared.  First,"]
    #[doc = " if setting a bit results in a task that was waiting for the bit leaving the"]
    #[doc = " blocked state then it is possible the bit will be cleared automatically"]
    #[doc = " (see the xClearBitOnExit parameter of xEventGroupWaitBits()).  Second, any"]
    #[doc = " unblocked (or otherwise Ready state) task that has a priority above that of"]
    #[doc = " the task that called xEventGroupSetBits() will execute and may change the"]
    #[doc = " event group value before the call to xEventGroupSetBits() returns."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "    #define BIT_0\t( 1 << 0 )"]
    #[doc = "    #define BIT_4\t( 1 << 4 )"]
    #[doc = ""]
    #[doc = "    void aFunction( EventGroupHandle_t xEventGroup )"]
    #[doc = "    {"]
    #[doc = "    EventBits_t uxBits;"]
    #[doc = ""]
    #[doc = " \t\t// Set bit 0 and bit 4 in xEventGroup."]
    #[doc = " \t\tuxBits = xEventGroupSetBits("]
    #[doc = " \t\t\t\t\t\t\txEventGroup,\t// The event group being updated."]
    #[doc = " \t\t\t\t\t\t\tBIT_0 | BIT_4 );// The bits being set."]
    #[doc = ""]
    #[doc = " \t\tif( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// Both bit 0 and bit 4 remained set when the function returned."]
    #[doc = " \t\t}"]
    #[doc = " \t\telse if( ( uxBits & BIT_0 ) != 0 )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// Bit 0 remained set when the function returned, but bit 4 was"]
    #[doc = " \t\t\t// cleared.  It might be that bit 4 was cleared automatically as a"]
    #[doc = " \t\t\t// task that was waiting for bit 4 was removed from the Blocked"]
    #[doc = " \t\t\t// state."]
    #[doc = " \t\t}"]
    #[doc = " \t\telse if( ( uxBits & BIT_4 ) != 0 )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// Bit 4 remained set when the function returned, but bit 0 was"]
    #[doc = " \t\t\t// cleared.  It might be that bit 0 was cleared automatically as a"]
    #[doc = " \t\t\t// task that was waiting for bit 0 was removed from the Blocked"]
    #[doc = " \t\t\t// state."]
    #[doc = " \t\t}"]
    #[doc = " \t\telse"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// Neither bit 0 nor bit 4 remained set.  It might be that a task"]
    #[doc = " \t\t\t// was waiting for both of the bits to be set, and the bits were"]
    #[doc = " \t\t\t// cleared as the task left the Blocked state."]
    #[doc = " \t\t}"]
    #[doc = "    }"]
    #[doc = " @endcode{c}"]
    #[doc = " \\ingroup EventGroup"]
    pub fn xEventGroupSetBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
    ) -> EventBits_t;
}
extern "C" {
    #[doc = " Atomically set bits within an event group, then wait for a combination of"]
    #[doc = " bits to be set within the same event group.  This functionality is typically"]
    #[doc = " used to synchronise multiple tasks, where each task has to wait for the other"]
    #[doc = " tasks to reach a synchronisation point before proceeding."]
    #[doc = ""]
    #[doc = " This function cannot be used from an interrupt."]
    #[doc = ""]
    #[doc = " The function will return before its block time expires if the bits specified"]
    #[doc = " by the uxBitsToWait parameter are set, or become set within that time.  In"]
    #[doc = " this case all the bits specified by uxBitsToWait will be automatically"]
    #[doc = " cleared before the function returns."]
    #[doc = ""]
    #[doc = " @param xEventGroup The event group in which the bits are being tested.  The"]
    #[doc = " event group must have previously been created using a call to"]
    #[doc = " xEventGroupCreate()."]
    #[doc = ""]
    #[doc = " @param uxBitsToSet The bits to set in the event group before determining"]
    #[doc = " if, and possibly waiting for, all the bits specified by the uxBitsToWait"]
    #[doc = " parameter are set."]
    #[doc = ""]
    #[doc = " @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test"]
    #[doc = " inside the event group.  For example, to wait for bit 0 and bit 2 set"]
    #[doc = " uxBitsToWaitFor to 0x05.  To wait for bits 0 and bit 1 and bit 2 set"]
    #[doc = " uxBitsToWaitFor to 0x07.  Etc."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait"]
    #[doc = " for all of the bits specified by uxBitsToWaitFor to become set."]
    #[doc = ""]
    #[doc = " @return The value of the event group at the time either the bits being waited"]
    #[doc = " for became set, or the block time expired.  Test the return value to know"]
    #[doc = " which bits were set.  If xEventGroupSync() returned because its timeout"]
    #[doc = " expired then not all the bits being waited for will be set.  If"]
    #[doc = " xEventGroupSync() returned because all the bits it was waiting for were"]
    #[doc = " set then the returned value is the event group value before any bits were"]
    #[doc = " automatically cleared."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  // Bits used by the three tasks."]
    #[doc = "  #define TASK_0_BIT\t\t( 1 << 0 )"]
    #[doc = "  #define TASK_1_BIT\t\t( 1 << 1 )"]
    #[doc = "  #define TASK_2_BIT\t\t( 1 << 2 )"]
    #[doc = ""]
    #[doc = "  #define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )"]
    #[doc = ""]
    #[doc = "  // Use an event group to synchronise three tasks.  It is assumed this event"]
    #[doc = "  // group has already been created elsewhere."]
    #[doc = "  EventGroupHandle_t xEventBits;"]
    #[doc = ""]
    #[doc = "  void vTask0( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  EventBits_t uxReturn;"]
    #[doc = "  TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;"]
    #[doc = ""]
    #[doc = " \t for( ;; )"]
    #[doc = " \t {"]
    #[doc = " \t\t// Perform task functionality here."]
    #[doc = ""]
    #[doc = " \t\t// Set bit 0 in the event flag to note this task has reached the"]
    #[doc = " \t\t// sync point.  The other two tasks will set the other two bits defined"]
    #[doc = " \t\t// by ALL_SYNC_BITS.  All three tasks have reached the synchronisation"]
    #[doc = " \t\t// point when all the ALL_SYNC_BITS are set.  Wait a maximum of 100ms"]
    #[doc = " \t\t// for this to happen."]
    #[doc = " \t\tuxReturn = xEventGroupSync( xEventBits, TASK_0_BIT, ALL_SYNC_BITS, xTicksToWait );"]
    #[doc = ""]
    #[doc = " \t\tif( ( uxReturn & ALL_SYNC_BITS ) == ALL_SYNC_BITS )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// All three tasks reached the synchronisation point before the call"]
    #[doc = " \t\t\t// to xEventGroupSync() timed out."]
    #[doc = " \t\t}"]
    #[doc = " \t}"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  void vTask1( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = " \t for( ;; )"]
    #[doc = " \t {"]
    #[doc = " \t\t// Perform task functionality here."]
    #[doc = ""]
    #[doc = " \t\t// Set bit 1 in the event flag to note this task has reached the"]
    #[doc = " \t\t// synchronisation point.  The other two tasks will set the other two"]
    #[doc = " \t\t// bits defined by ALL_SYNC_BITS.  All three tasks have reached the"]
    #[doc = " \t\t// synchronisation point when all the ALL_SYNC_BITS are set.  Wait"]
    #[doc = " \t\t// indefinitely for this to happen."]
    #[doc = " \t\txEventGroupSync( xEventBits, TASK_1_BIT, ALL_SYNC_BITS, portMAX_DELAY );"]
    #[doc = ""]
    #[doc = " \t\t// xEventGroupSync() was called with an indefinite block time, so"]
    #[doc = " \t\t// this task will only reach here if the syncrhonisation was made by all"]
    #[doc = " \t\t// three tasks, so there is no need to test the return value."]
    #[doc = " \t }"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  void vTask2( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = " \t for( ;; )"]
    #[doc = " \t {"]
    #[doc = " \t\t// Perform task functionality here."]
    #[doc = ""]
    #[doc = " \t\t// Set bit 2 in the event flag to note this task has reached the"]
    #[doc = " \t\t// synchronisation point.  The other two tasks will set the other two"]
    #[doc = " \t\t// bits defined by ALL_SYNC_BITS.  All three tasks have reached the"]
    #[doc = " \t\t// synchronisation point when all the ALL_SYNC_BITS are set.  Wait"]
    #[doc = " \t\t// indefinitely for this to happen."]
    #[doc = " \t\txEventGroupSync( xEventBits, TASK_2_BIT, ALL_SYNC_BITS, portMAX_DELAY );"]
    #[doc = ""]
    #[doc = " \t\t// xEventGroupSync() was called with an indefinite block time, so"]
    #[doc = " \t\t// this task will only reach here if the syncrhonisation was made by all"]
    #[doc = " \t\t// three tasks, so there is no need to test the return value."]
    #[doc = " \t}"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = " @endcode"]
    #[doc = " \\ingroup EventGroup"]
    pub fn xEventGroupSync(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        uxBitsToWaitFor: EventBits_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
extern "C" {
    #[doc = " A version of xEventGroupGetBits() that can be called from an ISR."]
    #[doc = ""]
    #[doc = " @param xEventGroup The event group being queried."]
    #[doc = ""]
    #[doc = " @return The event group bits at the time xEventGroupGetBitsFromISR() was called."]
    #[doc = ""]
    #[doc = " \\ingroup EventGroup"]
    pub fn xEventGroupGetBitsFromISR(xEventGroup: EventGroupHandle_t) -> EventBits_t;
}
extern "C" {
    #[doc = " Delete an event group that was previously created by a call to"]
    #[doc = " xEventGroupCreate().  Tasks that are blocked on the event group will be"]
    #[doc = " unblocked and obtain 0 as the event group's value."]
    #[doc = ""]
    #[doc = " @param xEventGroup The event group being deleted."]
    pub fn vEventGroupDelete(xEventGroup: EventGroupHandle_t);
}
extern "C" {
    #[doc = " @cond"]
    pub fn vEventGroupSetBitsCallback(pvEventGroup: *mut cty::c_void, ulBitsToSet: u32);
}
extern "C" {
    pub fn vEventGroupClearBitsCallback(pvEventGroup: *mut cty::c_void, ulBitsToClear: u32);
}
#[doc = " Type by which queues are referenced.  For example, a call to xQueueCreate()"]
#[doc = " returns an QueueHandle_t variable that can then be used as a parameter to"]
#[doc = " xQueueSend(), xQueueReceive(), etc."]
pub type QueueHandle_t = *mut cty::c_void;
#[doc = " Type by which queue sets are referenced.  For example, a call to"]
#[doc = " xQueueCreateSet() returns an xQueueSet variable that can then be used as a"]
#[doc = " parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc."]
pub type QueueSetHandle_t = *mut cty::c_void;
#[doc = " Queue sets can contain both queues and semaphores, so the"]
#[doc = " QueueSetMemberHandle_t is defined as a type to be used where a parameter or"]
#[doc = " return value can be either an QueueHandle_t or an SemaphoreHandle_t."]
pub type QueueSetMemberHandle_t = *mut cty::c_void;
extern "C" {
    #[doc = " It is preferred that the macros xQueueSend(), xQueueSendToFront() and"]
    #[doc = " xQueueSendToBack() are used in place of calling this function directly."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  The item is queued by copy, not by reference."]
    #[doc = " This function must not be called from an interrupt service routine."]
    #[doc = " See xQueueSendFromISR () for an alternative which may be used in an ISR."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for space to become available on the queue, should it already"]
    #[doc = " be full.  The call will return immediately if this is set to 0 and the"]
    #[doc = " queue is full.  The time is defined in tick periods so the constant"]
    #[doc = " portTICK_PERIOD_MS should be used to convert to real time if this is required."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  struct AMessage"]
    #[doc = "  {"]
    #[doc = "  char ucMessageID;"]
    #[doc = "  char ucData[ 20 ];"]
    #[doc = "  } xMessage;"]
    #[doc = ""]
    #[doc = "  uint32_t ulVar = 10UL;"]
    #[doc = ""]
    #[doc = "  void vATask( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  QueueHandle_t xQueue1, xQueue2;"]
    #[doc = "  struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = "  // Create a queue capable of containing 10 uint32_t values."]
    #[doc = "  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );"]
    #[doc = ""]
    #[doc = "  // Create a queue capable of containing 10 pointers to AMessage structures."]
    #[doc = "  // These should be passed by pointer as they contain a lot of data."]
    #[doc = "  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = ""]
    #[doc = "  // ..."]
    #[doc = ""]
    #[doc = "  if( xQueue1 != 0 )"]
    #[doc = "  {"]
    #[doc = "      // Send an uint32_t.  Wait for 10 ticks for space to become"]
    #[doc = "      // available if necessary."]
    #[doc = "      if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )"]
    #[doc = "      {"]
    #[doc = "          // Failed to post the message, even after 10 ticks."]
    #[doc = "      }"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  if( xQueue2 != 0 )"]
    #[doc = "  {"]
    #[doc = "      // Send a pointer to a struct AMessage object.  Don't block if the"]
    #[doc = "      // queue is already full."]
    #[doc = "      pxMessage = & xMessage;"]
    #[doc = "      xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  // ... Rest of task code."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " A version of xQueuePeek() that can be called from an interrupt service"]
    #[doc = " routine (ISR)."]
    #[doc = ""]
    #[doc = " Receive an item from a queue without removing the item from the queue."]
    #[doc = " The item is received by copy so a buffer of adequate size must be"]
    #[doc = " provided.  The number of bytes copied into the buffer was defined when"]
    #[doc = " the queue was created."]
    #[doc = ""]
    #[doc = " Successfully received items remain on the queue so will be returned again"]
    #[doc = " by the next call, or a call to xQueueReceive()."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueuePeekFromISR(xQueue: QueueHandle_t, pvBuffer: *mut cty::c_void) -> BaseType_t;
}
extern "C" {
    #[doc = " It is preferred that the macro xQueueReceive() be used rather than calling"]
    #[doc = " this function directly."]
    #[doc = ""]
    #[doc = " Receive an item from a queue.  The item is received by copy so a buffer of"]
    #[doc = " adequate size must be provided.  The number of bytes copied into the buffer"]
    #[doc = " was defined when the queue was created."]
    #[doc = ""]
    #[doc = " This function must not be used in an interrupt service routine.  See"]
    #[doc = " xQueueReceiveFromISR for an alternative that can."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for an item to receive should the queue be empty at the time"]
    #[doc = " of the call.\t The time is defined in tick periods so the constant"]
    #[doc = " portTICK_PERIOD_MS should be used to convert to real time if this is required."]
    #[doc = " xQueueGenericReceive() will return immediately if the queue is empty and"]
    #[doc = " xTicksToWait is 0."]
    #[doc = ""]
    #[doc = " @param xJustPeek When set to true, the item received from the queue is not"]
    #[doc = " actually removed from the queue - meaning a subsequent call to"]
    #[doc = " xQueueReceive() will return the same item.  When set to false, the item"]
    #[doc = " being received from the queue is also removed from the queue."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  struct AMessage"]
    #[doc = "  {"]
    #[doc = " \tchar ucMessageID;"]
    #[doc = " \tchar ucData[ 20 ];"]
    #[doc = "  } xMessage;"]
    #[doc = ""]
    #[doc = "  QueueHandle_t xQueue;"]
    #[doc = ""]
    #[doc = "  // Task to create a queue and post a value."]
    #[doc = "  void vATask( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = " \t// Create a queue capable of containing 10 pointers to AMessage structures."]
    #[doc = " \t// These should be passed by pointer as they contain a lot of data."]
    #[doc = " \txQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = " \tif( xQueue == 0 )"]
    #[doc = " \t{"]
    #[doc = " \t\t// Failed to create the queue."]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \t// ..."]
    #[doc = ""]
    #[doc = " \t// Send a pointer to a struct AMessage object.  Don't block if the"]
    #[doc = " \t// queue is already full."]
    #[doc = " \tpxMessage = & xMessage;"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );"]
    #[doc = ""]
    #[doc = " \t// ... Rest of task code."]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  // Task to receive from the queue."]
    #[doc = "  void vADifferentTask( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  struct AMessage *pxRxedMessage;"]
    #[doc = ""]
    #[doc = " \tif( xQueue != 0 )"]
    #[doc = " \t{"]
    #[doc = " \t\t// Receive a message on the created queue.  Block for 10 ticks if a"]
    #[doc = " \t\t// message is not immediately available."]
    #[doc = " \t\tif( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// pcRxedMessage now points to the struct AMessage variable posted"]
    #[doc = " \t\t\t// by vATask."]
    #[doc = " \t\t}"]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \t// ... Rest of task code."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        xTicksToWait: TickType_t,
        xJustPeek: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Return the number of messages stored in a queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue being queried."]
    #[doc = ""]
    #[doc = " @return The number of messages available in the queue."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Return the number of free spaces available in a queue.  This is equal to the"]
    #[doc = " number of items that can be sent to the queue before the queue becomes full"]
    #[doc = " if no items are removed."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue being queried."]
    #[doc = ""]
    #[doc = " @return The number of spaces available in the queue."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Delete a queue - freeing all the memory allocated for storing of items"]
    #[doc = " placed on the queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue to be deleted."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " It is preferred that the macros xQueueSendFromISR(),"]
    #[doc = " xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place"]
    #[doc = " of calling this function directly.  xQueueGiveFromISR() is an"]
    #[doc = " equivalent for use by semaphores that don't actually copy any data."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " Items are queued by copy not reference so it is preferable to only"]
    #[doc = " queue small items, especially when called from an ISR.  In most cases"]
    #[doc = " it would be preferable to store a pointer to the item being queued."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param[out] pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task"]
    #[doc = " to unblock, and the unblocked task has a priority higher than the currently"]
    #[doc = " running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then"]
    #[doc = " a context switch should be requested before the interrupt is exited."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the data was successfully sent to the queue, otherwise"]
    #[doc = " errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage for buffered IO (where the ISR can obtain more than one value"]
    #[doc = " per call):"]
    #[doc = " @code{c}"]
    #[doc = "  void vBufferISR( void )"]
    #[doc = "  {"]
    #[doc = "  char cIn;"]
    #[doc = "  BaseType_t xHigherPriorityTaskWokenByPost;"]
    #[doc = ""]
    #[doc = " \t// We have not woken a task at the start of the ISR."]
    #[doc = " \txHigherPriorityTaskWokenByPost = pdFALSE;"]
    #[doc = ""]
    #[doc = " \t// Loop until the buffer is empty."]
    #[doc = " \tdo"]
    #[doc = " \t{"]
    #[doc = " \t\t// Obtain a byte from the buffer."]
    #[doc = " \t\tcIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );"]
    #[doc = ""]
    #[doc = " \t\t// Post each byte."]
    #[doc = " \t\txQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );"]
    #[doc = ""]
    #[doc = " \t} while( portINPUT_BYTE( BUFFER_COUNT ) );"]
    #[doc = ""]
    #[doc = " \t// Now the buffer is empty we can switch context if necessary.  Note that the"]
    #[doc = " \t// name of the yield function required is port specific."]
    #[doc = " \tif( xHigherPriorityTaskWokenByPost )"]
    #[doc = " \t{"]
    #[doc = " \t\ttaskYIELD_YIELD_FROM_ISR();"]
    #[doc = " \t}"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Receive an item from a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param[out] pxHigherPriorityTaskWoken A task may be blocked waiting for space to become"]
    #[doc = " available on the queue.  If xQueueReceiveFromISR causes such a task to"]
    #[doc = " unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will"]
    #[doc = " remain unchanged."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  QueueHandle_t xQueue;"]
    #[doc = ""]
    #[doc = "  // Function to create a queue and post some values."]
    #[doc = "  void vAFunction( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  char cValueToPost;"]
    #[doc = "  const TickType_t xTicksToWait = ( TickType_t )0xff;"]
    #[doc = ""]
    #[doc = " \t// Create a queue capable of containing 10 characters."]
    #[doc = " \txQueue = xQueueCreate( 10, sizeof( char ) );"]
    #[doc = " \tif( xQueue == 0 )"]
    #[doc = " \t{"]
    #[doc = " \t\t// Failed to create the queue."]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \t// ..."]
    #[doc = ""]
    #[doc = " \t// Post some characters that will be used within an ISR.  If the queue"]
    #[doc = " \t// is full then this task will block for xTicksToWait ticks."]
    #[doc = " \tcValueToPost = 'a';"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = " \tcValueToPost = 'b';"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = ""]
    #[doc = " \t// ... keep posting characters ... this task may block when the queue"]
    #[doc = " \t// becomes full."]
    #[doc = ""]
    #[doc = " \tcValueToPost = 'c';"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  // ISR that outputs all the characters received on the queue."]
    #[doc = "  void vISR_Routine( void )"]
    #[doc = "  {"]
    #[doc = "  BaseType_t xTaskWokenByReceive = pdFALSE;"]
    #[doc = "  char cRxedChar;"]
    #[doc = ""]
    #[doc = " \twhile( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )"]
    #[doc = " \t{"]
    #[doc = " \t\t// A character was received.  Output the character now."]
    #[doc = " \t\tvOutputCharacter( cRxedChar );"]
    #[doc = ""]
    #[doc = " \t\t// If removing the character from the queue woke the task that was"]
    #[doc = " \t\t// posting onto the queue cTaskWokenByReceive will have been set to"]
    #[doc = " \t\t// pdTRUE.  No matter how many times this loop iterates only one"]
    #[doc = " \t\t// task will be woken."]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \tif( cTaskWokenByPost != ( char ) pdFALSE;"]
    #[doc = " \t{"]
    #[doc = " \t\ttaskYIELD ();"]
    #[doc = " \t}"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " Utilities to query queues that are safe to use from an ISR.  These utilities"]
    #[doc = " should be used only from witin an ISR, or within a critical section."]
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " xQueueAltGenericSend() is an alternative version of xQueueGenericSend()."]
    #[doc = " Likewise xQueueAltGenericReceive() is an alternative version of"]
    #[doc = " xQueueGenericReceive()."]
    #[doc = ""]
    #[doc = " The source code that implements the alternative (Alt) API is much"]
    #[doc = " simpler\tbecause it executes everything from within a critical section."]
    #[doc = " This is\tthe approach taken by many other RTOSes, but FreeRTOS.org has the"]
    #[doc = " preferred fully featured API too.  The fully featured API has more"]
    #[doc = " complex\tcode that takes longer to execute, but makes much less use of"]
    #[doc = " critical sections.  Therefore the alternative API sacrifices interrupt"]
    #[doc = " responsiveness to gain execution speed, whereas the fully featured API"]
    #[doc = " sacrifices execution speed to ensure better interrupt responsiveness."]
    pub fn xQueueAltGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueAltGenericReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        xTicksToWait: TickType_t,
        xJustPeeking: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(pxMutex: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    #[doc = " Queue sets provide a mechanism to allow a task to block (pend) on a read"]
    #[doc = " operation from multiple queues or semaphores simultaneously."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " A queue set must be explicitly created using a call to xQueueCreateSet()"]
    #[doc = " before it can be used.  Once created, standard FreeRTOS queues and semaphores"]
    #[doc = " can be added to the set using calls to xQueueAddToSet()."]
    #[doc = " xQueueSelectFromSet() is then used to determine which, if any, of the queues"]
    #[doc = " or semaphores contained in the set is in a state where a queue read or"]
    #[doc = " semaphore take operation would be successful."]
    #[doc = ""]
    #[doc = " Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html"]
    #[doc = " for reasons why queue sets are very rarely needed in practice as there are"]
    #[doc = " simpler methods of blocking on multiple objects."]
    #[doc = ""]
    #[doc = " Note 2:  Blocking on a queue set that contains a mutex will not cause the"]
    #[doc = " mutex holder to inherit the priority of the blocked task."]
    #[doc = ""]
    #[doc = " Note 3:  An additional 4 bytes of RAM is required for each space in a every"]
    #[doc = " queue added to a queue set.  Therefore counting semaphores that have a high"]
    #[doc = " maximum count value should not be added to a queue set."]
    #[doc = ""]
    #[doc = " Note 4:  A receive (in the case of a queue) or take (in the case of a"]
    #[doc = " semaphore) operation must not be performed on a member of a queue set unless"]
    #[doc = " a call to xQueueSelectFromSet() has first returned a handle to that set member."]
    #[doc = ""]
    #[doc = " @param uxEventQueueLength Queue sets store events that occur on"]
    #[doc = " the queues and semaphores contained in the set.  uxEventQueueLength specifies"]
    #[doc = " the maximum number of events that can be queued at once.  To be absolutely"]
    #[doc = " certain that events are not lost uxEventQueueLength should be set to the"]
    #[doc = " total sum of the length of the queues added to the set, where binary"]
    #[doc = " semaphores and mutexes have a length of 1, and counting semaphores have a"]
    #[doc = " length set by their maximum count value.  Examples:"]
    #[doc = "  + If a queue set is to hold a queue of length 5, another queue of length 12,"]
    #[doc = "    and a binary semaphore, then uxEventQueueLength should be set to"]
    #[doc = "    (5 + 12 + 1), or 18."]
    #[doc = "  + If a queue set is to hold three binary semaphores then uxEventQueueLength"]
    #[doc = "    should be set to (1 + 1 + 1 ), or 3."]
    #[doc = "  + If a queue set is to hold a counting semaphore that has a maximum count of"]
    #[doc = "    5, and a counting semaphore that has a maximum count of 3, then"]
    #[doc = "    uxEventQueueLength should be set to (5 + 3), or 8."]
    #[doc = ""]
    #[doc = " @return If the queue set is created successfully then a handle to the created"]
    #[doc = " queue set is returned.  Otherwise NULL is returned."]
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
extern "C" {
    #[doc = " Adds a queue or semaphore to a queue set that was previously created by a"]
    #[doc = " call to xQueueCreateSet()."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " Note 1:  A receive (in the case of a queue) or take (in the case of a"]
    #[doc = " semaphore) operation must not be performed on a member of a queue set unless"]
    #[doc = " a call to xQueueSelectFromSet() has first returned a handle to that set member."]
    #[doc = ""]
    #[doc = " @param xQueueOrSemaphore The handle of the queue or semaphore being added to"]
    #[doc = " the queue set (cast to an QueueSetMemberHandle_t type)."]
    #[doc = ""]
    #[doc = " @param xQueueSet The handle of the queue set to which the queue or semaphore"]
    #[doc = " is being added."]
    #[doc = ""]
    #[doc = " @return If the queue or semaphore was successfully added to the queue set"]
    #[doc = " then pdPASS is returned.  If the queue could not be successfully added to the"]
    #[doc = " queue set because it is already a member of a different queue set then pdFAIL"]
    #[doc = " is returned."]
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Removes a queue or semaphore from a queue set.  A queue or semaphore can only"]
    #[doc = " be removed from a set if the queue or semaphore is empty."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @param xQueueOrSemaphore The handle of the queue or semaphore being removed"]
    #[doc = " from the queue set (cast to an QueueSetMemberHandle_t type)."]
    #[doc = ""]
    #[doc = " @param xQueueSet The handle of the queue set in which the queue or semaphore"]
    #[doc = " is included."]
    #[doc = ""]
    #[doc = " @return If the queue or semaphore was successfully removed from the queue set"]
    #[doc = " then pdPASS is returned.  If the queue was not in the queue set, or the"]
    #[doc = " queue (or semaphore) was not empty, then pdFAIL is returned."]
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " xQueueSelectFromSet() selects from the members of a queue set a queue or"]
    #[doc = " semaphore that either contains data (in the case of a queue) or is available"]
    #[doc = " to take (in the case of a semaphore).  xQueueSelectFromSet() effectively"]
    #[doc = " allows a task to block (pend) on a read operation on all the queues and"]
    #[doc = " semaphores in a queue set simultaneously."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html"]
    #[doc = " for reasons why queue sets are very rarely needed in practice as there are"]
    #[doc = " simpler methods of blocking on multiple objects."]
    #[doc = ""]
    #[doc = " Note 2:  Blocking on a queue set that contains a mutex will not cause the"]
    #[doc = " mutex holder to inherit the priority of the blocked task."]
    #[doc = ""]
    #[doc = " Note 3:  A receive (in the case of a queue) or take (in the case of a"]
    #[doc = " semaphore) operation must not be performed on a member of a queue set unless"]
    #[doc = " a call to xQueueSelectFromSet() has first returned a handle to that set member."]
    #[doc = ""]
    #[doc = " @param xQueueSet The queue set on which the task will (potentially) block."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum time, in ticks, that the calling task will"]
    #[doc = " remain in the Blocked state (with other tasks executing) to wait for a member"]
    #[doc = " of the queue set to be ready for a successful queue read or semaphore take"]
    #[doc = " operation."]
    #[doc = ""]
    #[doc = " @return xQueueSelectFromSet() will return the handle of a queue (cast to"]
    #[doc = " a QueueSetMemberHandle_t type) contained in the queue set that contains data,"]
    #[doc = " or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained"]
    #[doc = " in the queue set that is available, or NULL if no such queue or semaphore"]
    #[doc = " exists before before the specified block time expires."]
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
extern "C" {
    #[doc = " A version of xQueueSelectFromSet() that can be used from an ISR."]
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
extern "C" {
    #[doc = " @cond"]
    pub fn vQueueWaitForMessageRestricted(xQueue: QueueHandle_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
#[doc = "< ESP32 station interface"]
pub const esp_interface_t_ESP_IF_WIFI_STA: esp_interface_t = 0;
#[doc = "< ESP32 soft-AP interface"]
pub const esp_interface_t_ESP_IF_WIFI_AP: esp_interface_t = 1;
#[doc = "< ESP32 ethernet interface"]
pub const esp_interface_t_ESP_IF_ETH: esp_interface_t = 2;
pub const esp_interface_t_ESP_IF_MAX: esp_interface_t = 3;
pub type esp_interface_t = u32;
#[doc = "< null mode"]
pub const wifi_mode_t_WIFI_MODE_NULL: wifi_mode_t = 0;
#[doc = "< WiFi station mode"]
pub const wifi_mode_t_WIFI_MODE_STA: wifi_mode_t = 1;
#[doc = "< WiFi soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_AP: wifi_mode_t = 2;
#[doc = "< WiFi station + soft-AP mode"]
pub const wifi_mode_t_WIFI_MODE_APSTA: wifi_mode_t = 3;
pub const wifi_mode_t_WIFI_MODE_MAX: wifi_mode_t = 4;
pub type wifi_mode_t = u32;
pub use self::esp_interface_t as wifi_interface_t;
#[doc = "< Country policy is auto, use the country info of AP to which the station is connected"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_AUTO: wifi_country_policy_t = 0;
#[doc = "< Country policy is manual, always use the configured country info"]
pub const wifi_country_policy_t_WIFI_COUNTRY_POLICY_MANUAL: wifi_country_policy_t = 1;
pub type wifi_country_policy_t = u32;
#[doc = " @brief Structure describing WiFi country-based regional restrictions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_country_t {
    #[doc = "< country code string"]
    pub cc: [cty::c_char; 3usize],
    #[doc = "< start channel"]
    pub schan: u8,
    #[doc = "< total channel number"]
    pub nchan: u8,
    #[doc = "< maximum tx power"]
    pub max_tx_power: i8,
    #[doc = "< country policy"]
    pub policy: wifi_country_policy_t,
}
#[doc = "< authenticate mode : open"]
pub const wifi_auth_mode_t_WIFI_AUTH_OPEN: wifi_auth_mode_t = 0;
#[doc = "< authenticate mode : WEP"]
pub const wifi_auth_mode_t_WIFI_AUTH_WEP: wifi_auth_mode_t = 1;
#[doc = "< authenticate mode : WPA_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_PSK: wifi_auth_mode_t = 2;
#[doc = "< authenticate mode : WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_PSK: wifi_auth_mode_t = 3;
#[doc = "< authenticate mode : WPA_WPA2_PSK"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA_WPA2_PSK: wifi_auth_mode_t = 4;
#[doc = "< authenticate mode : WPA2_ENTERPRISE"]
pub const wifi_auth_mode_t_WIFI_AUTH_WPA2_ENTERPRISE: wifi_auth_mode_t = 5;
pub const wifi_auth_mode_t_WIFI_AUTH_MAX: wifi_auth_mode_t = 6;
pub type wifi_auth_mode_t = u32;
pub const wifi_err_reason_t_WIFI_REASON_UNSPECIFIED: wifi_err_reason_t = 1;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_EXPIRE: wifi_err_reason_t = 2;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_LEAVE: wifi_err_reason_t = 3;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_EXPIRE: wifi_err_reason_t = 4;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_TOOMANY: wifi_err_reason_t = 5;
pub const wifi_err_reason_t_WIFI_REASON_NOT_AUTHED: wifi_err_reason_t = 6;
pub const wifi_err_reason_t_WIFI_REASON_NOT_ASSOCED: wifi_err_reason_t = 7;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_LEAVE: wifi_err_reason_t = 8;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_NOT_AUTHED: wifi_err_reason_t = 9;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_PWRCAP_BAD: wifi_err_reason_t = 10;
pub const wifi_err_reason_t_WIFI_REASON_DISASSOC_SUPCHAN_BAD: wifi_err_reason_t = 11;
pub const wifi_err_reason_t_WIFI_REASON_IE_INVALID: wifi_err_reason_t = 13;
pub const wifi_err_reason_t_WIFI_REASON_MIC_FAILURE: wifi_err_reason_t = 14;
pub const wifi_err_reason_t_WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 15;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT: wifi_err_reason_t = 16;
pub const wifi_err_reason_t_WIFI_REASON_IE_IN_4WAY_DIFFERS: wifi_err_reason_t = 17;
pub const wifi_err_reason_t_WIFI_REASON_GROUP_CIPHER_INVALID: wifi_err_reason_t = 18;
pub const wifi_err_reason_t_WIFI_REASON_PAIRWISE_CIPHER_INVALID: wifi_err_reason_t = 19;
pub const wifi_err_reason_t_WIFI_REASON_AKMP_INVALID: wifi_err_reason_t = 20;
pub const wifi_err_reason_t_WIFI_REASON_UNSUPP_RSN_IE_VERSION: wifi_err_reason_t = 21;
pub const wifi_err_reason_t_WIFI_REASON_INVALID_RSN_IE_CAP: wifi_err_reason_t = 22;
pub const wifi_err_reason_t_WIFI_REASON_802_1X_AUTH_FAILED: wifi_err_reason_t = 23;
pub const wifi_err_reason_t_WIFI_REASON_CIPHER_SUITE_REJECTED: wifi_err_reason_t = 24;
pub const wifi_err_reason_t_WIFI_REASON_BEACON_TIMEOUT: wifi_err_reason_t = 200;
pub const wifi_err_reason_t_WIFI_REASON_NO_AP_FOUND: wifi_err_reason_t = 201;
pub const wifi_err_reason_t_WIFI_REASON_AUTH_FAIL: wifi_err_reason_t = 202;
pub const wifi_err_reason_t_WIFI_REASON_ASSOC_FAIL: wifi_err_reason_t = 203;
pub const wifi_err_reason_t_WIFI_REASON_HANDSHAKE_TIMEOUT: wifi_err_reason_t = 204;
pub const wifi_err_reason_t_WIFI_REASON_CONNECTION_FAIL: wifi_err_reason_t = 205;
pub type wifi_err_reason_t = u32;
#[doc = "< the channel width is HT20"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_NONE: wifi_second_chan_t = 0;
#[doc = "< the channel width is HT40 and the secondary channel is above the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_ABOVE: wifi_second_chan_t = 1;
#[doc = "< the channel width is HT40 and the secondary channel is below the primary channel"]
pub const wifi_second_chan_t_WIFI_SECOND_CHAN_BELOW: wifi_second_chan_t = 2;
pub type wifi_second_chan_t = u32;
#[doc = "< active scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_ACTIVE: wifi_scan_type_t = 0;
#[doc = "< passive scan"]
pub const wifi_scan_type_t_WIFI_SCAN_TYPE_PASSIVE: wifi_scan_type_t = 1;
pub type wifi_scan_type_t = u32;
#[doc = " @brief Range of active scan times per channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_active_scan_time_t {
    #[doc = "< minimum active scan time per channel, units: millisecond"]
    pub min: u32,
    #[doc = "< maximum active scan time per channel, units: millisecond, values above 1500ms may"]
    #[doc = "cause station to disconnect from AP and are not recommended."]
    pub max: u32,
}
#[doc = " @brief Aggregate of active & passive scan time per channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_scan_time_t {
    #[doc = "< active scan time per channel, units: millisecond."]
    pub active: wifi_active_scan_time_t,
    #[doc = "< passive scan time per channel, units: millisecond, values above 1500ms may"]
    #[doc = "cause station to disconnect from AP and are not recommended."]
    pub passive: u32,
    _bindgen_union_align: [u32; 2usize],
}
#[doc = " @brief Parameters for an SSID scan."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_scan_config_t {
    #[doc = "< SSID of AP"]
    pub ssid: *mut u8,
    #[doc = "< MAC address of AP"]
    pub bssid: *mut u8,
    #[doc = "< channel, scan the specific channel"]
    pub channel: u8,
    #[doc = "< enable to scan AP whose SSID is hidden"]
    pub show_hidden: bool,
    #[doc = "< scan type, active or passive"]
    pub scan_type: wifi_scan_type_t,
    #[doc = "< scan time per channel"]
    pub scan_time: wifi_scan_time_t,
}
#[doc = "< the cipher type is none"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_NONE: wifi_cipher_type_t = 0;
#[doc = "< the cipher type is WEP40"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP40: wifi_cipher_type_t = 1;
#[doc = "< the cipher type is WEP104"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_WEP104: wifi_cipher_type_t = 2;
#[doc = "< the cipher type is TKIP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP: wifi_cipher_type_t = 3;
#[doc = "< the cipher type is CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_CCMP: wifi_cipher_type_t = 4;
#[doc = "< the cipher type is TKIP and CCMP"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_TKIP_CCMP: wifi_cipher_type_t = 5;
#[doc = "< the cipher type is unknown"]
pub const wifi_cipher_type_t_WIFI_CIPHER_TYPE_UNKNOWN: wifi_cipher_type_t = 6;
pub type wifi_cipher_type_t = u32;
#[doc = "< WiFi antenna 0"]
pub const wifi_ant_t_WIFI_ANT_ANT0: wifi_ant_t = 0;
#[doc = "< WiFi antenna 1"]
pub const wifi_ant_t_WIFI_ANT_ANT1: wifi_ant_t = 1;
#[doc = "< Invalid WiFi antenna"]
pub const wifi_ant_t_WIFI_ANT_MAX: wifi_ant_t = 2;
#[doc = " @brief WiFi antenna"]
#[doc = ""]
pub type wifi_ant_t = u32;
#[doc = " @brief Description of a WiFi AP"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_record_t {
    #[doc = "< MAC address of AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< SSID of AP"]
    pub ssid: [u8; 33usize],
    #[doc = "< channel of AP"]
    pub primary: u8,
    #[doc = "< secondary channel of AP"]
    pub second: wifi_second_chan_t,
    #[doc = "< signal strength of AP"]
    pub rssi: i8,
    #[doc = "< authmode of AP"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< pairwise cipher of AP"]
    pub pairwise_cipher: wifi_cipher_type_t,
    #[doc = "< group cipher of AP"]
    pub group_cipher: wifi_cipher_type_t,
    #[doc = "< antenna used to receive beacon from AP"]
    pub ant: wifi_ant_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< country information of AP"]
    pub country: wifi_country_t,
}
impl wifi_ap_record_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wps(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        wps: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wps: u32 = unsafe { ::core::mem::transmute(wps) };
            wps as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Do fast scan, scan will end after find SSID match AP"]
pub const wifi_scan_method_t_WIFI_FAST_SCAN: wifi_scan_method_t = 0;
#[doc = "< All channel scan, scan will end after scan all the channel"]
pub const wifi_scan_method_t_WIFI_ALL_CHANNEL_SCAN: wifi_scan_method_t = 1;
pub type wifi_scan_method_t = u32;
#[doc = "< Sort match AP in scan list by RSSI"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SIGNAL: wifi_sort_method_t = 0;
#[doc = "< Sort match AP in scan list by security mode"]
pub const wifi_sort_method_t_WIFI_CONNECT_AP_BY_SECURITY: wifi_sort_method_t = 1;
pub type wifi_sort_method_t = u32;
#[doc = " @brief Structure describing parameters for a WiFi fast scan"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_fast_scan_threshold_t {
    #[doc = "< The minimum rssi to accept in the fast scan mode"]
    pub rssi: i8,
    #[doc = "< The weakest authmode to accept in the fast scan mode"]
    pub authmode: wifi_auth_mode_t,
}
pub type wifi_scan_threshold_t = wifi_fast_scan_threshold_t;
#[doc = "< No power save"]
pub const wifi_ps_type_t_WIFI_PS_NONE: wifi_ps_type_t = 0;
#[doc = "< Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period"]
pub const wifi_ps_type_t_WIFI_PS_MIN_MODEM: wifi_ps_type_t = 1;
#[doc = "< Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval parameter in wifi_sta_config_t"]
pub const wifi_ps_type_t_WIFI_PS_MAX_MODEM: wifi_ps_type_t = 2;
pub type wifi_ps_type_t = u32;
pub const wifi_bandwidth_t_WIFI_BW_HT20: wifi_bandwidth_t = 1;
pub const wifi_bandwidth_t_WIFI_BW_HT40: wifi_bandwidth_t = 2;
pub type wifi_bandwidth_t = u32;
#[doc = " @brief Soft-AP configuration settings for the ESP32"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_ap_config_t {
    #[doc = "< SSID of ESP32 soft-AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< Password of ESP32 soft-AP"]
    pub password: [u8; 64usize],
    #[doc = "< Length of SSID. If softap_config.ssid_len==0, check the SSID until there is a termination character; otherwise, set the SSID length according to softap_config.ssid_len."]
    pub ssid_len: u8,
    #[doc = "< Channel of ESP32 soft-AP"]
    pub channel: u8,
    #[doc = "< Auth mode of ESP32 soft-AP. Do not support AUTH_WEP in soft-AP mode"]
    pub authmode: wifi_auth_mode_t,
    #[doc = "< Broadcast SSID or not, default 0, broadcast the SSID"]
    pub ssid_hidden: u8,
    #[doc = "< Max number of stations allowed to connect in, default 4, max 4"]
    pub max_connection: u8,
    #[doc = "< Beacon interval, 100 ~ 60000 ms, default 100 ms"]
    pub beacon_interval: u16,
}
#[doc = " @brief STA configuration settings for the ESP32"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_config_t {
    #[doc = "< SSID of target AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< password of target AP"]
    pub password: [u8; 64usize],
    #[doc = "< do all channel scan or fast scan"]
    pub scan_method: wifi_scan_method_t,
    #[doc = "< whether set MAC address of target AP or not. Generally, station_config.bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    pub bssid_set: bool,
    #[doc = "< MAC address of target AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< channel of target AP. Set to 1~13 to scan starting from the specified channel before connecting to AP. If the channel of AP is unknown, set it to 0."]
    pub channel: u8,
    #[doc = "< Listen interval for ESP32 station to receive beacon when WIFI_PS_MAX_MODEM is set. Units: AP beacon intervals. Defaults to 3 if set to 0."]
    pub listen_interval: u16,
    #[doc = "< sort the connect AP in the list by rssi or security mode"]
    pub sort_method: wifi_sort_method_t,
    #[doc = "< When scan_method is set, only APs which have an auth mode that is more secure than the selected auth mode and a signal stronger than the minimum RSSI will be used."]
    pub threshold: wifi_scan_threshold_t,
}
#[doc = " @brief Configuration data for ESP32 AP or STA."]
#[doc = ""]
#[doc = " The usage of this union (for ap or sta configuration) is determined by the accompanying"]
#[doc = " interface argument passed to esp_wifi_set_config() or esp_wifi_get_config()"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_config_t {
    #[doc = "< configuration of AP"]
    pub ap: wifi_ap_config_t,
    #[doc = "< configuration of STA"]
    pub sta: wifi_sta_config_t,
    _bindgen_union_align: [u32; 31usize],
}
#[doc = " @brief Description of STA associated with AP"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wifi_sta_info_t {
    #[doc = "< mac address"]
    pub mac: [u8; 6usize],
    #[doc = "< current average rssi of sta connected"]
    pub rssi: i8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl wifi_sta_info_t {
    #[inline]
    pub fn phy_11b(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11b(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11g(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11g(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_11n(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_11n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phy_lr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_phy_lr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        phy_11b: u32,
        phy_11g: u32,
        phy_11n: u32,
        phy_lr: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let phy_11b: u32 = unsafe { ::core::mem::transmute(phy_11b) };
            phy_11b as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let phy_11g: u32 = unsafe { ::core::mem::transmute(phy_11g) };
            phy_11g as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phy_11n: u32 = unsafe { ::core::mem::transmute(phy_11n) };
            phy_11n as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let phy_lr: u32 = unsafe { ::core::mem::transmute(phy_lr) };
            phy_lr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief List of stations associated with the ESP32 Soft-AP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_sta_list_t {
    #[doc = "< station list"]
    pub sta: [wifi_sta_info_t; 10usize],
    #[doc = "< number of stations in the list (other entries are invalid)"]
    pub num: cty::c_int,
}
#[doc = "< all configuration will strore in both memory and flash"]
pub const wifi_storage_t_WIFI_STORAGE_FLASH: wifi_storage_t = 0;
#[doc = "< all configuration will only store in the memory"]
pub const wifi_storage_t_WIFI_STORAGE_RAM: wifi_storage_t = 1;
pub type wifi_storage_t = u32;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_BEACON: wifi_vendor_ie_type_t = 0;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_REQ: wifi_vendor_ie_type_t = 1;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_PROBE_RESP: wifi_vendor_ie_type_t = 2;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_REQ: wifi_vendor_ie_type_t = 3;
pub const wifi_vendor_ie_type_t_WIFI_VND_IE_TYPE_ASSOC_RESP: wifi_vendor_ie_type_t = 4;
#[doc = " @brief     Vendor Information Element type"]
#[doc = ""]
#[doc = " Determines the frame type that the IE will be associated with."]
pub type wifi_vendor_ie_type_t = u32;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_0: wifi_vendor_ie_id_t = 0;
pub const wifi_vendor_ie_id_t_WIFI_VND_IE_ID_1: wifi_vendor_ie_id_t = 1;
#[doc = " @brief     Vendor Information Element index"]
#[doc = ""]
#[doc = " Each IE type can have up to two associated vendor ID elements."]
pub type wifi_vendor_ie_id_t = u32;
#[doc = " @brief Vendor Information Element header"]
#[doc = ""]
#[doc = " The first bytes of the Information Element will match this header. Payload follows."]
#[repr(C)]
#[derive(Debug)]
pub struct vendor_ie_data_t {
    #[doc = "< Should be set to WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    pub element_id: u8,
    #[doc = "< Length of all bytes in the element data following this field. Minimum 4."]
    pub length: u8,
    #[doc = "< Vendor identifier (OUI)."]
    pub vendor_oui: [u8; 3usize],
    #[doc = "< Vendor-specific OUI type."]
    pub vendor_oui_type: u8,
    #[doc = "< Payload. Length is equal to value in 'length' field, minus 4."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = " @brief Received packet radio metadata header, this is the common header at the beginning of all promiscuous mode RX callback buffers"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wifi_pkt_rx_ctrl_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 28usize], u32>,
}
impl wifi_pkt_rx_ctrl_t {
    #[inline]
    pub fn rssi(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rssi(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rate(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rate(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_mode(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sig_mode(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mcs(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_mcs(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn cwb(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cwb(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smoothing(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_smoothing(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_sounding(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_sounding(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aggregation(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aggregation(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fec_coding(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec_coding(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgi(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgi(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noise_floor(&self) -> cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_noise_floor(&mut self, val: cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ampdu_cnt(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ampdu_cnt(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary_channel(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(84usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_secondary_channel(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(84usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn ant(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(191usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ant(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(191usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_len(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(192usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_sig_len(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(192usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_state(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(216usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rx_state(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(216usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rssi: cty::c_int,
        rate: cty::c_uint,
        sig_mode: cty::c_uint,
        mcs: cty::c_uint,
        cwb: cty::c_uint,
        smoothing: cty::c_uint,
        not_sounding: cty::c_uint,
        aggregation: cty::c_uint,
        stbc: cty::c_uint,
        fec_coding: cty::c_uint,
        sgi: cty::c_uint,
        noise_floor: cty::c_int,
        ampdu_cnt: cty::c_uint,
        channel: cty::c_uint,
        secondary_channel: cty::c_uint,
        timestamp: cty::c_uint,
        ant: cty::c_uint,
        sig_len: cty::c_uint,
        rx_state: cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 28usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 28usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rssi: u32 = unsafe { ::core::mem::transmute(rssi) };
            rssi as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let rate: u32 = unsafe { ::core::mem::transmute(rate) };
            rate as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let sig_mode: u32 = unsafe { ::core::mem::transmute(sig_mode) };
            sig_mode as u64
        });
        __bindgen_bitfield_unit.set(32usize, 7u8, {
            let mcs: u32 = unsafe { ::core::mem::transmute(mcs) };
            mcs as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let cwb: u32 = unsafe { ::core::mem::transmute(cwb) };
            cwb as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let smoothing: u32 = unsafe { ::core::mem::transmute(smoothing) };
            smoothing as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let not_sounding: u32 = unsafe { ::core::mem::transmute(not_sounding) };
            not_sounding as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let aggregation: u32 = unsafe { ::core::mem::transmute(aggregation) };
            aggregation as u64
        });
        __bindgen_bitfield_unit.set(60usize, 2u8, {
            let stbc: u32 = unsafe { ::core::mem::transmute(stbc) };
            stbc as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let fec_coding: u32 = unsafe { ::core::mem::transmute(fec_coding) };
            fec_coding as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sgi: u32 = unsafe { ::core::mem::transmute(sgi) };
            sgi as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let noise_floor: u32 = unsafe { ::core::mem::transmute(noise_floor) };
            noise_floor as u64
        });
        __bindgen_bitfield_unit.set(72usize, 8u8, {
            let ampdu_cnt: u32 = unsafe { ::core::mem::transmute(ampdu_cnt) };
            ampdu_cnt as u64
        });
        __bindgen_bitfield_unit.set(80usize, 4u8, {
            let channel: u32 = unsafe { ::core::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(84usize, 4u8, {
            let secondary_channel: u32 = unsafe { ::core::mem::transmute(secondary_channel) };
            secondary_channel as u64
        });
        __bindgen_bitfield_unit.set(96usize, 32u8, {
            let timestamp: u32 = unsafe { ::core::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit.set(191usize, 1u8, {
            let ant: u32 = unsafe { ::core::mem::transmute(ant) };
            ant as u64
        });
        __bindgen_bitfield_unit.set(192usize, 12u8, {
            let sig_len: u32 = unsafe { ::core::mem::transmute(sig_len) };
            sig_len as u64
        });
        __bindgen_bitfield_unit.set(216usize, 8u8, {
            let rx_state: u32 = unsafe { ::core::mem::transmute(rx_state) };
            rx_state as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Payload passed to 'buf' parameter of promiscuous mode RX callback."]
#[repr(C)]
#[derive(Debug)]
pub struct wifi_promiscuous_pkt_t {
    #[doc = "< metadata header"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< Data or management payload. Length of payload is described by rx_ctrl.sig_len. Type of content determined by packet type argument of callback."]
    pub payload: __IncompleteArrayField<u8>,
}
#[doc = "< Management frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MGMT: wifi_promiscuous_pkt_type_t = 0;
#[doc = "< Control frame, indicates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_CTRL: wifi_promiscuous_pkt_type_t = 1;
#[doc = "< Data frame, indiciates 'buf' argument is wifi_promiscuous_pkt_t"]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_DATA: wifi_promiscuous_pkt_type_t = 2;
#[doc = "< Other type, such as MIMO etc. 'buf' argument is wifi_promiscuous_pkt_t but the payload is zero length."]
pub const wifi_promiscuous_pkt_type_t_WIFI_PKT_MISC: wifi_promiscuous_pkt_type_t = 3;
#[doc = " @brief Promiscuous frame type"]
#[doc = ""]
#[doc = " Passed to promiscuous mode RX callback to indicate the type of parameter in the buffer."]
#[doc = ""]
pub type wifi_promiscuous_pkt_type_t = u32;
#[doc = " @brief Mask for filtering different packet types in promiscuous mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_promiscuous_filter_t {
    #[doc = "< OR of one or more filter values WIFI_PROMIS_FILTER_*"]
    pub filter_mask: u32,
}
#[doc = " @brief Channel state information(CSI) configuration type"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_csi_config_t {
    #[doc = "< enable to receive legacy long training field(lltf) data. Default enabled"]
    pub lltf_en: bool,
    #[doc = "< enable to receive HT long training field(htltf) data. Default enabled"]
    pub htltf_en: bool,
    #[doc = "< enable to receive space time block code HT long training field(stbc-htltf2) data. Default enabled"]
    pub stbc_htltf2_en: bool,
    #[doc = "< enable to generate htlft data by averaging lltf and ht_ltf data when receiving HT packet. Otherwise, use ht_ltf data directly. Default enabled"]
    pub ltf_merge_en: bool,
    #[doc = "< enable to turn on channel filter to smooth adjacent sub-carrier. Disable it to keep independence of adjacent sub-carrier. Default enabled"]
    pub channel_filter_en: bool,
    #[doc = "< manually scale the CSI data by left shifting or automatically scale the CSI data. If set true, please set the shift bits. false: automatically. true: manually. Default false"]
    pub manu_scale: bool,
    #[doc = "< manually left shift bits of the scale of the CSI data. The range of the left shift bits is 0~15"]
    pub shift: u8,
}
#[doc = " @brief CSI data type"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_csi_info_t {
    #[doc = "< received packet radio metadata header of the CSI data"]
    pub rx_ctrl: wifi_pkt_rx_ctrl_t,
    #[doc = "< source MAC address of the CSI data"]
    pub mac: [u8; 6usize],
    #[doc = "< first four bytes of the CSI data is invalid or not"]
    pub first_word_invalid: bool,
    #[doc = "< buffer of CSI data"]
    pub buf: *mut i8,
    #[doc = "< length of CSI data"]
    pub len: u16,
}
#[doc = " @brief WiFi GPIO configuration for antenna selection"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_ant_gpio_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl wifi_ant_gpio_t {
    #[inline]
    pub fn gpio_select(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_select(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpio_num(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_gpio_num(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gpio_select: u8,
        gpio_num: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpio_select: u8 = unsafe { ::core::mem::transmute(gpio_select) };
            gpio_select as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let gpio_num: u8 = unsafe { ::core::mem::transmute(gpio_num) };
            gpio_num as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief WiFi GPIOs configuration for antenna selection"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_ant_gpio_config_t {
    #[doc = "< The configurations of GPIOs that connect to external antenna switch"]
    pub gpio_cfg: [wifi_ant_gpio_t; 4usize],
}
#[doc = "< Enable WiFi antenna 0 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT0: wifi_ant_mode_t = 0;
#[doc = "< Enable WiFi antenna 1 only"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_ANT1: wifi_ant_mode_t = 1;
#[doc = "< Enable WiFi antenna 0 and 1, automatically select an antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_AUTO: wifi_ant_mode_t = 2;
#[doc = "< Invalid WiFi enabled antenna"]
pub const wifi_ant_mode_t_WIFI_ANT_MODE_MAX: wifi_ant_mode_t = 3;
#[doc = " @brief WiFi antenna mode"]
#[doc = ""]
pub type wifi_ant_mode_t = u32;
#[doc = " @brief WiFi antenna configuration"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_ant_config_t {
    #[doc = "< WiFi antenna mode for receiving"]
    pub rx_ant_mode: wifi_ant_mode_t,
    #[doc = "< Default antenna mode for receiving, it's ignored if rx_ant_mode is not WIFI_ANT_MODE_AUTO"]
    pub rx_ant_default: wifi_ant_t,
    #[doc = "< WiFi antenna mode for transmission, it can be set to WIFI_ANT_MODE_AUTO only if rx_ant_mode is set to WIFI_ANT_MODE_AUTO"]
    pub tx_ant_mode: wifi_ant_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl wifi_ant_config_t {
    #[inline]
    pub fn enabled_ant0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled_ant1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_ant1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled_ant0: u8,
        enabled_ant1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let enabled_ant0: u8 = unsafe { ::core::mem::transmute(enabled_ant0) };
            enabled_ant0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let enabled_ant1: u8 = unsafe { ::core::mem::transmute(enabled_ant1) };
            enabled_ant1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< 1 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_1M_L: wifi_phy_rate_t = 0;
#[doc = "< 2 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_L: wifi_phy_rate_t = 1;
#[doc = "< 5.5 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_L: wifi_phy_rate_t = 2;
#[doc = "< 11 Mbps with long preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_L: wifi_phy_rate_t = 3;
#[doc = "< 2 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_2M_S: wifi_phy_rate_t = 5;
#[doc = "< 5.5 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_5M_S: wifi_phy_rate_t = 6;
#[doc = "< 11 Mbps with short preamble"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_11M_S: wifi_phy_rate_t = 7;
#[doc = "< 48 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_48M: wifi_phy_rate_t = 8;
#[doc = "< 24 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_24M: wifi_phy_rate_t = 9;
#[doc = "< 12 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_12M: wifi_phy_rate_t = 10;
#[doc = "< 6 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_6M: wifi_phy_rate_t = 11;
#[doc = "< 54 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_54M: wifi_phy_rate_t = 12;
#[doc = "< 36 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_36M: wifi_phy_rate_t = 13;
#[doc = "< 18 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_18M: wifi_phy_rate_t = 14;
#[doc = "< 9 Mbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_9M: wifi_phy_rate_t = 15;
#[doc = "< MCS0 with long GI, 6.5 Mbps for 20MHz, 13.5 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_LGI: wifi_phy_rate_t = 16;
#[doc = "< MCS1 with long GI, 13 Mbps for 20MHz, 27 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_LGI: wifi_phy_rate_t = 17;
#[doc = "< MCS2 with long GI, 19.5 Mbps for 20MHz, 40.5 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_LGI: wifi_phy_rate_t = 18;
#[doc = "< MCS3 with long GI, 26 Mbps for 20MHz, 54 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_LGI: wifi_phy_rate_t = 19;
#[doc = "< MCS4 with long GI, 39 Mbps for 20MHz, 81 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_LGI: wifi_phy_rate_t = 20;
#[doc = "< MCS5 with long GI, 52 Mbps for 20MHz, 108 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_LGI: wifi_phy_rate_t = 21;
#[doc = "< MCS6 with long GI, 58.5 Mbps for 20MHz, 121.5 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_LGI: wifi_phy_rate_t = 22;
#[doc = "< MCS7 with long GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_LGI: wifi_phy_rate_t = 23;
#[doc = "< MCS0 with short GI, 7.2 Mbps for 20MHz, 15 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS0_SGI: wifi_phy_rate_t = 24;
#[doc = "< MCS1 with short GI, 14.4 Mbps for 20MHz, 30 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS1_SGI: wifi_phy_rate_t = 25;
#[doc = "< MCS2 with short GI, 21.7 Mbps for 20MHz, 45 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS2_SGI: wifi_phy_rate_t = 26;
#[doc = "< MCS3 with short GI, 28.9 Mbps for 20MHz, 60 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS3_SGI: wifi_phy_rate_t = 27;
#[doc = "< MCS4 with short GI, 43.3 Mbps for 20MHz, 90 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS4_SGI: wifi_phy_rate_t = 28;
#[doc = "< MCS5 with short GI, 57.8 Mbps for 20MHz, 120 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS5_SGI: wifi_phy_rate_t = 29;
#[doc = "< MCS6 with short GI, 65 Mbps for 20MHz, 135 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS6_SGI: wifi_phy_rate_t = 30;
#[doc = "< MCS7 with short GI, 72.2 Mbps for 20MHz, 150 Mbps for 40MHz"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MCS7_SGI: wifi_phy_rate_t = 31;
#[doc = "< 250 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_250K: wifi_phy_rate_t = 41;
#[doc = "< 500 Kbps"]
pub const wifi_phy_rate_t_WIFI_PHY_RATE_LORA_500K: wifi_phy_rate_t = 42;
pub const wifi_phy_rate_t_WIFI_PHY_RATE_MAX: wifi_phy_rate_t = 43;
#[doc = " @brief WiFi PHY rate encodings"]
#[doc = ""]
pub type wifi_phy_rate_t = u32;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_MD5: esp_crypto_hash_alg_t = 0;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA1: esp_crypto_hash_alg_t = 1;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_MD5: esp_crypto_hash_alg_t = 2;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA1: esp_crypto_hash_alg_t = 3;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_SHA256: esp_crypto_hash_alg_t = 4;
pub const esp_crypto_hash_alg_t_ESP_CRYPTO_HASH_ALG_HMAC_SHA256: esp_crypto_hash_alg_t = 5;
pub type esp_crypto_hash_alg_t = u32;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_NULL: esp_crypto_cipher_alg_t = 0;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_AES: esp_crypto_cipher_alg_t = 1;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_3DES: esp_crypto_cipher_alg_t = 2;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_DES: esp_crypto_cipher_alg_t = 3;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC2: esp_crypto_cipher_alg_t = 4;
pub const esp_crypto_cipher_alg_t_ESP_CRYPTO_CIPHER_ALG_RC4: esp_crypto_cipher_alg_t = 5;
pub type esp_crypto_cipher_alg_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_hash {
    _unused: [u8; 0],
}
pub type esp_crypto_hash_t = crypto_hash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_cipher {
    _unused: [u8; 0],
}
pub type esp_crypto_cipher_t = crypto_cipher;
#[doc = " @brief The crypto callback function used in wpa enterprise hash operation when connect."]
#[doc = "        Initialize a esp_crypto_hash_t structure."]
#[doc = ""]
#[doc = " @param alg  Hash algorithm."]
#[doc = " @param key  Key for keyed hash (e.g., HMAC) or %NULL if not needed."]
#[doc = " @param key_len  Length of the key in bytes"]
#[doc = ""]
pub type esp_crypto_hash_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        alg: esp_crypto_hash_alg_t,
        key: *const cty::c_uchar,
        key_len: cty::c_int,
    ) -> *mut esp_crypto_hash_t,
>;
#[doc = " @brief The crypto callback function used in wpa enterprise hash operation when connect."]
#[doc = "        Add data to hash calculation."]
#[doc = ""]
#[doc = " @param ctz  Context pointer from esp_crypto_hash_init_t function."]
#[doc = " @param data  Data buffer to add."]
#[doc = " @param len  Length of the buffer."]
#[doc = ""]
pub type esp_crypto_hash_update_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut esp_crypto_hash_t, data: *const cty::c_uchar, len: cty::c_int),
>;
#[doc = " @brief The crypto callback function used in wpa enterprise hash operation when connect."]
#[doc = "        Complete hash calculation."]
#[doc = ""]
#[doc = " @param ctz  Context pointer from esp_crypto_hash_init_t function."]
#[doc = " @param hash   Buffer for hash value or %NULL if caller is just freeing the hash"]
#[doc = "               context."]
#[doc = " @param len  Pointer to length of the buffer or %NULL if caller is just freeing the"]
#[doc = "             hash context; on return, this is set to the actual length of the hash value"]
#[doc = "             Returns: 0 on success, -1 if buffer is too small (len set to needed length),"]
#[doc = "             or -2 on other failures (including failed crypto_hash_update() operations)"]
#[doc = ""]
pub type esp_crypto_hash_finish_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut esp_crypto_hash_t,
        hash: *mut cty::c_uchar,
        len: *mut cty::c_int,
    ) -> cty::c_int,
>;
#[doc = " @brief The AES callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Encryption key."]
#[doc = " @param iv  Encryption IV for CBC mode (16 bytes)."]
#[doc = " @param data  Data to encrypt in-place."]
#[doc = " @param data_len  Length of data in bytes (must be divisible by 16)"]
pub type esp_aes_128_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        iv: *const cty::c_uchar,
        data: *mut cty::c_uchar,
        data_len: cty::c_int,
    ) -> cty::c_int,
>;
#[doc = " @brief The AES callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Decryption key."]
#[doc = " @param iv  Decryption IV for CBC mode (16 bytes)."]
#[doc = " @param data  Data to decrypt in-place."]
#[doc = " @param data_len  Length of data in bytes (must be divisible by 16)"]
#[doc = ""]
pub type esp_aes_128_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        iv: *const cty::c_uchar,
        data: *mut cty::c_uchar,
        data_len: cty::c_int,
    ) -> cty::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect."]
#[doc = ""]
#[doc = " @param kek  16-octet Key encryption key (KEK)."]
#[doc = " @param n  Length of the plaintext key in 64-bit units;"]
#[doc = " @param plain  Plaintext key to be wrapped, n * 64 bits"]
#[doc = " @param cipher  Wrapped key, (n + 1) * 64 bits"]
#[doc = ""]
pub type esp_aes_wrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const cty::c_uchar,
        n: cty::c_int,
        plain: *const cty::c_uchar,
        cipher: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
#[doc = " @brief The AES callback function when do STA connect."]
#[doc = ""]
#[doc = " @param kek  16-octet Key decryption key (KEK)."]
#[doc = " @param n  Length of the plaintext key in 64-bit units;"]
#[doc = " @param cipher  Wrapped key to be unwrapped, (n + 1) * 64 bits"]
#[doc = " @param plain  Plaintext key, n * 64 bits"]
#[doc = ""]
pub type esp_aes_unwrap_t = ::core::option::Option<
    unsafe extern "C" fn(
        kek: *const cty::c_uchar,
        n: cty::c_int,
        cipher: *const cty::c_uchar,
        plain: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
#[doc = " @brief The crypto callback function used in wpa enterprise cipher operation when connect."]
#[doc = "        Initialize a esp_crypto_cipher_t structure."]
#[doc = ""]
#[doc = " @param alg  cipher algorithm."]
#[doc = " @param iv  Initialization vector for block ciphers or %NULL for stream ciphers."]
#[doc = " @param key  Cipher key"]
#[doc = " @param key_len  Length of key in bytes"]
#[doc = ""]
pub type esp_crypto_cipher_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        alg: esp_crypto_cipher_alg_t,
        iv: *const cty::c_uchar,
        key: *const cty::c_uchar,
        key_len: cty::c_int,
    ) -> *mut esp_crypto_cipher_t,
>;
#[doc = " @brief The crypto callback function used in wpa enterprise cipher operation when connect."]
#[doc = "        Cipher encrypt."]
#[doc = ""]
#[doc = " @param ctx  Context pointer from esp_crypto_cipher_init_t callback function."]
#[doc = " @param plain  Plaintext to cipher."]
#[doc = " @param crypt  Resulting ciphertext."]
#[doc = " @param len  Length of the plaintext."]
#[doc = ""]
pub type esp_crypto_cipher_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut esp_crypto_cipher_t,
        plain: *const cty::c_uchar,
        crypt: *mut cty::c_uchar,
        len: cty::c_int,
    ) -> cty::c_int,
>;
#[doc = " @brief The crypto callback function used in wpa enterprise cipher operation when connect."]
#[doc = "        Cipher decrypt."]
#[doc = ""]
#[doc = " @param ctx  Context pointer from esp_crypto_cipher_init_t callback function."]
#[doc = " @param crypt  Ciphertext to decrypt."]
#[doc = " @param plain  Resulting plaintext."]
#[doc = " @param len  Length of the cipher text."]
#[doc = ""]
pub type esp_crypto_cipher_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut esp_crypto_cipher_t,
        crypt: *const cty::c_uchar,
        plain: *mut cty::c_uchar,
        len: cty::c_int,
    ) -> cty::c_int,
>;
#[doc = " @brief The crypto callback function used in wpa enterprise cipher operation when connect."]
#[doc = "        Free cipher context."]
#[doc = ""]
#[doc = " @param ctx  Context pointer from esp_crypto_cipher_init_t callback function."]
#[doc = ""]
pub type esp_crypto_cipher_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut esp_crypto_cipher_t)>;
#[doc = " @brief The SHA256 callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Key for HMAC operations."]
#[doc = " @param key_len  Length of the key in bytes."]
#[doc = " @param data  Pointers to the data area."]
#[doc = " @param data_len  Length of the data area."]
#[doc = " @param mac  Buffer for the hash (20 bytes)."]
#[doc = ""]
pub type esp_hmac_sha256_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        key_len: cty::c_int,
        data: *const cty::c_uchar,
        data_len: cty::c_int,
        mac: *mut cty::c_uchar,
    ),
>;
#[doc = " @brief The SHA256 callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param key  Key for HMAC operations."]
#[doc = " @param key_len  Length of the key in bytes."]
#[doc = " @param num_elem  Number of elements in the data vector."]
#[doc = " @param addr  Pointers to the data areas."]
#[doc = " @param len  Lengths of the data blocks."]
#[doc = " @param mac  Buffer for the hash (32 bytes)."]
#[doc = ""]
pub type esp_hmac_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        key_len: cty::c_int,
        num_elem: cty::c_int,
        addr: *mut *const cty::c_uchar,
        len: *const cty::c_int,
        mac: *mut cty::c_uchar,
    ),
>;
#[doc = " @brief The AES callback function when do STA connect."]
#[doc = ""]
#[doc = " @param key  Key for PRF."]
#[doc = " @param key_len  Length of the key in bytes."]
#[doc = " @param label  A unique label for each purpose of the PRF."]
#[doc = " @param data  Extra data to bind into the key."]
#[doc = " @param data_len  Length of the data."]
#[doc = " @param buf  Buffer for the generated pseudo-random key."]
#[doc = " @param buf_len  Number of bytes of key to generate."]
#[doc = ""]
pub type esp_sha256_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        key_len: cty::c_int,
        label: *const cty::c_char,
        data: *const cty::c_uchar,
        data_len: cty::c_int,
        buf: *mut cty::c_uchar,
        buf_len: cty::c_int,
    ),
>;
#[doc = " @brief The SHA256 callback function when do WPS connect."]
#[doc = ""]
#[doc = " @param num_elem  Number of elements in the data vector."]
#[doc = " @param addr  Pointers to the data areas."]
#[doc = " @param len  Lengths of the data blocks."]
#[doc = " @paramac  Buffer for the hash."]
#[doc = ""]
pub type esp_sha256_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: cty::c_int,
        addr: *mut *const cty::c_uchar,
        len: *const cty::c_int,
        mac: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
#[doc = " @brief The bignum calculate callback function used when do connect."]
#[doc = "        In WPS process, it used to calculate public key and private key."]
#[doc = ""]
#[doc = " @param base  Base integer (big endian byte array)."]
#[doc = " @param base_len  Length of base integer in bytes."]
#[doc = " @param power  Power integer (big endian byte array)."]
#[doc = " @param power_len  Length of power integer in bytes."]
#[doc = " @param modulus  Modulus integer (big endian byte array)."]
#[doc = " @param modulus_len  Length of modulus integer in bytes."]
#[doc = " @param result  Buffer for the result."]
#[doc = " @param result_len  Result length (max buffer size on input, real len on output)."]
#[doc = ""]
pub type esp_crypto_mod_exp_t = ::core::option::Option<
    unsafe extern "C" fn(
        base: *const cty::c_uchar,
        base_len: cty::c_int,
        power: *const cty::c_uchar,
        power_len: cty::c_int,
        modulus: *const cty::c_uchar,
        modulus_len: cty::c_int,
        result: *mut cty::c_uchar,
        result_len: *mut cty::c_uint,
    ) -> cty::c_int,
>;
#[doc = " @brief HMAC-MD5 over data buffer (RFC 2104)'"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @data: Pointers to the data area"]
#[doc = " @data_len: Length of the data area"]
#[doc = " @mac: Buffer for the hash (16 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
        data: *const cty::c_uchar,
        data_len: cty::c_uint,
        mac: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
#[doc = " @brief HMAC-MD5 over data vector (RFC 2104)"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash (16 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_hmac_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
        num_elem: cty::c_uint,
        addr: *mut *const cty::c_uchar,
        len: *const cty::c_uint,
        mac: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
#[doc = " @brief HMAC-SHA1 over data buffer (RFC 2104)"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @data: Pointers to the data area"]
#[doc = " @data_len: Length of the data area"]
#[doc = " @mac: Buffer for the hash (20 bytes)"]
#[doc = " Returns: 0 on success, -1 of failure"]
pub type esp_hmac_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
        data: *const cty::c_uchar,
        data_len: cty::c_uint,
        mac: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
#[doc = " @brief HMAC-SHA1 over data vector (RFC 2104)"]
#[doc = ""]
#[doc = " @key: Key for HMAC operations"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash (20 bytes)"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_hmac_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
        num_elem: cty::c_uint,
        addr: *mut *const cty::c_uchar,
        len: *const cty::c_uint,
        mac: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
#[doc = " @brief SHA1-based Pseudo-Random Function (PRF) (IEEE 802.11i, 8.5.1.1)"]
#[doc = ""]
#[doc = " @key: Key for PRF"]
#[doc = " @key_len: Length of the key in bytes"]
#[doc = " @label: A unique label for each purpose of the PRF"]
#[doc = " @data: Extra data to bind into the key"]
#[doc = " @data_len: Length of the data"]
#[doc = " @buf: Buffer for the generated pseudo-random key"]
#[doc = " @buf_len: Number of bytes of key to generate"]
#[doc = " Returns: 0 on success, -1 of failure"]
#[doc = ""]
#[doc = " This function is used to derive new, cryptographically separate keys from a"]
#[doc = " given key (e.g., PMK in IEEE 802.11i)."]
pub type esp_sha1_prf_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
        label: *const cty::c_char,
        data: *const cty::c_uchar,
        data_len: cty::c_uint,
        buf: *mut cty::c_uchar,
        buf_len: cty::c_uint,
    ) -> cty::c_int,
>;
#[doc = " @brief SHA-1 hash for data vector"]
#[doc = ""]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_sha1_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: cty::c_uint,
        addr: *mut *const cty::c_uchar,
        len: *const cty::c_uint,
        mac: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
#[doc = " @brief SHA1-based key derivation function (PBKDF2) for IEEE 802.11i"]
#[doc = ""]
#[doc = " @passphrase: ASCII passphrase"]
#[doc = " @ssid: SSID"]
#[doc = " @ssid_len: SSID length in bytes"]
#[doc = " @iterations: Number of iterations to run"]
#[doc = " @buf: Buffer for the generated key"]
#[doc = " @buflen: Length of the buffer in bytes"]
#[doc = " Returns: 0 on success, -1 of failure"]
#[doc = ""]
#[doc = " This function is used to derive PSK for WPA-PSK. For this protocol,"]
#[doc = " iterations is set to 4096 and buflen to 32. This function is described in"]
#[doc = " IEEE Std 802.11-2004, Clause H.4. The main construction is from PKCS#5 v2.0."]
pub type esp_pbkdf2_sha1_t = ::core::option::Option<
    unsafe extern "C" fn(
        passphrase: *const cty::c_char,
        ssid: *const cty::c_char,
        ssid_len: cty::c_uint,
        iterations: cty::c_int,
        buf: *mut cty::c_uchar,
        buflen: cty::c_uint,
    ) -> cty::c_int,
>;
#[doc = " @brief XOR RC4 stream to given data with skip-stream-start"]
#[doc = ""]
#[doc = " @key: RC4 key"]
#[doc = " @keylen: RC4 key length"]
#[doc = " @skip: number of bytes to skip from the beginning of the RC4 stream"]
#[doc = " @data: data to be XOR'ed with RC4 stream"]
#[doc = " @data_len: buf length"]
#[doc = " Returns: 0 on success, -1 on failure"]
#[doc = ""]
#[doc = " Generate RC4 pseudo random stream for the given key, skip beginning of the"]
#[doc = " stream, and XOR the end result with the data buffer to perform RC4"]
#[doc = " encryption/decryption."]
pub type esp_rc4_skip_t = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const cty::c_uchar,
        keylen: cty::c_uint,
        skip: cty::c_uint,
        data: *mut cty::c_uchar,
        data_len: cty::c_uint,
    ) -> cty::c_int,
>;
#[doc = " @brief MD5 hash for data vector"]
#[doc = ""]
#[doc = " @num_elem: Number of elements in the data vector"]
#[doc = " @addr: Pointers to the data areas"]
#[doc = " @len: Lengths of the data blocks"]
#[doc = " @mac: Buffer for the hash"]
#[doc = " Returns: 0 on success, -1 on failure"]
pub type esp_md5_vector_t = ::core::option::Option<
    unsafe extern "C" fn(
        num_elem: cty::c_uint,
        addr: *mut *const cty::c_uchar,
        len: *const cty::c_uint,
        mac: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
#[doc = " @brief Encrypt one AES block"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
#[doc = " @plain: Plaintext data to be encrypted (16 bytes)"]
#[doc = " @crypt: Buffer for the encrypted data (16 bytes)"]
pub type esp_aes_encrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut cty::c_void,
        plain: *const cty::c_uchar,
        crypt: *mut cty::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES for encryption"]
#[doc = ""]
#[doc = " @key: Encryption key"]
#[doc = " @len: Key length in bytes (usually 16, i.e., 128 bits)"]
#[doc = " Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_encrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(key: *const cty::c_uchar, len: cty::c_uint) -> *mut cty::c_void,
>;
#[doc = " @brief Deinitialize AES encryption"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
pub type esp_aes_encrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut cty::c_void)>;
#[doc = " @brief Decrypt one AES block"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
#[doc = " @crypt: Encrypted data (16 bytes)"]
#[doc = " @plain: Buffer for the decrypted data (16 bytes)"]
pub type esp_aes_decrypt_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut cty::c_void,
        crypt: *const cty::c_uchar,
        plain: *mut cty::c_uchar,
    ),
>;
#[doc = " @brief Initialize AES for decryption"]
#[doc = ""]
#[doc = " @key: Decryption key"]
#[doc = " @len: Key length in bytes (usually 16, i.e., 128 bits)"]
#[doc = " Returns: Pointer to context data or %NULL on failure"]
pub type esp_aes_decrypt_init_t = ::core::option::Option<
    unsafe extern "C" fn(key: *const cty::c_uchar, len: cty::c_uint) -> *mut cty::c_void,
>;
#[doc = " @brief Deinitialize AES decryption"]
#[doc = ""]
#[doc = " @ctx: Context pointer from aes_encrypt_init()"]
pub type esp_aes_decrypt_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut cty::c_void)>;
#[doc = " @brief Initialize TLS library"]
#[doc = ""]
#[doc = " @conf: Configuration data for TLS library"]
#[doc = " Returns: Context data to be used as tls_ctx in calls to other functions,"]
#[doc = " or %NULL on failure."]
#[doc = ""]
#[doc = " Called once during program startup and once for each RSN pre-authentication"]
#[doc = " session. In other words, there can be two concurrent TLS contexts. If global"]
#[doc = " library initialization is needed (i.e., one that is shared between both"]
#[doc = " authentication types), the TLS library wrapper should maintain a reference"]
#[doc = " counter and do global initialization only when moving from 0 to 1 reference."]
pub type esp_tls_init_t = ::core::option::Option<unsafe extern "C" fn() -> *mut cty::c_void>;
#[doc = " @brief Deinitialize TLS library"]
#[doc = ""]
#[doc = " @tls_ctx: TLS context data from tls_init()"]
#[doc = ""]
#[doc = " Called once during program shutdown and once for each RSN pre-authentication"]
#[doc = " session. If global library deinitialization is needed (i.e., one that is"]
#[doc = " shared between both authentication types), the TLS library wrapper should"]
#[doc = " maintain a reference counter and do global deinitialization only when moving"]
#[doc = " from 1 to 0 references."]
pub type esp_tls_deinit_t = ::core::option::Option<unsafe extern "C" fn(tls_ctx: *mut cty::c_void)>;
#[doc = " @brief Add certificate and private key for connect"]
#[doc = ""]
#[doc = " @sm: eap state machine"]
#[doc = ""]
#[doc = " Returns: 0 for success, -1 state machine didn't exist, -2 short of certificate or key"]
pub type esp_eap_peer_blob_init_t =
    ::core::option::Option<unsafe extern "C" fn(sm: *mut cty::c_void) -> cty::c_int>;
#[doc = " @brief delete the certificate and private"]
#[doc = ""]
#[doc = " @sm: eap state machine"]
#[doc = ""]
pub type esp_eap_peer_blob_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(sm: *mut cty::c_void)>;
#[doc = " @brief Initialize the eap state machine"]
#[doc = ""]
#[doc = " @sm: eap state machine"]
#[doc = " @private_key_passwd: the start address of private_key_passwd"]
#[doc = " @private_key_passwd_len: length of private_key_password"]
#[doc = ""]
#[doc = " Returns: 0 is success, -1 state machine didn't exist, -2 short of parameters"]
#[doc = ""]
pub type esp_eap_peer_config_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        sm: *mut cty::c_void,
        private_key_passwd: *mut cty::c_uchar,
        private_key_passwd_len: cty::c_int,
    ) -> cty::c_int,
>;
#[doc = " @brief Deinit the eap state machine"]
#[doc = ""]
#[doc = " @sm: eap state machine"]
#[doc = ""]
pub type esp_eap_peer_config_deinit_t =
    ::core::option::Option<unsafe extern "C" fn(sm: *mut cty::c_void)>;
#[doc = " @brief Register the eap method"]
#[doc = ""]
#[doc = " Note: ESP32 only support PEAP/TTLS/TLS three eap methods now."]
#[doc = ""]
pub type esp_eap_peer_register_methods_t =
    ::core::option::Option<unsafe extern "C" fn() -> cty::c_int>;
#[doc = " @brief remove the eap method"]
#[doc = ""]
#[doc = " Note: ESP32 only support PEAP/TTLS/TLS three eap methods now."]
#[doc = ""]
pub type esp_eap_peer_unregister_methods_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief remove the eap method before build new connect"]
#[doc = ""]
#[doc = " @sm: eap state machine"]
#[doc = " @txt: not used now"]
pub type esp_eap_deinit_prev_method_t =
    ::core::option::Option<unsafe extern "C" fn(sm: *mut cty::c_void, txt: *const cty::c_char)>;
#[doc = " @brief Get EAP method based on type number"]
#[doc = ""]
#[doc = " @vendor: EAP Vendor-Id (0 = IETF)"]
#[doc = " @method: EAP type number"]
#[doc = " Returns: Pointer to EAP method or %NULL if not found"]
pub type esp_eap_peer_get_eap_method_t = ::core::option::Option<
    unsafe extern "C" fn(vendor: cty::c_int, method: cty::c_int) -> *const cty::c_void,
>;
#[doc = " @brief Abort EAP authentication"]
#[doc = ""]
#[doc = " @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()"]
#[doc = ""]
#[doc = " Release system resources that have been allocated for the authentication"]
#[doc = " session without fully deinitializing the EAP state machine."]
pub type esp_eap_sm_abort_t = ::core::option::Option<unsafe extern "C" fn(sm: *mut cty::c_void)>;
#[doc = " @brief Build EAP-NAK for the current network"]
#[doc = ""]
#[doc = " @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()"]
#[doc = " @type: EAP type of the fail reason"]
#[doc = " @id: EAP identifier for the packet"]
#[doc = ""]
#[doc = " This function allocates and builds a nak packet for the"]
#[doc = " current network. The caller is responsible for freeing the returned data."]
pub type esp_eap_sm_build_nak_t = ::core::option::Option<
    unsafe extern "C" fn(
        sm: *mut cty::c_void,
        type_: cty::c_int,
        id: cty::c_uchar,
    ) -> *mut cty::c_void,
>;
#[doc = " @brief Build EAP-Identity/Response for the current network"]
#[doc = ""]
#[doc = " @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()"]
#[doc = " @id: EAP identifier for the packet"]
#[doc = " @encrypted: Whether the packet is for encrypted tunnel (EAP phase 2)"]
#[doc = " Returns: Pointer to the allocated EAP-Identity/Response packet or %NULL on"]
#[doc = " failure"]
#[doc = ""]
#[doc = " This function allocates and builds an EAP-Identity/Response packet for the"]
#[doc = " current network. The caller is responsible for freeing the returned data."]
pub type esp_eap_sm_build_identity_resp_t = ::core::option::Option<
    unsafe extern "C" fn(
        sm: *mut cty::c_void,
        id: cty::c_uchar,
        encrypted: cty::c_int,
    ) -> *mut cty::c_void,
>;
#[doc = " @brief Allocate a buffer for an EAP message"]
#[doc = ""]
#[doc = " @vendor: Vendor-Id (0 = IETF)"]
#[doc = " @type: EAP type"]
#[doc = " @payload_len: Payload length in bytes (data after Type)"]
#[doc = " @code: Message Code (EAP_CODE_*)"]
#[doc = " @identifier: Identifier"]
#[doc = " Returns: Pointer to the allocated message buffer or %NULL on error"]
#[doc = ""]
#[doc = " This function can be used to allocate a buffer for an EAP message and fill"]
#[doc = " in the EAP header. This function is automatically using expanded EAP header"]
#[doc = " if the selected Vendor-Id is not IETF. In other words, most EAP methods do"]
#[doc = " not need to separately select which header type to use when using this"]
#[doc = " function to allocate the message buffers. The returned buffer has room for"]
#[doc = " payload_len bytes and has the EAP header and Type field already filled in."]
pub type esp_eap_msg_alloc_t = ::core::option::Option<
    unsafe extern "C" fn(
        vendor: cty::c_int,
        type_: cty::c_int,
        payload_len: cty::c_uint,
        code: cty::c_uchar,
        identifier: cty::c_uchar,
    ) -> *mut cty::c_void,
>;
#[doc = " @brief get the enrollee mac address"]
#[doc = " @mac_addr: instore the mac address of enrollee"]
#[doc = " @uuid: Universally Unique Identifer of the enrollee"]
#[doc = ""]
pub type esp_uuid_gen_mac_addr_t = ::core::option::Option<
    unsafe extern "C" fn(mac_addr: *const cty::c_uchar, uuid: *mut cty::c_uchar),
>;
#[doc = " @brief free the message after finish DH"]
#[doc = ""]
pub type esp_dh5_free_t = ::core::option::Option<unsafe extern "C" fn(ctx: *mut cty::c_void)>;
#[doc = " @brief Build WPS IE for (Re)Association Request"]
#[doc = ""]
#[doc = " @req_type: Value for Request Type attribute"]
#[doc = " Returns: WPS IE or %NULL on failure"]
#[doc = ""]
#[doc = " The caller is responsible for freeing the buffer."]
pub type esp_wps_build_assoc_req_ie_t =
    ::core::option::Option<unsafe extern "C" fn(req_type: cty::c_int) -> *mut cty::c_void>;
#[doc = " @brief Build WPS IE for (Re)Association Response"]
#[doc = ""]
#[doc = " Returns: WPS IE or %NULL on failure"]
#[doc = ""]
#[doc = " The caller is responsible for freeing the buffer."]
pub type esp_wps_build_assoc_resp_ie_t =
    ::core::option::Option<unsafe extern "C" fn() -> *mut cty::c_void>;
#[doc = " @brief Build WPS IE for Probe Request"]
#[doc = ""]
#[doc = " @pw_id: Password ID (DEV_PW_PUSHBUTTON for active PBC and DEV_PW_DEFAULT for"]
#[doc = " most other use cases)"]
#[doc = " @dev: Device attributes"]
#[doc = " @uuid: Own UUID"]
#[doc = " @req_type: Value for Request Type attribute"]
#[doc = " @num_req_dev_types: Number of requested device types"]
#[doc = " @req_dev_types: Requested device types (8 * num_req_dev_types octets) or"]
#[doc = "\t%NULL if none"]
#[doc = " Returns: WPS IE or %NULL on failure"]
#[doc = ""]
#[doc = " The caller is responsible for freeing the buffer."]
pub type esp_wps_build_probe_req_ie_t = ::core::option::Option<
    unsafe extern "C" fn(
        pw_id: u16,
        dev: *mut cty::c_void,
        uuid: *const cty::c_uchar,
        req_type: cty::c_int,
        num_req_dev_types: cty::c_uint,
        req_dev_types: *const cty::c_uchar,
    ) -> *mut cty::c_void,
>;
#[doc = " @brief build public key for exchange in M1"]
#[doc = ""]
#[doc = ""]
pub type esp_wps_build_public_key_t = ::core::option::Option<
    unsafe extern "C" fn(
        wps: *mut cty::c_void,
        msg: *mut cty::c_void,
        mode: cty::c_int,
    ) -> cty::c_int,
>;
#[doc = " @brief get the wps information in exchange password"]
#[doc = ""]
#[doc = ""]
pub type esp_wps_enrollee_get_msg_t = ::core::option::Option<
    unsafe extern "C" fn(wps: *mut cty::c_void, op_code: *mut cty::c_void) -> *mut cty::c_void,
>;
#[doc = " @brief deal with the wps information in exchange password"]
#[doc = ""]
#[doc = ""]
pub type esp_wps_enrollee_process_msg_t = ::core::option::Option<
    unsafe extern "C" fn(
        wps: *mut cty::c_void,
        op_code: cty::c_int,
        msg: *const cty::c_void,
    ) -> cty::c_int,
>;
#[doc = " @brief Generate a random PIN"]
#[doc = ""]
#[doc = " Returns: Eight digit PIN (i.e., including the checksum digit)"]
pub type esp_wps_generate_pin_t = ::core::option::Option<unsafe extern "C" fn() -> cty::c_uint>;
#[doc = " @brief Check whether WPS IE indicates active PIN"]
#[doc = ""]
#[doc = " @msg: WPS IE contents from Beacon or Probe Response frame"]
#[doc = " Returns: 1 if PIN Registrar is active, 0 if not"]
pub type esp_wps_is_selected_pin_registrar_t = ::core::option::Option<
    unsafe extern "C" fn(msg: *const cty::c_void, bssid: *mut cty::c_uchar) -> cty::c_int,
>;
#[doc = " @brief Check whether WPS IE indicates active PBC"]
#[doc = ""]
#[doc = " @msg: WPS IE contents from Beacon or Probe Response frame"]
#[doc = " Returns: 1 if PBC Registrar is active, 0 if not"]
pub type esp_wps_is_selected_pbc_registrar_t = ::core::option::Option<
    unsafe extern "C" fn(msg: *const cty::c_void, bssid: *mut cty::c_uchar) -> cty::c_int,
>;
#[doc = " @brief The crypto callback function structure used when do station security connect."]
#[doc = "        The structure can be set as software crypto or the crypto optimized by ESP32"]
#[doc = "        hardware."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpa_crypto_funcs_t {
    pub size: u32,
    pub version: u32,
    #[doc = "< station connect function used when send EAPOL frame"]
    pub aes_wrap: esp_aes_wrap_t,
    #[doc = "< station connect function used when decrypt key data"]
    pub aes_unwrap: esp_aes_unwrap_t,
    #[doc = "< station connect function used when check MIC"]
    pub hmac_sha256_vector: esp_hmac_sha256_vector_t,
    #[doc = "< station connect function used when check MIC"]
    pub sha256_prf: esp_sha256_prf_t,
    pub hmac_md5: esp_hmac_md5_t,
    pub hamc_md5_vector: esp_hmac_md5_vector_t,
    pub hmac_sha1: esp_hmac_sha1_t,
    pub hmac_sha1_vector: esp_hmac_sha1_vector_t,
    pub sha1_prf: esp_sha1_prf_t,
    pub sha1_vector: esp_sha1_vector_t,
    pub pbkdf2_sha1: esp_pbkdf2_sha1_t,
    pub rc4_skip: esp_rc4_skip_t,
    pub md5_vector: esp_md5_vector_t,
    pub aes_encrypt: esp_aes_encrypt_t,
    pub aes_encrypt_init: esp_aes_encrypt_init_t,
    pub aes_encrypt_deinit: esp_aes_encrypt_deinit_t,
    pub aes_decrypt: esp_aes_decrypt_t,
    pub aes_decrypt_init: esp_aes_decrypt_init_t,
    pub aes_decrypt_deinit: esp_aes_decrypt_deinit_t,
}
#[doc = " @brief The crypto callback function structure used when do WPS process. The"]
#[doc = "        structure can be set as software crypto or the crypto optimized by ESP32"]
#[doc = "        hardware."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wps_crypto_funcs_t {
    pub size: u32,
    pub version: u32,
    #[doc = "< function used to process message when do WPS"]
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    #[doc = "< function used to process message when do WPS"]
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
    #[doc = "< function used to calculate public key and private key"]
    pub crypto_mod_exp: esp_crypto_mod_exp_t,
    #[doc = "< function used to get attribute"]
    pub hmac_sha256: esp_hmac_sha256_t,
    #[doc = "< function used to process message when do WPS"]
    pub hmac_sha256_vector: esp_hmac_sha256_vector_t,
    #[doc = "< function used to process message when do WPS"]
    pub sha256_vector: esp_sha256_vector_t,
    pub uuid_gen_mac_addr: esp_uuid_gen_mac_addr_t,
    pub dh5_free: esp_dh5_free_t,
    pub wps_build_assoc_req_ie: esp_wps_build_assoc_req_ie_t,
    pub wps_build_assoc_resp_ie: esp_wps_build_assoc_resp_ie_t,
    pub wps_build_probe_req_ie: esp_wps_build_probe_req_ie_t,
    pub wps_build_public_key: esp_wps_build_public_key_t,
    pub wps_enrollee_get_msg: esp_wps_enrollee_get_msg_t,
    pub wps_enrollee_process_msg: esp_wps_enrollee_process_msg_t,
    pub wps_generate_pin: esp_wps_generate_pin_t,
    pub wps_is_selected_pin_registrar: esp_wps_is_selected_pin_registrar_t,
    pub wps_is_selected_pbc_registrar: esp_wps_is_selected_pbc_registrar_t,
    pub eap_msg_alloc: esp_eap_msg_alloc_t,
}
#[doc = " @brief The crypto callback function structure used when do WPA enterprise connect."]
#[doc = "        The structure can be set as software crypto or the crypto optimized by ESP32"]
#[doc = "        hardware."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpa2_crypto_funcs_t {
    pub size: u32,
    pub version: u32,
    #[doc = "< function used to initialize a crypto_hash structure when use TLSV1"]
    pub crypto_hash_init: esp_crypto_hash_init_t,
    #[doc = "< function used to calculate hash data when use TLSV1"]
    pub crypto_hash_update: esp_crypto_hash_update_t,
    #[doc = "< function used to finish the hash calculate when use TLSV1"]
    pub crypto_hash_finish: esp_crypto_hash_finish_t,
    #[doc = "< function used to initialize a crypt_cipher structure when use TLSV1"]
    pub crypto_cipher_init: esp_crypto_cipher_init_t,
    #[doc = "< function used to encrypt cipher when use TLSV1"]
    pub crypto_cipher_encrypt: esp_crypto_cipher_encrypt_t,
    #[doc = "< function used to decrypt cipher when use TLSV1"]
    pub crypto_cipher_decrypt: esp_crypto_cipher_decrypt_t,
    #[doc = "< function used to free context when use TLSV1"]
    pub crypto_cipher_deinit: esp_crypto_cipher_deinit_t,
    #[doc = "< function used to do key exchange when use TLSV1"]
    pub crypto_mod_exp: esp_crypto_mod_exp_t,
    #[doc = "< function used to do X.509v3 certificate parsing and processing"]
    pub sha256_vector: esp_sha256_vector_t,
    pub tls_init: esp_tls_init_t,
    pub tls_deinit: esp_tls_deinit_t,
    pub eap_peer_blob_init: esp_eap_peer_blob_init_t,
    pub eap_peer_blob_deinit: esp_eap_peer_blob_deinit_t,
    pub eap_peer_config_init: esp_eap_peer_config_init_t,
    pub eap_peer_config_deinit: esp_eap_peer_config_deinit_t,
    pub eap_peer_register_methods: esp_eap_peer_register_methods_t,
    pub eap_peer_unregister_methods: esp_eap_peer_unregister_methods_t,
    pub eap_deinit_prev_method: esp_eap_deinit_prev_method_t,
    pub eap_peer_get_eap_method: esp_eap_peer_get_eap_method_t,
    pub eap_sm_abort: esp_eap_sm_abort_t,
    pub eap_sm_build_nak: esp_eap_sm_build_nak_t,
    pub eap_sm_build_identity_resp: esp_eap_sm_build_identity_resp_t,
    pub eap_msg_alloc: esp_eap_msg_alloc_t,
}
#[doc = " @brief The crypto callback function structure used in mesh vendor IE encryption. The"]
#[doc = "        structure can be set as software crypto or the crypto optimized by ESP32"]
#[doc = "        hardware."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mesh_crypto_funcs_t {
    #[doc = "< function used in mesh vendor IE encryption"]
    pub aes_128_encrypt: esp_aes_128_encrypt_t,
    #[doc = "< function used in mesh vendor IE decryption"]
    pub aes_128_decrypt: esp_aes_128_decrypt_t,
}
pub type SemaphoreHandle_t = QueueHandle_t;
pub type esp_event_base_t = *const cty::c_char;
pub type esp_event_loop_handle_t = *mut cty::c_void;
pub type esp_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        event_handler_arg: *mut cty::c_void,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut cty::c_void,
    ),
>;
extern "C" {
    pub static mut environ: *mut *mut cty::c_char;
}
extern "C" {
    pub fn _exit(__status: cty::c_int);
}
extern "C" {
    pub fn access(__path: *const cty::c_char, __amode: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn alarm(__secs: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn chdir(__path: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn chmod(__path: *const cty::c_char, __mode: mode_t) -> cty::c_int;
}
extern "C" {
    pub fn chown(__path: *const cty::c_char, __owner: uid_t, __group: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn close(__fildes: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn dup(__fildes: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn dup2(__fildes: cty::c_int, __fildes2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn execl(__path: *const cty::c_char, arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn execle(__path: *const cty::c_char, arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn execlp(__file: *const cty::c_char, arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn execv(__path: *const cty::c_char, __argv: *const *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn execve(
        __path: *const cty::c_char,
        __argv: *const *mut cty::c_char,
        __envp: *const *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn execvp(__file: *const cty::c_char, __argv: *const *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn faccessat(
        __dirfd: cty::c_int,
        __path: *const cty::c_char,
        __mode: cty::c_int,
        __flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fchmod(__fildes: cty::c_int, __mode: mode_t) -> cty::c_int;
}
extern "C" {
    pub fn fchown(__fildes: cty::c_int, __owner: uid_t, __group: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn fchownat(
        __dirfd: cty::c_int,
        __path: *const cty::c_char,
        __owner: uid_t,
        __group: gid_t,
        __flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(__fd: cty::c_int, __name: cty::c_int) -> cty::c_long;
}
extern "C" {
    pub fn fsync(__fd: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fdatasync(__fd: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut cty::c_char, __size: usize) -> *mut cty::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(__gidsetsize: cty::c_int, __grouplist: *mut gid_t) -> cty::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut cty::c_char;
}
extern "C" {
    pub fn getpass(__prompt: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn getpagesize() -> cty::c_int;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(__fildes: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lchown(__path: *const cty::c_char, __owner: uid_t, __group: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn link(__path1: *const cty::c_char, __path2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn linkat(
        __dirfd1: cty::c_int,
        __path1: *const cty::c_char,
        __dirfd2: cty::c_int,
        __path2: *const cty::c_char,
        __flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn nice(__nice_value: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lseek(__fildes: cty::c_int, __offset: off_t, __whence: cty::c_int) -> off_t;
}
extern "C" {
    pub fn pathconf(__path: *const cty::c_char, __name: cty::c_int) -> cty::c_long;
}
extern "C" {
    pub fn pause() -> cty::c_int;
}
extern "C" {
    pub fn pipe(__fildes: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pread(
        __fd: cty::c_int,
        __buf: *mut cty::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: cty::c_int,
        __buf: *const cty::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    pub fn read(__fd: cty::c_int, __buf: *mut cty::c_void, __nbyte: usize) -> cty::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn sbrk(__incr: isize) -> *mut cty::c_void;
}
extern "C" {
    pub fn setgid(__gid: gid_t) -> cty::c_int;
}
extern "C" {
    pub fn sethostname(arg1: *const cty::c_char, arg2: usize) -> cty::c_int;
}
extern "C" {
    pub fn setpgid(__pid: pid_t, __pgid: pid_t) -> cty::c_int;
}
extern "C" {
    pub fn setpgrp() -> cty::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(__uid: uid_t) -> cty::c_int;
}
extern "C" {
    pub fn sleep(__seconds: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn swab(arg1: *const cty::c_void, arg2: *mut cty::c_void, arg3: isize);
}
extern "C" {
    pub fn sysconf(__name: cty::c_int) -> cty::c_long;
}
extern "C" {
    pub fn tcgetpgrp(__fildes: cty::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fildes: cty::c_int, __pgrp_id: pid_t) -> cty::c_int;
}
extern "C" {
    pub fn ttyname(__fildes: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn unlink(__path: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn usleep(__useconds: useconds_t) -> cty::c_int;
}
extern "C" {
    pub fn vhangup() -> cty::c_int;
}
extern "C" {
    pub fn write(__fd: cty::c_int, __buf: *const cty::c_void, __nbyte: usize) -> cty::c_int;
}
extern "C" {
    pub static mut optarg: *mut cty::c_char;
}
extern "C" {
    pub static mut optind: cty::c_int;
}
extern "C" {
    pub static mut opterr: cty::c_int;
}
extern "C" {
    pub static mut optopt: cty::c_int;
}
extern "C" {
    pub fn getopt(
        arg1: cty::c_int,
        arg2: *const *mut cty::c_char,
        arg3: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub static mut optreset: cty::c_int;
}
extern "C" {
    pub fn vfork() -> cty::c_int;
}
extern "C" {
    pub fn readlink(__path: *const cty::c_char, __buf: *mut cty::c_char, __buflen: usize) -> isize;
}
extern "C" {
    pub fn readlinkat(
        __dirfd1: cty::c_int,
        __path: *const cty::c_char,
        __buf: *mut cty::c_char,
        __buflen: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlink(__name1: *const cty::c_char, __name2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const cty::c_char,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn unlinkat(arg1: cty::c_int, arg2: *const cty::c_char, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn truncate(arg1: *const cty::c_char, __length: off_t) -> cty::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut cty::c_char, __len: usize) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: cty::c_int,
    pub tz_dsttime: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> cty::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> cty::c_int;
}
extern "C" {
    pub fn utimes(__path: *const cty::c_char, __tvp: *const timeval) -> cty::c_int;
}
extern "C" {
    pub fn getitimer(__which: cty::c_int, __value: *mut itimerval) -> cty::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: cty::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: cty::c_short,
    pub l_whence: cty::c_short,
    pub l_start: cty::c_long,
    pub l_len: cty::c_long,
    pub l_pid: cty::c_short,
    pub l_xxx: cty::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eflock {
    pub l_type: cty::c_short,
    pub l_whence: cty::c_short,
    pub l_start: cty::c_long,
    pub l_len: cty::c_long,
    pub l_pid: cty::c_short,
    pub l_xxx: cty::c_short,
    pub l_rpid: cty::c_long,
    pub l_rsys: cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_size: off_t,
    pub st_atime: time_t,
    pub st_spare1: cty::c_long,
    pub st_mtime: time_t,
    pub st_spare2: cty::c_long,
    pub st_ctime: time_t,
    pub st_spare3: cty::c_long,
    pub st_blksize: cty::c_long,
    pub st_blocks: cty::c_long,
    pub st_spare4: [cty::c_long; 2usize],
}
extern "C" {
    pub fn fstat(__fd: cty::c_int, __sbuf: *mut stat) -> cty::c_int;
}
extern "C" {
    pub fn mkdir(_path: *const cty::c_char, __mode: mode_t) -> cty::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const cty::c_char, __mode: mode_t) -> cty::c_int;
}
extern "C" {
    pub fn stat(__path: *const cty::c_char, __sbuf: *mut stat) -> cty::c_int;
}
extern "C" {
    pub fn umask(__mask: mode_t) -> mode_t;
}
extern "C" {
    pub fn fchmodat(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: mode_t,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fstatat(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: *mut stat,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mkdirat(arg1: cty::c_int, arg2: *const cty::c_char, arg3: mode_t) -> cty::c_int;
}
extern "C" {
    pub fn mkfifoat(arg1: cty::c_int, arg2: *const cty::c_char, arg3: mode_t) -> cty::c_int;
}
extern "C" {
    pub fn mknodat(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: mode_t,
        arg4: dev_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn utimensat(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: *const timespec,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn futimens(arg1: cty::c_int, arg2: *const timespec) -> cty::c_int;
}
extern "C" {
    pub fn open(arg1: *const cty::c_char, arg2: cty::c_int, ...) -> cty::c_int;
}
extern "C" {
    pub fn openat(arg1: cty::c_int, arg2: *const cty::c_char, arg3: cty::c_int, ...) -> cty::c_int;
}
extern "C" {
    pub fn creat(arg1: *const cty::c_char, arg2: mode_t) -> cty::c_int;
}
extern "C" {
    pub fn fcntl(arg1: cty::c_int, arg2: cty::c_int, ...) -> cty::c_int;
}
extern "C" {
    pub fn flock(arg1: cty::c_int, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ioctl(fd: cty::c_int, request: cty::c_int, ...) -> cty::c_int;
}
extern "C" {
    pub fn select(
        nfds: cty::c_int,
        readfds: *mut _types_fd_set,
        writefds: *mut _types_fd_set,
        errorfds: *mut _types_fd_set,
        timeout: *mut timeval,
    ) -> cty::c_int;
}
extern "C" {
    pub fn dhcp_ip_addr_restore(netif: *mut cty::c_void) -> bool;
}
extern "C" {
    pub fn dhcp_ip_addr_store(netif: *mut cty::c_void);
}
extern "C" {
    pub fn dhcp_ip_addr_erase(netif: *mut cty::c_void);
}
pub type error_t = cty::c_int;
extern "C" {
    pub fn __errno() -> *mut cty::c_int;
}
extern "C" {
    pub static mut _sys_errlist: [*const cty::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: cty::c_int;
}
extern "C" {
    pub fn esp_vfs_lwip_sockets_register();
}
pub type sys_sem_t = SemaphoreHandle_t;
pub type sys_mutex_t = SemaphoreHandle_t;
pub type sys_thread_t = TaskHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_mbox_s {
    pub os_mbox: QueueHandle_t,
    pub owner: *mut cty::c_void,
}
pub type sys_mbox_t = *mut sys_mbox_s;
extern "C" {
    pub fn sys_delay_ms(ms: u32);
}
extern "C" {
    pub fn sys_thread_sem_init() -> *mut sys_sem_t;
}
extern "C" {
    pub fn sys_thread_sem_deinit();
}
extern "C" {
    pub fn sys_thread_sem_get() -> *mut sys_sem_t;
}
pub type u8_t = u8;
pub type s8_t = i8;
pub type u16_t = u16;
pub type s16_t = i16;
pub type u32_t = u32;
pub type s32_t = i32;
pub type mem_ptr_t = cty::c_ulong;
pub type sys_prot_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const cty::c_char,
        arg2: *mut *mut cty::c_char,
        arg3: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const cty::c_char,
        arg2: *mut *mut cty::c_char,
        arg3: cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(arg1: *const wchar_t, arg2: *mut *mut wchar_t, arg3: cty::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(arg1: *const wchar_t, arg2: *mut *mut wchar_t, arg3: cty::c_int) -> uintmax_t;
}
extern "C" {
    pub fn lwip_htons(x: u16_t) -> u16_t;
}
extern "C" {
    pub fn lwip_htonl(x: u32_t) -> u32_t;
}
extern "C" {
    pub fn lwip_itoa(result: *mut cty::c_char, bufsize: usize, number: cty::c_int);
}
extern "C" {
    pub fn lwip_strnicmp(
        str1: *const cty::c_char,
        str2: *const cty::c_char,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_stricmp(str1: *const cty::c_char, str2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn lwip_strnstr(
        buffer: *const cty::c_char,
        token: *const cty::c_char,
        n: usize,
    ) -> *mut cty::c_char;
}
#[doc = " This is the aligned version of ip4_addr_t,"]
#[doc = "used as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
#[doc = " ip4_addr_t uses a struct for convenience only, so that the same defines can"]
#[doc = " operate both on ip4_addr_t as well as on ip4_addr_p_t."]
pub type ip4_addr_t = ip4_addr;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ip4_addr2 {
    pub addrw: [u16_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ip4_addr_isbroadcast_u32(addr: u32_t, netif: *const netif) -> u8_t;
}
extern "C" {
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
}
extern "C" {
    pub fn ipaddr_addr(cp: *const cty::c_char) -> u32_t;
}
extern "C" {
    pub fn ip4addr_aton(cp: *const cty::c_char, addr: *mut ip4_addr_t) -> cty::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip4addr_ntoa(addr: *const ip4_addr_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn ip4addr_ntoa_r(
        addr: *const ip4_addr_t,
        buf: *mut cty::c_char,
        buflen: cty::c_int,
    ) -> *mut cty::c_char;
}
#[doc = " This is the aligned version of ip6_addr_t,"]
#[doc = "used as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_addr {
    pub addr: [u32_t; 4usize],
}
#[doc = " IPv6 address"]
pub type ip6_addr_t = ip6_addr;
extern "C" {
    pub fn ip6addr_aton(cp: *const cty::c_char, addr: *mut ip6_addr_t) -> cty::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip6addr_ntoa(addr: *const ip6_addr_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn ip6addr_ntoa_r(
        addr: *const ip6_addr_t,
        buf: *mut cty::c_char,
        buflen: cty::c_int,
    ) -> *mut cty::c_char;
}
#[doc = " IPv4"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V4: lwip_ip_addr_type = 0;
#[doc = " IPv6"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V6: lwip_ip_addr_type = 6;
#[doc = " IPv4+IPv6 (\"dual-stack\")"]
pub const lwip_ip_addr_type_IPADDR_TYPE_ANY: lwip_ip_addr_type = 46;
#[doc = " @ingroup ipaddr"]
#[doc = " IP address types for use in ip_addr_t.type member."]
#[doc = " @see tcp_new_ip_type(), udp_new_ip_type(), raw_new_ip_type()."]
pub type lwip_ip_addr_type = u32;
#[doc = " @ingroup ipaddr"]
#[doc = " A union struct for both IP version's addresses."]
#[doc = " ATTENTION: watch out for its size when adding IPv6 address scope!"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_addr {
    pub u_addr: ip_addr__bindgen_ty_1,
    #[doc = " @ref lwip_ip_addr_type"]
    pub type_: u8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_addr__bindgen_ty_1 {
    pub ip6: ip6_addr_t,
    pub ip4: ip4_addr_t,
    _bindgen_union_align: [u32; 4usize],
}
pub type ip_addr_t = ip_addr;
extern "C" {
    pub static ip_addr_any_type: ip_addr_t;
}
extern "C" {
    pub fn ipaddr_aton(cp: *const cty::c_char, addr: *mut ip_addr_t) -> cty::c_int;
}
extern "C" {
    pub static ip_addr_any: ip_addr_t;
}
extern "C" {
    pub static ip_addr_broadcast: ip_addr_t;
}
extern "C" {
    pub static ip6_addr_any: ip_addr_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_state {
    pub state: s16_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dhcps_msg {
    pub op: u8_t,
    pub htype: u8_t,
    pub hlen: u8_t,
    pub hops: u8_t,
    pub xid: [u8_t; 4usize],
    pub secs: u16_t,
    pub flags: u16_t,
    pub ciaddr: [u8_t; 4usize],
    pub yiaddr: [u8_t; 4usize],
    pub siaddr: [u8_t; 4usize],
    pub giaddr: [u8_t; 4usize],
    pub chaddr: [u8_t; 16usize],
    pub sname: [u8_t; 64usize],
    pub file: [u8_t; 128usize],
    pub options: [u8_t; 312usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_lease_t {
    pub enable: bool,
    pub start_ip: ip4_addr_t,
    pub end_ip: ip4_addr_t,
}
pub const dhcps_offer_option_OFFER_START: dhcps_offer_option = 0;
pub const dhcps_offer_option_OFFER_ROUTER: dhcps_offer_option = 1;
pub const dhcps_offer_option_OFFER_DNS: dhcps_offer_option = 2;
pub const dhcps_offer_option_OFFER_END: dhcps_offer_option = 3;
pub type dhcps_offer_option = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_pool {
    pub ip: ip4_addr_t,
    pub mac: [u8_t; 6usize],
    pub lease_timer: u32_t,
}
pub type dhcps_time_t = u32_t;
pub type dhcps_offer_t = u8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhcps_options_t {
    pub dhcps_offer: dhcps_offer_t,
    pub dhcps_dns: dhcps_offer_t,
    pub dhcps_time: dhcps_time_t,
    pub dhcps_poll: dhcps_lease_t,
}
pub type dhcps_cb_t = ::core::option::Option<unsafe extern "C" fn(client_ip: *mut u8_t)>;
extern "C" {
    pub fn dhcps_start(netif: *mut netif, ip: ip4_addr_t);
}
extern "C" {
    pub fn dhcps_stop(netif: *mut netif);
}
extern "C" {
    pub fn dhcps_option_info(op_id: u8_t, opt_len: u32_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn dhcps_set_option_info(op_id: u8_t, opt_info: *mut cty::c_void, opt_len: u32_t);
}
extern "C" {
    pub fn dhcp_search_ip_on_mac(mac: *mut u8_t, ip: *mut ip4_addr_t) -> bool;
}
extern "C" {
    pub fn dhcps_dns_setserver(dnsserver: *const ip_addr_t);
}
extern "C" {
    pub fn dhcps_dns_getserver() -> ip4_addr_t;
}
extern "C" {
    pub fn dhcps_set_new_lease_cb(cb: dhcps_cb_t);
}
pub type tcpip_adapter_dhcps_lease_t = dhcps_lease_t;
#[doc = " @brief IPV4 IP address information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_ip_info_t {
    #[doc = "< Interface IPV4 address"]
    pub ip: ip4_addr_t,
    #[doc = "< Interface IPV4 netmask"]
    pub netmask: ip4_addr_t,
    #[doc = "< Interface IPV4 gateway address"]
    pub gw: ip4_addr_t,
}
#[doc = " @brief IPV6 IP address information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_ip6_info_t {
    #[doc = "< Interface IPV6 address"]
    pub ip: ip6_addr_t,
}
#[doc = " @brief IP address info of station connected to WLAN AP"]
#[doc = ""]
#[doc = " @note See also wifi_sta_info_t (MAC layer information only)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_sta_info_t {
    #[doc = "< Station MAC address"]
    pub mac: [u8; 6usize],
    #[doc = "< Station assigned IP address"]
    pub ip: ip4_addr_t,
}
#[doc = " @brief WLAN AP: Connected stations list"]
#[doc = ""]
#[doc = " Used to retrieve IP address information about connected stations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_adapter_sta_list_t {
    #[doc = "< Connected stations"]
    pub sta: [tcpip_adapter_sta_info_t; 10usize],
    #[doc = "< Number of connected stations"]
    pub num: cty::c_int,
}
#[doc = "< Wi-Fi STA (station) interface"]
pub const tcpip_adapter_if_t_TCPIP_ADAPTER_IF_STA: tcpip_adapter_if_t = 0;
#[doc = "< Wi-Fi soft-AP interface"]
pub const tcpip_adapter_if_t_TCPIP_ADAPTER_IF_AP: tcpip_adapter_if_t = 1;
#[doc = "< Ethernet interface"]
pub const tcpip_adapter_if_t_TCPIP_ADAPTER_IF_ETH: tcpip_adapter_if_t = 2;
pub const tcpip_adapter_if_t_TCPIP_ADAPTER_IF_MAX: tcpip_adapter_if_t = 3;
pub type tcpip_adapter_if_t = u32;
#[doc = "< DNS main server address"]
pub const tcpip_adapter_dns_type_t_TCPIP_ADAPTER_DNS_MAIN: tcpip_adapter_dns_type_t = 0;
#[doc = "< DNS backup server address (Wi-Fi STA and Ethernet only)"]
pub const tcpip_adapter_dns_type_t_TCPIP_ADAPTER_DNS_BACKUP: tcpip_adapter_dns_type_t = 1;
#[doc = "< DNS fallback server address (Wi-Fi STA and Ethernet only)"]
pub const tcpip_adapter_dns_type_t_TCPIP_ADAPTER_DNS_FALLBACK: tcpip_adapter_dns_type_t = 2;
pub const tcpip_adapter_dns_type_t_TCPIP_ADAPTER_DNS_MAX: tcpip_adapter_dns_type_t = 3;
#[doc = " @brief Type of DNS server"]
pub type tcpip_adapter_dns_type_t = u32;
#[doc = " @brief DNS server info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcpip_adapter_dns_info_t {
    #[doc = "< IPV4 address of DNS server"]
    pub ip: ip_addr_t,
}
#[doc = "< DHCP client/server is in initial state (not yet started)"]
pub const tcpip_adapter_dhcp_status_t_TCPIP_ADAPTER_DHCP_INIT: tcpip_adapter_dhcp_status_t = 0;
#[doc = "< DHCP client/server has been started"]
pub const tcpip_adapter_dhcp_status_t_TCPIP_ADAPTER_DHCP_STARTED: tcpip_adapter_dhcp_status_t = 1;
#[doc = "< DHCP client/server has been stopped"]
pub const tcpip_adapter_dhcp_status_t_TCPIP_ADAPTER_DHCP_STOPPED: tcpip_adapter_dhcp_status_t = 2;
pub const tcpip_adapter_dhcp_status_t_TCPIP_ADAPTER_DHCP_STATUS_MAX: tcpip_adapter_dhcp_status_t =
    3;
#[doc = " @brief Status of DHCP client or DHCP server"]
pub type tcpip_adapter_dhcp_status_t = u32;
pub const tcpip_adapter_dhcp_option_mode_t_TCPIP_ADAPTER_OP_START:
    tcpip_adapter_dhcp_option_mode_t = 0;
#[doc = "< Set option"]
pub const tcpip_adapter_dhcp_option_mode_t_TCPIP_ADAPTER_OP_SET: tcpip_adapter_dhcp_option_mode_t =
    1;
#[doc = "< Get option"]
pub const tcpip_adapter_dhcp_option_mode_t_TCPIP_ADAPTER_OP_GET: tcpip_adapter_dhcp_option_mode_t =
    2;
pub const tcpip_adapter_dhcp_option_mode_t_TCPIP_ADAPTER_OP_MAX: tcpip_adapter_dhcp_option_mode_t =
    3;
#[doc = " @brief Mode for DHCP client or DHCP server option functions"]
pub type tcpip_adapter_dhcp_option_mode_t = u32;
pub use self::tcpip_adapter_dhcp_option_mode_t as tcpip_adapter_option_mode_t;
#[doc = "< Domain name server"]
pub const tcpip_adapter_dhcp_option_id_t_TCPIP_ADAPTER_DOMAIN_NAME_SERVER:
    tcpip_adapter_dhcp_option_id_t = 6;
#[doc = "< Solicitation router address"]
pub const tcpip_adapter_dhcp_option_id_t_TCPIP_ADAPTER_ROUTER_SOLICITATION_ADDRESS:
    tcpip_adapter_dhcp_option_id_t = 32;
#[doc = "< Request specific IP address"]
pub const tcpip_adapter_dhcp_option_id_t_TCPIP_ADAPTER_REQUESTED_IP_ADDRESS:
    tcpip_adapter_dhcp_option_id_t = 50;
#[doc = "< Request IP address lease time"]
pub const tcpip_adapter_dhcp_option_id_t_TCPIP_ADAPTER_IP_ADDRESS_LEASE_TIME:
    tcpip_adapter_dhcp_option_id_t = 51;
#[doc = "< Request IP address retry counter"]
pub const tcpip_adapter_dhcp_option_id_t_TCPIP_ADAPTER_IP_REQUEST_RETRY_TIME:
    tcpip_adapter_dhcp_option_id_t = 52;
#[doc = " @brief Supported options for DHCP client or DHCP server"]
pub type tcpip_adapter_dhcp_option_id_t = u32;
pub use self::tcpip_adapter_dhcp_option_id_t as tcpip_adapter_option_id_t;
extern "C" {
    #[doc = " @brief  Initialize the underlying TCP/IP stack"]
    #[doc = ""]
    #[doc = " @note This function should be called exactly once from application code, when the application starts up."]
    pub fn tcpip_adapter_init();
}
extern "C" {
    #[doc = " @brief  Cause the TCP/IP stack to start the Ethernet interface with specified MAC and IP"]
    #[doc = ""]
    #[doc = " @note This function should be called after the Ethernet MAC hardware is initialized. In the default configuration, application code does not need to call this function - it is called automatically by the default handler for the SYSTEM_EVENT_ETH_START event."]
    #[doc = ""]
    #[doc = " @param[in]  mac Set MAC address of this interface"]
    #[doc = " @param[in]  ip_info Set IP address of this interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_NO_MEM"]
    pub fn tcpip_adapter_eth_start(
        mac: *mut u8,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Cause the TCP/IP stack to start the Wi-Fi station interface with specified MAC and IP"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @note This function should be called after the Wi-Fi Station hardware is initialized. In the default configuration, application code does not need to call this function - it is called automatically by the default handler for the SYSTEM_EVENT_STA_START event."]
    #[doc = ""]
    #[doc = " @param[in]  mac Set MAC address of this interface"]
    #[doc = " @param[in]  ip_info Set IP address of this interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_NO_MEM"]
    pub fn tcpip_adapter_sta_start(
        mac: *mut u8,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Cause the TCP/IP stack to start the Wi-Fi AP interface with specified MAC and IP"]
    #[doc = ""]
    #[doc = " @note This function should be called after the Wi-Fi AP hardware is initialized. In the default configuration, application code does not need to call this function - it is called automatically by the default handler for the SYSTEM_EVENT_AP_START event."]
    #[doc = ""]
    #[doc = " DHCP server will be started automatically when this function is called."]
    #[doc = ""]
    #[doc = " @param[in]  mac Set MAC address of this interface"]
    #[doc = " @param[in]  ip_info Set IP address of this interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_NO_MEM"]
    pub fn tcpip_adapter_ap_start(mac: *mut u8, ip_info: *mut tcpip_adapter_ip_info_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Cause the TCP/IP stack to stop a network interface"]
    #[doc = ""]
    #[doc = " Causes TCP/IP stack to clean up this interface. This includes stopping the DHCP server or client, if they are started."]
    #[doc = ""]
    #[doc = " @note This API is called by the default Wi-Fi and Ethernet event handlers if the underlying network driver reports that the"]
    #[doc = " interface has stopped."]
    #[doc = ""]
    #[doc = " @note To stop an interface from application code, call the network-specific API (esp_wifi_stop() or esp_eth_stop())."]
    #[doc = " The driver layer will then send a stop event and the event handler should call this API."]
    #[doc = " Otherwise, the driver and MAC layer will remain started."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface which will be stopped"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_stop(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Cause the TCP/IP stack to bring up an interface"]
    #[doc = ""]
    #[doc = " @note This function is called automatically by the default event handlers for the Wi-Fi Station and Ethernet interfaces,"]
    #[doc = " in response to the SYSTEM_EVENT_STA_CONNECTED and SYSTEM_EVENT_ETH_CONNECTED events, respectively."]
    #[doc = ""]
    #[doc = " @note This function is not normally used with Wi-Fi AP interface. If the AP interface is started, it is up."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to bring up"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_up(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Cause the TCP/IP stack to shutdown an interface"]
    #[doc = ""]
    #[doc = " @note This function is called automatically by the default event handlers for the Wi-Fi Station and Ethernet interfaces,"]
    #[doc = " in response to the SYSTEM_EVENT_STA_DISCONNECTED and SYSTEM_EVENT_ETH_DISCONNECTED events, respectively."]
    #[doc = ""]
    #[doc = " @note This function is not normally used with Wi-Fi AP interface. If the AP interface is stopped, it is down."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to shutdown"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_down(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface's IP address information"]
    #[doc = ""]
    #[doc = " If the interface is up, IP information is read directly from the TCP/IP stack."]
    #[doc = ""]
    #[doc = " If the interface is down, IP information is read from a copy kept in the TCP/IP adapter"]
    #[doc = " library itself."]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if Interface to get IP information"]
    #[doc = " @param[out]  ip_info If successful, IP information will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_get_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set interface's IP address information"]
    #[doc = ""]
    #[doc = " This function is mainly used to set a static IP on an interface."]
    #[doc = ""]
    #[doc = " If the interface is up, the new IP information is set directly in the TCP/IP stack."]
    #[doc = ""]
    #[doc = " The copy of IP information kept in the TCP/IP adapter library is also updated (this"]
    #[doc = " copy is returned if the IP is queried while the interface is still down.)"]
    #[doc = ""]
    #[doc = " @note DHCP client/server must be stopped before setting new IP information."]
    #[doc = ""]
    #[doc = " @note Calling this interface for the Wi-Fi STA or Ethernet interfaces may generate a"]
    #[doc = " SYSTEM_EVENT_STA_GOT_IP or SYSTEM_EVENT_ETH_GOT_IP event."]
    #[doc = ""]
    #[doc = " @param[in] tcpip_if Interface to set IP information"]
    #[doc = " @param[in] ip_info IP information to set on the specified interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_DHCP_NOT_STOPPED If DHCP server or client is still running"]
    pub fn tcpip_adapter_set_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *const tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set DNS Server information"]
    #[doc = ""]
    #[doc = " This function behaves differently for different interfaces:"]
    #[doc = ""]
    #[doc = " - For Wi-Fi Station interface and Ethernet interface, up to three types of DNS server can be set (in order of priority):"]
    #[doc = "   - Main DNS Server (TCPIP_ADAPTER_DNS_MAIN)"]
    #[doc = "   - Backup DNS Server (TCPIP_ADAPTER_DNS_BACKUP)"]
    #[doc = "   - Fallback DNS Server (TCPIP_ADAPTER_DNS_FALLBACK)"]
    #[doc = ""]
    #[doc = "   If DHCP client is enabled, main and backup DNS servers will be updated automatically from the DHCP lease if the relevant DHCP options are set. Fallback DNS Server is never updated from the DHCP lease and is designed to be set via this API."]
    #[doc = ""]
    #[doc = "   If DHCP client is disabled, all DNS server types can be set via this API only."]
    #[doc = ""]
    #[doc = " - For Wi-Fi AP interface, the Main DNS Server setting is used by the DHCP server to provide a DNS Server option to DHCP clients (Wi-Fi stations)."]
    #[doc = "   - The default Main DNS server is the IP of the Wi-Fi AP interface itself."]
    #[doc = "   - This function can override it by setting server type TCPIP_ADAPTER_DNS_MAIN."]
    #[doc = "   - Other DNS Server types are not supported for the Wi-Fi AP interface."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to set DNS Server information"]
    #[doc = " @param[in]  type Type of DNS Server to set: TCPIP_ADAPTER_DNS_MAIN, TCPIP_ADAPTER_DNS_BACKUP, TCPIP_ADAPTER_DNS_FALLBACK"]
    #[doc = " @param[in]  dns  DNS Server address to set"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS invalid params"]
    pub fn tcpip_adapter_set_dns_info(
        tcpip_if: tcpip_adapter_if_t,
        type_: tcpip_adapter_dns_type_t,
        dns: *mut tcpip_adapter_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DNS Server information"]
    #[doc = ""]
    #[doc = " Return the currently configured DNS Server address for the specified interface and Server type."]
    #[doc = ""]
    #[doc = " This may be result of a previous call to tcpip_adapter_set_dns_info(). If the interface's DHCP client is enabled,"]
    #[doc = " the Main or Backup DNS Server may be set by the current DHCP lease."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to get DNS Server information"]
    #[doc = " @param[in]  type Type of DNS Server to get: TCPIP_ADAPTER_DNS_MAIN, TCPIP_ADAPTER_DNS_BACKUP, TCPIP_ADAPTER_DNS_FALLBACK"]
    #[doc = " @param[out] dns  DNS Server result is written here on success"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS invalid params"]
    pub fn tcpip_adapter_get_dns_info(
        tcpip_if: tcpip_adapter_if_t,
        type_: tcpip_adapter_dns_type_t,
        dns: *mut tcpip_adapter_dns_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface's old IP information"]
    #[doc = ""]
    #[doc = " Returns an \"old\" IP address previously stored for the interface when the valid IP changed."]
    #[doc = ""]
    #[doc = " If the IP lost timer has expired (meaning the interface was down for longer than the configured interval)"]
    #[doc = " then the old IP information will be zero."]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if Interface to get old IP information"]
    #[doc = " @param[out]  ip_info If successful, IP information will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_get_old_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *mut tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set interface old IP information"]
    #[doc = ""]
    #[doc = " This function is called from the DHCP client for the Wi-Fi STA and Ethernet interfaces, before a new IP is set. It is also called from the default handlers for the SYSTEM_EVENT_STA_CONNECTED and SYSTEM_EVENT_ETH_CONNECTED events."]
    #[doc = ""]
    #[doc = " Calling this function stores the previously configured IP, which can be used to determine if the IP changes in the future."]
    #[doc = ""]
    #[doc = " If the interface is disconnected or down for too long, the \"IP lost timer\" will expire (after the configured interval) and set the old IP information to zero."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to set old IP information"]
    #[doc = " @param[in]  ip_info Store the old IP information for the specified interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_set_old_ip_info(
        tcpip_if: tcpip_adapter_if_t,
        ip_info: *const tcpip_adapter_ip_info_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Create interface link-local IPv6 address"]
    #[doc = ""]
    #[doc = " Cause the TCP/IP stack to create a link-local IPv6 address for the specified interface."]
    #[doc = ""]
    #[doc = " This function also registers a callback for the specified interface, so that if the link-local address becomes verified as the preferred address then a SYSTEM_EVENT_GOT_IP6 event will be sent."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to create a link-local IPv6 address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_create_ip6_linklocal(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface link-local IPv6 address"]
    #[doc = ""]
    #[doc = " If the specified interface is up and a preferred link-local IPv6 address"]
    #[doc = " has been created for the interface, return a copy of it."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to get link-local IPv6 address"]
    #[doc = " @param[out] if_ip6 IPv6 information will be returned in this argument if successful."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK"]
    #[doc = "      - ESP_FAIL If interface is down, does not have a link-local IPv6 address, or the link-local IPv6 address is not a preferred address."]
    pub fn tcpip_adapter_get_ip6_linklocal(
        tcpip_if: tcpip_adapter_if_t,
        if_ip6: *mut ip6_addr_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DHCP Server status"]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if Interface to get status of DHCP server."]
    #[doc = " @param[out]  status If successful, the status of the DHCP server will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    pub fn tcpip_adapter_dhcps_get_status(
        tcpip_if: tcpip_adapter_if_t,
        status: *mut tcpip_adapter_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set or Get DHCP server option"]
    #[doc = ""]
    #[doc = " @param[in] opt_op TCPIP_ADAPTER_OP_SET to set an option, TCPIP_ADAPTER_OP_GET to get an option."]
    #[doc = " @param[in] opt_id Option index to get or set, must be one of the supported enum values."]
    #[doc = " @param[inout] opt_val Pointer to the option parameter."]
    #[doc = " @param[in] opt_len Length of the option parameter."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPPED"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED"]
    pub fn tcpip_adapter_dhcps_option(
        opt_op: tcpip_adapter_dhcp_option_mode_t,
        opt_id: tcpip_adapter_dhcp_option_id_t,
        opt_val: *mut cty::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start DHCP server"]
    #[doc = ""]
    #[doc = " @note   Currently DHCP server is only supported on the Wi-Fi AP interface."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to start DHCP server. Must be TCPIP_ADAPTER_IF_AP."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED"]
    pub fn tcpip_adapter_dhcps_start(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop DHCP server"]
    #[doc = ""]
    #[doc = " @note   Currently DHCP server is only supported on the Wi-Fi AP interface."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to stop DHCP server. Must be TCPIP_ADAPTER_IF_AP."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPPED"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_dhcps_stop(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get DHCP client status"]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to get status of DHCP client"]
    #[doc = " @param[out] status If successful, the status of DHCP client will be returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    pub fn tcpip_adapter_dhcpc_get_status(
        tcpip_if: tcpip_adapter_if_t,
        status: *mut tcpip_adapter_dhcp_status_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set or Get DHCP client's option"]
    #[doc = ""]
    #[doc = " @note This function is not yet implemented"]
    #[doc = ""]
    #[doc = " @param[in] opt_op TCPIP_ADAPTER_OP_SET to set an option, TCPIP_ADAPTER_OP_GET to get an option."]
    #[doc = " @param[in] opt_id Option index to get or set, must be one of the supported enum values."]
    #[doc = " @param[inout] opt_val Pointer to the option parameter."]
    #[doc = " @param[in] opt_len Length of the option parameter."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_ERR_NOT_SUPPORTED (not implemented)"]
    pub fn tcpip_adapter_dhcpc_option(
        opt_op: tcpip_adapter_dhcp_option_mode_t,
        opt_id: tcpip_adapter_dhcp_option_id_t,
        opt_val: *mut cty::c_void,
        opt_len: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start DHCP client"]
    #[doc = ""]
    #[doc = " @note DHCP Client is only supported for the Wi-Fi station and Ethernet interfaces."]
    #[doc = ""]
    #[doc = " @note The default event handlers for the SYSTEM_EVENT_STA_CONNECTED and SYSTEM_EVENT_ETH_CONNECTED events call this function."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to start the DHCP client"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STARTED"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_DHCPC_START_FAILED"]
    pub fn tcpip_adapter_dhcpc_start(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop DHCP client"]
    #[doc = ""]
    #[doc = " @note DHCP Client is only supported for the Wi-Fi station and Ethernet interfaces."]
    #[doc = ""]
    #[doc = " @note Calling tcpip_adapter_stop() or tcpip_adapter_down() will also stop the DHCP Client if it is running."]
    #[doc = ""]
    #[doc = " @param[in] tcpip_if Interface to stop the DHCP client"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_DHCP_ALREADY_STOPPED"]
    #[doc = "      - ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY"]
    pub fn tcpip_adapter_dhcpc_stop(tcpip_if: tcpip_adapter_if_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Receive an Ethernet frame from the Ethernet interface"]
    #[doc = ""]
    #[doc = " This function will automatically be installed by esp_eth_init(). The Ethernet driver layer will then call this function to forward frames to the TCP/IP stack."]
    #[doc = ""]
    #[doc = " @note Application code does not usually need to use this function directly."]
    #[doc = ""]
    #[doc = " @param[in]  buffer Received data"]
    #[doc = " @param[in]  len Length of the data frame"]
    #[doc = " @param[in]  eb Pointer to internal Wi-Fi buffer (ignored for Ethernet)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    pub fn tcpip_adapter_eth_input(
        buffer: *mut cty::c_void,
        len: u16,
        eb: *mut cty::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Receive an 802.11 data frame from the Wi-Fi Station interface"]
    #[doc = ""]
    #[doc = " This function should be installed by calling esp_wifi_reg_rxcb(). The Wi-Fi driver layer will then call this function to forward frames to the TCP/IP stack."]
    #[doc = ""]
    #[doc = " @note Installation happens automatically in the default handler for the SYSTEM_EVENT_STA_CONNECTED event."]
    #[doc = ""]
    #[doc = " @note Application code does not usually need to call this function directly."]
    #[doc = ""]
    #[doc = " @param[in]  buffer Received data"]
    #[doc = " @param[in]  len Length of the data frame"]
    #[doc = " @param[in]  eb Pointer to internal Wi-Fi buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    pub fn tcpip_adapter_sta_input(
        buffer: *mut cty::c_void,
        len: u16,
        eb: *mut cty::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Receive an 802.11 data frame from the Wi-Fi AP interface"]
    #[doc = ""]
    #[doc = " This function should be installed by calling esp_wifi_reg_rxcb(). The Wi-Fi driver layer will then call this function to forward frames to the TCP/IP stack."]
    #[doc = ""]
    #[doc = " @note Installation happens automatically in the default handler for the SYSTEM_EVENT_AP_START event."]
    #[doc = ""]
    #[doc = " @note Application code does not usually need to call this function directly."]
    #[doc = ""]
    #[doc = " @param[in]  buffer Received data"]
    #[doc = " @param[in]  len Length of the data frame"]
    #[doc = " @param[in]  eb Pointer to internal Wi-Fi buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    pub fn tcpip_adapter_ap_input(
        buffer: *mut cty::c_void,
        len: u16,
        eb: *mut cty::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get network interface index"]
    #[doc = ""]
    #[doc = " Get network interface from TCP/IP implementation-specific interface pointer."]
    #[doc = ""]
    #[doc = " @param[in]  dev Implementation-specific TCP/IP stack interface pointer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_IF_WIFI_STA"]
    #[doc = "         - ESP_IF_WIFI_AP"]
    #[doc = "         - ESP_IF_ETH"]
    #[doc = "         - ESP_IF_MAX - invalid parameter"]
    pub fn tcpip_adapter_get_esp_if(dev: *mut cty::c_void) -> esp_interface_t;
}
extern "C" {
    #[doc = " @brief  Get IP information for stations connected to the Wi-Fi AP interface"]
    #[doc = ""]
    #[doc = " @param[in]   wifi_sta_list Wi-Fi station info list, returned from esp_wifi_ap_get_sta_list()"]
    #[doc = " @param[out]  tcpip_sta_list IP layer station info list, corresponding to MAC addresses provided in wifi_sta_list"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_NO_MEM"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS"]
    pub fn tcpip_adapter_get_sta_list(
        wifi_sta_list: *const wifi_sta_list_t,
        tcpip_sta_list: *mut tcpip_adapter_sta_list_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set the hostname of an interface"]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if Interface to set the hostname"]
    #[doc = " @param[in]   hostname New hostname for the interface. Maximum length 32 bytes."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK - success"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY - interface status error"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS - parameter error"]
    pub fn tcpip_adapter_set_hostname(
        tcpip_if: tcpip_adapter_if_t,
        hostname: *const cty::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get interface hostname."]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if Interface to get the hostname"]
    #[doc = " @param[out]   hostname Returns a pointer to the hostname. May be NULL if no hostname is set. If set non-NULL, pointer remains valid (and string may change if the hostname changes)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK - success"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY - interface status error"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS - parameter error"]
    pub fn tcpip_adapter_get_hostname(
        tcpip_if: tcpip_adapter_if_t,
        hostname: *mut *const cty::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get the TCP/IP stack-specific interface that is assigned to a given interface"]
    #[doc = ""]
    #[doc = " @note For lwIP, this returns a pointer to a netif structure."]
    #[doc = ""]
    #[doc = " @param[in]  tcpip_if Interface to get the implementation-specific interface"]
    #[doc = " @param[out] netif Pointer to the implementation-specific interface"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - ESP_OK - success"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_IF_NOT_READY - interface status error"]
    #[doc = "         - ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS - parameter error"]
    pub fn tcpip_adapter_get_netif(
        tcpip_if: tcpip_adapter_if_t,
        netif: *mut *mut cty::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Test if supplied interface is up or down"]
    #[doc = ""]
    #[doc = " @param[in]   tcpip_if Interface to test up/down status"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - true - Interface is up"]
    #[doc = "         - false - Interface is down"]
    pub fn tcpip_adapter_is_netif_up(tcpip_if: tcpip_adapter_if_t) -> bool;
}
#[doc = "< ESP32 WiFi ready"]
pub const system_event_id_t_SYSTEM_EVENT_WIFI_READY: system_event_id_t = 0;
#[doc = "< ESP32 finish scanning AP"]
pub const system_event_id_t_SYSTEM_EVENT_SCAN_DONE: system_event_id_t = 1;
#[doc = "< ESP32 station start"]
pub const system_event_id_t_SYSTEM_EVENT_STA_START: system_event_id_t = 2;
#[doc = "< ESP32 station stop"]
pub const system_event_id_t_SYSTEM_EVENT_STA_STOP: system_event_id_t = 3;
#[doc = "< ESP32 station connected to AP"]
pub const system_event_id_t_SYSTEM_EVENT_STA_CONNECTED: system_event_id_t = 4;
#[doc = "< ESP32 station disconnected from AP"]
pub const system_event_id_t_SYSTEM_EVENT_STA_DISCONNECTED: system_event_id_t = 5;
#[doc = "< the auth mode of AP connected by ESP32 station changed"]
pub const system_event_id_t_SYSTEM_EVENT_STA_AUTHMODE_CHANGE: system_event_id_t = 6;
#[doc = "< ESP32 station got IP from connected AP"]
pub const system_event_id_t_SYSTEM_EVENT_STA_GOT_IP: system_event_id_t = 7;
#[doc = "< ESP32 station lost IP and the IP is reset to 0"]
pub const system_event_id_t_SYSTEM_EVENT_STA_LOST_IP: system_event_id_t = 8;
#[doc = "< ESP32 station wps succeeds in enrollee mode"]
pub const system_event_id_t_SYSTEM_EVENT_STA_WPS_ER_SUCCESS: system_event_id_t = 9;
#[doc = "< ESP32 station wps fails in enrollee mode"]
pub const system_event_id_t_SYSTEM_EVENT_STA_WPS_ER_FAILED: system_event_id_t = 10;
#[doc = "< ESP32 station wps timeout in enrollee mode"]
pub const system_event_id_t_SYSTEM_EVENT_STA_WPS_ER_TIMEOUT: system_event_id_t = 11;
#[doc = "< ESP32 station wps pin code in enrollee mode"]
pub const system_event_id_t_SYSTEM_EVENT_STA_WPS_ER_PIN: system_event_id_t = 12;
#[doc = "< ESP32 soft-AP start"]
pub const system_event_id_t_SYSTEM_EVENT_AP_START: system_event_id_t = 13;
#[doc = "< ESP32 soft-AP stop"]
pub const system_event_id_t_SYSTEM_EVENT_AP_STOP: system_event_id_t = 14;
#[doc = "< a station connected to ESP32 soft-AP"]
pub const system_event_id_t_SYSTEM_EVENT_AP_STACONNECTED: system_event_id_t = 15;
#[doc = "< a station disconnected from ESP32 soft-AP"]
pub const system_event_id_t_SYSTEM_EVENT_AP_STADISCONNECTED: system_event_id_t = 16;
#[doc = "< ESP32 soft-AP assign an IP to a connected station"]
pub const system_event_id_t_SYSTEM_EVENT_AP_STAIPASSIGNED: system_event_id_t = 17;
#[doc = "< Receive probe request packet in soft-AP interface"]
pub const system_event_id_t_SYSTEM_EVENT_AP_PROBEREQRECVED: system_event_id_t = 18;
#[doc = "< ESP32 station or ap or ethernet interface v6IP addr is preferred"]
pub const system_event_id_t_SYSTEM_EVENT_GOT_IP6: system_event_id_t = 19;
#[doc = "< ESP32 ethernet start"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_START: system_event_id_t = 20;
#[doc = "< ESP32 ethernet stop"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_STOP: system_event_id_t = 21;
#[doc = "< ESP32 ethernet phy link up"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_CONNECTED: system_event_id_t = 22;
#[doc = "< ESP32 ethernet phy link down"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_DISCONNECTED: system_event_id_t = 23;
#[doc = "< ESP32 ethernet got IP from connected AP"]
pub const system_event_id_t_SYSTEM_EVENT_ETH_GOT_IP: system_event_id_t = 24;
pub const system_event_id_t_SYSTEM_EVENT_MAX: system_event_id_t = 25;
pub type system_event_id_t = u32;
#[doc = "< ESP32 WPS normal fail reason"]
pub const system_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_NORMAL:
    system_event_sta_wps_fail_reason_t = 0;
#[doc = "< ESP32 WPS receive M2D frame"]
pub const system_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_RECV_M2D:
    system_event_sta_wps_fail_reason_t = 1;
pub const system_event_sta_wps_fail_reason_t_WPS_FAIL_REASON_MAX:
    system_event_sta_wps_fail_reason_t = 2;
pub type system_event_sta_wps_fail_reason_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_sta_scan_done_t {
    #[doc = "< status of scanning APs"]
    pub status: u32,
    pub number: u8,
    pub scan_id: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_sta_connected_t {
    #[doc = "< SSID of connected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of connected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of connected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< channel of connected AP"]
    pub channel: u8,
    pub authmode: wifi_auth_mode_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_sta_disconnected_t {
    #[doc = "< SSID of disconnected AP"]
    pub ssid: [u8; 32usize],
    #[doc = "< SSID length of disconnected AP"]
    pub ssid_len: u8,
    #[doc = "< BSSID of disconnected AP"]
    pub bssid: [u8; 6usize],
    #[doc = "< reason of disconnection"]
    pub reason: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_sta_authmode_change_t {
    #[doc = "< the old auth mode of AP"]
    pub old_mode: wifi_auth_mode_t,
    #[doc = "< the new auth mode of AP"]
    pub new_mode: wifi_auth_mode_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_sta_got_ip_t {
    pub ip_info: tcpip_adapter_ip_info_t,
    pub ip_changed: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_sta_wps_er_pin_t {
    #[doc = "< PIN code of station in enrollee mode"]
    pub pin_code: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_got_ip6_t {
    pub if_index: tcpip_adapter_if_t,
    pub ip6_info: tcpip_adapter_ip6_info_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_ap_staconnected_t {
    #[doc = "< MAC address of the station connected to ESP32 soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< the aid that ESP32 soft-AP gives to the station connected to"]
    pub aid: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_ap_stadisconnected_t {
    #[doc = "< MAC address of the station disconnects to ESP32 soft-AP"]
    pub mac: [u8; 6usize],
    #[doc = "< the aid that ESP32 soft-AP gave to the station disconnects to"]
    pub aid: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_ap_probe_req_rx_t {
    #[doc = "< Received probe request signal strength"]
    pub rssi: cty::c_int,
    #[doc = "< MAC address of the station which send probe request"]
    pub mac: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_event_ap_staipassigned_t {
    pub ip: ip4_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union system_event_info_t {
    #[doc = "< ESP32 station connected to AP"]
    pub connected: system_event_sta_connected_t,
    #[doc = "< ESP32 station disconnected to AP"]
    pub disconnected: system_event_sta_disconnected_t,
    #[doc = "< ESP32 station scan (APs) done"]
    pub scan_done: system_event_sta_scan_done_t,
    #[doc = "< the auth mode of AP ESP32 station connected to changed"]
    pub auth_change: system_event_sta_authmode_change_t,
    #[doc = "< ESP32 station got IP, first time got IP or when IP is changed"]
    pub got_ip: system_event_sta_got_ip_t,
    #[doc = "< ESP32 station WPS enrollee mode PIN code received"]
    pub sta_er_pin: system_event_sta_wps_er_pin_t,
    #[doc = "< ESP32 station WPS enrollee mode failed reason code received"]
    pub sta_er_fail_reason: system_event_sta_wps_fail_reason_t,
    #[doc = "< a station connected to ESP32 soft-AP"]
    pub sta_connected: system_event_ap_staconnected_t,
    #[doc = "< a station disconnected to ESP32 soft-AP"]
    pub sta_disconnected: system_event_ap_stadisconnected_t,
    #[doc = "< ESP32 soft-AP receive probe request packet"]
    pub ap_probereqrecved: system_event_ap_probe_req_rx_t,
    #[doc = "< ESP32 soft-AP assign an IP to the station"]
    pub ap_staipassigned: system_event_ap_staipassigned_t,
    #[doc = "< ESP32 station\u{3000}or ap or ethernet ipv6 addr state change to preferred"]
    pub got_ip6: system_event_got_ip6_t,
    _bindgen_union_align: [u32; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_event_t {
    #[doc = "< event ID"]
    pub event_id: system_event_id_t,
    #[doc = "< event information"]
    pub event_info: system_event_info_t,
}
pub type system_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(event: *mut system_event_t) -> esp_err_t>;
extern "C" {
    #[doc = " @brief  Send a event to event task"]
    #[doc = ""]
    #[doc = " @attention 1. Other task/modules, such as the TCPIP module, can call this API to send an event to event task"]
    #[doc = ""]
    #[doc = " @param  system_event_t * event : event"]
    #[doc = ""]
    #[doc = " @return ESP_OK : succeed"]
    #[doc = " @return others : fail"]
    pub fn esp_event_send(event: *mut system_event_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Default event handler for system events"]
    #[doc = ""]
    #[doc = " This function performs default handling of system events."]
    #[doc = " When using esp_event_loop APIs, it is called automatically before invoking the user-provided"]
    #[doc = " callback function."]
    #[doc = ""]
    #[doc = " Applications which implement a custom event loop must call this function"]
    #[doc = " as part of event processing."]
    #[doc = ""]
    #[doc = " @param  event pointer to event to be handled"]
    #[doc = " @return ESP_OK if an event was handled successfully"]
    pub fn esp_event_process_default(event: *mut system_event_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Install default event handlers for Ethernet interface"]
    #[doc = ""]
    pub fn esp_event_set_default_eth_handlers();
}
extern "C" {
    #[doc = " @brief  Install default event handlers for Wi-Fi interfaces (station and AP)"]
    #[doc = ""]
    pub fn esp_event_set_default_wifi_handlers();
}
#[doc = " Configuration for creating event loops"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_event_loop_args_t {
    #[doc = "< size of the event loop queue"]
    pub queue_size: i32,
    #[doc = "< name of the event loop task; if NULL,"]
    #[doc = "a dedicated task is not created for event loop"]
    pub task_name: *const cty::c_char,
    #[doc = "< priority of the event loop task, ignored if task name is NULL"]
    pub task_priority: UBaseType_t,
    #[doc = "< stack size of the event loop task, ignored if task name is NULL"]
    pub task_stack_size: u32,
    #[doc = "< core to which the event loop task is pinned to,"]
    #[doc = "ignored if task name is NULL"]
    pub task_core_id: BaseType_t,
}
extern "C" {
    #[doc = " @brief Create a new event loop."]
    #[doc = ""]
    #[doc = " @param[in] event_loop_args configuration structure for the event loop to create"]
    #[doc = " @param[out] event_loop handle to the created event loop"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list"]
    #[doc = "  - ESP_FAIL: Failed to create task loop"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_create(
        event_loop_args: *const esp_event_loop_args_t,
        event_loop: *mut esp_event_loop_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an existing event loop."]
    #[doc = ""]
    #[doc = " @param[in] event_loop event loop to delete"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_delete(event_loop: esp_event_loop_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create default event loop"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list"]
    #[doc = "  - ESP_FAIL: Failed to create task loop"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_create_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete the default event loop"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_delete_default() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dispatch events posted to an event loop."]
    #[doc = ""]
    #[doc = " This function is used to dispatch events posted to a loop with no dedicated task, i.e task name was set to NULL"]
    #[doc = " in event_loop_args argument during loop creation. This function includes an argument to limit the amount of time"]
    #[doc = " it runs, returning control to the caller when that time expires (or some time afterwards). There is no guarantee"]
    #[doc = " that a call to this function will exit at exactly the time of expiry. There is also no guarantee that events have"]
    #[doc = " been dispatched during the call, as the function might have spent all of the alloted time waiting on the event queue."]
    #[doc = " Once an event has been unqueued, however, it is guaranteed to be dispatched. This guarantee contributes to not being"]
    #[doc = " able to exit exactly at time of expiry as (1) blocking on internal mutexes is necessary for dispatching the unqueued"]
    #[doc = " event, and (2) during  dispatch of the unqueued event there is no way to control the time occupied by handler code"]
    #[doc = " execution. The guaranteed time of exit is therefore the alloted time + amount of time required to dispatch"]
    #[doc = " the last unqueued event."]
    #[doc = ""]
    #[doc = " In cases where waiting on the queue times out, ESP_OK is returned and not ESP_ERR_TIMEOUT, since it is"]
    #[doc = " normal behavior."]
    #[doc = ""]
    #[doc = " @param[in] event_loop event loop to dispatch posted events from"]
    #[doc = " @param[in] ticks_to_run number of ticks to run the loop"]
    #[doc = ""]
    #[doc = " @note encountering an unknown event that has been posted to the loop will only generate a warning, not an error."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_loop_run(
        event_loop: esp_event_loop_handle_t,
        ticks_to_run: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to the system event loop."]
    #[doc = ""]
    #[doc = " This function can be used to register a handler for either: (1) specific events,"]
    #[doc = " (2) all events of a certain event base, or (3) all events known by the system event loop."]
    #[doc = ""]
    #[doc = "  - specific events: specify exact event_base and event_id"]
    #[doc = "  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id"]
    #[doc = "  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id"]
    #[doc = ""]
    #[doc = " Registering multiple handlers to events is possible. Registering a single handler to multiple events is"]
    #[doc = " also possible. However, registering the same handler to the same event multiple times would cause the"]
    #[doc = " previous registrations to be overwritten."]
    #[doc = ""]
    #[doc = " @param[in] event_base the base id of the event to register the handler for"]
    #[doc = " @param[in] event_id the id of the event to register the handler for"]
    #[doc = " @param[in] event_handler the handler function which gets called when the event is dispatched"]
    #[doc = " @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called"]
    #[doc = ""]
    #[doc = " @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should"]
    #[doc = " ensure that event_handler_arg still points to a valid location by the time the handler gets called"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_register(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut cty::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register an event handler to a specific loop."]
    #[doc = ""]
    #[doc = " This function behaves in the same manner as esp_event_handler_register, except the additional"]
    #[doc = " specification of the event loop to register the handler to."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop to register this handler function to"]
    #[doc = " @param[in] event_base the base id of the event to register the handler for"]
    #[doc = " @param[in] event_id the id of the event to register the handler for"]
    #[doc = " @param[in] event_handler the handler function which gets called when the event is dispatched"]
    #[doc = " @param[in] event_handler_arg data, aside from event data, that is passed to the handler when it is called"]
    #[doc = ""]
    #[doc = " @note the event loop library does not maintain a copy of event_handler_arg, therefore the user should"]
    #[doc = " ensure that event_handler_arg still points to a valid location by the time the handler gets called"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for the handler"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_register_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
        event_handler_arg: *mut cty::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler with the system event loop."]
    #[doc = ""]
    #[doc = " This function can be used to unregister a handler so that it no longer gets called during dispatch."]
    #[doc = " Handlers can be unregistered for either: (1) specific events, (2) all events of a certain event base,"]
    #[doc = " or (3) all events known by the system event loop"]
    #[doc = ""]
    #[doc = "  - specific events: specify exact event_base and event_id"]
    #[doc = "  - all events of a certain base: specify exact event_base and use ESP_EVENT_ANY_ID as the event_id"]
    #[doc = "  - all events known by the loop: use ESP_EVENT_ANY_BASE for event_base and ESP_EVENT_ANY_ID as the event_id"]
    #[doc = ""]
    #[doc = " This function ignores unregistration of handlers that has not been previously registered."]
    #[doc = ""]
    #[doc = " @param[in] event_base the base of the event with which to unregister the handler"]
    #[doc = " @param[in] event_id the id of the event with which to unregister the handler"]
    #[doc = " @param[in] event_handler the handler to unregister"]
    #[doc = ""]
    #[doc = " @return ESP_OK success"]
    #[doc = " @return ESP_ERR_INVALID_ARG invalid combination of event base and event id"]
    #[doc = " @return others fail"]
    pub fn esp_event_handler_unregister(
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Unregister a handler with the system event loop."]
    #[doc = ""]
    #[doc = " This function behaves in the same manner as esp_event_handler_unregister, except the additional specification of"]
    #[doc = " the event loop to unregister the handler with."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop with which to unregister this handler function"]
    #[doc = " @param[in] event_base the base of the event with which to unregister the handler"]
    #[doc = " @param[in] event_id the id of the event with which to unregister the handler"]
    #[doc = " @param[in] event_handler the handler to unregister"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_handler_unregister_with(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_handler: esp_event_handler_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the system default event loop. The event loop library keeps a copy of event_data and manages"]
    #[doc = " the copy's lifetime automatically (allocation + deletion); this ensures that the data the"]
    #[doc = " handler recieves is always valid."]
    #[doc = ""]
    #[doc = " @param[in] event_base the event base that identifies the event"]
    #[doc = " @param[in] event_id the the event id that identifies the event"]
    #[doc = " @param[in] event_data the data, specific to the event occurence, that gets passed to the handler"]
    #[doc = " @param[in] event_data_size the size of the event data"]
    #[doc = " @param[in] ticks_to_wait number of ticks to block on a full event queue"]
    #[doc = ""]
    #[doc = " @note posting events from an ISR is not supported"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_post(
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut cty::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Posts an event to the specified event loop. The event loop library keeps a copy of event_data and manages"]
    #[doc = " the copy's lifetime automatically (allocation + deletion); this ensures that the data the"]
    #[doc = " handler recieves is always valid."]
    #[doc = ""]
    #[doc = " This function behaves in the same manner as esp_event_post_to, except the additional specification of the event loop"]
    #[doc = " to post the event to."]
    #[doc = ""]
    #[doc = " @param[in] event_loop the event loop to post to"]
    #[doc = " @param[in] event_base the event base that identifies the event"]
    #[doc = " @param[in] event_id the the event id that identifies the event"]
    #[doc = " @param[in] event_data the data, specific to the event occurence, that gets passed to the handler"]
    #[doc = " @param[in] event_data_size the size of the event data"]
    #[doc = " @param[in] ticks_to_wait number of ticks to block on a full event queue"]
    #[doc = ""]
    #[doc = " @note posting events from an ISR is not supported"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_TIMEOUT: Time to wait for event queue to unblock expired"]
    #[doc = "  - ESP_ERR_INVALID_ARG: Invalid combination of event base and event id"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_post_to(
        event_loop: esp_event_loop_handle_t,
        event_base: esp_event_base_t,
        event_id: i32,
        event_data: *mut cty::c_void,
        event_data_size: usize,
        ticks_to_wait: TickType_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Dumps statistics of all event loops."]
    #[doc = ""]
    #[doc = " Dumps event loop info in the format:"]
    #[doc = ""]
    #[doc = "@verbatim"]
    #[doc = "event loop"]
    #[doc = "handler"]
    #[doc = "handler"]
    #[doc = "..."]
    #[doc = "event loop"]
    #[doc = "handler"]
    #[doc = "handler"]
    #[doc = "..."]
    #[doc = ""]
    #[doc = "where:"]
    #[doc = ""]
    #[doc = "event loop"]
    #[doc = "format: address,name rx:total_recieved dr:total_dropped"]
    #[doc = "where:"]
    #[doc = "address - memory address of the event loop"]
    #[doc = "name - name of the event loop, 'none' if no dedicated task"]
    #[doc = "total_recieved - number of successfully posted events"]
    #[doc = "total_dropped - number of events unsucessfully posted due to queue being full"]
    #[doc = ""]
    #[doc = "handler"]
    #[doc = "format: address ev:base,id inv:total_invoked run:total_runtime"]
    #[doc = "where:"]
    #[doc = "address - address of the handler function"]
    #[doc = "base,id - the event specified by event base and id this handler executes"]
    #[doc = "total_invoked - number of times this handler has been invoked"]
    #[doc = "total_runtime - total amount of time used for invoking this handler"]
    #[doc = ""]
    #[doc = "@endverbatim"]
    #[doc = ""]
    #[doc = " @param[in] file the file stream to output to"]
    #[doc = ""]
    #[doc = " @note this function is a noop when CONFIG_EVENT_LOOP_PROFILING is disabled"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK: Success"]
    #[doc = "  - ESP_ERR_NO_MEM: Cannot allocate memory for event loops list"]
    #[doc = "  - Others: Fail"]
    pub fn esp_event_dump(file: *mut FILE) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_osi_funcs_t {
    pub _version: i32,
    pub _set_isr: ::core::option::Option<
        unsafe extern "C" fn(n: i32, f: *mut cty::c_void, arg: *mut cty::c_void),
    >,
    pub _ints_on: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _ints_off: ::core::option::Option<unsafe extern "C" fn(mask: u32)>,
    pub _spin_lock_create: ::core::option::Option<unsafe extern "C" fn() -> *mut cty::c_void>,
    pub _spin_lock_delete: ::core::option::Option<unsafe extern "C" fn(lock: *mut cty::c_void)>,
    pub _wifi_int_disable:
        ::core::option::Option<unsafe extern "C" fn(wifi_int_mux: *mut cty::c_void) -> u32>,
    pub _wifi_int_restore:
        ::core::option::Option<unsafe extern "C" fn(wifi_int_mux: *mut cty::c_void, tmp: u32)>,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create:
        ::core::option::Option<unsafe extern "C" fn(max: u32, init: u32) -> *mut cty::c_void>,
    pub _semphr_delete: ::core::option::Option<unsafe extern "C" fn(semphr: *mut cty::c_void)>,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut cty::c_void, block_time_tick: u32) -> i32,
    >,
    pub _semphr_give: ::core::option::Option<unsafe extern "C" fn(semphr: *mut cty::c_void) -> i32>,
    pub _mutex_create: ::core::option::Option<unsafe extern "C" fn() -> *mut cty::c_void>,
    pub _recursive_mutex_create: ::core::option::Option<unsafe extern "C" fn() -> *mut cty::c_void>,
    pub _mutex_delete: ::core::option::Option<unsafe extern "C" fn(mutex: *mut cty::c_void)>,
    pub _mutex_lock: ::core::option::Option<unsafe extern "C" fn(mutex: *mut cty::c_void) -> i32>,
    pub _mutex_unlock: ::core::option::Option<unsafe extern "C" fn(mutex: *mut cty::c_void) -> i32>,
    pub _queue_create: ::core::option::Option<
        unsafe extern "C" fn(queue_len: u32, item_size: u32) -> *mut cty::c_void,
    >,
    pub _queue_delete: ::core::option::Option<unsafe extern "C" fn(queue: *mut cty::c_void)>,
    pub _queue_send: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut cty::c_void,
            item: *mut cty::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut cty::c_void,
            item: *mut cty::c_void,
            hptw: *mut cty::c_void,
        ) -> i32,
    >,
    pub _queue_send_to_back: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut cty::c_void,
            item: *mut cty::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_send_to_front: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut cty::c_void,
            item: *mut cty::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_recv: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut cty::c_void,
            item: *mut cty::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _queue_msg_waiting:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut cty::c_void) -> u32>,
    pub _event_group_create: ::core::option::Option<unsafe extern "C" fn() -> *mut cty::c_void>,
    pub _event_group_delete: ::core::option::Option<unsafe extern "C" fn(event: *mut cty::c_void)>,
    pub _event_group_set_bits:
        ::core::option::Option<unsafe extern "C" fn(event: *mut cty::c_void, bits: u32) -> u32>,
    pub _event_group_clear_bits:
        ::core::option::Option<unsafe extern "C" fn(event: *mut cty::c_void, bits: u32) -> u32>,
    pub _event_group_wait_bits: ::core::option::Option<
        unsafe extern "C" fn(
            event: *mut cty::c_void,
            bits_to_wait_for: u32,
            clear_on_exit: i32,
            wait_for_all_bits: i32,
            block_time_tick: u32,
        ) -> u32,
    >,
    pub _task_create_pinned_to_core: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut cty::c_void,
            name: *const cty::c_char,
            stack_depth: u32,
            param: *mut cty::c_void,
            prio: u32,
            task_handle: *mut cty::c_void,
            core_id: u32,
        ) -> i32,
    >,
    pub _task_create: ::core::option::Option<
        unsafe extern "C" fn(
            task_func: *mut cty::c_void,
            name: *const cty::c_char,
            stack_depth: u32,
            param: *mut cty::c_void,
            prio: u32,
            task_handle: *mut cty::c_void,
        ) -> i32,
    >,
    pub _task_delete: ::core::option::Option<unsafe extern "C" fn(task_handle: *mut cty::c_void)>,
    pub _task_delay: ::core::option::Option<unsafe extern "C" fn(tick: u32)>,
    pub _task_ms_to_tick: ::core::option::Option<unsafe extern "C" fn(ms: u32) -> i32>,
    pub _task_get_current_task: ::core::option::Option<unsafe extern "C" fn() -> *mut cty::c_void>,
    pub _task_get_max_priority: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    pub _malloc: ::core::option::Option<unsafe extern "C" fn(size: u32) -> *mut cty::c_void>,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut cty::c_void)>,
    pub _get_free_heap_size: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _rand: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _dport_access_stall_other_cpu_start_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _dport_access_stall_other_cpu_end_wrap: ::core::option::Option<unsafe extern "C" fn()>,
    pub _phy_rf_deinit: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _phy_load_cal_and_init: ::core::option::Option<unsafe extern "C" fn(module: u32)>,
    pub _read_mac: ::core::option::Option<unsafe extern "C" fn(mac: *mut u8, type_: u32) -> i32>,
    pub _timer_arm: ::core::option::Option<
        unsafe extern "C" fn(timer: *mut cty::c_void, tmout: u32, repeat: bool),
    >,
    pub _timer_disarm: ::core::option::Option<unsafe extern "C" fn(timer: *mut cty::c_void)>,
    pub _timer_done: ::core::option::Option<unsafe extern "C" fn(ptimer: *mut cty::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut cty::c_void,
            pfunction: *mut cty::c_void,
            parg: *mut cty::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut cty::c_void, us: u32, repeat: bool),
    >,
    pub _periph_module_enable: ::core::option::Option<unsafe extern "C" fn(periph: u32)>,
    pub _periph_module_disable: ::core::option::Option<unsafe extern "C" fn(periph: u32)>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _nvs_set_i8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const cty::c_char, value: i8) -> i32,
    >,
    pub _nvs_get_i8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const cty::c_char, out_value: *mut i8) -> i32,
    >,
    pub _nvs_set_u8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const cty::c_char, value: u8) -> i32,
    >,
    pub _nvs_get_u8: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const cty::c_char, out_value: *mut u8) -> i32,
    >,
    pub _nvs_set_u16: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const cty::c_char, value: u16) -> i32,
    >,
    pub _nvs_get_u16: ::core::option::Option<
        unsafe extern "C" fn(handle: u32, key: *const cty::c_char, out_value: *mut u16) -> i32,
    >,
    pub _nvs_open: ::core::option::Option<
        unsafe extern "C" fn(name: *const cty::c_char, open_mode: u32, out_handle: *mut u32) -> i32,
    >,
    pub _nvs_close: ::core::option::Option<unsafe extern "C" fn(handle: u32)>,
    pub _nvs_commit: ::core::option::Option<unsafe extern "C" fn(handle: u32) -> i32>,
    pub _nvs_set_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const cty::c_char,
            value: *const cty::c_void,
            length: usize,
        ) -> i32,
    >,
    pub _nvs_get_blob: ::core::option::Option<
        unsafe extern "C" fn(
            handle: u32,
            key: *const cty::c_char,
            out_value: *mut cty::c_void,
            length: *mut usize,
        ) -> i32,
    >,
    pub _nvs_erase_key:
        ::core::option::Option<unsafe extern "C" fn(handle: u32, key: *const cty::c_char) -> i32>,
    pub _get_random: ::core::option::Option<unsafe extern "C" fn(buf: *mut u8, len: usize) -> i32>,
    pub _get_time: ::core::option::Option<unsafe extern "C" fn(t: *mut cty::c_void) -> i32>,
    pub _random: ::core::option::Option<unsafe extern "C" fn() -> cty::c_ulong>,
    pub _log_write: ::core::option::Option<
        unsafe extern "C" fn(level: u32, tag: *const cty::c_char, format: *const cty::c_char, ...),
    >,
    pub _log_timestamp: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _malloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut cty::c_void>,
    pub _realloc_internal: ::core::option::Option<
        unsafe extern "C" fn(ptr: *mut cty::c_void, size: usize) -> *mut cty::c_void,
    >,
    pub _calloc_internal:
        ::core::option::Option<unsafe extern "C" fn(n: usize, size: usize) -> *mut cty::c_void>,
    pub _zalloc_internal:
        ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut cty::c_void>,
    pub _wifi_malloc: ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut cty::c_void>,
    pub _wifi_realloc: ::core::option::Option<
        unsafe extern "C" fn(ptr: *mut cty::c_void, size: usize) -> *mut cty::c_void,
    >,
    pub _wifi_calloc:
        ::core::option::Option<unsafe extern "C" fn(n: usize, size: usize) -> *mut cty::c_void>,
    pub _wifi_zalloc: ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut cty::c_void>,
    pub _wifi_create_queue: ::core::option::Option<
        unsafe extern "C" fn(queue_len: i32, item_size: i32) -> *mut cty::c_void,
    >,
    pub _wifi_delete_queue: ::core::option::Option<unsafe extern "C" fn(queue: *mut cty::c_void)>,
    pub _modem_sleep_enter: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _modem_sleep_exit: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _modem_sleep_register: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _modem_sleep_deregister: ::core::option::Option<unsafe extern "C" fn(module: u32) -> i32>,
    pub _sc_ack_send: ::core::option::Option<unsafe extern "C" fn(param: *mut cty::c_void)>,
    pub _sc_ack_send_stop: ::core::option::Option<unsafe extern "C" fn()>,
    pub _coex_status_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _coex_wifi_request: ::core::option::Option<
        unsafe extern "C" fn(event: u32, latency: u32, duration: u32) -> i32,
    >,
    pub _coex_wifi_release: ::core::option::Option<unsafe extern "C" fn(event: u32) -> i32>,
    pub _magic: i32,
}
extern "C" {
    pub static mut g_wifi_osi_funcs: wifi_osi_funcs_t;
}
#[doc = " @brief WiFi stack configuration parameters passed to esp_wifi_init call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_init_config_t {
    #[doc = "< WiFi event handler"]
    pub event_handler: system_event_handler_t,
    #[doc = "< WiFi OS functions"]
    pub osi_funcs: *mut wifi_osi_funcs_t,
    #[doc = "< WiFi station crypto functions when connect"]
    pub wpa_crypto_funcs: wpa_crypto_funcs_t,
    #[doc = "< WiFi static RX buffer number"]
    pub static_rx_buf_num: cty::c_int,
    #[doc = "< WiFi dynamic RX buffer number"]
    pub dynamic_rx_buf_num: cty::c_int,
    #[doc = "< WiFi TX buffer type"]
    pub tx_buf_type: cty::c_int,
    #[doc = "< WiFi static TX buffer number"]
    pub static_tx_buf_num: cty::c_int,
    #[doc = "< WiFi dynamic TX buffer number"]
    pub dynamic_tx_buf_num: cty::c_int,
    #[doc = "< WiFi channel state information enable flag"]
    pub csi_enable: cty::c_int,
    #[doc = "< WiFi AMPDU RX feature enable flag"]
    pub ampdu_rx_enable: cty::c_int,
    #[doc = "< WiFi AMPDU TX feature enable flag"]
    pub ampdu_tx_enable: cty::c_int,
    #[doc = "< WiFi NVS flash enable flag"]
    pub nvs_enable: cty::c_int,
    #[doc = "< Nano option for printf/scan family enable flag"]
    pub nano_enable: cty::c_int,
    #[doc = "< WiFi Block Ack TX window size"]
    pub tx_ba_win: cty::c_int,
    #[doc = "< WiFi Block Ack RX window size"]
    pub rx_ba_win: cty::c_int,
    #[doc = "< WiFi Task Core ID"]
    pub wifi_task_core_id: cty::c_int,
    #[doc = "< WiFi softAP maximum length of the beacon"]
    pub beacon_max_len: cty::c_int,
    #[doc = "< WiFi management short buffer number, the minimum value is 6, the maximum value is 32"]
    pub mgmt_sbuf_num: cty::c_int,
    #[doc = "< WiFi init magic number, it should be the last field"]
    pub magic: cty::c_int,
}
extern "C" {
    pub static g_wifi_default_wpa_crypto_funcs: wpa_crypto_funcs_t;
}
extern "C" {
    #[doc = " @brief  Init WiFi"]
    #[doc = "         Alloc resource for WiFi driver, such as WiFi control structure, RX/TX buffer,"]
    #[doc = "         WiFi NVS structure etc, this WiFi also start WiFi task"]
    #[doc = ""]
    #[doc = " @attention 1. This API must be called before all other WiFi API can be called"]
    #[doc = " @attention 2. Always use WIFI_INIT_CONFIG_DEFAULT macro to init the config to default values, this can"]
    #[doc = "               guarantee all the fields got correct value when more fields are added into wifi_init_config_t"]
    #[doc = "               in future release. If you want to set your owner initial values, overwrite the default values"]
    #[doc = "               which are set by WIFI_INIT_CONFIG_DEFAULT, please be notified that the field 'magic' of"]
    #[doc = "               wifi_init_config_t should always be WIFI_INIT_CONFIG_MAGIC!"]
    #[doc = ""]
    #[doc = " @param  config pointer to WiFi init configuration structure; can point to a temporary variable."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    #[doc = "    - others: refer to error code esp_err.h"]
    pub fn esp_wifi_init(config: *const wifi_init_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Deinit WiFi"]
    #[doc = "         Free all resource allocated in esp_wifi_init and stop WiFi task"]
    #[doc = ""]
    #[doc = " @attention 1. This API should be called if you want to remove WiFi driver from the system"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi operating mode"]
    #[doc = ""]
    #[doc = "            Set the WiFi operating mode as station, soft-AP or station+soft-AP,"]
    #[doc = "            The default mode is soft-AP mode."]
    #[doc = ""]
    #[doc = " @param     mode  WiFi operating mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_set_mode(mode: wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Get current operating mode of WiFi"]
    #[doc = ""]
    #[doc = " @param[out]  mode  store current WiFi mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_mode(mode: *mut wifi_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Start WiFi according to current configuration"]
    #[doc = "         If mode is WIFI_MODE_STA, it create station control block and start station"]
    #[doc = "         If mode is WIFI_MODE_AP, it create soft-AP control block and start soft-AP"]
    #[doc = "         If mode is WIFI_MODE_APSTA, it create soft-AP and station control block and start soft-AP and station"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong"]
    #[doc = "    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_start() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Stop WiFi"]
    #[doc = "         If mode is WIFI_MODE_STA, it stop station and free station control block"]
    #[doc = "         If mode is WIFI_MODE_AP, it stop soft-AP and free soft-AP control block"]
    #[doc = "         If mode is WIFI_MODE_APSTA, it stop station/soft-AP and free station/soft-AP control block"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Restore WiFi stack persistent settings to default values"]
    #[doc = ""]
    #[doc = " This function will reset settings made using the following APIs:"]
    #[doc = " - esp_wifi_get_auto_connect,"]
    #[doc = " - esp_wifi_set_protocol,"]
    #[doc = " - esp_wifi_set_config related"]
    #[doc = " - esp_wifi_set_mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_restore() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Connect the ESP32 WiFi station to the AP."]
    #[doc = ""]
    #[doc = " @attention 1. This API only impact WIFI_MODE_STA or WIFI_MODE_APSTA mode"]
    #[doc = " @attention 2. If the ESP32 is connected to an AP, call esp_wifi_disconnect to disconnect."]
    #[doc = " @attention 3. The scanning triggered by esp_wifi_start_scan() will not be effective until connection between ESP32 and the AP is established."]
    #[doc = "               If ESP32 is scanning and connecting at the same time, ESP32 will abort scanning and return a warning message and error"]
    #[doc = "               number ESP_ERR_WIFI_STATE."]
    #[doc = "               If you want to do reconnection after ESP32 received disconnect event, remember to add the maximum retry time, otherwise the called"]
    #[doc = "               scan will not work. This is especially true when the AP doesn't exist, and you still try reconnection after ESP32 received disconnect"]
    #[doc = "               event with the reason code WIFI_REASON_NO_AP_FOUND."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_START: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, station or soft-AP control block wrong"]
    #[doc = "    - ESP_ERR_WIFI_SSID: SSID of AP which station connects is invalid"]
    pub fn esp_wifi_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Disconnect the ESP32 WiFi station from the AP."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi was not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_FAIL: other WiFi internal errors"]
    pub fn esp_wifi_disconnect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Currently this API is just an stub API"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - others: fail"]
    pub fn esp_wifi_clear_fast_connect() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     deauthenticate all stations or associated id equals to aid"]
    #[doc = ""]
    #[doc = " @param     aid  when aid is 0, deauthenticate all stations, otherwise deauthenticate station whose associated id is aid"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    pub fn esp_wifi_deauth_sta(aid: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Scan all available APs."]
    #[doc = ""]
    #[doc = " @attention If this API is called, the found APs are stored in WiFi driver dynamic allocated memory and the"]
    #[doc = "            will be freed in esp_wifi_scan_get_ap_records, so generally, call esp_wifi_scan_get_ap_records to cause"]
    #[doc = "            the memory to be freed once the scan is done"]
    #[doc = " @attention The values of maximum active scan time and passive scan time per channel are limited to 1500 milliseconds."]
    #[doc = "            Values above 1500ms may cause station to disconnect from AP and are not recommended."]
    #[doc = ""]
    #[doc = " @param     config  configuration of scanning"]
    #[doc = " @param     block if block is true, this API will block the caller until the scan is done, otherwise"]
    #[doc = "                         it will return immediately"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi was not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_WIFI_TIMEOUT: blocking scan is timeout"]
    #[doc = "    - ESP_ERR_WIFI_STATE: wifi still connecting when invoke esp_wifi_scan_start"]
    #[doc = "    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_scan_start(config: *const wifi_scan_config_t, block: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Stop the scan in process"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_scan_stop() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get number of APs found in last scan"]
    #[doc = ""]
    #[doc = " @param[out] number  store number of APIs found in last scan"]
    #[doc = ""]
    #[doc = " @attention This API can only be called when the scan is completed, otherwise it may get wrong value."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_scan_get_ap_num(number: *mut u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get AP list found in last scan"]
    #[doc = ""]
    #[doc = " @param[inout]  number As input param, it stores max AP number ap_records can hold."]
    #[doc = "                As output param, it receives the actual AP number this API returns."]
    #[doc = " @param         ap_records  wifi_ap_record_t array to hold the found APs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_NO_MEM: out of memory"]
    pub fn esp_wifi_scan_get_ap_records(
        number: *mut u16,
        ap_records: *mut wifi_ap_record_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get information of AP which the ESP32 station is associated with"]
    #[doc = ""]
    #[doc = " @param     ap_info  the wifi_ap_record_t to hold AP information"]
    #[doc = "            sta can get the connected ap's phy mode info through the struct member"]
    #[doc = "            phy_11b\u{ff0c}phy_11g\u{ff0c}phy_11n\u{ff0c}phy_lr in the wifi_ap_record_t struct."]
    #[doc = "            For example, phy_11b = 1 imply that ap support 802.11b mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_CONN: The station interface don't initialized"]
    #[doc = "    - ESP_ERR_WIFI_NOT_CONNECT: The station is in disconnect status"]
    pub fn esp_wifi_sta_get_ap_info(ap_info: *mut wifi_ap_record_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set current WiFi power save type"]
    #[doc = ""]
    #[doc = " @attention Default power save type is WIFI_PS_MIN_MODEM."]
    #[doc = ""]
    #[doc = " @param     type  power save type"]
    #[doc = ""]
    #[doc = " @return    ESP_OK: succeed"]
    pub fn esp_wifi_set_ps(type_: wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current WiFi power save type"]
    #[doc = ""]
    #[doc = " @attention Default power save type is WIFI_PS_MIN_MODEM."]
    #[doc = ""]
    #[doc = " @param[out]  type: store current power save type"]
    #[doc = ""]
    #[doc = " @return    ESP_OK: succeed"]
    pub fn esp_wifi_get_ps(type_: *mut wifi_ps_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set protocol type of specified interface"]
    #[doc = "            The default protocol is (WIFI_PROTOCOL_11B|WIFI_PROTOCOL_11G|WIFI_PROTOCOL_11N)"]
    #[doc = ""]
    #[doc = " @attention Currently we only support 802.11b or 802.11bg or 802.11bgn mode"]
    #[doc = ""]
    #[doc = " @param     ifx  interfaces"]
    #[doc = " @param     protocol_bitmap  WiFi protocol bitmap"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_protocol(ifx: wifi_interface_t, protocol_bitmap: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the current protocol bitmap of the specified interface"]
    #[doc = ""]
    #[doc = " @param     ifx  interface"]
    #[doc = " @param[out] protocol_bitmap  store current WiFi protocol bitmap of interface ifx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_get_protocol(ifx: wifi_interface_t, protocol_bitmap: *mut u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the bandwidth of ESP32 specified interface"]
    #[doc = ""]
    #[doc = " @attention 1. API return false if try to configure an interface that is not enabled"]
    #[doc = " @attention 2. WIFI_BW_HT40 is supported only when the interface support 11N"]
    #[doc = ""]
    #[doc = " @param     ifx  interface to be configured"]
    #[doc = " @param     bw  bandwidth"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_bandwidth(ifx: wifi_interface_t, bw: wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the bandwidth of ESP32 specified interface"]
    #[doc = ""]
    #[doc = " @attention 1. API return false if try to get a interface that is not enable"]
    #[doc = ""]
    #[doc = " @param     ifx interface to be configured"]
    #[doc = " @param[out] bw  store bandwidth of interface ifx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_bandwidth(ifx: wifi_interface_t, bw: *mut wifi_bandwidth_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set primary/secondary channel of ESP32"]
    #[doc = ""]
    #[doc = " @attention 1. This is a special API for sniffer"]
    #[doc = " @attention 2. This API should be called after esp_wifi_start() or esp_wifi_set_promiscuous()"]
    #[doc = ""]
    #[doc = " @param     primary  for HT20, primary is the channel number, for HT40, primary is the primary channel"]
    #[doc = " @param     second   for HT20, second is ignored, for HT40, second is the second channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_channel(primary: u8, second: wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the primary/secondary channel of ESP32"]
    #[doc = ""]
    #[doc = " @attention 1. API return false if try to get a interface that is not enable"]
    #[doc = ""]
    #[doc = " @param     primary   store current primary channel"]
    #[doc = " @param[out]  second  store current second channel"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_channel(primary: *mut u8, second: *mut wifi_second_chan_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     configure country info"]
    #[doc = ""]
    #[doc = " @attention 1. The default country is {.cc=\"CN\", .schan=1, .nchan=13, policy=WIFI_COUNTRY_POLICY_AUTO}"]
    #[doc = " @attention 2. When the country policy is WIFI_COUNTRY_POLICY_AUTO, the country info of the AP to which"]
    #[doc = "               the station is connected is used. E.g. if the configured country info is {.cc=\"USA\", .schan=1, .nchan=11}"]
    #[doc = "               and the country info of the AP to which the station is connected is {.cc=\"JP\", .schan=1, .nchan=14}"]
    #[doc = "               then the country info that will be used is {.cc=\"JP\", .schan=1, .nchan=14}. If the station disconnected"]
    #[doc = "               from the AP the country info is set back back to the country info of the station automatically,"]
    #[doc = "               {.cc=\"USA\", .schan=1, .nchan=11} in the example."]
    #[doc = " @attention 3. When the country policy is WIFI_COUNTRY_POLICY_MANUAL, always use the configured country info."]
    #[doc = " @attention 4. When the country info is changed because of configuration or because the station connects to a different"]
    #[doc = "               external AP, the country IE in probe response/beacon of the soft-AP is changed also."]
    #[doc = " @attention 5. The country configuration is not stored into flash"]
    #[doc = " @attention 6. This API doesn't validate the per-country rules, it's up to the user to fill in all fields according to"]
    #[doc = "               local regulations."]
    #[doc = ""]
    #[doc = " @param     country   the configured country info"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_country(country: *const wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     get the current country info"]
    #[doc = ""]
    #[doc = " @param     country  country info"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_country(country: *mut wifi_country_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set MAC address of the ESP32 WiFi station or the soft-AP interface."]
    #[doc = ""]
    #[doc = " @attention 1. This API can only be called when the interface is disabled"]
    #[doc = " @attention 2. ESP32 soft-AP and station have different MAC addresses, do not set them to be the same."]
    #[doc = " @attention 3. The bit 0 of the first byte of ESP32 MAC address can not be 1. For example, the MAC address"]
    #[doc = "      can set to be \"1a:XX:XX:XX:XX:XX\", but can not be \"15:XX:XX:XX:XX:XX\"."]
    #[doc = ""]
    #[doc = " @param     ifx  interface"]
    #[doc = " @param     mac  the MAC address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_WIFI_MAC: invalid mac address"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    #[doc = "    - others: refer to error codes in esp_err.h"]
    pub fn esp_wifi_set_mac(ifx: wifi_interface_t, mac: *const u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mac of specified interface"]
    #[doc = ""]
    #[doc = " @param      ifx  interface"]
    #[doc = " @param[out] mac  store mac of the interface ifx"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_mac(ifx: wifi_interface_t, mac: *mut u8) -> esp_err_t;
}
#[doc = " @brief The RX callback function in the promiscuous mode."]
#[doc = "        Each time a packet is received, the callback function will be called."]
#[doc = ""]
#[doc = " @param buf  Data received. Type of data in buffer (wifi_promiscuous_pkt_t or wifi_pkt_rx_ctrl_t) indicated by 'type' parameter."]
#[doc = " @param type  promiscuous packet type."]
#[doc = ""]
pub type wifi_promiscuous_cb_t = ::core::option::Option<
    unsafe extern "C" fn(buf: *mut cty::c_void, type_: wifi_promiscuous_pkt_type_t),
>;
extern "C" {
    #[doc = " @brief Register the RX callback function in the promiscuous mode."]
    #[doc = ""]
    #[doc = " Each time a packet is received, the registered callback function will be called."]
    #[doc = ""]
    #[doc = " @param cb  callback"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_rx_cb(cb: wifi_promiscuous_cb_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Enable the promiscuous mode."]
    #[doc = ""]
    #[doc = " @param     en  false - disable, true - enable"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[out] en  store the current status of promiscuous mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous(en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the promiscuous mode packet type filter."]
    #[doc = ""]
    #[doc = " @note The default filter is to filter all packets except WIFI_PKT_MISC"]
    #[doc = ""]
    #[doc = " @param filter the packet type filtered in promiscuous mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_filter(filter: *const wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the promiscuous filter."]
    #[doc = ""]
    #[doc = " @param[out] filter  store the current status of promiscuous filter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_filter(filter: *mut wifi_promiscuous_filter_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable subtype filter of the control packet in promiscuous mode."]
    #[doc = ""]
    #[doc = " @note The default filter is to filter none control packet."]
    #[doc = ""]
    #[doc = " @param filter the subtype of the control packet filtered in promiscuous mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_promiscuous_ctrl_filter(
        filter: *const wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the subtype filter of the control packet in promiscuous mode."]
    #[doc = ""]
    #[doc = " @param[out] filter  store the current status of subtype filter of the control packet in promiscuous mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_promiscuous_ctrl_filter(
        filter: *mut wifi_promiscuous_filter_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the configuration of the ESP32 STA or AP"]
    #[doc = ""]
    #[doc = " @attention 1. This API can be called only when specified interface is enabled, otherwise, API fail"]
    #[doc = " @attention 2. For station configuration, bssid_set needs to be 0; and it needs to be 1 only when users need to check the MAC address of the AP."]
    #[doc = " @attention 3. ESP32 is limited to only one channel, so when in the soft-AP+station mode, the soft-AP will adjust its channel automatically to be the same as"]
    #[doc = "               the channel of the ESP32 station."]
    #[doc = ""]
    #[doc = " @param     interface  interface"]
    #[doc = " @param     conf  station or soft-AP configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    #[doc = "    - ESP_ERR_WIFI_MODE: invalid mode"]
    #[doc = "    - ESP_ERR_WIFI_PASSWORD: invalid password"]
    #[doc = "    - ESP_ERR_WIFI_NVS: WiFi internal NVS error"]
    #[doc = "    - others: refer to the erro code in esp_err.h"]
    pub fn esp_wifi_set_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get configuration of specified interface"]
    #[doc = ""]
    #[doc = " @param     interface  interface"]
    #[doc = " @param[out]  conf  station or soft-AP configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_IF: invalid interface"]
    pub fn esp_wifi_get_config(interface: wifi_interface_t, conf: *mut wifi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get STAs associated with soft-AP"]
    #[doc = ""]
    #[doc = " @attention SSC only API"]
    #[doc = ""]
    #[doc = " @param[out] sta  station list"]
    #[doc = "             ap can get the connected sta's phy mode info through the struct member"]
    #[doc = "             phy_11b\u{ff0c}phy_11g\u{ff0c}phy_11n\u{ff0c}phy_lr in the wifi_sta_info_t struct."]
    #[doc = "             For example, phy_11b = 1 imply that sta support 802.11b mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi mode is wrong"]
    #[doc = "    - ESP_ERR_WIFI_CONN: WiFi internal error, the station/soft-AP control block is invalid"]
    pub fn esp_wifi_ap_get_sta_list(sta: *mut wifi_sta_list_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set the WiFi API configuration storage type"]
    #[doc = ""]
    #[doc = " @attention 1. The default value is WIFI_STORAGE_FLASH"]
    #[doc = ""]
    #[doc = " @param     storage : storage type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - ESP_OK: succeed"]
    #[doc = "   - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "   - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_storage(storage: wifi_storage_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set auto connect"]
    #[doc = "            The default value is true"]
    #[doc = ""]
    #[doc = " @param     en : true - enable auto connect / false - disable auto connect"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_MODE: WiFi internal error, the station/soft-AP control block is invalid"]
    #[doc = "    - others: refer to error code in esp_err.h"]
    pub fn esp_wifi_set_auto_connect(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get the auto connect flag"]
    #[doc = ""]
    #[doc = " @param[out] en  store current auto connect configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_auto_connect(en: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set 802.11 Vendor-Specific Information Element"]
    #[doc = ""]
    #[doc = " @param     enable If true, specified IE is enabled. If false, specified IE is removed."]
    #[doc = " @param     type Information Element type. Determines the frame type to associate with the IE."]
    #[doc = " @param     idx  Index to set or clear. Each IE type can be associated with up to two elements (indices 0 & 1)."]
    #[doc = " @param     vnd_ie Pointer to vendor specific element data. First 6 bytes should be a header with fields matching vendor_ie_data_t."]
    #[doc = "            If enable is false, this argument is ignored and can be NULL. Data does not need to remain valid after the function returns."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init()"]
    #[doc = "    - ESP_ERR_INVALID_ARG: Invalid argument, including if first byte of vnd_ie is not WIFI_VENDOR_IE_ELEMENT_ID (0xDD)"]
    #[doc = "      or second byte is an invalid length."]
    #[doc = "    - ESP_ERR_NO_MEM: Out of memory"]
    pub fn esp_wifi_set_vendor_ie(
        enable: bool,
        type_: wifi_vendor_ie_type_t,
        idx: wifi_vendor_ie_id_t,
        vnd_ie: *const cty::c_void,
    ) -> esp_err_t;
}
#[doc = " @brief     Function signature for received Vendor-Specific Information Element callback."]
#[doc = " @param     ctx Context argument, as passed to esp_wifi_set_vendor_ie_cb() when registering callback."]
#[doc = " @param     type Information element type, based on frame type received."]
#[doc = " @param     sa Source 802.11 address."]
#[doc = " @param     vnd_ie Pointer to the vendor specific element data received."]
#[doc = " @param     rssi Received signal strength indication."]
pub type esp_vendor_ie_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut cty::c_void,
        type_: wifi_vendor_ie_type_t,
        sa: *const u8,
        vnd_ie: *const vendor_ie_data_t,
        rssi: cty::c_int,
    ),
>;
extern "C" {
    #[doc = " @brief     Register Vendor-Specific Information Element monitoring callback."]
    #[doc = ""]
    #[doc = " @param     cb   Callback function"]
    #[doc = " @param     ctx  Context argument, passed to callback function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_vendor_ie_cb(cb: esp_vendor_ie_cb_t, ctx: *mut cty::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set maximum WiFi transmiting power"]
    #[doc = ""]
    #[doc = " @attention WiFi transmiting power is divided to six levels in phy init data."]
    #[doc = "            Level0 represents highest transmiting power and level5 represents lowest"]
    #[doc = "            transmiting power. Packets of different rates are transmitted in"]
    #[doc = "            different powers according to the configuration in phy init data."]
    #[doc = "            This API only sets maximum WiFi transmiting power. If this API is called,"]
    #[doc = "            the transmiting power of every packet will be less than or equal to the"]
    #[doc = "            value set by this API. If this API is not called, the value of maximum"]
    #[doc = "            transmitting power set in phy_init_data.bin or menuconfig (depend on"]
    #[doc = "            whether to use phy init data in partition or not) will be used. Default"]
    #[doc = "            value is level0. Values passed in power are mapped to transmit power"]
    #[doc = "            levels as follows:"]
    #[doc = "            - [78, 127]: level0"]
    #[doc = "            - [76, 77]: level1"]
    #[doc = "            - [74, 75]: level2"]
    #[doc = "            - [68, 73]: level3"]
    #[doc = "            - [60, 67]: level4"]
    #[doc = "            - [52, 59]: level5"]
    #[doc = "            - [44, 51]: level5 - 2dBm"]
    #[doc = "            - [34, 43]: level5 - 4.5dBm"]
    #[doc = "            - [28, 33]: level5 - 6dBm"]
    #[doc = "            - [20, 27]: level5 - 8dBm"]
    #[doc = "            - [8, 19]: level5 - 11dBm"]
    #[doc = "            - [-128, 7]: level5 - 14dBm"]
    #[doc = ""]
    #[doc = " @param     power  Maximum WiFi transmiting power."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_START: WiFi is not started by esp_wifi_start"]
    pub fn esp_wifi_set_max_tx_power(power: i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get maximum WiFi transmiting power"]
    #[doc = ""]
    #[doc = " @attention This API gets maximum WiFi transmiting power. Values got"]
    #[doc = "            from power are mapped to transmit power levels as follows:"]
    #[doc = "            - 78: 19.5dBm"]
    #[doc = "            - 76: 19dBm"]
    #[doc = "            - 74: 18.5dBm"]
    #[doc = "            - 68: 17dBm"]
    #[doc = "            - 60: 15dBm"]
    #[doc = "            - 52: 13dBm"]
    #[doc = "            - 44: 11dBm"]
    #[doc = "            - 34: 8.5dBm"]
    #[doc = "            - 28: 7dBm"]
    #[doc = "            - 20: 5dBm"]
    #[doc = "            - 8:  2dBm"]
    #[doc = "            - -4: -1dBm"]
    #[doc = ""]
    #[doc = " @param     power  Maximum WiFi transmiting power."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_START: WiFi is not started by esp_wifi_start"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_get_max_tx_power(power: *mut i8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set mask to enable or disable some WiFi events"]
    #[doc = ""]
    #[doc = " @attention 1. Mask can be created by logical OR of various WIFI_EVENT_MASK_ constants."]
    #[doc = "               Events which have corresponding bit set in the mask will not be delivered to the system event handler."]
    #[doc = " @attention 2. Default WiFi event mask is WIFI_EVENT_MASK_AP_PROBEREQRECVED."]
    #[doc = " @attention 3. There may be lots of stations sending probe request data around."]
    #[doc = "               Don't unmask this event unless you need to receive probe request data."]
    #[doc = ""]
    #[doc = " @param     mask  WiFi event mask."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_event_mask(mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get mask of WiFi events"]
    #[doc = ""]
    #[doc = " @param     mask  WiFi event mask."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument"]
    pub fn esp_wifi_get_event_mask(mask: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Send raw ieee80211 data"]
    #[doc = ""]
    #[doc = " @attention Currently only support for sending beacon/probe request/probe response/action and non-QoS"]
    #[doc = "            data frame"]
    #[doc = ""]
    #[doc = " @param     ifx interface if the Wi-Fi mode is Station, the ifx should be WIFI_IF_STA. If the Wi-Fi"]
    #[doc = "            mode is SoftAP, the ifx should be WIFI_IF_AP. If the Wi-Fi mode is Station+SoftAP, the"]
    #[doc = "            ifx should be WIFI_IF_STA or WIFI_IF_AP. If the ifx is wrong, the API returns ESP_ERR_WIFI_IF."]
    #[doc = " @param     buffer raw ieee80211 buffer"]
    #[doc = " @param     len the length of raw buffer, the len must be <= 1500 Bytes and >= 24 Bytes"]
    #[doc = " @param     en_sys_seq indicate whether use the internal sequence number. If en_sys_seq is false, the"]
    #[doc = "            sequence in raw buffer is unchanged, otherwise it will be overwritten by WiFi driver with"]
    #[doc = "            the system sequence number."]
    #[doc = "            Generally, if esp_wifi_80211_tx is called before the Wi-Fi connection has been set up, both"]
    #[doc = "            en_sys_seq==true and en_sys_seq==false are fine. However, if the API is called after the Wi-Fi"]
    #[doc = "            connection has been set up, en_sys_seq must be true, otherwise ESP_ERR_WIFI_ARG is returned."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: success"]
    #[doc = "    - ESP_ERR_WIFI_IF: Invalid interface"]
    #[doc = "    - ESP_ERR_INVALID_ARG: Invalid parameter"]
    #[doc = "    - ESP_ERR_WIFI_NO_MEM: out of memory"]
    pub fn esp_wifi_80211_tx(
        ifx: wifi_interface_t,
        buffer: *const cty::c_void,
        len: cty::c_int,
        en_sys_seq: bool,
    ) -> esp_err_t;
}
#[doc = " @brief The RX callback function of Channel State Information(CSI)  data."]
#[doc = ""]
#[doc = "        Each time a CSI data is received, the callback function will be called."]
#[doc = ""]
#[doc = " @param ctx context argument, passed to esp_wifi_set_csi_rx_cb() when registering callback function."]
#[doc = " @param data CSI data received. The memory that it points to will be deallocated after callback function returns."]
#[doc = ""]
pub type wifi_csi_cb_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut cty::c_void, data: *mut wifi_csi_info_t)>;
extern "C" {
    #[doc = " @brief Register the RX callback function of CSI data."]
    #[doc = ""]
    #[doc = "        Each time a CSI data is received, the callback function will be called."]
    #[doc = ""]
    #[doc = " @param cb  callback"]
    #[doc = " @param ctx context argument, passed to callback function"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    pub fn esp_wifi_set_csi_rx_cb(cb: wifi_csi_cb_t, ctx: *mut cty::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set CSI data configuration"]
    #[doc = ""]
    #[doc = " @param config configuration"]
    #[doc = ""]
    #[doc = " return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_START: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi_config(config: *const wifi_csi_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable or disable CSI"]
    #[doc = ""]
    #[doc = " @param en true - enable, false - disable"]
    #[doc = ""]
    #[doc = " return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_NOT_START: WiFi is not started by esp_wifi_start or promiscuous mode is not enabled"]
    #[doc = "    - ESP_ERR_INVALID_ARG: invalid argument"]
    pub fn esp_wifi_set_csi(en: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna GPIO configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna GPIO configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: Invalid argument, e.g. parameter is NULL, invalid GPIO number etc"]
    pub fn esp_wifi_set_ant_gpio(config: *const wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna GPIO configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna GPIO configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant_gpio(config: *mut wifi_ant_gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Set antenna configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: Invalid argument, e.g. parameter is NULL, invalid antenna mode or invalid GPIO number"]
    pub fn esp_wifi_set_ant(config: *const wifi_ant_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     Get current antenna configuration"]
    #[doc = ""]
    #[doc = " @param     config  Antenna configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK: succeed"]
    #[doc = "    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init"]
    #[doc = "    - ESP_ERR_WIFI_ARG: invalid argument, e.g. parameter is NULL"]
    pub fn esp_wifi_get_ant(config: *mut wifi_ant_config_t) -> esp_err_t;
}
#[doc = " @brief  Application specified event callback function"]
#[doc = ""]
#[doc = " @param  void *ctx : reserved for user"]
#[doc = " @param  system_event_t *event : event type defined in this file"]
#[doc = ""]
#[doc = " @return ESP_OK : succeed"]
#[doc = " @return others : fail"]
pub type system_event_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut cty::c_void, event: *mut system_event_t) -> esp_err_t,
>;
extern "C" {
    #[doc = " @brief  Initialize event loop"]
    #[doc = "         Create the event handler and task"]
    #[doc = ""]
    #[doc = " @param  system_event_cb_t cb : application specified event callback, it can be modified by call esp_event_set_cb"]
    #[doc = " @param  void *ctx : reserved for user"]
    #[doc = ""]
    #[doc = " @return ESP_OK : succeed"]
    #[doc = " @return others : fail"]
    pub fn esp_event_loop_init(cb: system_event_cb_t, ctx: *mut cty::c_void) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Set application specified event callback function"]
    #[doc = ""]
    #[doc = " @attention 1. If cb is NULL, means application don't need to handle"]
    #[doc = "               If cb is not NULL, it will be call when an event is received, after the default event callback is completed"]
    #[doc = ""]
    #[doc = " @param  system_event_cb_t cb : callback"]
    #[doc = " @param  void *ctx : reserved for user"]
    #[doc = ""]
    #[doc = " @return system_event_cb_t : old callback"]
    pub fn esp_event_loop_set_cb(cb: system_event_cb_t, ctx: *mut cty::c_void)
        -> system_event_cb_t;
}
extern "C" {
    #[doc = " @brief  Get the queue used by event loop"]
    #[doc = ""]
    #[doc = " @attention : currently this API is used to initialize \"q\" parameter"]
    #[doc = " of wifi_init structure."]
    #[doc = ""]
    #[doc = " @return QueueHandle_t : event queue handle"]
    pub fn esp_event_loop_get_queue() -> QueueHandle_t;
}
#[doc = "< No log output"]
pub const esp_log_level_t_ESP_LOG_NONE: esp_log_level_t = 0;
#[doc = "< Critical errors, software module can not recover on its own"]
pub const esp_log_level_t_ESP_LOG_ERROR: esp_log_level_t = 1;
#[doc = "< Error conditions from which recovery measures have been taken"]
pub const esp_log_level_t_ESP_LOG_WARN: esp_log_level_t = 2;
#[doc = "< Information messages which describe normal flow of events"]
pub const esp_log_level_t_ESP_LOG_INFO: esp_log_level_t = 3;
#[doc = "< Extra information which is not necessary for normal use (values, pointers, sizes, etc)."]
pub const esp_log_level_t_ESP_LOG_DEBUG: esp_log_level_t = 4;
#[doc = "< Bigger chunks of debugging information, or frequent messages which can potentially flood the output."]
pub const esp_log_level_t_ESP_LOG_VERBOSE: esp_log_level_t = 5;
#[doc = " @brief Log level"]
#[doc = ""]
pub type esp_log_level_t = u32;
pub type vprintf_like_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const cty::c_char, arg2: va_list) -> cty::c_int,
>;
extern "C" {
    #[doc = " @brief Set log level for given tag"]
    #[doc = ""]
    #[doc = " If logging for given component has already been enabled, changes previous setting."]
    #[doc = ""]
    #[doc = " Note that this function can not raise log level above the level set using"]
    #[doc = " CONFIG_LOG_DEFAULT_LEVEL setting in menuconfig."]
    #[doc = ""]
    #[doc = " To raise log level above the default one for a given file, define"]
    #[doc = " LOG_LOCAL_LEVEL to one of the ESP_LOG_* values, before including"]
    #[doc = " esp_log.h in this file."]
    #[doc = ""]
    #[doc = " @param tag Tag of the log entries to enable. Must be a non-NULL zero terminated string."]
    #[doc = "            Value \"*\" resets log level for all tags to the given value."]
    #[doc = ""]
    #[doc = " @param level  Selects log level to enable. Only logs at this and lower verbosity"]
    #[doc = " levels will be shown."]
    pub fn esp_log_level_set(tag: *const cty::c_char, level: esp_log_level_t);
}
extern "C" {
    #[doc = " @brief Set function used to output log entries"]
    #[doc = ""]
    #[doc = " By default, log output goes to UART0. This function can be used to redirect log"]
    #[doc = " output to some other destination, such as file or network. Returns the original"]
    #[doc = " log handler, which may be necessary to return output to the previous destination."]
    #[doc = ""]
    #[doc = " @param func new Function used for output. Must have same signature as vprintf."]
    #[doc = ""]
    #[doc = " @return func old Function used for output."]
    pub fn esp_log_set_vprintf(func: vprintf_like_t) -> vprintf_like_t;
}
extern "C" {
    #[doc = " @brief Function which returns timestamp to be used in log output"]
    #[doc = ""]
    #[doc = " This function is used in expansion of ESP_LOGx macros."]
    #[doc = " In the 2nd stage bootloader, and at early application startup stage"]
    #[doc = " this function uses CPU cycle counter as time source. Later when"]
    #[doc = " FreeRTOS scheduler start running, it switches to FreeRTOS tick count."]
    #[doc = ""]
    #[doc = " For now, we ignore millisecond counter overflow."]
    #[doc = ""]
    #[doc = " @return timestamp, in milliseconds"]
    pub fn esp_log_timestamp() -> u32;
}
extern "C" {
    #[doc = " @brief Function which returns timestamp to be used in log output"]
    #[doc = ""]
    #[doc = " This function uses HW cycle counter and does not depend on OS,"]
    #[doc = " so it can be safely used after application crash."]
    #[doc = ""]
    #[doc = " @return timestamp, in milliseconds"]
    pub fn esp_log_early_timestamp() -> u32;
}
extern "C" {
    #[doc = " @brief Write message into the log"]
    #[doc = ""]
    #[doc = " This function is not intended to be used directly. Instead, use one of"]
    #[doc = " ESP_LOGE, ESP_LOGW, ESP_LOGI, ESP_LOGD, ESP_LOGV macros."]
    #[doc = ""]
    #[doc = " This function or these macros should not be used from an interrupt."]
    pub fn esp_log_write(
        level: esp_log_level_t,
        tag: *const cty::c_char,
        format: *const cty::c_char,
        ...
    );
}
extern "C" {
    pub fn esp_log_buffer_hex_internal(
        tag: *const cty::c_char,
        buffer: *const cty::c_void,
        buff_len: u16,
        level: esp_log_level_t,
    );
}
extern "C" {
    pub fn esp_log_buffer_char_internal(
        tag: *const cty::c_char,
        buffer: *const cty::c_void,
        buff_len: u16,
        level: esp_log_level_t,
    );
}
extern "C" {
    pub fn esp_log_buffer_hexdump_internal(
        tag: *const cty::c_char,
        buffer: *const cty::c_void,
        buff_len: u16,
        log_level: esp_log_level_t,
    );
}
#[doc = " Opaque pointer type representing non-volatile storage handle"]
pub type nvs_handle = u32;
#[doc = "< Read only"]
pub const nvs_open_mode_NVS_READONLY: nvs_open_mode = 0;
#[doc = "< Read and write"]
pub const nvs_open_mode_NVS_READWRITE: nvs_open_mode = 1;
#[doc = " @brief Mode of opening the non-volatile storage"]
#[doc = ""]
pub type nvs_open_mode = u32;
pub const nvs_type_t_NVS_TYPE_U8: nvs_type_t = 1;
pub const nvs_type_t_NVS_TYPE_I8: nvs_type_t = 17;
pub const nvs_type_t_NVS_TYPE_U16: nvs_type_t = 2;
pub const nvs_type_t_NVS_TYPE_I16: nvs_type_t = 18;
pub const nvs_type_t_NVS_TYPE_U32: nvs_type_t = 4;
pub const nvs_type_t_NVS_TYPE_I32: nvs_type_t = 20;
pub const nvs_type_t_NVS_TYPE_U64: nvs_type_t = 8;
pub const nvs_type_t_NVS_TYPE_I64: nvs_type_t = 24;
pub const nvs_type_t_NVS_TYPE_STR: nvs_type_t = 33;
pub const nvs_type_t_NVS_TYPE_BLOB: nvs_type_t = 66;
pub const nvs_type_t_NVS_TYPE_ANY: nvs_type_t = 255;
pub type nvs_type_t = u32;
extern "C" {
    #[doc = " @brief      Open non-volatile storage with a given namespace from the default NVS partition"]
    #[doc = ""]
    #[doc = " Multiple internal ESP-IDF and third party application modules can store"]
    #[doc = " their key-value pairs in the NVS module. In order to reduce possible"]
    #[doc = " conflicts on key names, each module can use its own namespace."]
    #[doc = " The default NVS partition is the one that is labelled \"nvs\" in the partition"]
    #[doc = " table."]
    #[doc = ""]
    #[doc = " @param[in]  name        Namespace name. Maximal length is determined by the"]
    #[doc = "                         underlying implementation, but is guaranteed to be"]
    #[doc = "                         at least 15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  open_mode   NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will"]
    #[doc = "                         open a handle for reading only. All write requests will"]
    #[doc = "\t\t\t   be rejected for this handle."]
    #[doc = " @param[out] out_handle  If successful (return code is zero), handle will be"]
    #[doc = "                         returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if storage handle was opened successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized"]
    #[doc = "             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with label \"nvs\" is not found"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and"]
    #[doc = "               mode is NVS_READONLY"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints"]
    #[doc = "             - other error codes from the underlying storage driver"]
    pub fn nvs_open(
        name: *const cty::c_char,
        open_mode: nvs_open_mode,
        out_handle: *mut nvs_handle,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Open non-volatile storage with a given namespace from specified partition"]
    #[doc = ""]
    #[doc = " The behaviour is same as nvs_open() API. However this API can operate on a specified NVS"]
    #[doc = " partition instead of default NVS partition. Note that the specified partition must be registered"]
    #[doc = " with NVS using nvs_flash_init_partition() API."]
    #[doc = ""]
    #[doc = " @param[in]  part_name   Label (name) of the partition of interest for object read/write/erase"]
    #[doc = " @param[in]  name        Namespace name. Maximal length is determined by the"]
    #[doc = "                         underlying implementation, but is guaranteed to be"]
    #[doc = "                         at least 15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  open_mode   NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will"]
    #[doc = "                         open a handle for reading only. All write requests will"]
    #[doc = "\t\t\t   be rejected for this handle."]
    #[doc = " @param[out] out_handle  If successful (return code is zero), handle will be"]
    #[doc = "                         returned in this argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if storage handle was opened successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized"]
    #[doc = "             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with specified name is not found"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND id namespace doesn't exist yet and"]
    #[doc = "               mode is NVS_READONLY"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if namespace name doesn't satisfy constraints"]
    #[doc = "             - other error codes from the underlying storage driver"]
    pub fn nvs_open_from_partition(
        part_name: *const cty::c_char,
        name: *const cty::c_char,
        open_mode: nvs_open_mode,
        out_handle: *mut nvs_handle,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " @brief      set value for given key"]
    #[doc = ""]
    #[doc = " This family of functions set value for the key, given its name. Note that"]
    #[doc = " actual storage will not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Handle obtained from nvs_open function."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = " @param[in]  key     Key name. Maximal length is determined by the underlying"]
    #[doc = "                     implementation, but is guaranteed to be at least"]
    #[doc = "                     15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  value   The value to set."]
    #[doc = "                     For strings, the maximum length (including null character) is"]
    #[doc = "                     4000 bytes."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if value was set successfully"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the"]
    #[doc = "               underlying storage to save the value"]
    #[doc = "             - ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash"]
    #[doc = "               write operation has failed. The value was written however, and"]
    #[doc = "               update will be finished after re-initialization of nvs, provided that"]
    #[doc = "               flash operation doesn't fail again."]
    #[doc = "             - ESP_ERR_NVS_VALUE_TOO_LONG if the string value is too long"]
    pub fn nvs_set_i8(handle: nvs_handle, key: *const cty::c_char, value: i8) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u8(handle: nvs_handle, key: *const cty::c_char, value: u8) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i16(handle: nvs_handle, key: *const cty::c_char, value: i16) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u16(handle: nvs_handle, key: *const cty::c_char, value: u16) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i32(handle: nvs_handle, key: *const cty::c_char, value: i32) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u32(handle: nvs_handle, key: *const cty::c_char, value: u32) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_i64(handle: nvs_handle, key: *const cty::c_char, value: i64) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_u64(handle: nvs_handle, key: *const cty::c_char, value: u64) -> esp_err_t;
}
extern "C" {
    pub fn nvs_set_str(
        handle: nvs_handle,
        key: *const cty::c_char,
        value: *const cty::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief       set variable length binary value for given key"]
    #[doc = ""]
    #[doc = " This family of functions set value for the key, given its name. Note that"]
    #[doc = " actual storage will not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Handle obtained from nvs_open function."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = " @param[in]  key     Key name. Maximal length is 15 characters. Shouldn't be empty."]
    #[doc = " @param[in]  value   The value to set."]
    #[doc = " @param[in]  length  length of binary value to set, in bytes; Maximum length is"]
    #[doc = "                     508000 bytes or (97.6% of the partition size - 4000) bytes"]
    #[doc = "                     whichever is lower."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if value was set successfully"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the"]
    #[doc = "               underlying storage to save the value"]
    #[doc = "             - ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash"]
    #[doc = "               write operation has failed. The value was written however, and"]
    #[doc = "               update will be finished after re-initialization of nvs, provided that"]
    #[doc = "               flash operation doesn't fail again."]
    #[doc = "             - ESP_ERR_NVS_VALUE_TOO_LONG if the value is too long"]
    pub fn nvs_set_blob(
        handle: nvs_handle,
        key: *const cty::c_char,
        value: *const cty::c_void,
        length: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " @brief      get value for given key"]
    #[doc = ""]
    #[doc = " These functions retrieve value for the key, given its name. If key does not"]
    #[doc = " exist, or the requested variable type doesn't match the type which was used"]
    #[doc = " when setting a value, an error is returned."]
    #[doc = ""]
    #[doc = " In case of any error, out_value is not modified."]
    #[doc = ""]
    #[doc = " All functions expect out_value to be a pointer to an already allocated variable"]
    #[doc = " of the given type."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example of using nvs_get_i32:"]
    #[doc = " int32_t max_buffer_size = 4096; // default value"]
    #[doc = " esp_err_t err = nvs_get_i32(my_handle, \"max_buffer_size\", &max_buffer_size);"]
    #[doc = " assert(err == ESP_OK || err == ESP_ERR_NVS_NOT_FOUND);"]
    #[doc = " // if ESP_ERR_NVS_NOT_FOUND was returned, max_buffer_size will still"]
    #[doc = " // have its default value."]
    #[doc = ""]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]     handle     Handle obtained from nvs_open function."]
    #[doc = " @param[in]     key        Key name. Maximal length is determined by the underlying"]
    #[doc = "                           implementation, but is guaranteed to be at least"]
    #[doc = "                           15 characters. Shouldn't be empty."]
    #[doc = " @param         out_value  Pointer to the output value."]
    #[doc = "                           May be NULL for nvs_get_str and nvs_get_blob, in this"]
    #[doc = "                           case required length will be returned in length argument."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the value was retrieved successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data"]
    pub fn nvs_get_i8(handle: nvs_handle, key: *const cty::c_char, out_value: *mut i8)
        -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u8(handle: nvs_handle, key: *const cty::c_char, out_value: *mut u8)
        -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i16(
        handle: nvs_handle,
        key: *const cty::c_char,
        out_value: *mut i16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u16(
        handle: nvs_handle,
        key: *const cty::c_char,
        out_value: *mut u16,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i32(
        handle: nvs_handle,
        key: *const cty::c_char,
        out_value: *mut i32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u32(
        handle: nvs_handle,
        key: *const cty::c_char,
        out_value: *mut u32,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_i64(
        handle: nvs_handle,
        key: *const cty::c_char,
        out_value: *mut i64,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_u64(
        handle: nvs_handle,
        key: *const cty::c_char,
        out_value: *mut u64,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      get value for given key"]
    #[doc = ""]
    #[doc = " These functions retrieve value for the key, given its name. If key does not"]
    #[doc = " exist, or the requested variable type doesn't match the type which was used"]
    #[doc = " when setting a value, an error is returned."]
    #[doc = ""]
    #[doc = " In case of any error, out_value is not modified."]
    #[doc = ""]
    #[doc = " All functions expect out_value to be a pointer to an already allocated variable"]
    #[doc = " of the given type."]
    #[doc = ""]
    #[doc = " nvs_get_str and nvs_get_blob functions support WinAPI-style length queries."]
    #[doc = " To get the size necessary to store the value, call nvs_get_str or nvs_get_blob"]
    #[doc = " with zero out_value and non-zero pointer to length. Variable pointed to"]
    #[doc = " by length argument will be set to the required length. For nvs_get_str,"]
    #[doc = " this length includes the zero terminator. When calling nvs_get_str and"]
    #[doc = " nvs_get_blob with non-zero out_value, length has to be non-zero and has to"]
    #[doc = " point to the length available in out_value."]
    #[doc = " It is suggested that nvs_get/set_str is used for zero-terminated C strings, and"]
    #[doc = " nvs_get/set_blob used for arbitrary data structures."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example (without error checking) of using nvs_get_str to get a string into dynamic array:"]
    #[doc = " size_t required_size;"]
    #[doc = " nvs_get_str(my_handle, \"server_name\", NULL, &required_size);"]
    #[doc = " char* server_name = malloc(required_size);"]
    #[doc = " nvs_get_str(my_handle, \"server_name\", server_name, &required_size);"]
    #[doc = ""]
    #[doc = " // Example (without error checking) of using nvs_get_blob to get a binary data"]
    #[doc = " into a static array:"]
    #[doc = " uint8_t mac_addr[6];"]
    #[doc = " size_t size = sizeof(mac_addr);"]
    #[doc = " nvs_get_blob(my_handle, \"dst_mac_addr\", mac_addr, &size);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]     handle     Handle obtained from nvs_open function."]
    #[doc = " @param[in]     key        Key name. Maximal length is determined by the underlying"]
    #[doc = "                           implementation, but is guaranteed to be at least"]
    #[doc = "                           15 characters. Shouldn't be empty."]
    #[doc = " @param         out_value  Pointer to the output value."]
    #[doc = "                           May be NULL for nvs_get_str and nvs_get_blob, in this"]
    #[doc = "                           case required length will be returned in length argument."]
    #[doc = " @param[inout]  length     A non-zero pointer to the variable holding the length of out_value."]
    #[doc = "                           In case out_value a zero, will be set to the length"]
    #[doc = "                           required to hold the value. In case out_value is not"]
    #[doc = "                           zero, will be set to the actual length of the value"]
    #[doc = "                           written. For nvs_get_str this includes zero terminator."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the value was retrieved successfully"]
    #[doc = "             - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints"]
    #[doc = "             - ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data"]
    pub fn nvs_get_str(
        handle: nvs_handle,
        key: *const cty::c_char,
        out_value: *mut cty::c_char,
        length: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    pub fn nvs_get_blob(
        handle: nvs_handle,
        key: *const cty::c_char,
        out_value: *mut cty::c_void,
        length: *mut usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Erase key-value pair with given key name."]
    #[doc = ""]
    #[doc = " Note that actual storage may not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle obtained with nvs_open."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = ""]
    #[doc = " @param[in]  key     Key name. Maximal length is determined by the underlying"]
    #[doc = "                     implementation, but is guaranteed to be at least"]
    #[doc = "                     15 characters. Shouldn't be empty."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "              - ESP_OK if erase operation was successful"]
    #[doc = "              - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "              - ESP_ERR_NVS_READ_ONLY if handle was opened as read only"]
    #[doc = "              - ESP_ERR_NVS_NOT_FOUND if the requested key doesn't exist"]
    #[doc = "              - other error codes from the underlying storage driver"]
    pub fn nvs_erase_key(handle: nvs_handle, key: *const cty::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Erase all key-value pairs in a namespace"]
    #[doc = ""]
    #[doc = " Note that actual storage may not be updated until nvs_commit function is called."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle obtained with nvs_open."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "              - ESP_OK if erase operation was successful"]
    #[doc = "              - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "              - ESP_ERR_NVS_READ_ONLY if handle was opened as read only"]
    #[doc = "              - other error codes from the underlying storage driver"]
    pub fn nvs_erase_all(handle: nvs_handle) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Write any pending changes to non-volatile storage"]
    #[doc = ""]
    #[doc = " After setting any values, nvs_commit() must be called to ensure changes are written"]
    #[doc = " to non-volatile storage. Individual implementations may write to storage at other times,"]
    #[doc = " but this is not guaranteed."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle obtained with nvs_open."]
    #[doc = "                     Handles that were opened read only cannot be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the changes have been written successfully"]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL"]
    #[doc = "             - other error codes from the underlying storage driver"]
    pub fn nvs_commit(handle: nvs_handle) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Close the storage handle and free any allocated resources"]
    #[doc = ""]
    #[doc = " This function should be called for each handle opened with nvs_open once"]
    #[doc = " the handle is not in use any more. Closing the handle may not automatically"]
    #[doc = " write the changes to nonvolatile storage. This has to be done explicitly using"]
    #[doc = " nvs_commit function."]
    #[doc = " Once this function is called on a handle, the handle should no longer be used."]
    #[doc = ""]
    #[doc = " @param[in]  handle  Storage handle to close"]
    pub fn nvs_close(handle: nvs_handle);
}
#[doc = " @note Info about storage space NVS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvs_stats_t {
    #[doc = "< Amount of used entries."]
    pub used_entries: usize,
    #[doc = "< Amount of free entries."]
    pub free_entries: usize,
    #[doc = "< Amount all available entries."]
    pub total_entries: usize,
    #[doc = "< Amount name space."]
    pub namespace_count: usize,
}
extern "C" {
    #[doc = " @brief      Fill structure nvs_stats_t. It provides info about used memory the partition."]
    #[doc = ""]
    #[doc = " This function calculates to runtime the number of used entries, free entries, total entries,"]
    #[doc = " and amount namespace in partition."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example of nvs_get_stats() to get the number of used entries and free entries:"]
    #[doc = " nvs_stats_t nvs_stats;"]
    #[doc = " nvs_get_stats(NULL, &nvs_stats);"]
    #[doc = " printf(\"Count: UsedEntries = (%d), FreeEntries = (%d), AllEntries = (%d)\\n\","]
    #[doc = "nvs_stats.used_entries, nvs_stats.free_entries, nvs_stats.total_entries);"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]   part_name   Partition name NVS in the partition table."]
    #[doc = "                          If pass a NULL than will use NVS_DEFAULT_PART_NAME (\"nvs\")."]
    #[doc = ""]
    #[doc = " @param[out]  nvs_stats   Returns filled structure nvs_states_t."]
    #[doc = "                          It provides info about used memory the partition."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the changes have been written successfully."]
    #[doc = "               Return param nvs_stats will be filled."]
    #[doc = "             - ESP_ERR_NVS_PART_NOT_FOUND if the partition with label \"name\" is not found."]
    #[doc = "               Return param nvs_stats will be filled 0."]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized."]
    #[doc = "               Return param nvs_stats will be filled 0."]
    #[doc = "             - ESP_ERR_INVALID_ARG if nvs_stats equal to NULL."]
    #[doc = "             - ESP_ERR_INVALID_STATE if there is page with the status of INVALID."]
    #[doc = "               Return param nvs_stats will be filled not with correct values because"]
    #[doc = "               not all pages will be counted. Counting will be interrupted at the first INVALID page."]
    pub fn nvs_get_stats(part_name: *const cty::c_char, nvs_stats: *mut nvs_stats_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Calculate all entries in a namespace."]
    #[doc = ""]
    #[doc = " Note that to find out the total number of records occupied by the namespace,"]
    #[doc = " add one to the returned value used_entries (if err is equal to ESP_OK)."]
    #[doc = " Because the name space entry takes one entry."]
    #[doc = ""]
    #[doc = " \\code{c}"]
    #[doc = " // Example of nvs_get_used_entry_count() to get amount of all key-value pairs in one namespace:"]
    #[doc = " nvs_handle handle;"]
    #[doc = " nvs_open(\"namespace1\", NVS_READWRITE, &handle);"]
    #[doc = " ..."]
    #[doc = " size_t used_entries;"]
    #[doc = " size_t total_entries_namespace;"]
    #[doc = " if(nvs_get_used_entry_count(handle, &used_entries) == ESP_OK){"]
    #[doc = "     // the total number of records occupied by the namespace"]
    #[doc = "     total_entries_namespace = used_entries + 1;"]
    #[doc = " }"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " @param[in]   handle              Handle obtained from nvs_open function."]
    #[doc = ""]
    #[doc = " @param[out]  used_entries        Returns amount of used entries from a namespace."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK if the changes have been written successfully."]
    #[doc = "               Return param used_entries will be filled valid value."]
    #[doc = "             - ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized."]
    #[doc = "               Return param used_entries will be filled 0."]
    #[doc = "             - ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL."]
    #[doc = "               Return param used_entries will be filled 0."]
    #[doc = "             - ESP_ERR_INVALID_ARG if nvs_stats equal to NULL."]
    #[doc = "             - Other error codes from the underlying storage driver."]
    #[doc = "               Return param used_entries will be filled 0."]
    pub fn nvs_get_used_entry_count(handle: nvs_handle, used_entries: *mut usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Initialize SPI flash access driver"]
    #[doc = ""]
    #[doc = "  This function must be called exactly once, before any other"]
    #[doc = "  spi_flash_* functions are called."]
    #[doc = "  Currently this function is called from startup code. There is"]
    #[doc = "  no need to call it from application code."]
    #[doc = ""]
    pub fn spi_flash_init();
}
extern "C" {
    #[doc = " @brief  Get flash chip size, as set in binary image header"]
    #[doc = ""]
    #[doc = " @note This value does not necessarily match real flash size."]
    #[doc = ""]
    #[doc = " @return size of flash chip, in bytes"]
    pub fn spi_flash_get_chip_size() -> usize;
}
extern "C" {
    #[doc = " @brief  Erase the Flash sector."]
    #[doc = ""]
    #[doc = " @param  sector  Sector number, the count starts at sector 0, 4KB per sector."]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_erase_sector(sector: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Erase a range of flash sectors"]
    #[doc = ""]
    #[doc = " @param  start_address  Address where erase operation has to start."]
    #[doc = "                                  Must be 4kB-aligned"]
    #[doc = " @param  size  Size of erased range, in bytes. Must be divisible by 4kB."]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_erase_range(start_address: usize, size: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Write data to Flash."]
    #[doc = ""]
    #[doc = " @note For fastest write performance, write a 4 byte aligned size at a"]
    #[doc = " 4 byte aligned offset in flash from a source buffer in DRAM. Varying any of"]
    #[doc = " these parameters will still work, but will be slower due to buffering."]
    #[doc = ""]
    #[doc = " @note Writing more than 8KB at a time will be split into multiple"]
    #[doc = " write operations to avoid disrupting other tasks in the system."]
    #[doc = ""]
    #[doc = " @param  dest_addr Destination address in Flash."]
    #[doc = " @param  src       Pointer to the source buffer."]
    #[doc = " @param  size      Length of data, in bytes."]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_write(dest_addr: usize, src: *const cty::c_void, size: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Write data encrypted to Flash."]
    #[doc = ""]
    #[doc = " @note Flash encryption must be enabled for this function to work."]
    #[doc = ""]
    #[doc = " @note Flash encryption must be enabled when calling this function."]
    #[doc = " If flash encryption is disabled, the function returns"]
    #[doc = " ESP_ERR_INVALID_STATE.  Use esp_flash_encryption_enabled()"]
    #[doc = " function to determine if flash encryption is enabled."]
    #[doc = ""]
    #[doc = " @note Both dest_addr and size must be multiples of 16 bytes. For"]
    #[doc = " absolute best performance, both dest_addr and size arguments should"]
    #[doc = " be multiples of 32 bytes."]
    #[doc = ""]
    #[doc = " @param  dest_addr Destination address in Flash. Must be a multiple of 16 bytes."]
    #[doc = " @param  src       Pointer to the source buffer."]
    #[doc = " @param  size      Length of data, in bytes. Must be a multiple of 16 bytes."]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_write_encrypted(
        dest_addr: usize,
        src: *const cty::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Read data from Flash."]
    #[doc = ""]
    #[doc = " @note For fastest read performance, all parameters should be"]
    #[doc = " 4 byte aligned. If source address and read size are not 4 byte"]
    #[doc = " aligned, read may be split into multiple flash operations. If"]
    #[doc = " destination buffer is not 4 byte aligned, a temporary buffer will"]
    #[doc = " be allocated on the stack."]
    #[doc = ""]
    #[doc = " @note Reading more than 16KB of data at a time will be split"]
    #[doc = " into multiple reads to avoid disruption to other tasks in the"]
    #[doc = " system. Consider using spi_flash_mmap() to read large amounts"]
    #[doc = " of data."]
    #[doc = ""]
    #[doc = " @param  src_addr source address of the data in Flash."]
    #[doc = " @param  dest     pointer to the destination buffer"]
    #[doc = " @param  size     length of data"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_read(src_addr: usize, dest: *mut cty::c_void, size: usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Read data from Encrypted Flash."]
    #[doc = ""]
    #[doc = " If flash encryption is enabled, this function will transparently decrypt data as it is read."]
    #[doc = " If flash encryption is not enabled, this function behaves the same as spi_flash_read()."]
    #[doc = ""]
    #[doc = " See esp_flash_encryption_enabled() for a function to check if flash encryption is enabled."]
    #[doc = ""]
    #[doc = " @param  src   source address of the data in Flash."]
    #[doc = " @param  dest  pointer to the destination buffer"]
    #[doc = " @param  size  length of data"]
    #[doc = ""]
    #[doc = " @return esp_err_t"]
    pub fn spi_flash_read_encrypted(src: usize, dest: *mut cty::c_void, size: usize) -> esp_err_t;
}
#[doc = "< map to data memory (Vaddr0), allows byte-aligned access, 4 MB total"]
pub const spi_flash_mmap_memory_t_SPI_FLASH_MMAP_DATA: spi_flash_mmap_memory_t = 0;
#[doc = "< map to instruction memory (Vaddr1-3), allows only 4-byte-aligned access, 11 MB total"]
pub const spi_flash_mmap_memory_t_SPI_FLASH_MMAP_INST: spi_flash_mmap_memory_t = 1;
#[doc = " @brief Enumeration which specifies memory space requested in an mmap call"]
pub type spi_flash_mmap_memory_t = u32;
#[doc = " @brief Opaque handle for memory region obtained from spi_flash_mmap."]
pub type spi_flash_mmap_handle_t = u32;
extern "C" {
    #[doc = " @brief Map region of flash memory into data or instruction address space"]
    #[doc = ""]
    #[doc = " This function allocates sufficient number of 64kB MMU pages and configures"]
    #[doc = " them to map the requested region of flash memory into the address space."]
    #[doc = " It may reuse MMU pages which already provide the required mapping."]
    #[doc = ""]
    #[doc = " As with any allocator, if mmap/munmap are heavily used then the address space"]
    #[doc = " may become fragmented. To troubleshoot issues with page allocation, use"]
    #[doc = " spi_flash_mmap_dump() function."]
    #[doc = ""]
    #[doc = " @param src_addr  Physical address in flash where requested region starts."]
    #[doc = "                  This address *must* be aligned to 64kB boundary"]
    #[doc = "                  (SPI_FLASH_MMU_PAGE_SIZE)"]
    #[doc = " @param size  Size of region to be mapped. This size will be rounded"]
    #[doc = "              up to a 64kB boundary"]
    #[doc = " @param memory  Address space where the region should be mapped (data or instruction)"]
    #[doc = " @param[out] out_ptr  Output, pointer to the mapped memory region"]
    #[doc = " @param[out] out_handle  Output, handle which should be used for spi_flash_munmap call"]
    #[doc = ""]
    #[doc = " @return  ESP_OK on success, ESP_ERR_NO_MEM if pages can not be allocated"]
    pub fn spi_flash_mmap(
        src_addr: usize,
        size: usize,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const cty::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Map sequences of pages of flash memory into data or instruction address space"]
    #[doc = ""]
    #[doc = " This function allocates sufficient number of 64kB MMU pages and configures"]
    #[doc = " them to map the indicated pages of flash memory contiguously into address space."]
    #[doc = " In this respect, it works in a similar way as spi_flash_mmap() but it allows mapping"]
    #[doc = " a (maybe non-contiguous) set of pages into a contiguous region of memory."]
    #[doc = ""]
    #[doc = " @param pages An array of numbers indicating the 64kB pages in flash to be mapped"]
    #[doc = "              contiguously into memory. These indicate the indexes of the 64kB pages,"]
    #[doc = "              not the byte-size addresses as used in other functions."]
    #[doc = "              Array must be located in internal memory."]
    #[doc = " @param page_count  Number of entries in the pages array"]
    #[doc = " @param memory  Address space where the region should be mapped (instruction or data)"]
    #[doc = " @param[out] out_ptr  Output, pointer to the mapped memory region"]
    #[doc = " @param[out] out_handle  Output, handle which should be used for spi_flash_munmap call"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if pages can not be allocated"]
    #[doc = "      - ESP_ERR_INVALID_ARG if pagecount is zero or pages array is not in"]
    #[doc = "        internal memory"]
    pub fn spi_flash_mmap_pages(
        pages: *const cty::c_int,
        page_count: usize,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const cty::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Release region previously obtained using spi_flash_mmap"]
    #[doc = ""]
    #[doc = " @note Calling this function will not necessarily unmap memory region."]
    #[doc = "       Region will only be unmapped when there are no other handles which"]
    #[doc = "       reference this region. In case of partially overlapping regions"]
    #[doc = "       it is possible that memory will be unmapped partially."]
    #[doc = ""]
    #[doc = " @param handle  Handle obtained from spi_flash_mmap"]
    pub fn spi_flash_munmap(handle: spi_flash_mmap_handle_t);
}
extern "C" {
    #[doc = " @brief Display information about mapped regions"]
    #[doc = ""]
    #[doc = " This function lists handles obtained using spi_flash_mmap, along with range"]
    #[doc = " of pages allocated to each handle. It also lists all non-zero entries of"]
    #[doc = " MMU table and corresponding reference counts."]
    pub fn spi_flash_mmap_dump();
}
extern "C" {
    #[doc = " @brief get free pages number which can be mmap"]
    #[doc = ""]
    #[doc = " This function will return number of free pages available in mmu table. This could be useful"]
    #[doc = " before calling actual spi_flash_mmap (maps flash range to DCache or ICache memory) to check"]
    #[doc = " if there is sufficient space available for mapping."]
    #[doc = ""]
    #[doc = " @param memory memory type of MMU table free page"]
    #[doc = ""]
    #[doc = " @return number of free pages which can be mmaped"]
    pub fn spi_flash_mmap_get_free_pages(memory: spi_flash_mmap_memory_t) -> u32;
}
extern "C" {
    #[doc = " @brief Given a memory address where flash is mapped, return the corresponding physical flash offset."]
    #[doc = ""]
    #[doc = " Cache address does not have have been assigned via spi_flash_mmap(), any address in memory mapped flash space can be looked up."]
    #[doc = ""]
    #[doc = " @param cached Pointer to flashed cached memory."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " - SPI_FLASH_CACHE2PHYS_FAIL If cache address is outside flash cache region, or the address is not mapped."]
    #[doc = " - Otherwise, returns physical offset in flash"]
    pub fn spi_flash_cache2phys(cached: *const cty::c_void) -> usize;
}
extern "C" {
    #[doc = " @brief Given a physical offset in flash, return the address where it is mapped in the memory space."]
    #[doc = ""]
    #[doc = " Physical address does not have to have been assigned via spi_flash_mmap(), any address in flash can be looked up."]
    #[doc = ""]
    #[doc = " @note Only the first matching cache address is returned. If MMU flash cache table is configured so multiple entries"]
    #[doc = " point to the same physical address, there may be more than one cache address corresponding to that physical"]
    #[doc = " address. It is also possible for a single physical address to be mapped to both the IROM and DROM regions."]
    #[doc = ""]
    #[doc = " @note This function doesn't impose any alignment constraints, but if memory argument is SPI_FLASH_MMAP_INST and"]
    #[doc = " phys_offs is not 4-byte aligned, then reading from the returned pointer will result in a crash."]
    #[doc = ""]
    #[doc = " @param phys_offs Physical offset in flash memory to look up."]
    #[doc = " @param memory Address space type to look up a flash cache address mapping for (instruction or data)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " - NULL if the physical address is invalid or not mapped to flash cache of the specified memory type."]
    #[doc = " - Cached memory address (in IROM or DROM space) corresponding to phys_offs."]
    pub fn spi_flash_phys2cache(
        phys_offs: usize,
        memory: spi_flash_mmap_memory_t,
    ) -> *const cty::c_void;
}
extern "C" {
    #[doc = " @brief Check at runtime if flash cache is enabled on both CPUs"]
    #[doc = ""]
    #[doc = " @return true if both CPUs have flash cache enabled, false otherwise."]
    pub fn spi_flash_cache_enabled() -> bool;
}
#[doc = " @brief SPI flash critical section enter function."]
#[doc = ""]
pub type spi_flash_guard_start_func_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief SPI flash critical section exit function."]
pub type spi_flash_guard_end_func_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief SPI flash operation lock function."]
pub type spi_flash_op_lock_func_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief SPI flash operation unlock function."]
pub type spi_flash_op_unlock_func_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief Function to protect SPI flash critical regions corruption."]
pub type spi_flash_is_safe_write_address_t =
    ::core::option::Option<unsafe extern "C" fn(addr: usize, size: usize) -> bool>;
#[doc = " Structure holding SPI flash access critical sections management functions."]
#[doc = ""]
#[doc = " Flash API uses two types of flash access management functions:"]
#[doc = " 1) Functions which prepare/restore flash cache and interrupts before calling"]
#[doc = "    appropriate ROM functions (SPIWrite, SPIRead and SPIEraseBlock):"]
#[doc = "   - 'start' function should disables flash cache and non-IRAM interrupts and"]
#[doc = "      is invoked before the call to one of ROM function above."]
#[doc = "   - 'end' function should restore state of flash cache and non-IRAM interrupts and"]
#[doc = "      is invoked after the call to one of ROM function above."]
#[doc = "    These two functions are not recursive."]
#[doc = " 2) Functions which synchronizes access to internal data used by flash API."]
#[doc = "    This functions are mostly intended to synchronize access to flash API internal data"]
#[doc = "    in multithreaded environment and use OS primitives:"]
#[doc = "   - 'op_lock' locks access to flash API internal data."]
#[doc = "   - 'op_unlock' unlocks access to flash API internal data."]
#[doc = "   These two functions are recursive and can be used around the outside of multiple calls to"]
#[doc = "   'start' & 'end', in order to create atomic multi-part flash operations."]
#[doc = " 3) When CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ALLOWED is disabled, flash writing/erasing"]
#[doc = "    API checks for addresses provided by user to avoid corruption of critical flash regions"]
#[doc = "    (bootloader, partition table, running application etc.)."]
#[doc = ""]
#[doc = " Different versions of the guarding functions should be used depending on the context of"]
#[doc = " execution (with or without functional OS). In normal conditions when flash API is called"]
#[doc = " from task the functions use OS primitives. When there is no OS at all or when"]
#[doc = " it is not guaranteed that OS is functional (accessing flash from exception handler) these"]
#[doc = " functions cannot use OS primitives or even does not need them (multithreaded access is not possible)."]
#[doc = ""]
#[doc = " @note Structure and corresponding guard functions should not reside in flash."]
#[doc = "       For example structure can be placed in DRAM and functions in IRAM sections."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_flash_guard_funcs_t {
    #[doc = "< critical section start function."]
    pub start: spi_flash_guard_start_func_t,
    #[doc = "< critical section end function."]
    pub end: spi_flash_guard_end_func_t,
    #[doc = "< flash access API lock function."]
    pub op_lock: spi_flash_op_lock_func_t,
    #[doc = "< flash access API unlock function."]
    pub op_unlock: spi_flash_op_unlock_func_t,
    #[doc = "< checks flash write addresses."]
    pub is_safe_write_address: spi_flash_is_safe_write_address_t,
}
extern "C" {
    #[doc = " @brief  Sets guard functions to access flash."]
    #[doc = ""]
    #[doc = " @note Pointed structure and corresponding guard functions should not reside in flash."]
    #[doc = "       For example structure can be placed in DRAM and functions in IRAM sections."]
    #[doc = ""]
    #[doc = " @param funcs pointer to structure holding flash access guard functions."]
    pub fn spi_flash_guard_set(funcs: *const spi_flash_guard_funcs_t);
}
extern "C" {
    #[doc = " @brief Get the guard functions used for flash access"]
    #[doc = ""]
    #[doc = " @return The guard functions that were set via spi_flash_guard_set(). These functions"]
    #[doc = " can be called if implementing custom low-level SPI flash operations."]
    pub fn spi_flash_guard_get() -> *const spi_flash_guard_funcs_t;
}
extern "C" {
    pub static g_flash_guard_default_ops: spi_flash_guard_funcs_t;
}
extern "C" {
    pub static g_flash_guard_no_os_ops: spi_flash_guard_funcs_t;
}
#[doc = "!< Application partition type"]
pub const esp_partition_type_t_ESP_PARTITION_TYPE_APP: esp_partition_type_t = 0;
#[doc = "!< Data partition type"]
pub const esp_partition_type_t_ESP_PARTITION_TYPE_DATA: esp_partition_type_t = 1;
#[doc = " @brief Partition type"]
#[doc = " @note Keep this enum in sync with PartitionDefinition class gen_esp32part.py"]
pub type esp_partition_type_t = u32;
#[doc = "!< Factory application partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_FACTORY: esp_partition_subtype_t = 0;
#[doc = "!< Base for OTA partition subtypes"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_MIN: esp_partition_subtype_t = 16;
#[doc = "!< OTA partition 0"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_0: esp_partition_subtype_t = 16;
#[doc = "!< OTA partition 1"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_1: esp_partition_subtype_t = 17;
#[doc = "!< OTA partition 2"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_2: esp_partition_subtype_t = 18;
#[doc = "!< OTA partition 3"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_3: esp_partition_subtype_t = 19;
#[doc = "!< OTA partition 4"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_4: esp_partition_subtype_t = 20;
#[doc = "!< OTA partition 5"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_5: esp_partition_subtype_t = 21;
#[doc = "!< OTA partition 6"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_6: esp_partition_subtype_t = 22;
#[doc = "!< OTA partition 7"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_7: esp_partition_subtype_t = 23;
#[doc = "!< OTA partition 8"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_8: esp_partition_subtype_t = 24;
#[doc = "!< OTA partition 9"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_9: esp_partition_subtype_t = 25;
#[doc = "!< OTA partition 10"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_10: esp_partition_subtype_t = 26;
#[doc = "!< OTA partition 11"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_11: esp_partition_subtype_t = 27;
#[doc = "!< OTA partition 12"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_12: esp_partition_subtype_t = 28;
#[doc = "!< OTA partition 13"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_13: esp_partition_subtype_t = 29;
#[doc = "!< OTA partition 14"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_14: esp_partition_subtype_t = 30;
#[doc = "!< OTA partition 15"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_15: esp_partition_subtype_t = 31;
#[doc = "!< Max subtype of OTA partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_OTA_MAX: esp_partition_subtype_t = 32;
#[doc = "!< Test application partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_APP_TEST: esp_partition_subtype_t = 32;
#[doc = "!< OTA selection partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_OTA: esp_partition_subtype_t = 0;
#[doc = "!< PHY init data partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_PHY: esp_partition_subtype_t = 1;
#[doc = "!< NVS partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_NVS: esp_partition_subtype_t = 2;
#[doc = "!< COREDUMP partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_COREDUMP: esp_partition_subtype_t = 3;
#[doc = "!< Partition for NVS keys"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS: esp_partition_subtype_t = 4;
#[doc = "!< Partition for emulate eFuse bits"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM: esp_partition_subtype_t = 5;
#[doc = "!< ESPHTTPD partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD: esp_partition_subtype_t =
    128;
#[doc = "!< FAT partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_FAT: esp_partition_subtype_t = 129;
#[doc = "!< SPIFFS partition"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_DATA_SPIFFS: esp_partition_subtype_t = 130;
#[doc = "!< Used to search for partitions with any subtype"]
pub const esp_partition_subtype_t_ESP_PARTITION_SUBTYPE_ANY: esp_partition_subtype_t = 255;
#[doc = " @brief Partition subtype"]
#[doc = " @note Keep this enum in sync with PartitionDefinition class gen_esp32part.py"]
pub type esp_partition_subtype_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_partition_iterator_opaque_ {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque partition iterator type"]
pub type esp_partition_iterator_t = *mut esp_partition_iterator_opaque_;
#[doc = " @brief partition information structure"]
#[doc = ""]
#[doc = " This is not the format in flash, that format is esp_partition_info_t."]
#[doc = ""]
#[doc = " However, this is the format used by this API."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_partition_t {
    #[doc = "< partition type (app/data)"]
    pub type_: esp_partition_type_t,
    #[doc = "< partition subtype"]
    pub subtype: esp_partition_subtype_t,
    #[doc = "< starting address of the partition in flash"]
    pub address: u32,
    #[doc = "< size of the partition, in bytes"]
    pub size: u32,
    #[doc = "< partition label, zero-terminated ASCII string"]
    pub label: [cty::c_char; 17usize],
    #[doc = "< flag is set to true if partition is encrypted"]
    pub encrypted: bool,
}
extern "C" {
    #[doc = " @brief Find partition based on one or more parameters"]
    #[doc = ""]
    #[doc = " @param type Partition type, one of esp_partition_type_t values"]
    #[doc = " @param subtype Partition subtype, one of esp_partition_subtype_t values."]
    #[doc = "                To find all partitions of given type, use"]
    #[doc = "                ESP_PARTITION_SUBTYPE_ANY."]
    #[doc = " @param label (optional) Partition label. Set this value if looking"]
    #[doc = "             for partition with a specific name. Pass NULL otherwise."]
    #[doc = ""]
    #[doc = " @return iterator which can be used to enumerate all the partitions found,"]
    #[doc = "         or NULL if no partitions were found."]
    #[doc = "         Iterator obtained through this function has to be released"]
    #[doc = "         using esp_partition_iterator_release when not used any more."]
    pub fn esp_partition_find(
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        label: *const cty::c_char,
    ) -> esp_partition_iterator_t;
}
extern "C" {
    #[doc = " @brief Find first partition based on one or more parameters"]
    #[doc = ""]
    #[doc = " @param type Partition type, one of esp_partition_type_t values"]
    #[doc = " @param subtype Partition subtype, one of esp_partition_subtype_t values."]
    #[doc = "                To find all partitions of given type, use"]
    #[doc = "                ESP_PARTITION_SUBTYPE_ANY."]
    #[doc = " @param label (optional) Partition label. Set this value if looking"]
    #[doc = "             for partition with a specific name. Pass NULL otherwise."]
    #[doc = ""]
    #[doc = " @return pointer to esp_partition_t structure, or NULL if no partition is found."]
    #[doc = "         This pointer is valid for the lifetime of the application."]
    pub fn esp_partition_find_first(
        type_: esp_partition_type_t,
        subtype: esp_partition_subtype_t,
        label: *const cty::c_char,
    ) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Get esp_partition_t structure for given partition"]
    #[doc = ""]
    #[doc = " @param iterator  Iterator obtained using esp_partition_find. Must be non-NULL."]
    #[doc = ""]
    #[doc = " @return pointer to esp_partition_t structure. This pointer is valid for the lifetime"]
    #[doc = "         of the application."]
    pub fn esp_partition_get(iterator: esp_partition_iterator_t) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Move partition iterator to the next partition found"]
    #[doc = ""]
    #[doc = " Any copies of the iterator will be invalid after this call."]
    #[doc = ""]
    #[doc = " @param iterator Iterator obtained using esp_partition_find. Must be non-NULL."]
    #[doc = ""]
    #[doc = " @return NULL if no partition was found, valid esp_partition_iterator_t otherwise."]
    pub fn esp_partition_next(iterator: esp_partition_iterator_t) -> esp_partition_iterator_t;
}
extern "C" {
    #[doc = " @brief Release partition iterator"]
    #[doc = ""]
    #[doc = " @param iterator Iterator obtained using esp_partition_find. Must be non-NULL."]
    #[doc = ""]
    pub fn esp_partition_iterator_release(iterator: esp_partition_iterator_t);
}
extern "C" {
    #[doc = " @brief Verify partition data"]
    #[doc = ""]
    #[doc = " Given a pointer to partition data, verify this partition exists in the partition table (all fields match.)"]
    #[doc = ""]
    #[doc = " This function is also useful to take partition data which may be in a RAM buffer and convert it to a pointer to the"]
    #[doc = " permanent partition data stored in flash."]
    #[doc = ""]
    #[doc = " Pointers returned from this function can be compared directly to the address of any pointer returned from"]
    #[doc = " esp_partition_get(), as a test for equality."]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition data to verify. Must be non-NULL. All fields of this structure must match the"]
    #[doc = " partition table entry in flash for this function to return a successful match."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " - If partition not found, returns NULL."]
    #[doc = " - If found, returns a pointer to the esp_partition_t structure in flash. This pointer is always valid for the lifetime of the application."]
    pub fn esp_partition_verify(partition: *const esp_partition_t) -> *const esp_partition_t;
}
extern "C" {
    #[doc = " @brief Read data from the partition"]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition structure obtained using"]
    #[doc = "                  esp_partition_find_first or esp_partition_get."]
    #[doc = "                  Must be non-NULL."]
    #[doc = " @param dst Pointer to the buffer where data should be stored."]
    #[doc = "            Pointer must be non-NULL and buffer must be at least 'size' bytes long."]
    #[doc = " @param src_offset Address of the data to be read, relative to the"]
    #[doc = "                   beginning of the partition."]
    #[doc = " @param size Size of data to be read, in bytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK, if data was read successfully;"]
    #[doc = "         ESP_ERR_INVALID_ARG, if src_offset exceeds partition size;"]
    #[doc = "         ESP_ERR_INVALID_SIZE, if read would go out of bounds of the partition;"]
    #[doc = "         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_read(
        partition: *const esp_partition_t,
        src_offset: usize,
        dst: *mut cty::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Write data to the partition"]
    #[doc = ""]
    #[doc = " Before writing data to flash, corresponding region of flash needs to be erased."]
    #[doc = " This can be done using esp_partition_erase_range function."]
    #[doc = ""]
    #[doc = " Partitions marked with an encryption flag will automatically be"]
    #[doc = " written via the spi_flash_write_encrypted() function. If writing to"]
    #[doc = " an encrypted partition, all write offsets and lengths must be"]
    #[doc = " multiples of 16 bytes. See the spi_flash_write_encrypted() function"]
    #[doc = " for more details. Unencrypted partitions do not have this"]
    #[doc = " restriction."]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition structure obtained using"]
    #[doc = "                  esp_partition_find_first or esp_partition_get."]
    #[doc = "                  Must be non-NULL."]
    #[doc = " @param dst_offset Address where the data should be written, relative to the"]
    #[doc = "                   beginning of the partition."]
    #[doc = " @param src Pointer to the source buffer.  Pointer must be non-NULL and"]
    #[doc = "            buffer must be at least 'size' bytes long."]
    #[doc = " @param size Size of data to be written, in bytes."]
    #[doc = ""]
    #[doc = " @note Prior to writing to flash memory, make sure it has been erased with"]
    #[doc = "       esp_partition_erase_range call."]
    #[doc = ""]
    #[doc = " @return ESP_OK, if data was written successfully;"]
    #[doc = "         ESP_ERR_INVALID_ARG, if dst_offset exceeds partition size;"]
    #[doc = "         ESP_ERR_INVALID_SIZE, if write would go out of bounds of the partition;"]
    #[doc = "         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_write(
        partition: *const esp_partition_t,
        dst_offset: usize,
        src: *const cty::c_void,
        size: usize,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase part of the partition"]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition structure obtained using"]
    #[doc = "                  esp_partition_find_first or esp_partition_get."]
    #[doc = "                  Must be non-NULL."]
    #[doc = " @param start_addr Address where erase operation should start. Must be aligned"]
    #[doc = "                   to 4 kilobytes."]
    #[doc = " @param size Size of the range which should be erased, in bytes."]
    #[doc = "                   Must be divisible by 4 kilobytes."]
    #[doc = ""]
    #[doc = " @return ESP_OK, if the range was erased successfully;"]
    #[doc = "         ESP_ERR_INVALID_ARG, if iterator or dst are NULL;"]
    #[doc = "         ESP_ERR_INVALID_SIZE, if erase would go out of bounds of the partition;"]
    #[doc = "         or one of error codes from lower-level flash driver."]
    pub fn esp_partition_erase_range(
        partition: *const esp_partition_t,
        start_addr: u32,
        size: u32,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure MMU to map partition into data memory"]
    #[doc = ""]
    #[doc = " Unlike spi_flash_mmap function, which requires a 64kB aligned base address,"]
    #[doc = " this function doesn't impose such a requirement."]
    #[doc = " If offset results in a flash address which is not aligned to 64kB boundary,"]
    #[doc = " address will be rounded to the lower 64kB boundary, so that mapped region"]
    #[doc = " includes requested range."]
    #[doc = " Pointer returned via out_ptr argument will be adjusted to point to the"]
    #[doc = " requested offset (not necessarily to the beginning of mmap-ed region)."]
    #[doc = ""]
    #[doc = " To release mapped memory, pass handle returned via out_handle argument to"]
    #[doc = " spi_flash_munmap function."]
    #[doc = ""]
    #[doc = " @param partition Pointer to partition structure obtained using"]
    #[doc = "                  esp_partition_find_first or esp_partition_get."]
    #[doc = "                  Must be non-NULL."]
    #[doc = " @param offset Offset from the beginning of partition where mapping should start."]
    #[doc = " @param size Size of the area to be mapped."]
    #[doc = " @param memory  Memory space where the region should be mapped"]
    #[doc = " @param out_ptr  Output, pointer to the mapped memory region"]
    #[doc = " @param out_handle  Output, handle which should be used for spi_flash_munmap call"]
    #[doc = ""]
    #[doc = " @return ESP_OK, if successful"]
    pub fn esp_partition_mmap(
        partition: *const esp_partition_t,
        offset: u32,
        size: u32,
        memory: spi_flash_mmap_memory_t,
        out_ptr: *mut *const cty::c_void,
        out_handle: *mut spi_flash_mmap_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get SHA-256 digest for required partition."]
    #[doc = ""]
    #[doc = " For apps with SHA-256 appended to the app image, the result is the appended SHA-256 value for the app image content."]
    #[doc = " The hash is verified before returning, if app content is invalid then the function returns ESP_ERR_IMAGE_INVALID."]
    #[doc = " For apps without SHA-256 appended to the image, the result is the SHA-256 of all bytes in the app image."]
    #[doc = " For other partition types, the result is the SHA-256 of the entire partition."]
    #[doc = ""]
    #[doc = " @param[in]  partition    Pointer to info for partition containing app or data. (fields: address, size and type, are required to be filled)."]
    #[doc = " @param[out] sha_256      Returned SHA-256 digest for a given partition."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "          - ESP_OK: In case of successful operation."]
    #[doc = "          - ESP_ERR_INVALID_ARG: The size was 0 or the sha_256 was NULL."]
    #[doc = "          - ESP_ERR_NO_MEM: Cannot allocate memory for sha256 operation."]
    #[doc = "          - ESP_ERR_IMAGE_INVALID: App partition doesn't contain a valid app image."]
    #[doc = "          - ESP_FAIL: An allocation error occurred."]
    pub fn esp_partition_get_sha256(
        partition: *const esp_partition_t,
        sha_256: *mut u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Check for the identity of two partitions by SHA-256 digest."]
    #[doc = ""]
    #[doc = " @param[in] partition_1 Pointer to info for partition 1 containing app or data. (fields: address, size and type, are required to be filled)."]
    #[doc = " @param[in] partition_2 Pointer to info for partition 2 containing app or data. (fields: address, size and type, are required to be filled)."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - True:  In case of the two firmware is equal."]
    #[doc = "         - False: Otherwise"]
    pub fn esp_partition_check_identity(
        partition_1: *const esp_partition_t,
        partition_2: *const esp_partition_t,
    ) -> bool;
}
#[doc = " @brief Key for encryption and decryption"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvs_sec_cfg_t {
    #[doc = "<  XTS encryption and decryption key"]
    pub eky: [u8; 32usize],
    #[doc = "<  XTS tweak key"]
    pub tky: [u8; 32usize],
}
extern "C" {
    #[doc = " @brief Initialize the default NVS partition."]
    #[doc = ""]
    #[doc = " This API initialises the default NVS partition. The default NVS partition"]
    #[doc = " is the one that is labeled \"nvs\" in the partition table."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if no partition with label \"nvs\" is found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize NVS flash storage for the specified partition."]
    #[doc = ""]
    #[doc = " @param[in]  partition_label   Label of the partition. Note that internally a reference to"]
    #[doc = "                               passed value is kept and it should be accessible for future operations"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if specified partition is not found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_init_partition(partition_label: *const cty::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize NVS storage for the default NVS partition"]
    #[doc = ""]
    #[doc = " Default NVS partition is the partition with \"nvs\" label in the partition table."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success (storage was deinitialized)"]
    #[doc = "      - ESP_ERR_NVS_NOT_INITIALIZED if the storage was not initialized prior to this call"]
    pub fn nvs_flash_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize NVS storage for the given NVS partition"]
    #[doc = ""]
    #[doc = " @param[in]  partition_label   Label of the partition"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NVS_NOT_INITIALIZED if the storage for given partition was not"]
    #[doc = "        initialized prior to this call"]
    pub fn nvs_flash_deinit_partition(partition_label: *const cty::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase the default NVS partition"]
    #[doc = ""]
    #[doc = " This function erases all contents of the default NVS partition (one with label \"nvs\")"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_FOUND if there is no NVS partition labeled \"nvs\" in the"]
    #[doc = "        partition table"]
    pub fn nvs_flash_erase() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase specified NVS partition"]
    #[doc = ""]
    #[doc = " This function erases all contents of specified NVS partition"]
    #[doc = ""]
    #[doc = " @param[in]  part_name    Name (label) of the partition to be erased"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NOT_FOUND if there is no NVS partition with the specified name"]
    #[doc = "        in the partition table"]
    pub fn nvs_flash_erase_partition(part_name: *const cty::c_char) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize the default NVS partition."]
    #[doc = ""]
    #[doc = " This API initialises the default NVS partition. The default NVS partition"]
    #[doc = " is the one that is labeled \"nvs\" in the partition table."]
    #[doc = ""]
    #[doc = " @param[in]  cfg Security configuration (keys) to be used for NVS encryption/decryption."]
    #[doc = "                              If cfg is NULL, no encryption is used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if no partition with label \"nvs\" is found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_secure_init(cfg: *mut nvs_sec_cfg_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize NVS flash storage for the specified partition."]
    #[doc = ""]
    #[doc = " @param[in]  partition_label   Label of the partition. Note that internally a reference to"]
    #[doc = "                               passed value is kept and it should be accessible for future operations"]
    #[doc = ""]
    #[doc = " @param[in]  cfg Security configuration (keys) to be used for NVS encryption/decryption."]
    #[doc = "                              If cfg is null, no encryption/decryption is used."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK if storage was successfully initialized."]
    #[doc = "      - ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages"]
    #[doc = "        (which may happen if NVS partition was truncated)"]
    #[doc = "      - ESP_ERR_NOT_FOUND if specified partition is not found in the partition table"]
    #[doc = "      - one of the error codes from the underlying flash storage driver"]
    pub fn nvs_flash_secure_init_partition(
        partition_label: *const cty::c_char,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Generate and store NVS keys in the provided esp partition"]
    #[doc = ""]
    #[doc = " @param[in]  partition Pointer to partition structure obtained using"]
    #[doc = "                       esp_partition_find_first or esp_partition_get."]
    #[doc = "                       Must be non-NULL."]
    #[doc = " @param[out] cfg       Pointer to nvs security configuration structure."]
    #[doc = "                       Pointer must be non-NULL."]
    #[doc = "                       Generated keys will be populated in this structure."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      -ESP_OK, if cfg was read successfully;"]
    #[doc = "      -or error codes from esp_partition_write/erase APIs."]
    pub fn nvs_flash_generate_keys(
        partition: *const esp_partition_t,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Read NVS security configuration from a partition."]
    #[doc = ""]
    #[doc = " @param[in]  partition Pointer to partition structure obtained using"]
    #[doc = "                       esp_partition_find_first or esp_partition_get."]
    #[doc = "                       Must be non-NULL."]
    #[doc = " @param[out] cfg       Pointer to nvs security configuration structure."]
    #[doc = "                       Pointer must be non-NULL."]
    #[doc = ""]
    #[doc = " @note  Provided parition is assumed to be marked 'encrypted'."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      -ESP_OK, if cfg was read successfully;"]
    #[doc = "      -ESP_ERR_NVS_KEYS_NOT_INITIALIZED, if the partition is not yet written with keys."]
    #[doc = "      -ESP_ERR_NVS_CORRUPT_KEY_PART, if the partition containing keys is found to be corrupt"]
    #[doc = "      -or error codes from esp_partition_read API."]
    pub fn nvs_flash_read_security_cfg(
        partition: *const esp_partition_t,
        cfg: *mut nvs_sec_cfg_t,
    ) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub fifo: _bindgen_ty_2__bindgen_ty_1,
    pub int_raw: _bindgen_ty_2__bindgen_ty_2,
    pub int_st: _bindgen_ty_2__bindgen_ty_3,
    pub int_ena: _bindgen_ty_2__bindgen_ty_4,
    pub int_clr: _bindgen_ty_2__bindgen_ty_5,
    pub clk_div: _bindgen_ty_2__bindgen_ty_6,
    pub auto_baud: _bindgen_ty_2__bindgen_ty_7,
    pub status: _bindgen_ty_2__bindgen_ty_8,
    pub conf0: _bindgen_ty_2__bindgen_ty_9,
    pub conf1: _bindgen_ty_2__bindgen_ty_10,
    pub lowpulse: _bindgen_ty_2__bindgen_ty_11,
    pub highpulse: _bindgen_ty_2__bindgen_ty_12,
    pub rxd_cnt: _bindgen_ty_2__bindgen_ty_13,
    pub flow_conf: _bindgen_ty_2__bindgen_ty_14,
    pub sleep_conf: _bindgen_ty_2__bindgen_ty_15,
    pub swfc_conf: _bindgen_ty_2__bindgen_ty_16,
    pub idle_conf: _bindgen_ty_2__bindgen_ty_17,
    pub rs485_conf: _bindgen_ty_2__bindgen_ty_18,
    pub at_cmd_precnt: _bindgen_ty_2__bindgen_ty_19,
    pub at_cmd_postcnt: _bindgen_ty_2__bindgen_ty_20,
    pub at_cmd_gaptout: _bindgen_ty_2__bindgen_ty_21,
    pub at_cmd_char: _bindgen_ty_2__bindgen_ty_22,
    pub mem_conf: _bindgen_ty_2__bindgen_ty_23,
    pub mem_tx_status: _bindgen_ty_2__bindgen_ty_24,
    pub mem_rx_status: _bindgen_ty_2__bindgen_ty_25,
    pub mem_cnt_status: _bindgen_ty_2__bindgen_ty_26,
    pub pospulse: _bindgen_ty_2__bindgen_ty_27,
    pub negpulse: _bindgen_ty_2__bindgen_ty_28,
    pub reserved_70: u32,
    pub reserved_74: u32,
    pub date: u32,
    pub id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub rw_byte: u8,
    pub reserved: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_2 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brk_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_idle_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_idle_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_clash(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_clash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn at_cmd_char_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_at_cmd_char_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full: u32,
        txfifo_empty: u32,
        parity_err: u32,
        frm_err: u32,
        rxfifo_ovf: u32,
        dsr_chg: u32,
        cts_chg: u32,
        brk_det: u32,
        rxfifo_tout: u32,
        sw_xon: u32,
        sw_xoff: u32,
        glitch_det: u32,
        tx_brk_done: u32,
        tx_brk_idle_done: u32,
        tx_done: u32,
        rs485_parity_err: u32,
        rs485_frm_err: u32,
        rs485_clash: u32,
        at_cmd_char_det: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rxfifo_full: u32 = unsafe { ::core::mem::transmute(rxfifo_full) };
            rxfifo_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let txfifo_empty: u32 = unsafe { ::core::mem::transmute(txfifo_empty) };
            txfifo_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let parity_err: u32 = unsafe { ::core::mem::transmute(parity_err) };
            parity_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frm_err: u32 = unsafe { ::core::mem::transmute(frm_err) };
            frm_err as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxfifo_ovf: u32 = unsafe { ::core::mem::transmute(rxfifo_ovf) };
            rxfifo_ovf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsr_chg: u32 = unsafe { ::core::mem::transmute(dsr_chg) };
            dsr_chg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cts_chg: u32 = unsafe { ::core::mem::transmute(cts_chg) };
            cts_chg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let brk_det: u32 = unsafe { ::core::mem::transmute(brk_det) };
            brk_det as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rxfifo_tout: u32 = unsafe { ::core::mem::transmute(rxfifo_tout) };
            rxfifo_tout as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_xon: u32 = unsafe { ::core::mem::transmute(sw_xon) };
            sw_xon as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_xoff: u32 = unsafe { ::core::mem::transmute(sw_xoff) };
            sw_xoff as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let glitch_det: u32 = unsafe { ::core::mem::transmute(glitch_det) };
            glitch_det as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_brk_done: u32 = unsafe { ::core::mem::transmute(tx_brk_done) };
            tx_brk_done as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tx_brk_idle_done: u32 = unsafe { ::core::mem::transmute(tx_brk_idle_done) };
            tx_brk_idle_done as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rs485_parity_err: u32 = unsafe { ::core::mem::transmute(rs485_parity_err) };
            rs485_parity_err as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rs485_frm_err: u32 = unsafe { ::core::mem::transmute(rs485_frm_err) };
            rs485_frm_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rs485_clash: u32 = unsafe { ::core::mem::transmute(rs485_clash) };
            rs485_clash as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let at_cmd_char_det: u32 = unsafe { ::core::mem::transmute(at_cmd_char_det) };
            at_cmd_char_det as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_3 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_2__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brk_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_idle_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_idle_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_clash(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_clash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn at_cmd_char_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_at_cmd_char_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full: u32,
        txfifo_empty: u32,
        parity_err: u32,
        frm_err: u32,
        rxfifo_ovf: u32,
        dsr_chg: u32,
        cts_chg: u32,
        brk_det: u32,
        rxfifo_tout: u32,
        sw_xon: u32,
        sw_xoff: u32,
        glitch_det: u32,
        tx_brk_done: u32,
        tx_brk_idle_done: u32,
        tx_done: u32,
        rs485_parity_err: u32,
        rs485_frm_err: u32,
        rs485_clash: u32,
        at_cmd_char_det: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rxfifo_full: u32 = unsafe { ::core::mem::transmute(rxfifo_full) };
            rxfifo_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let txfifo_empty: u32 = unsafe { ::core::mem::transmute(txfifo_empty) };
            txfifo_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let parity_err: u32 = unsafe { ::core::mem::transmute(parity_err) };
            parity_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frm_err: u32 = unsafe { ::core::mem::transmute(frm_err) };
            frm_err as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxfifo_ovf: u32 = unsafe { ::core::mem::transmute(rxfifo_ovf) };
            rxfifo_ovf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsr_chg: u32 = unsafe { ::core::mem::transmute(dsr_chg) };
            dsr_chg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cts_chg: u32 = unsafe { ::core::mem::transmute(cts_chg) };
            cts_chg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let brk_det: u32 = unsafe { ::core::mem::transmute(brk_det) };
            brk_det as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rxfifo_tout: u32 = unsafe { ::core::mem::transmute(rxfifo_tout) };
            rxfifo_tout as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_xon: u32 = unsafe { ::core::mem::transmute(sw_xon) };
            sw_xon as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_xoff: u32 = unsafe { ::core::mem::transmute(sw_xoff) };
            sw_xoff as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let glitch_det: u32 = unsafe { ::core::mem::transmute(glitch_det) };
            glitch_det as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_brk_done: u32 = unsafe { ::core::mem::transmute(tx_brk_done) };
            tx_brk_done as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tx_brk_idle_done: u32 = unsafe { ::core::mem::transmute(tx_brk_idle_done) };
            tx_brk_idle_done as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rs485_parity_err: u32 = unsafe { ::core::mem::transmute(rs485_parity_err) };
            rs485_parity_err as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rs485_frm_err: u32 = unsafe { ::core::mem::transmute(rs485_frm_err) };
            rs485_frm_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rs485_clash: u32 = unsafe { ::core::mem::transmute(rs485_clash) };
            rs485_clash as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let at_cmd_char_det: u32 = unsafe { ::core::mem::transmute(at_cmd_char_det) };
            at_cmd_char_det as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_4 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_2__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brk_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_idle_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_idle_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_clash(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_clash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn at_cmd_char_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_at_cmd_char_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full: u32,
        txfifo_empty: u32,
        parity_err: u32,
        frm_err: u32,
        rxfifo_ovf: u32,
        dsr_chg: u32,
        cts_chg: u32,
        brk_det: u32,
        rxfifo_tout: u32,
        sw_xon: u32,
        sw_xoff: u32,
        glitch_det: u32,
        tx_brk_done: u32,
        tx_brk_idle_done: u32,
        tx_done: u32,
        rs485_parity_err: u32,
        rs485_frm_err: u32,
        rs485_clash: u32,
        at_cmd_char_det: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rxfifo_full: u32 = unsafe { ::core::mem::transmute(rxfifo_full) };
            rxfifo_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let txfifo_empty: u32 = unsafe { ::core::mem::transmute(txfifo_empty) };
            txfifo_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let parity_err: u32 = unsafe { ::core::mem::transmute(parity_err) };
            parity_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frm_err: u32 = unsafe { ::core::mem::transmute(frm_err) };
            frm_err as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxfifo_ovf: u32 = unsafe { ::core::mem::transmute(rxfifo_ovf) };
            rxfifo_ovf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsr_chg: u32 = unsafe { ::core::mem::transmute(dsr_chg) };
            dsr_chg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cts_chg: u32 = unsafe { ::core::mem::transmute(cts_chg) };
            cts_chg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let brk_det: u32 = unsafe { ::core::mem::transmute(brk_det) };
            brk_det as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rxfifo_tout: u32 = unsafe { ::core::mem::transmute(rxfifo_tout) };
            rxfifo_tout as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_xon: u32 = unsafe { ::core::mem::transmute(sw_xon) };
            sw_xon as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_xoff: u32 = unsafe { ::core::mem::transmute(sw_xoff) };
            sw_xoff as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let glitch_det: u32 = unsafe { ::core::mem::transmute(glitch_det) };
            glitch_det as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_brk_done: u32 = unsafe { ::core::mem::transmute(tx_brk_done) };
            tx_brk_done as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tx_brk_idle_done: u32 = unsafe { ::core::mem::transmute(tx_brk_idle_done) };
            tx_brk_idle_done as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rs485_parity_err: u32 = unsafe { ::core::mem::transmute(rs485_parity_err) };
            rs485_parity_err as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rs485_frm_err: u32 = unsafe { ::core::mem::transmute(rs485_frm_err) };
            rs485_frm_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rs485_clash: u32 = unsafe { ::core::mem::transmute(rs485_clash) };
            rs485_clash as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let at_cmd_char_det: u32 = unsafe { ::core::mem::transmute(at_cmd_char_det) };
            at_cmd_char_det as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_5 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_2__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brk_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_idle_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_idle_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_clash(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_clash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn at_cmd_char_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_at_cmd_char_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full: u32,
        txfifo_empty: u32,
        parity_err: u32,
        frm_err: u32,
        rxfifo_ovf: u32,
        dsr_chg: u32,
        cts_chg: u32,
        brk_det: u32,
        rxfifo_tout: u32,
        sw_xon: u32,
        sw_xoff: u32,
        glitch_det: u32,
        tx_brk_done: u32,
        tx_brk_idle_done: u32,
        tx_done: u32,
        rs485_parity_err: u32,
        rs485_frm_err: u32,
        rs485_clash: u32,
        at_cmd_char_det: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rxfifo_full: u32 = unsafe { ::core::mem::transmute(rxfifo_full) };
            rxfifo_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let txfifo_empty: u32 = unsafe { ::core::mem::transmute(txfifo_empty) };
            txfifo_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let parity_err: u32 = unsafe { ::core::mem::transmute(parity_err) };
            parity_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frm_err: u32 = unsafe { ::core::mem::transmute(frm_err) };
            frm_err as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxfifo_ovf: u32 = unsafe { ::core::mem::transmute(rxfifo_ovf) };
            rxfifo_ovf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsr_chg: u32 = unsafe { ::core::mem::transmute(dsr_chg) };
            dsr_chg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cts_chg: u32 = unsafe { ::core::mem::transmute(cts_chg) };
            cts_chg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let brk_det: u32 = unsafe { ::core::mem::transmute(brk_det) };
            brk_det as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rxfifo_tout: u32 = unsafe { ::core::mem::transmute(rxfifo_tout) };
            rxfifo_tout as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_xon: u32 = unsafe { ::core::mem::transmute(sw_xon) };
            sw_xon as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_xoff: u32 = unsafe { ::core::mem::transmute(sw_xoff) };
            sw_xoff as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let glitch_det: u32 = unsafe { ::core::mem::transmute(glitch_det) };
            glitch_det as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_brk_done: u32 = unsafe { ::core::mem::transmute(tx_brk_done) };
            tx_brk_done as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tx_brk_idle_done: u32 = unsafe { ::core::mem::transmute(tx_brk_idle_done) };
            tx_brk_idle_done as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rs485_parity_err: u32 = unsafe { ::core::mem::transmute(rs485_parity_err) };
            rs485_parity_err as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rs485_frm_err: u32 = unsafe { ::core::mem::transmute(rs485_frm_err) };
            rs485_frm_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rs485_clash: u32 = unsafe { ::core::mem::transmute(rs485_clash) };
            rs485_clash as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let at_cmd_char_det: u32 = unsafe { ::core::mem::transmute(at_cmd_char_det) };
            at_cmd_char_det as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_6 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn div_int(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_div_int(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn div_frag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_div_frag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        div_int: u32,
        div_frag: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let div_int: u32 = unsafe { ::core::mem::transmute(div_int) };
            div_int as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let div_frag: u32 = unsafe { ::core::mem::transmute(div_frag) };
            div_frag as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_7 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_2__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_filt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_filt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        en: u32,
        reserved1: u32,
        glitch_filt: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let glitch_filt: u32 = unsafe { ::core::mem::transmute(glitch_filt) };
            glitch_filt as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_8 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl _bindgen_ty_2__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn st_urx_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_st_urx_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsrn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsrn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ctsn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctsn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn st_utx_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_st_utx_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dtrn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dtrn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtsn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtsn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_cnt: u32,
        st_urx_out: u32,
        reserved12: u32,
        dsrn: u32,
        ctsn: u32,
        rxd: u32,
        txfifo_cnt: u32,
        st_utx_out: u32,
        reserved28: u32,
        dtrn: u32,
        rtsn: u32,
        txd: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rxfifo_cnt: u32 = unsafe { ::core::mem::transmute(rxfifo_cnt) };
            rxfifo_cnt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let st_urx_out: u32 = unsafe { ::core::mem::transmute(st_urx_out) };
            st_urx_out as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let dsrn: u32 = unsafe { ::core::mem::transmute(dsrn) };
            dsrn as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ctsn: u32 = unsafe { ::core::mem::transmute(ctsn) };
            ctsn as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rxd: u32 = unsafe { ::core::mem::transmute(rxd) };
            rxd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let txfifo_cnt: u32 = unsafe { ::core::mem::transmute(txfifo_cnt) };
            txfifo_cnt as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let st_utx_out: u32 = unsafe { ::core::mem::transmute(st_utx_out) };
            st_utx_out as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let dtrn: u32 = unsafe { ::core::mem::transmute(dtrn) };
            dtrn as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rtsn: u32 = unsafe { ::core::mem::transmute(rtsn) };
            rtsn as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let txd: u32 = unsafe { ::core::mem::transmute(txd) };
            txd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_9 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl _bindgen_ty_2__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn parity(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_bit_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn stop_bit_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stop_bit_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_rts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_rts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_dtr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_dtr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txd_brk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txd_brk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_dplx(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_dplx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_tx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_tx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_wctl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_wctl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_tx_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_tx_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_rx_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_rx_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loopback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loopback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_flow_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxd_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxd_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txd_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txd_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rts_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rts_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dtr_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dtr_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn err_wr_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_err_wr_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tick_ref_always_on(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tick_ref_always_on(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        parity: u32,
        parity_en: u32,
        bit_num: u32,
        stop_bit_num: u32,
        sw_rts: u32,
        sw_dtr: u32,
        txd_brk: u32,
        irda_dplx: u32,
        irda_tx_en: u32,
        irda_wctl: u32,
        irda_tx_inv: u32,
        irda_rx_inv: u32,
        loopback: u32,
        tx_flow_en: u32,
        irda_en: u32,
        rxfifo_rst: u32,
        txfifo_rst: u32,
        rxd_inv: u32,
        cts_inv: u32,
        dsr_inv: u32,
        txd_inv: u32,
        rts_inv: u32,
        dtr_inv: u32,
        clk_en: u32,
        err_wr_mask: u32,
        tick_ref_always_on: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let parity: u32 = unsafe { ::core::mem::transmute(parity) };
            parity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let parity_en: u32 = unsafe { ::core::mem::transmute(parity_en) };
            parity_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let bit_num: u32 = unsafe { ::core::mem::transmute(bit_num) };
            bit_num as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let stop_bit_num: u32 = unsafe { ::core::mem::transmute(stop_bit_num) };
            stop_bit_num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sw_rts: u32 = unsafe { ::core::mem::transmute(sw_rts) };
            sw_rts as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sw_dtr: u32 = unsafe { ::core::mem::transmute(sw_dtr) };
            sw_dtr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let txd_brk: u32 = unsafe { ::core::mem::transmute(txd_brk) };
            txd_brk as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let irda_dplx: u32 = unsafe { ::core::mem::transmute(irda_dplx) };
            irda_dplx as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let irda_tx_en: u32 = unsafe { ::core::mem::transmute(irda_tx_en) };
            irda_tx_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let irda_wctl: u32 = unsafe { ::core::mem::transmute(irda_wctl) };
            irda_wctl as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let irda_tx_inv: u32 = unsafe { ::core::mem::transmute(irda_tx_inv) };
            irda_tx_inv as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let irda_rx_inv: u32 = unsafe { ::core::mem::transmute(irda_rx_inv) };
            irda_rx_inv as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let loopback: u32 = unsafe { ::core::mem::transmute(loopback) };
            loopback as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_flow_en: u32 = unsafe { ::core::mem::transmute(tx_flow_en) };
            tx_flow_en as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let irda_en: u32 = unsafe { ::core::mem::transmute(irda_en) };
            irda_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rxfifo_rst: u32 = unsafe { ::core::mem::transmute(rxfifo_rst) };
            rxfifo_rst as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let txfifo_rst: u32 = unsafe { ::core::mem::transmute(txfifo_rst) };
            txfifo_rst as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rxd_inv: u32 = unsafe { ::core::mem::transmute(rxd_inv) };
            rxd_inv as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let cts_inv: u32 = unsafe { ::core::mem::transmute(cts_inv) };
            cts_inv as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let dsr_inv: u32 = unsafe { ::core::mem::transmute(dsr_inv) };
            dsr_inv as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let txd_inv: u32 = unsafe { ::core::mem::transmute(txd_inv) };
            txd_inv as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rts_inv: u32 = unsafe { ::core::mem::transmute(rts_inv) };
            rts_inv as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let dtr_inv: u32 = unsafe { ::core::mem::transmute(dtr_inv) };
            dtr_inv as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let err_wr_mask: u32 = unsafe { ::core::mem::transmute(err_wr_mask) };
            err_wr_mask as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let tick_ref_always_on: u32 = unsafe { ::core::mem::transmute(tick_ref_always_on) };
            tick_ref_always_on as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_10 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl _bindgen_ty_2__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_flow_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rx_flow_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_flow_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_tout_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rx_tout_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_tout_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_tout_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full_thrhd: u32,
        reserved7: u32,
        txfifo_empty_thrhd: u32,
        reserved15: u32,
        rx_flow_thrhd: u32,
        rx_flow_en: u32,
        rx_tout_thrhd: u32,
        rx_tout_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let rxfifo_full_thrhd: u32 = unsafe { ::core::mem::transmute(rxfifo_full_thrhd) };
            rxfifo_full_thrhd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved7: u32 = unsafe { ::core::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 7u8, {
            let txfifo_empty_thrhd: u32 = unsafe { ::core::mem::transmute(txfifo_empty_thrhd) };
            txfifo_empty_thrhd as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let rx_flow_thrhd: u32 = unsafe { ::core::mem::transmute(rx_flow_thrhd) };
            rx_flow_thrhd as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_flow_en: u32 = unsafe { ::core::mem::transmute(rx_flow_en) };
            rx_flow_en as u64
        });
        __bindgen_bitfield_unit.set(24usize, 7u8, {
            let rx_tout_thrhd: u32 = unsafe { ::core::mem::transmute(rx_tout_thrhd) };
            rx_tout_thrhd as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rx_tout_en: u32 = unsafe { ::core::mem::transmute(rx_tout_en) };
            rx_tout_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_11 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn min_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_min_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        min_cnt: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let min_cnt: u32 = unsafe { ::core::mem::transmute(min_cnt) };
            min_cnt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_12 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn min_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_min_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        min_cnt: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let min_cnt: u32 = unsafe { ::core::mem::transmute(min_cnt) };
            min_cnt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_13 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn edge_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_edge_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        edge_cnt: u32,
        reserved10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let edge_cnt: u32 = unsafe { ::core::mem::transmute(edge_cnt) };
            edge_cnt as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_14 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn sw_flow_con_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_flow_con_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xonoff_del(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xonoff_del(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn send_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn send_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sw_flow_con_en: u32,
        xonoff_del: u32,
        force_xon: u32,
        force_xoff: u32,
        send_xon: u32,
        send_xoff: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sw_flow_con_en: u32 = unsafe { ::core::mem::transmute(sw_flow_con_en) };
            sw_flow_con_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let xonoff_del: u32 = unsafe { ::core::mem::transmute(xonoff_del) };
            xonoff_del as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let force_xon: u32 = unsafe { ::core::mem::transmute(force_xon) };
            force_xon as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let force_xoff: u32 = unsafe { ::core::mem::transmute(force_xoff) };
            force_xoff as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let send_xon: u32 = unsafe { ::core::mem::transmute(send_xon) };
            send_xon as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let send_xoff: u32 = unsafe { ::core::mem::transmute(send_xoff) };
            send_xoff as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_15 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn active_threshold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_active_threshold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active_threshold: u32,
        reserved10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let active_threshold: u32 = unsafe { ::core::mem::transmute(active_threshold) };
            active_threshold as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_16 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl _bindgen_ty_2__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn xon_threshold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xon_threshold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xoff_threshold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xoff_threshold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xon_char(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xon_char(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xoff_char(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xoff_char(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xon_threshold: u32,
        xoff_threshold: u32,
        xon_char: u32,
        xoff_char: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let xon_threshold: u32 = unsafe { ::core::mem::transmute(xon_threshold) };
            xon_threshold as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let xoff_threshold: u32 = unsafe { ::core::mem::transmute(xoff_threshold) };
            xoff_threshold as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let xon_char: u32 = unsafe { ::core::mem::transmute(xon_char) };
            xon_char as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let xoff_char: u32 = unsafe { ::core::mem::transmute(xoff_char) };
            xoff_char as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_17 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_2__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn rx_idle_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rx_idle_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_idle_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_tx_idle_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_idle_thrhd: u32,
        tx_idle_num: u32,
        tx_brk_num: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let rx_idle_thrhd: u32 = unsafe { ::core::mem::transmute(rx_idle_thrhd) };
            rx_idle_thrhd as u64
        });
        __bindgen_bitfield_unit.set(10usize, 10u8, {
            let tx_idle_num: u32 = unsafe { ::core::mem::transmute(tx_idle_num) };
            tx_idle_num as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let tx_brk_num: u32 = unsafe { ::core::mem::transmute(tx_brk_num) };
            tx_brk_num as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_18 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl0_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl0_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl1_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl1_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_busy_tx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_busy_tx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dly_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dly_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dly_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dly_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        en: u32,
        dl0_en: u32,
        dl1_en: u32,
        tx_rx_en: u32,
        rx_busy_tx_en: u32,
        rx_dly_num: u32,
        tx_dly_num: u32,
        reserved10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl0_en: u32 = unsafe { ::core::mem::transmute(dl0_en) };
            dl0_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl1_en: u32 = unsafe { ::core::mem::transmute(dl1_en) };
            dl1_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tx_rx_en: u32 = unsafe { ::core::mem::transmute(tx_rx_en) };
            tx_rx_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rx_busy_tx_en: u32 = unsafe { ::core::mem::transmute(rx_busy_tx_en) };
            rx_busy_tx_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rx_dly_num: u32 = unsafe { ::core::mem::transmute(rx_dly_num) };
            rx_dly_num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let tx_dly_num: u32 = unsafe { ::core::mem::transmute(tx_dly_num) };
            tx_dly_num as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_19 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn pre_idle_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pre_idle_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pre_idle_num: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let pre_idle_num: u32 = unsafe { ::core::mem::transmute(pre_idle_num) };
            pre_idle_num as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_20 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn post_idle_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_post_idle_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        post_idle_num: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let post_idle_num: u32 = unsafe { ::core::mem::transmute(post_idle_num) };
            post_idle_num as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_21 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn rx_gap_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_rx_gap_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_gap_tout: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let rx_gap_tout: u32 = unsafe { ::core::mem::transmute(rx_gap_tout) };
            rx_gap_tout as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_22 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_2__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn char_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_char_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        data: u32,
        char_num: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let char_num: u32 = unsafe { ::core::mem::transmute(char_num) };
            char_num as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_23 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl _bindgen_ty_2__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn mem_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rx_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tx_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_flow_thrhd_h3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_flow_thrhd_h3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_tout_thrhd_h3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_tout_thrhd_h3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn xon_threshold_h2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_xon_threshold_h2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn xoff_threshold_h2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_xoff_threshold_h2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_mem_full_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_mem_full_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_mem_empty_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_mem_empty_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mem_pd: u32,
        reserved1: u32,
        reserved2: u32,
        rx_size: u32,
        tx_size: u32,
        reserved11: u32,
        rx_flow_thrhd_h3: u32,
        rx_tout_thrhd_h3: u32,
        xon_threshold_h2: u32,
        xoff_threshold_h2: u32,
        rx_mem_full_thrhd: u32,
        tx_mem_empty_thrhd: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mem_pd: u32 = unsafe { ::core::mem::transmute(mem_pd) };
            mem_pd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let rx_size: u32 = unsafe { ::core::mem::transmute(rx_size) };
            rx_size as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let tx_size: u32 = unsafe { ::core::mem::transmute(tx_size) };
            tx_size as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let rx_flow_thrhd_h3: u32 = unsafe { ::core::mem::transmute(rx_flow_thrhd_h3) };
            rx_flow_thrhd_h3 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let rx_tout_thrhd_h3: u32 = unsafe { ::core::mem::transmute(rx_tout_thrhd_h3) };
            rx_tout_thrhd_h3 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let xon_threshold_h2: u32 = unsafe { ::core::mem::transmute(xon_threshold_h2) };
            xon_threshold_h2 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 2u8, {
            let xoff_threshold_h2: u32 = unsafe { ::core::mem::transmute(xoff_threshold_h2) };
            xoff_threshold_h2 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let rx_mem_full_thrhd: u32 = unsafe { ::core::mem::transmute(rx_mem_full_thrhd) };
            rx_mem_full_thrhd as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let tx_mem_empty_thrhd: u32 = unsafe { ::core::mem::transmute(tx_mem_empty_thrhd) };
            tx_mem_empty_thrhd as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_24 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let status: u32 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_25 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_25__bindgen_ty_1,
    pub __bindgen_anon_2: _bindgen_ty_2__bindgen_ty_25__bindgen_ty_2,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let status: u32 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_25__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl _bindgen_ty_2__bindgen_ty_25__bindgen_ty_2 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_rd_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_wr_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        rd_addr: u32,
        wr_addr: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 11u8, {
            let rd_addr: u32 = unsafe { ::core::mem::transmute(rd_addr) };
            rd_addr as u64
        });
        __bindgen_bitfield_unit.set(13usize, 11u8, {
            let wr_addr: u32 = unsafe { ::core::mem::transmute(wr_addr) };
            wr_addr as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_26 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn rx_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_cnt: u32,
        tx_cnt: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let rx_cnt: u32 = unsafe { ::core::mem::transmute(rx_cnt) };
            rx_cnt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let tx_cnt: u32 = unsafe { ::core::mem::transmute(tx_cnt) };
            tx_cnt as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_27 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn min_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_min_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        min_cnt: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let min_cnt: u32 = unsafe { ::core::mem::transmute(min_cnt) };
            min_cnt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _bindgen_ty_2__bindgen_ty_28 {
    pub __bindgen_anon_1: _bindgen_ty_2__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _bindgen_ty_2__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn min_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_min_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        min_cnt: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let min_cnt: u32 = unsafe { ::core::mem::transmute(min_cnt) };
            min_cnt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type uart_dev_t = _bindgen_ty_2;
extern "C" {
    pub static mut UART0: uart_dev_t;
}
extern "C" {
    pub static mut UART1: uart_dev_t;
}
extern "C" {
    pub static mut UART2: uart_dev_t;
}
extern "C" {
    pub fn esp_dport_access_stall_other_cpu_start();
}
extern "C" {
    pub fn esp_dport_access_stall_other_cpu_end();
}
extern "C" {
    pub fn esp_dport_access_int_init();
}
extern "C" {
    pub fn esp_dport_access_int_pause();
}
extern "C" {
    pub fn esp_dport_access_int_resume();
}
extern "C" {
    pub fn esp_dport_access_read_buffer(buff_out: *mut u32, address: u32, num_words: u32);
}
extern "C" {
    pub fn esp_dport_access_reg_read(reg: u32) -> u32;
}
extern "C" {
    pub fn esp_dport_access_sequence_reg_read(reg: u32) -> u32;
}
extern "C" {
    pub fn esp_dport_access_int_abort();
}
pub const periph_module_t_PERIPH_LEDC_MODULE: periph_module_t = 0;
pub const periph_module_t_PERIPH_UART0_MODULE: periph_module_t = 1;
pub const periph_module_t_PERIPH_UART1_MODULE: periph_module_t = 2;
pub const periph_module_t_PERIPH_UART2_MODULE: periph_module_t = 3;
pub const periph_module_t_PERIPH_I2C0_MODULE: periph_module_t = 4;
pub const periph_module_t_PERIPH_I2C1_MODULE: periph_module_t = 5;
pub const periph_module_t_PERIPH_I2S0_MODULE: periph_module_t = 6;
pub const periph_module_t_PERIPH_I2S1_MODULE: periph_module_t = 7;
pub const periph_module_t_PERIPH_TIMG0_MODULE: periph_module_t = 8;
pub const periph_module_t_PERIPH_TIMG1_MODULE: periph_module_t = 9;
pub const periph_module_t_PERIPH_PWM0_MODULE: periph_module_t = 10;
pub const periph_module_t_PERIPH_PWM1_MODULE: periph_module_t = 11;
pub const periph_module_t_PERIPH_PWM2_MODULE: periph_module_t = 12;
pub const periph_module_t_PERIPH_PWM3_MODULE: periph_module_t = 13;
pub const periph_module_t_PERIPH_UHCI0_MODULE: periph_module_t = 14;
pub const periph_module_t_PERIPH_UHCI1_MODULE: periph_module_t = 15;
pub const periph_module_t_PERIPH_RMT_MODULE: periph_module_t = 16;
pub const periph_module_t_PERIPH_PCNT_MODULE: periph_module_t = 17;
pub const periph_module_t_PERIPH_SPI_MODULE: periph_module_t = 18;
pub const periph_module_t_PERIPH_HSPI_MODULE: periph_module_t = 19;
pub const periph_module_t_PERIPH_VSPI_MODULE: periph_module_t = 20;
pub const periph_module_t_PERIPH_SPI_DMA_MODULE: periph_module_t = 21;
pub const periph_module_t_PERIPH_SDMMC_MODULE: periph_module_t = 22;
pub const periph_module_t_PERIPH_SDIO_SLAVE_MODULE: periph_module_t = 23;
pub const periph_module_t_PERIPH_CAN_MODULE: periph_module_t = 24;
pub const periph_module_t_PERIPH_EMAC_MODULE: periph_module_t = 25;
pub const periph_module_t_PERIPH_RNG_MODULE: periph_module_t = 26;
pub const periph_module_t_PERIPH_WIFI_MODULE: periph_module_t = 27;
pub const periph_module_t_PERIPH_BT_MODULE: periph_module_t = 28;
pub const periph_module_t_PERIPH_WIFI_BT_COMMON_MODULE: periph_module_t = 29;
pub const periph_module_t_PERIPH_BT_BASEBAND_MODULE: periph_module_t = 30;
pub const periph_module_t_PERIPH_BT_LC_MODULE: periph_module_t = 31;
pub const periph_module_t_PERIPH_AES_MODULE: periph_module_t = 32;
pub const periph_module_t_PERIPH_SHA_MODULE: periph_module_t = 33;
pub const periph_module_t_PERIPH_RSA_MODULE: periph_module_t = 34;
pub type periph_module_t = u32;
extern "C" {
    #[doc = " @brief      enable peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Clock for the module will be ungated, and reset de-asserted."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_enable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      disable peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Clock for the module will be gated, reset asserted."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_disable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      reset peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Reset will asserted then de-assrted for the peripheral."]
    #[doc = ""]
    #[doc = " Calling this function does not enable or disable the clock for the module."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_reset(periph: periph_module_t);
}
#[doc = " Type by which ring buffers are referenced. For example, a call to xRingbufferCreate()"]
#[doc = " returns a RingbufHandle_t variable that can then be used as a parameter to"]
#[doc = " xRingbufferSend(), xRingbufferReceive(), etc."]
pub type RingbufHandle_t = *mut cty::c_void;
#[doc = " No-split buffers will only store an item in contiguous memory and will"]
#[doc = " never split an item. Each item requires an 8 byte overhead for a header"]
#[doc = " and will always internally occupy a 32-bit aligned size of space."]
pub const ringbuf_type_t_RINGBUF_TYPE_NOSPLIT: ringbuf_type_t = 0;
#[doc = " Allow-split buffers will split an item into two parts if necessary in"]
#[doc = " order to store it. Each item requires an 8 byte overhead for a header,"]
#[doc = " splitting incurs an extra header. Each item will always internally occupy"]
#[doc = " a 32-bit aligned size of space."]
pub const ringbuf_type_t_RINGBUF_TYPE_ALLOWSPLIT: ringbuf_type_t = 1;
#[doc = " Byte buffers store data as a sequence of bytes and do not maintain separate"]
#[doc = " items, therefore byte buffers have no overhead. All data is stored as a"]
#[doc = " sequence of byte and any number of bytes can be sent or retrieved each"]
#[doc = " time."]
pub const ringbuf_type_t_RINGBUF_TYPE_BYTEBUF: ringbuf_type_t = 2;
pub type ringbuf_type_t = u32;
extern "C" {
    #[doc = " @brief       Create a ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xBufferSize Size of the buffer in bytes. Note that items require"]
    #[doc = "              space for overhead in no-split/allow-split buffers"]
    #[doc = " @param[in]   xBufferType Type of ring buffer, see documentation."]
    #[doc = ""]
    #[doc = " @note    xBufferSize of no-split/allow-split buffers will be rounded up to the nearest 32-bit aligned size."]
    #[doc = ""]
    #[doc = " @return  A handle to the created ring buffer, or NULL in case of error."]
    pub fn xRingbufferCreate(xBufferSize: usize, xBufferType: ringbuf_type_t) -> RingbufHandle_t;
}
extern "C" {
    #[doc = " @brief Create a ring buffer of type RINGBUF_TYPE_NOSPLIT for a fixed item_size"]
    #[doc = ""]
    #[doc = " This API is similar to xRingbufferCreate(), but it will internally allocate"]
    #[doc = " additional space for the headers."]
    #[doc = ""]
    #[doc = " @param[in]   xItemSize   Size of each item to be put into the ring buffer"]
    #[doc = " @param[in]   xItemNum    Maximum number of items the buffer needs to hold simultaneously"]
    #[doc = ""]
    #[doc = " @return  A RingbufHandle_t handle to the created ring buffer, or NULL in case of error."]
    pub fn xRingbufferCreateNoSplit(xItemSize: usize, xItemNum: usize) -> RingbufHandle_t;
}
extern "C" {
    #[doc = " @brief       Insert an item into the ring buffer"]
    #[doc = ""]
    #[doc = " Attempt to insert an item into the ring buffer. This function will block until"]
    #[doc = " enough free space is available or until it timesout."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to insert the item into"]
    #[doc = " @param[in]   pvItem          Pointer to data to insert. NULL is allowed if xItemSize is 0."]
    #[doc = " @param[in]   xItemSize       Size of data to insert."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for room in the ring buffer."]
    #[doc = ""]
    #[doc = " @note    For no-split/allow-split ring buffers, the actual size of memory that"]
    #[doc = "          the item will occupy will be rounded up to the nearest 32-bit aligned"]
    #[doc = "          size. This is done to ensure all items are always stored in 32-bit"]
    #[doc = "          aligned fashion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE on time-out or when the data is larger than the maximum permissible size of the buffer"]
    pub fn xRingbufferSend(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const cty::c_void,
        xItemSize: usize,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief       Insert an item into the ring buffer in an ISR"]
    #[doc = ""]
    #[doc = " Attempt to insert an item into the ring buffer from an ISR. This function"]
    #[doc = " will return immediately if there is insufficient free space in the buffer."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer to insert the item into"]
    #[doc = " @param[in]   pvItem      Pointer to data to insert. NULL is allowed if xItemSize is 0."]
    #[doc = " @param[in]   xItemSize   Size of data to insert."]
    #[doc = " @param[out]  pxHigherPriorityTaskWoken   Value pointed to will be set to pdTRUE if the function woke up a higher priority task."]
    #[doc = ""]
    #[doc = " @note    For no-split/allow-split ring buffers, the actual size of memory that"]
    #[doc = "          the item will occupy will be rounded up to the nearest 32-bit aligned"]
    #[doc = "          size. This is done to ensure all items are always stored in 32-bit"]
    #[doc = "          aligned fashion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE when the ring buffer does not have space."]
    pub fn xRingbufferSendFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const cty::c_void,
        xItemSize: usize,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve an item from the ring buffer"]
    #[doc = ""]
    #[doc = " Attempt to retrieve an item from the ring buffer. This function will block"]
    #[doc = " until an item is available or until it timesout."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize      Pointer to a variable to which the size of the retrieved item will be written."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItem() is required after this to free the item retrieved."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with the length of the item."]
    #[doc = "      - NULL on timeout, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceive(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
        xTicksToWait: TickType_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve an item from the ring buffer in an ISR"]
    #[doc = ""]
    #[doc = " Attempt to retrieve an item from the ring buffer. This function returns immediately"]
    #[doc = " if there are no items available for retrieval"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize      Pointer to a variable to which the size of the"]
    #[doc = "                              retrieved item will be written."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItemFromISR() is required after this to free the item retrieved."]
    #[doc = " @note    Byte buffers do not allow multiple retrievals before returning an item"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with the length of the item."]
    #[doc = "      - NULL when the ring buffer is empty, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve a split item from an allow-split ring buffer"]
    #[doc = ""]
    #[doc = " Attempt to retrieve a split item from an allow-split ring buffer. If the item"]
    #[doc = " is not split, only a single item is retried. If the item is split, both parts"]
    #[doc = " will be retrieved. This function will block until an item is available or"]
    #[doc = " until it timesout."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  ppvHeadItem     Double pointer to first part (set to NULL if no items were retrieved)"]
    #[doc = " @param[out]  ppvTailItem     Double pointer to second part (set to NULL if item is not split)"]
    #[doc = " @param[out]  pxHeadItemSize  Pointer to size of first part (unmodified if no items were retrieved)"]
    #[doc = " @param[out]  pxTailItemSize  Pointer to size of second part (unmodified if item is not split)"]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer."]
    #[doc = ""]
    #[doc = " @note    Call(s) to vRingbufferReturnItem() is required after this to free up the item(s) retrieved."]
    #[doc = " @note    This function should only be called on allow-split buffers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if an item (split or unsplit) was retrieved"]
    #[doc = "      - pdFALSE when no item was retrieved"]
    pub fn xRingbufferReceiveSplit(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut cty::c_void,
        ppvTailItem: *mut *mut cty::c_void,
        pxHeadItemSize: *mut usize,
        pxTailItemSize: *mut usize,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve a split item from an allow-split ring buffer in an ISR"]
    #[doc = ""]
    #[doc = " Attempt to retrieve a split item from an allow-split ring buffer. If the item"]
    #[doc = " is not split, only a single item is retried. If the item is split, both parts"]
    #[doc = " will be retrieved. This function returns immediately if there are no items"]
    #[doc = " available for retrieval"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  ppvHeadItem     Double pointer to first part (set to NULL if no items were retrieved)"]
    #[doc = " @param[out]  ppvTailItem     Double pointer to second part (set to NULL if item is not split)"]
    #[doc = " @param[out]  pxHeadItemSize  Pointer to size of first part (unmodified if no items were retrieved)"]
    #[doc = " @param[out]  pxTailItemSize  Pointer to size of second part (unmodified if item is not split)"]
    #[doc = ""]
    #[doc = " @note    Calls to vRingbufferReturnItemFromISR() is required after this to free up the item(s) retrieved."]
    #[doc = " @note    This function should only be called on allow-split buffers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if an item (split or unsplit) was retrieved"]
    #[doc = "      - pdFALSE when no item was retrieved"]
    pub fn xRingbufferReceiveSplitFromISR(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut cty::c_void,
        ppvTailItem: *mut *mut cty::c_void,
        pxHeadItemSize: *mut usize,
        pxTailItemSize: *mut usize,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve bytes from a byte buffer, specifying the maximum amount of bytes to retrieve"]
    #[doc = ""]
    #[doc = " Attempt to retrieve data from a byte buffer whilst specifying a maximum number"]
    #[doc = " of bytes to retrieve. This function will block until there is data available"]
    #[doc = " for retrieval or until it timesout."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize      Pointer to a variable to which the size of the retrieved item will be written."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer."]
    #[doc = " @param[in]   xMaxSize        Maximum number of bytes to return."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItem() is required after this to free up the data retrieved."]
    #[doc = " @note    This function should only be called on byte buffers"]
    #[doc = " @note    Byte buffers do not allow multiple retrievals before returning an item"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with"]
    #[doc = "        the length of the item."]
    #[doc = "      - NULL on timeout, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveUpTo(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
        xTicksToWait: TickType_t,
        xMaxSize: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve bytes from a byte buffer, specifying the maximum amount of"]
    #[doc = "          bytes to retrieve. Call this from an ISR."]
    #[doc = ""]
    #[doc = " Attempt to retrieve bytes from a byte buffer whilst specifying a maximum number"]
    #[doc = " of bytes to retrieve. This function will return immediately if there is no data"]
    #[doc = " available for retrieval."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize  Pointer to a variable to which the size of the retrieved item will be written."]
    #[doc = " @param[in]   xMaxSize    Maximum number of bytes to return."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItemFromISR() is required after this to free up the data received."]
    #[doc = " @note    This function should only be called on byte buffers"]
    #[doc = " @note    Byte buffers do not allow multiple retrievals before returning an item"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with"]
    #[doc = "        the length of the item."]
    #[doc = "      - NULL when the ring buffer is empty, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveUpToFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut usize,
        xMaxSize: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief   Return a previously-retrieved item to the ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer the item was retrieved from"]
    #[doc = " @param[in]   pvItem      Item that was received earlier"]
    #[doc = ""]
    #[doc = " @note    If a split item is retrieved, both parts should be returned by calling this function twice"]
    pub fn vRingbufferReturnItem(xRingbuffer: RingbufHandle_t, pvItem: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief   Return a previously-retrieved item to the ring buffer from an ISR"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer the item was retrieved from"]
    #[doc = " @param[in]   pvItem      Item that was received earlier"]
    #[doc = " @param[out]  pxHigherPriorityTaskWoken   Value pointed to will be set to pdTRUE"]
    #[doc = "                                          if the function woke up a higher priority task."]
    #[doc = ""]
    #[doc = " @note    If a split item is retrieved, both parts should be returned by calling this function twice"]
    pub fn vRingbufferReturnItemFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *mut cty::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    #[doc = " @brief   Delete a ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to delete"]
    pub fn vRingbufferDelete(xRingbuffer: RingbufHandle_t);
}
extern "C" {
    #[doc = " @brief   Get maximum size of an item that can be placed in the ring buffer"]
    #[doc = ""]
    #[doc = " This function returns the maximum size an item can have if it was placed in"]
    #[doc = " an empty ring buffer."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to query"]
    #[doc = ""]
    #[doc = " @return  Maximum size, in bytes, of an item that can be placed in a ring buffer."]
    pub fn xRingbufferGetMaxItemSize(xRingbuffer: RingbufHandle_t) -> usize;
}
extern "C" {
    #[doc = " @brief   Get current free size available for an item/data in the buffer"]
    #[doc = ""]
    #[doc = " This gives the real time free space available for an item/data in the ring"]
    #[doc = " buffer. This represents the maximum size an item/data can have if it was"]
    #[doc = " currently sent to the ring buffer."]
    #[doc = ""]
    #[doc = " @warning This API is not thread safe. So, if multiple threads are accessing"]
    #[doc = "          the same ring buffer, it is the application's responsibility to"]
    #[doc = "          ensure atomic access to this API and the subsequent Send"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to query"]
    #[doc = ""]
    #[doc = " @return  Current free size, in bytes, available for an entry"]
    pub fn xRingbufferGetCurFreeSize(xRingbuffer: RingbufHandle_t) -> usize;
}
extern "C" {
    #[doc = " @brief   Add the ring buffer's read semaphore to a queue set."]
    #[doc = ""]
    #[doc = " The ring buffer's read semaphore indicates that data has been written"]
    #[doc = " to the ring buffer. This function adds the ring buffer's read semaphore to"]
    #[doc = " a queue set."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to add to the queue set"]
    #[doc = " @param[in]   xQueueSet       Queue set to add the ring buffer's read semaphore to"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE on success, pdFALSE otherwise"]
    pub fn xRingbufferAddToQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Check if the selected queue set member is the ring buffer's read semaphore"]
    #[doc = ""]
    #[doc = " This API checks if queue set member returned from xQueueSelectFromSet()"]
    #[doc = " is the read semaphore of this ring buffer. If so, this indicates the ring buffer"]
    #[doc = " has items waiting to be retrieved."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer which should be checked"]
    #[doc = " @param[in]   xMember         Member returned from xQueueSelectFromSet"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE when semaphore belongs to ring buffer"]
    #[doc = "      - pdFALSE otherwise."]
    pub fn xRingbufferCanRead(
        xRingbuffer: RingbufHandle_t,
        xMember: QueueSetMemberHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Remove the ring buffer's read semaphore from a queue set."]
    #[doc = ""]
    #[doc = " This specifically removes a ring buffer's read semaphore from a queue set. The"]
    #[doc = " read semaphore is used to indicate when data has been written to the ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to remove from the queue set"]
    #[doc = " @param[in]   xQueueSet       Queue set to remove the ring buffer's read semaphore from"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE on success"]
    #[doc = "      - pdFALSE otherwise"]
    pub fn xRingbufferRemoveFromQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Get information about ring buffer status"]
    #[doc = ""]
    #[doc = " Get information of the a ring buffer's current status such as"]
    #[doc = " free/read/write pointer positions, and number of items waiting to be retrieved."]
    #[doc = " Arguments can be set to NULL if they are not required."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to remove from the queue set"]
    #[doc = " @param[out]  uxFree          Pointer use to store free pointer position"]
    #[doc = " @param[out]  uxRead          Pointer use to store read pointer position"]
    #[doc = " @param[out]  uxWrite         Pointer use to store write pointer position"]
    #[doc = " @param[out]  uxItemsWaiting  Pointer use to store number of items (bytes for byte buffer) waiting to be retrieved"]
    pub fn vRingbufferGetInfo(
        xRingbuffer: RingbufHandle_t,
        uxFree: *mut UBaseType_t,
        uxRead: *mut UBaseType_t,
        uxWrite: *mut UBaseType_t,
        uxItemsWaiting: *mut UBaseType_t,
    );
}
extern "C" {
    #[doc = " @brief   Debugging function to print the internal pointers in the ring buffer"]
    #[doc = ""]
    #[doc = " @param   xRingbuffer Ring buffer to show"]
    pub fn xRingbufferPrintInfo(xRingbuffer: RingbufHandle_t);
}
extern "C" {
    #[doc = " @cond"]
    pub fn xRingbufferIsNextItemWrapped(xRingbuffer: RingbufHandle_t) -> bool;
}
extern "C" {
    pub fn xRingbufferAddToQueueSetWrite(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xRingbufferRemoveFromQueueSetWrite(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
#[doc = "< mode: regular UART mode"]
pub const uart_mode_t_UART_MODE_UART: uart_mode_t = 0;
#[doc = "< mode: half duplex RS485 UART mode control by RTS pin"]
pub const uart_mode_t_UART_MODE_RS485_HALF_DUPLEX: uart_mode_t = 1;
#[doc = "< mode: IRDA  UART mode"]
pub const uart_mode_t_UART_MODE_IRDA: uart_mode_t = 2;
#[doc = "< mode: RS485 collision detection UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_COLLISION_DETECT: uart_mode_t = 3;
#[doc = "< mode: application control RS485 UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_APP_CTRL: uart_mode_t = 4;
#[doc = " @brief UART mode selection"]
pub type uart_mode_t = u32;
#[doc = "< word length: 5bits"]
pub const uart_word_length_t_UART_DATA_5_BITS: uart_word_length_t = 0;
#[doc = "< word length: 6bits"]
pub const uart_word_length_t_UART_DATA_6_BITS: uart_word_length_t = 1;
#[doc = "< word length: 7bits"]
pub const uart_word_length_t_UART_DATA_7_BITS: uart_word_length_t = 2;
#[doc = "< word length: 8bits"]
pub const uart_word_length_t_UART_DATA_8_BITS: uart_word_length_t = 3;
pub const uart_word_length_t_UART_DATA_BITS_MAX: uart_word_length_t = 4;
#[doc = " @brief UART word length constants"]
pub type uart_word_length_t = u32;
#[doc = "< stop bit: 1bit"]
pub const uart_stop_bits_t_UART_STOP_BITS_1: uart_stop_bits_t = 1;
#[doc = "< stop bit: 1.5bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_1_5: uart_stop_bits_t = 2;
#[doc = "< stop bit: 2bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_2: uart_stop_bits_t = 3;
pub const uart_stop_bits_t_UART_STOP_BITS_MAX: uart_stop_bits_t = 4;
#[doc = " @brief UART stop bits number"]
pub type uart_stop_bits_t = u32;
#[doc = "< UART base address 0x3ff40000"]
pub const uart_port_t_UART_NUM_0: uart_port_t = 0;
#[doc = "< UART base address 0x3ff50000"]
pub const uart_port_t_UART_NUM_1: uart_port_t = 1;
#[doc = "< UART base address 0x3ff6e000"]
pub const uart_port_t_UART_NUM_2: uart_port_t = 2;
pub const uart_port_t_UART_NUM_MAX: uart_port_t = 3;
#[doc = " @brief UART peripheral number"]
pub type uart_port_t = u32;
#[doc = "< Disable UART parity"]
pub const uart_parity_t_UART_PARITY_DISABLE: uart_parity_t = 0;
#[doc = "< Enable UART even parity"]
pub const uart_parity_t_UART_PARITY_EVEN: uart_parity_t = 2;
#[doc = "< Enable UART odd parity"]
pub const uart_parity_t_UART_PARITY_ODD: uart_parity_t = 3;
#[doc = " @brief UART parity constants"]
pub type uart_parity_t = u32;
#[doc = "< disable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_DISABLE: uart_hw_flowcontrol_t = 0;
#[doc = "< enable RX hardware flow control (rts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_RTS: uart_hw_flowcontrol_t = 1;
#[doc = "< enable TX hardware flow control (cts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS: uart_hw_flowcontrol_t = 2;
#[doc = "< enable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS_RTS: uart_hw_flowcontrol_t = 3;
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_MAX: uart_hw_flowcontrol_t = 4;
#[doc = " @brief UART hardware flow control modes"]
pub type uart_hw_flowcontrol_t = u32;
#[doc = " @brief UART configuration parameters for uart_param_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_config_t {
    #[doc = "< UART baud rate"]
    pub baud_rate: cty::c_int,
    #[doc = "< UART byte size"]
    pub data_bits: uart_word_length_t,
    #[doc = "< UART parity mode"]
    pub parity: uart_parity_t,
    #[doc = "< UART stop bits"]
    pub stop_bits: uart_stop_bits_t,
    #[doc = "< UART HW flow control mode (cts/rts)"]
    pub flow_ctrl: uart_hw_flowcontrol_t,
    #[doc = "< UART HW RTS threshold"]
    pub rx_flow_ctrl_thresh: u8,
    #[doc = "< Set to true if UART should be clocked from REF_TICK"]
    pub use_ref_tick: bool,
}
#[doc = " @brief UART interrupt configuration parameters for uart_intr_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_intr_config_t {
    #[doc = "< UART interrupt enable mask, choose from UART_XXXX_INT_ENA_M under UART_INT_ENA_REG(i), connect with bit-or operator"]
    pub intr_enable_mask: u32,
    #[doc = "< UART timeout interrupt threshold (unit: time of sending one byte)"]
    pub rx_timeout_thresh: u8,
    #[doc = "< UART TX empty interrupt threshold."]
    pub txfifo_empty_intr_thresh: u8,
    #[doc = "< UART RX full interrupt threshold."]
    pub rxfifo_full_thresh: u8,
}
#[doc = "< UART data event"]
pub const uart_event_type_t_UART_DATA: uart_event_type_t = 0;
#[doc = "< UART break event"]
pub const uart_event_type_t_UART_BREAK: uart_event_type_t = 1;
#[doc = "< UART RX buffer full event"]
pub const uart_event_type_t_UART_BUFFER_FULL: uart_event_type_t = 2;
#[doc = "< UART FIFO overflow event"]
pub const uart_event_type_t_UART_FIFO_OVF: uart_event_type_t = 3;
#[doc = "< UART RX frame error event"]
pub const uart_event_type_t_UART_FRAME_ERR: uart_event_type_t = 4;
#[doc = "< UART RX parity event"]
pub const uart_event_type_t_UART_PARITY_ERR: uart_event_type_t = 5;
#[doc = "< UART TX data and break event"]
pub const uart_event_type_t_UART_DATA_BREAK: uart_event_type_t = 6;
#[doc = "< UART pattern detected"]
pub const uart_event_type_t_UART_PATTERN_DET: uart_event_type_t = 7;
#[doc = "< UART event max index"]
pub const uart_event_type_t_UART_EVENT_MAX: uart_event_type_t = 8;
#[doc = " @brief UART event types used in the ring buffer"]
pub type uart_event_type_t = u32;
#[doc = " @brief Event structure used in UART event queue"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_event_t {
    #[doc = "< UART event type"]
    pub type_: uart_event_type_t,
    #[doc = "< UART data size for UART_DATA event"]
    pub size: usize,
}
pub type uart_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief Set UART data bits."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param data_bit UART data bits"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_word_length(uart_num: uart_port_t, data_bit: uart_word_length_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART data bits."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param data_bit Pointer to accept value of UART data bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL  Parameter error"]
    #[doc = "     - ESP_OK    Success, result will be put in (*data_bit)"]
    pub fn uart_get_word_length(
        uart_num: uart_port_t,
        data_bit: *mut uart_word_length_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART stop bits."]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param stop_bits  UART stop bits"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Fail"]
    pub fn uart_set_stop_bits(uart_num: uart_port_t, stop_bits: uart_stop_bits_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART stop bits."]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param stop_bits  Pointer to accept value of UART stop bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success, result will be put in (*stop_bit)"]
    pub fn uart_get_stop_bits(uart_num: uart_port_t, stop_bits: *mut uart_stop_bits_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART parity mode."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param parity_mode the enum of uart parity configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL  Parameter error"]
    #[doc = "     - ESP_OK    Success"]
    pub fn uart_set_parity(uart_num: uart_port_t, parity_mode: uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART parity mode."]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param parity_mode Pointer to accept value of UART parity mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL  Parameter error"]
    #[doc = "     - ESP_OK    Success, result will be put in (*parity_mode)"]
    #[doc = ""]
    pub fn uart_get_parity(uart_num: uart_port_t, parity_mode: *mut uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART baud rate."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param baudrate UART baud rate."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success"]
    pub fn uart_set_baudrate(uart_num: uart_port_t, baudrate: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART baud rate."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param baudrate Pointer to accept value of UART baud rate"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success, result will be put in (*baudrate)"]
    #[doc = ""]
    pub fn uart_get_baudrate(uart_num: uart_port_t, baudrate: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART line inverse mode"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param inverse_mask Choose the wires that need to be inverted."]
    #[doc = "        Inverse_mask should be chosen from"]
    #[doc = "        UART_INVERSE_RXD / UART_INVERSE_TXD / UART_INVERSE_RTS / UART_INVERSE_CTS,"]
    #[doc = "        combined with OR operation."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_line_inverse(uart_num: uart_port_t, inverse_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set hardware flow control."]
    #[doc = ""]
    #[doc = " @param uart_num   UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param flow_ctrl Hardware flow control mode"]
    #[doc = " @param rx_thresh Threshold of Hardware RX flow control (0 ~ UART_FIFO_LEN)."]
    #[doc = "        Only when UART_HW_FLOWCTRL_RTS is set, will the rx_thresh value be set."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: uart_hw_flowcontrol_t,
        rx_thresh: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set software flow control."]
    #[doc = ""]
    #[doc = " @param uart_num   UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param enable     switch on or off"]
    #[doc = " @param rx_thresh_xon  low water mark"]
    #[doc = " @param rx_thresh_xoff high water mark"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_sw_flow_ctrl(
        uart_num: uart_port_t,
        enable: bool,
        rx_thresh_xon: u8,
        rx_thresh_xoff: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get hardware flow control mode"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param flow_ctrl Option for different flow control mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success, result will be put in (*flow_ctrl)"]
    pub fn uart_get_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: *mut uart_hw_flowcontrol_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear UART interrupt status"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param clr_mask  Bit mask of the interrupt status to be cleared."]
    #[doc = "                  The bit mask should be composed from the fields of register UART_INT_CLR_REG."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_clear_intr_status(uart_num: uart_port_t, clr_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART interrupt enable"]
    #[doc = ""]
    #[doc = " @param uart_num     UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param enable_mask  Bit mask of the enable bits."]
    #[doc = "                     The bit mask should be composed from the fields of register UART_INT_ENA_REG."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_intr_mask(uart_num: uart_port_t, enable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear UART interrupt enable bits"]
    #[doc = ""]
    #[doc = " @param uart_num      UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param disable_mask  Bit mask of the disable bits."]
    #[doc = "                      The bit mask should be composed from the fields of register UART_INT_ENA_REG."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_intr_mask(uart_num: uart_port_t, disable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_tx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param enable  1: enable; 0: disable"]
    #[doc = " @param thresh  Threshold of TX interrupt, 0 ~ UART_FIFO_LEN"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_tx_intr(
        uart_num: uart_port_t,
        enable: cty::c_int,
        thresh: cty::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register UART interrupt handler (ISR)."]
    #[doc = ""]
    #[doc = " @note UART ISR handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param fn  Interrupt handler function."]
    #[doc = " @param arg parameter for handler function"]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param handle Pointer to return handle. If non-NULL, a handle for the interrupt will"]
    #[doc = "        be returned here."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_isr_register(
        uart_num: uart_port_t,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg: *mut cty::c_void,
        intr_alloc_flags: cty::c_int,
        handle: *mut uart_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Free UART interrupt handler registered by uart_isr_register. Must be called on the same core as"]
    #[doc = " uart_isr_register was called."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_isr_free(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART pin number"]
    #[doc = ""]
    #[doc = " @note Internal signal can be output to multiple GPIO pads."]
    #[doc = "       Only one GPIO pad can connect with input signal."]
    #[doc = ""]
    #[doc = " @note Instead of GPIO number a macro 'UART_PIN_NO_CHANGE' may be provided"]
    #[doc = "to keep the currently allocated pin."]
    #[doc = ""]
    #[doc = " @param uart_num   UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param tx_io_num  UART TX pin GPIO number."]
    #[doc = " @param rx_io_num  UART RX pin GPIO number."]
    #[doc = " @param rts_io_num UART RTS pin GPIO number."]
    #[doc = " @param cts_io_num UART CTS pin GPIO number."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_pin(
        uart_num: uart_port_t,
        tx_io_num: cty::c_int,
        rx_io_num: cty::c_int,
        rts_io_num: cty::c_int,
        cts_io_num: cty::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Manually set the UART RTS pin level."]
    #[doc = " @note  UART must be configured with hardware flow control disabled."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param level    1: RTS output low (active); 0: RTS output high (block)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_rts(uart_num: uart_port_t, level: cty::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Manually set the UART DTR pin level."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param level    1: DTR output low; 0: DTR output high"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_dtr(uart_num: uart_port_t, level: cty::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART idle interval after tx FIFO is empty"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param idle_num idle interval after tx FIFO is empty(unit: the time it takes to send one bit"]
    #[doc = "        under current baudrate)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_tx_idle_num(uart_num: uart_port_t, idle_num: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART configuration parameters."]
    #[doc = ""]
    #[doc = " @param uart_num    UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param uart_config UART parameter settings"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_param_config(uart_num: uart_port_t, uart_config: *const uart_config_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure UART interrupts."]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param intr_conf UART interrupt settings"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_intr_config(
        uart_num: uart_port_t,
        intr_conf: *const uart_intr_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install UART driver."]
    #[doc = ""]
    #[doc = " UART ISR handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @note  Rx_buffer_size should be greater than UART_FIFO_LEN. Tx_buffer_size should be either zero or greater than UART_FIFO_LEN."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param rx_buffer_size UART RX ring buffer size."]
    #[doc = " @param tx_buffer_size UART TX ring buffer size."]
    #[doc = "        If set to zero, driver will not use TX buffer, TX function will block task until all data have been sent out."]
    #[doc = " @param queue_size UART event queue size/depth."]
    #[doc = " @param uart_queue UART event queue handle (out param). On success, a new queue handle is written here to provide"]
    #[doc = "        access to UART events. If set to NULL, driver will not use an event queue."]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. Do not set ESP_INTR_FLAG_IRAM here"]
    #[doc = "        (the driver's ISR handler is not located in IRAM)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_driver_install(
        uart_num: uart_port_t,
        rx_buffer_size: cty::c_int,
        tx_buffer_size: cty::c_int,
        queue_size: cty::c_int,
        uart_queue: *mut QueueHandle_t,
        intr_alloc_flags: cty::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall UART driver."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_driver_delete(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait until UART TX FIFO is empty."]
    #[doc = ""]
    #[doc = " @param uart_num      UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param ticks_to_wait Timeout, count in RTOS ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_ERR_TIMEOUT  Timeout"]
    pub fn uart_wait_tx_done(uart_num: uart_port_t, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length."]
    #[doc = ""]
    #[doc = " This function will not wait for enough space in TX FIFO. It will just fill the available TX FIFO and return when the FIFO is full."]
    #[doc = " @note This function should only be used when UART TX buffer is not enabled."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param buffer data buffer address"]
    #[doc = " @param len    data length to send"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1)  Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_tx_chars(uart_num: uart_port_t, buffer: *const cty::c_char, len: u32)
        -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,"]
    #[doc = ""]
    #[doc = " If the UART driver's parameter 'tx_buffer_size' is set to zero:"]
    #[doc = " This function will not return until all the data have been sent out, or at least pushed into TX FIFO."]
    #[doc = ""]
    #[doc = " Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,"]
    #[doc = " UART ISR will then move data from the ring buffer to TX FIFO gradually."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param src   data buffer address"]
    #[doc = " @param size  data length to send"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes(
        uart_num: uart_port_t,
        src: *const cty::c_char,
        size: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,"]
    #[doc = ""]
    #[doc = " If the UART driver's parameter 'tx_buffer_size' is set to zero:"]
    #[doc = " This function will not return until all the data and the break signal have been sent out."]
    #[doc = " After all data is sent out, send a break signal."]
    #[doc = ""]
    #[doc = " Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,"]
    #[doc = " UART ISR will then move data from the ring buffer to TX FIFO gradually."]
    #[doc = " After all data sent out, send a break signal."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param src   data buffer address"]
    #[doc = " @param size  data length to send"]
    #[doc = " @param brk_len break signal duration(unit: the time it takes to send one bit at current baudrate)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes_with_break(
        uart_num: uart_port_t,
        src: *const cty::c_char,
        size: usize,
        brk_len: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief UART read bytes from UART buffer"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param buf     pointer to the buffer."]
    #[doc = " @param length  data length"]
    #[doc = " @param ticks_to_wait sTimeout, count in RTOS ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Error"]
    #[doc = "     - OTHERS (>=0) The number of bytes read from UART FIFO"]
    pub fn uart_read_bytes(
        uart_num: uart_port_t,
        buf: *mut u8,
        length: u32,
        ticks_to_wait: TickType_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Alias of uart_flush_input."]
    #[doc = "        UART ring buffer flush. This will discard all data in the UART RX buffer."]
    #[doc = " @note  Instead of waiting the data sent out, this function will clear UART rx buffer."]
    #[doc = "        In order to send all the data in tx FIFO, we can use uart_wait_tx_done function."]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_flush(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear input buffer, discard all the data is in the ring-buffer."]
    #[doc = " @note  In order to send all the data in tx FIFO, we can use uart_wait_tx_done function."]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_flush_input(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART get RX ring buffer cached data length"]
    #[doc = ""]
    #[doc = " @param   uart_num UART port number."]
    #[doc = " @param   size Pointer of size_t to accept cached data length"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_get_buffered_data_len(uart_num: uart_port_t, size: *mut usize) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART disable pattern detect function."]
    #[doc = "          Designed for applications like 'AT commands'."]
    #[doc = "          When the hardware detects a series of one same character, the interrupt will be triggered."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_pattern_det_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART enable pattern detect function."]
    #[doc = "        Designed for applications like 'AT commands'."]
    #[doc = "        When the hardware detect a series of one same character, the interrupt will be triggered."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number."]
    #[doc = " @param pattern_chr character of the pattern"]
    #[doc = " @param chr_num number of the character, 8bit value."]
    #[doc = " @param chr_tout timeout of the interval between each pattern characters, 24bit value, unit is APB (80Mhz) clock cycle."]
    #[doc = "        When the duration is less than this value, it will not take this data as at_cmd char"]
    #[doc = " @param post_idle idle time after the last pattern character, 24bit value, unit is APB (80Mhz) clock cycle."]
    #[doc = "        When the duration is less than this value, it will not take the previous data as the last at_cmd char"]
    #[doc = " @param pre_idle idle time before the first pattern character, 24bit value, unit is APB (80Mhz) clock cycle."]
    #[doc = "        When the duration is less than this value, it will not take this data as the first at_cmd char"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_pattern_det_intr(
        uart_num: uart_port_t,
        pattern_chr: cty::c_char,
        chr_num: u8,
        chr_tout: cty::c_int,
        post_idle: cty::c_int,
        pre_idle: cty::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer."]
    #[doc = "        The positions of the detected pattern are saved in a queue,"]
    #[doc = "        this function will dequeue the first pattern position and move the pointer to next pattern position."]
    #[doc = " @note  If the RX buffer is full and flow control is not enabled,"]
    #[doc = "        the detected pattern may not be found in the rx buffer due to overflow."]
    #[doc = ""]
    #[doc = "        The following APIs will modify the pattern position info:"]
    #[doc = "        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos"]
    #[doc = "        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer"]
    #[doc = "        when using pattern detect feature."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number"]
    #[doc = " @return"]
    #[doc = "     - (-1) No pattern found for current index or parameter error"]
    #[doc = "     - others the pattern position in rx buffer."]
    pub fn uart_pattern_pop_pos(uart_num: uart_port_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer."]
    #[doc = "        The positions of the detected pattern are saved in a queue,"]
    #[doc = "        This function do nothing to the queue."]
    #[doc = " @note  If the RX buffer is full and flow control is not enabled,"]
    #[doc = "        the detected pattern may not be found in the rx buffer due to overflow."]
    #[doc = ""]
    #[doc = "        The following APIs will modify the pattern position info:"]
    #[doc = "        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos"]
    #[doc = "        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer"]
    #[doc = "        when using pattern detect feature."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number"]
    #[doc = " @return"]
    #[doc = "     - (-1) No pattern found for current index or parameter error"]
    #[doc = "     - others the pattern position in rx buffer."]
    pub fn uart_pattern_get_pos(uart_num: uart_port_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Allocate a new memory with the given length to save record the detected pattern position in rx buffer."]
    #[doc = " @param uart_num UART port number"]
    #[doc = " @param queue_length Max queue length for the detected pattern."]
    #[doc = "        If the queue length is not large enough, some pattern positions might be lost."]
    #[doc = "        Set this value to the maximum number of patterns that could be saved in data buffer at the same time."]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_NO_MEM No enough memory"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver not installed"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn uart_pattern_queue_reset(uart_num: uart_port_t, queue_length: cty::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART set communication mode"]
    #[doc = " @note  This function must be executed after uart_driver_install(), when the driver object is initialized."]
    #[doc = " @param uart_num     Uart number to configure"]
    #[doc = " @param mode UART    UART mode to set"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_mode(uart_num: uart_port_t, mode: uart_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART set threshold timeout for TOUT feature"]
    #[doc = ""]
    #[doc = " @param uart_num     Uart number to configure"]
    #[doc = " @param tout_thresh  This parameter defines timeout threshold in uart symbol periods. The maximum value of threshold is 126."]
    #[doc = "        tout_thresh = 1, defines TOUT interrupt timeout equal to transmission time of one symbol (~11 bit) on current baudrate."]
    #[doc = "        If the time is expired the UART_RXFIFO_TOUT_INT interrupt is triggered. If tout_thresh == 0,"]
    #[doc = "        the TOUT feature is disabled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_rx_timeout(uart_num: uart_port_t, tout_thresh: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns collision detection flag for RS485 mode"]
    #[doc = "        Function returns the collision detection flag into variable pointed by collision_flag."]
    #[doc = "        *collision_flag = true, if collision detected else it is equal to false."]
    #[doc = "        This function should be executed when actual transmission is completed (after uart_write_bytes())."]
    #[doc = ""]
    #[doc = " @param uart_num       Uart number to configure"]
    #[doc = " @param collision_flag Pointer to variable of type bool to return collision flag."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_collision_flag(uart_num: uart_port_t, collision_flag: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the number of RX pin signal edges for light sleep wakeup"]
    #[doc = ""]
    #[doc = " UART can be used to wake up the system from light sleep. This feature works"]
    #[doc = " by counting the number of positive edges on RX pin and comparing the count to"]
    #[doc = " the threshold. When the count exceeds the threshold, system is woken up from"]
    #[doc = " light sleep. This function allows setting the threshold value."]
    #[doc = ""]
    #[doc = " Stop bit and parity bits (if enabled) also contribute to the number of edges."]
    #[doc = " For example, letter 'a' with ASCII code 97 is encoded as 0100001101 on the wire"]
    #[doc = " (with 8n1 configuration), start and stop bits included. This sequence has 3"]
    #[doc = " positive edges (transitions from 0 to 1). Therefore, to wake up the system"]
    #[doc = " when 'a' is sent, set wakeup_threshold=3."]
    #[doc = ""]
    #[doc = " The character that triggers wakeup is not received by UART (i.e. it can not"]
    #[doc = " be obtained from UART FIFO). Depending on the baud rate, a few characters"]
    #[doc = " after that will also not be received. Note that when the chip enters and exits"]
    #[doc = " light sleep mode, APB frequency will be changing. To make sure that UART has"]
    #[doc = " correct baud rate all the time, select REF_TICK as UART clock source,"]
    #[doc = " by setting use_ref_tick field in uart_config_t to true."]
    #[doc = ""]
    #[doc = " @note in ESP32, the wakeup signal can only be input via IO_MUX (i.e."]
    #[doc = "       GPIO3 should be configured as function_1 to wake up UART0,"]
    #[doc = "       GPIO9 should be configured as function_5 to wake up UART1), UART2"]
    #[doc = "       does not support light sleep wakeup feature."]
    #[doc = ""]
    #[doc = " @param uart_num  UART number"]
    #[doc = " @param wakeup_threshold  number of RX edges for light sleep wakeup, value is 3 .. 0x3ff."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if uart_num is incorrect or wakeup_threshold is"]
    #[doc = "        outside of [3, 0x3ff] range."]
    pub fn uart_set_wakeup_threshold(
        uart_num: uart_port_t,
        wakeup_threshold: cty::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the number of RX pin signal edges for light sleep wakeup."]
    #[doc = ""]
    #[doc = " See description of uart_set_wakeup_threshold for the explanation of UART"]
    #[doc = " wakeup feature."]
    #[doc = ""]
    #[doc = " @param uart_num  UART number"]
    #[doc = " @param[out] out_wakeup_threshold  output, set to the current value of wakeup"]
    #[doc = "                                   threshold for the given UART."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if out_wakeup_threshold is NULL"]
    pub fn uart_get_wakeup_threshold(
        uart_num: uart_port_t,
        out_wakeup_threshold: *mut cty::c_int,
    ) -> esp_err_t;
}
pub type http_data_cb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut http_parser,
        at: *const cty::c_char,
        length: usize,
    ) -> cty::c_int,
>;
pub type http_cb =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut http_parser) -> cty::c_int>;
pub const http_method_HTTP_DELETE: http_method = 0;
pub const http_method_HTTP_GET: http_method = 1;
pub const http_method_HTTP_HEAD: http_method = 2;
pub const http_method_HTTP_POST: http_method = 3;
pub const http_method_HTTP_PUT: http_method = 4;
pub const http_method_HTTP_CONNECT: http_method = 5;
pub const http_method_HTTP_OPTIONS: http_method = 6;
pub const http_method_HTTP_TRACE: http_method = 7;
pub const http_method_HTTP_COPY: http_method = 8;
pub const http_method_HTTP_LOCK: http_method = 9;
pub const http_method_HTTP_MKCOL: http_method = 10;
pub const http_method_HTTP_MOVE: http_method = 11;
pub const http_method_HTTP_PROPFIND: http_method = 12;
pub const http_method_HTTP_PROPPATCH: http_method = 13;
pub const http_method_HTTP_SEARCH: http_method = 14;
pub const http_method_HTTP_UNLOCK: http_method = 15;
pub const http_method_HTTP_BIND: http_method = 16;
pub const http_method_HTTP_REBIND: http_method = 17;
pub const http_method_HTTP_UNBIND: http_method = 18;
pub const http_method_HTTP_ACL: http_method = 19;
pub const http_method_HTTP_REPORT: http_method = 20;
pub const http_method_HTTP_MKACTIVITY: http_method = 21;
pub const http_method_HTTP_CHECKOUT: http_method = 22;
pub const http_method_HTTP_MERGE: http_method = 23;
pub const http_method_HTTP_MSEARCH: http_method = 24;
pub const http_method_HTTP_NOTIFY: http_method = 25;
pub const http_method_HTTP_SUBSCRIBE: http_method = 26;
pub const http_method_HTTP_UNSUBSCRIBE: http_method = 27;
pub const http_method_HTTP_PATCH: http_method = 28;
pub const http_method_HTTP_PURGE: http_method = 29;
pub const http_method_HTTP_MKCALENDAR: http_method = 30;
pub const http_method_HTTP_LINK: http_method = 31;
pub const http_method_HTTP_UNLINK: http_method = 32;
pub type http_method = u32;
pub const http_parser_type_HTTP_REQUEST: http_parser_type = 0;
pub const http_parser_type_HTTP_RESPONSE: http_parser_type = 1;
pub const http_parser_type_HTTP_BOTH: http_parser_type = 2;
pub type http_parser_type = u32;
pub const flags_F_CHUNKED: flags = 1;
pub const flags_F_CONNECTION_KEEP_ALIVE: flags = 2;
pub const flags_F_CONNECTION_CLOSE: flags = 4;
pub const flags_F_CONNECTION_UPGRADE: flags = 8;
pub const flags_F_TRAILING: flags = 16;
pub const flags_F_UPGRADE: flags = 32;
pub const flags_F_SKIPBODY: flags = 64;
pub const flags_F_CONTENTLENGTH: flags = 128;
pub type flags = u32;
pub const http_errno_HPE_OK: http_errno = 0;
pub const http_errno_HPE_CB_message_begin: http_errno = 1;
pub const http_errno_HPE_CB_url: http_errno = 2;
pub const http_errno_HPE_CB_header_field: http_errno = 3;
pub const http_errno_HPE_CB_header_value: http_errno = 4;
pub const http_errno_HPE_CB_headers_complete: http_errno = 5;
pub const http_errno_HPE_CB_body: http_errno = 6;
pub const http_errno_HPE_CB_message_complete: http_errno = 7;
pub const http_errno_HPE_CB_status: http_errno = 8;
pub const http_errno_HPE_CB_chunk_header: http_errno = 9;
pub const http_errno_HPE_CB_chunk_complete: http_errno = 10;
pub const http_errno_HPE_INVALID_EOF_STATE: http_errno = 11;
pub const http_errno_HPE_HEADER_OVERFLOW: http_errno = 12;
pub const http_errno_HPE_CLOSED_CONNECTION: http_errno = 13;
pub const http_errno_HPE_INVALID_VERSION: http_errno = 14;
pub const http_errno_HPE_INVALID_STATUS: http_errno = 15;
pub const http_errno_HPE_INVALID_METHOD: http_errno = 16;
pub const http_errno_HPE_INVALID_URL: http_errno = 17;
pub const http_errno_HPE_INVALID_HOST: http_errno = 18;
pub const http_errno_HPE_INVALID_PORT: http_errno = 19;
pub const http_errno_HPE_INVALID_PATH: http_errno = 20;
pub const http_errno_HPE_INVALID_QUERY_STRING: http_errno = 21;
pub const http_errno_HPE_INVALID_FRAGMENT: http_errno = 22;
pub const http_errno_HPE_LF_EXPECTED: http_errno = 23;
pub const http_errno_HPE_INVALID_HEADER_TOKEN: http_errno = 24;
pub const http_errno_HPE_INVALID_CONTENT_LENGTH: http_errno = 25;
pub const http_errno_HPE_UNEXPECTED_CONTENT_LENGTH: http_errno = 26;
pub const http_errno_HPE_INVALID_CHUNK_SIZE: http_errno = 27;
pub const http_errno_HPE_INVALID_CONSTANT: http_errno = 28;
pub const http_errno_HPE_INVALID_INTERNAL_STATE: http_errno = 29;
pub const http_errno_HPE_STRICT: http_errno = 30;
pub const http_errno_HPE_PAUSED: http_errno = 31;
pub const http_errno_HPE_UNKNOWN: http_errno = 32;
pub type http_errno = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_parser {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub nread: u32,
    pub content_length: u64,
    #[doc = " READ-ONLY"]
    pub http_major: cty::c_ushort,
    pub http_minor: cty::c_ushort,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    #[doc = " PUBLIC"]
    pub data: *mut cty::c_void,
}
impl http_parser {
    #[inline]
    pub fn type_(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn state(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn header_state(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_header_state(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn index(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_index(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn lenient_http_headers(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lenient_http_headers(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: cty::c_uint,
        flags: cty::c_uint,
        state: cty::c_uint,
        header_state: cty::c_uint,
        index: cty::c_uint,
        lenient_http_headers: cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 8u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(10usize, 7u8, {
            let state: u32 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(17usize, 7u8, {
            let header_state: u32 = unsafe { ::core::mem::transmute(header_state) };
            header_state as u64
        });
        __bindgen_bitfield_unit.set(24usize, 7u8, {
            let index: u32 = unsafe { ::core::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lenient_http_headers: u32 = unsafe { ::core::mem::transmute(lenient_http_headers) };
            lenient_http_headers as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn status_code(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_status_code(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn method(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_method(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn http_errno(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(24usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_http_errno(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(24usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn upgrade(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upgrade(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        status_code: cty::c_uint,
        method: cty::c_uint,
        http_errno: cty::c_uint,
        upgrade: cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let status_code: u32 = unsafe { ::core::mem::transmute(status_code) };
            status_code as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let method: u32 = unsafe { ::core::mem::transmute(method) };
            method as u64
        });
        __bindgen_bitfield_unit.set(24usize, 7u8, {
            let http_errno: u32 = unsafe { ::core::mem::transmute(http_errno) };
            http_errno as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let upgrade: u32 = unsafe { ::core::mem::transmute(upgrade) };
            upgrade as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_parser_settings {
    pub on_message_begin: http_cb,
    pub on_url: http_data_cb,
    pub on_status: http_data_cb,
    pub on_header_field: http_data_cb,
    pub on_header_value: http_data_cb,
    pub on_headers_complete: http_cb,
    pub on_body: http_data_cb,
    pub on_message_complete: http_cb,
    pub on_chunk_header: http_cb,
    pub on_chunk_complete: http_cb,
}
pub const http_parser_url_fields_UF_SCHEMA: http_parser_url_fields = 0;
pub const http_parser_url_fields_UF_HOST: http_parser_url_fields = 1;
pub const http_parser_url_fields_UF_PORT: http_parser_url_fields = 2;
pub const http_parser_url_fields_UF_PATH: http_parser_url_fields = 3;
pub const http_parser_url_fields_UF_QUERY: http_parser_url_fields = 4;
pub const http_parser_url_fields_UF_FRAGMENT: http_parser_url_fields = 5;
pub const http_parser_url_fields_UF_USERINFO: http_parser_url_fields = 6;
pub const http_parser_url_fields_UF_MAX: http_parser_url_fields = 7;
pub type http_parser_url_fields = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_parser_url {
    pub field_set: u16,
    pub port: u16,
    pub field_data: [http_parser_url__bindgen_ty_1; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_parser_url__bindgen_ty_1 {
    pub off: u16,
    pub len: u16,
}
extern "C" {
    pub fn http_parser_version() -> cty::c_ulong;
}
extern "C" {
    pub fn http_parser_init(parser: *mut http_parser, type_: http_parser_type);
}
extern "C" {
    pub fn http_parser_settings_init(settings: *mut http_parser_settings);
}
extern "C" {
    pub fn http_parser_execute(
        parser: *mut http_parser,
        settings: *const http_parser_settings,
        data: *const cty::c_char,
        len: usize,
    ) -> usize;
}
extern "C" {
    pub fn http_should_keep_alive(parser: *const http_parser) -> cty::c_int;
}
extern "C" {
    pub fn http_method_str(m: http_method) -> *const cty::c_char;
}
extern "C" {
    pub fn http_errno_name(err: http_errno) -> *const cty::c_char;
}
extern "C" {
    pub fn http_errno_description(err: http_errno) -> *const cty::c_char;
}
extern "C" {
    pub fn http_parser_url_init(u: *mut http_parser_url);
}
extern "C" {
    pub fn http_parser_parse_url(
        buf: *const cty::c_char,
        buflen: usize,
        is_connect: cty::c_int,
        u: *mut http_parser_url,
    ) -> cty::c_int;
}
extern "C" {
    pub fn http_parser_pause(parser: *mut http_parser, paused: cty::c_int);
}
extern "C" {
    pub fn http_body_is_final(parser: *const http_parser) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_http_client {
    _unused: [u8; 0],
}
pub type esp_http_client_handle_t = *mut esp_http_client;
pub type esp_http_client_event_handle_t = *mut esp_http_client_event;
#[doc = "< This event occurs when there are any errors during execution"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ERROR: esp_http_client_event_id_t = 0;
#[doc = "< Once the HTTP has been connected to the server, no data exchange has been performed"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ON_CONNECTED: esp_http_client_event_id_t = 1;
#[doc = "< After sending all the headers to the server"]
pub const esp_http_client_event_id_t_HTTP_EVENT_HEADER_SENT: esp_http_client_event_id_t = 2;
#[doc = "< Occurs when receiving each header sent from the server"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ON_HEADER: esp_http_client_event_id_t = 3;
#[doc = "< Occurs when receiving data from the server, possibly multiple portions of the packet"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ON_DATA: esp_http_client_event_id_t = 4;
#[doc = "< Occurs when finish a HTTP session"]
pub const esp_http_client_event_id_t_HTTP_EVENT_ON_FINISH: esp_http_client_event_id_t = 5;
#[doc = "< The connection has been disconnected"]
pub const esp_http_client_event_id_t_HTTP_EVENT_DISCONNECTED: esp_http_client_event_id_t = 6;
#[doc = " @brief   HTTP Client events id"]
pub type esp_http_client_event_id_t = u32;
#[doc = " @brief      HTTP Client events data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_http_client_event {
    #[doc = "< event_id, to know the cause of the event"]
    pub event_id: esp_http_client_event_id_t,
    #[doc = "< esp_http_client_handle_t context"]
    pub client: esp_http_client_handle_t,
    #[doc = "< data of the event"]
    pub data: *mut cty::c_void,
    #[doc = "< data length of data"]
    pub data_len: cty::c_int,
    #[doc = "< user_data context, from esp_http_client_config_t user_data"]
    pub user_data: *mut cty::c_void,
    #[doc = "< For HTTP_EVENT_ON_HEADER event_id, it's store current http header key"]
    pub header_key: *mut cty::c_char,
    #[doc = "< For HTTP_EVENT_ON_HEADER event_id, it's store current http header value"]
    pub header_value: *mut cty::c_char,
}
pub type esp_http_client_event_t = esp_http_client_event;
#[doc = "< Unknown"]
pub const esp_http_client_transport_t_HTTP_TRANSPORT_UNKNOWN: esp_http_client_transport_t = 0;
#[doc = "< Transport over tcp"]
pub const esp_http_client_transport_t_HTTP_TRANSPORT_OVER_TCP: esp_http_client_transport_t = 1;
#[doc = "< Transport over ssl"]
pub const esp_http_client_transport_t_HTTP_TRANSPORT_OVER_SSL: esp_http_client_transport_t = 2;
#[doc = " @brief      HTTP Client transport"]
pub type esp_http_client_transport_t = u32;
pub type http_event_handle_cb =
    ::core::option::Option<unsafe extern "C" fn(evt: *mut esp_http_client_event_t) -> esp_err_t>;
#[doc = "< HTTP GET Method"]
pub const esp_http_client_method_t_HTTP_METHOD_GET: esp_http_client_method_t = 0;
#[doc = "< HTTP POST Method"]
pub const esp_http_client_method_t_HTTP_METHOD_POST: esp_http_client_method_t = 1;
#[doc = "< HTTP PUT Method"]
pub const esp_http_client_method_t_HTTP_METHOD_PUT: esp_http_client_method_t = 2;
#[doc = "< HTTP PATCH Method"]
pub const esp_http_client_method_t_HTTP_METHOD_PATCH: esp_http_client_method_t = 3;
#[doc = "< HTTP DELETE Method"]
pub const esp_http_client_method_t_HTTP_METHOD_DELETE: esp_http_client_method_t = 4;
#[doc = "< HTTP HEAD Method"]
pub const esp_http_client_method_t_HTTP_METHOD_HEAD: esp_http_client_method_t = 5;
#[doc = "< HTTP NOTIFY Method"]
pub const esp_http_client_method_t_HTTP_METHOD_NOTIFY: esp_http_client_method_t = 6;
#[doc = "< HTTP SUBSCRIBE Method"]
pub const esp_http_client_method_t_HTTP_METHOD_SUBSCRIBE: esp_http_client_method_t = 7;
#[doc = "< HTTP UNSUBSCRIBE Method"]
pub const esp_http_client_method_t_HTTP_METHOD_UNSUBSCRIBE: esp_http_client_method_t = 8;
#[doc = "< HTTP OPTIONS Method"]
pub const esp_http_client_method_t_HTTP_METHOD_OPTIONS: esp_http_client_method_t = 9;
pub const esp_http_client_method_t_HTTP_METHOD_MAX: esp_http_client_method_t = 10;
#[doc = " @brief HTTP method"]
pub type esp_http_client_method_t = u32;
#[doc = "< No authention"]
pub const esp_http_client_auth_type_t_HTTP_AUTH_TYPE_NONE: esp_http_client_auth_type_t = 0;
#[doc = "< HTTP Basic authentication"]
pub const esp_http_client_auth_type_t_HTTP_AUTH_TYPE_BASIC: esp_http_client_auth_type_t = 1;
#[doc = "< HTTP Disgest authentication"]
pub const esp_http_client_auth_type_t_HTTP_AUTH_TYPE_DIGEST: esp_http_client_auth_type_t = 2;
#[doc = " @brief HTTP Authentication type"]
pub type esp_http_client_auth_type_t = u32;
#[doc = " @brief HTTP configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_http_client_config_t {
    #[doc = "< HTTP URL, the information on the URL is most important, it overrides the other fields below, if any"]
    pub url: *const cty::c_char,
    #[doc = "< Domain or IP as string"]
    pub host: *const cty::c_char,
    #[doc = "< Port to connect, default depend on esp_http_client_transport_t (80 or 443)"]
    pub port: cty::c_int,
    #[doc = "< Using for Http authentication"]
    pub username: *const cty::c_char,
    #[doc = "< Using for Http authentication"]
    pub password: *const cty::c_char,
    #[doc = "< Http authentication type, see `esp_http_client_auth_type_t`"]
    pub auth_type: esp_http_client_auth_type_t,
    #[doc = "< HTTP Path, if not set, default is `/`"]
    pub path: *const cty::c_char,
    #[doc = "< HTTP query"]
    pub query: *const cty::c_char,
    #[doc = "< SSL server certification, PEM format as string, if the client requires to verify server"]
    pub cert_pem: *const cty::c_char,
    #[doc = "< SSL client certification, PEM format as string, if the server requires to verify client"]
    pub client_cert_pem: *const cty::c_char,
    #[doc = "< SSL client key, PEM format as string, if the server requires to verify client"]
    pub client_key_pem: *const cty::c_char,
    #[doc = "< HTTP Method"]
    pub method: esp_http_client_method_t,
    #[doc = "< Network timeout in milliseconds"]
    pub timeout_ms: cty::c_int,
    #[doc = "< Disable HTTP automatic redirects"]
    pub disable_auto_redirect: bool,
    #[doc = "< Max redirection number, using default value if zero"]
    pub max_redirection_count: cty::c_int,
    #[doc = "< HTTP Event Handle"]
    pub event_handler: http_event_handle_cb,
    #[doc = "< HTTP transport type, see `esp_http_client_transport_t`"]
    pub transport_type: esp_http_client_transport_t,
    #[doc = "< HTTP buffer size (both send and receive)"]
    pub buffer_size: cty::c_int,
    #[doc = "< HTTP user_data context"]
    pub user_data: *mut cty::c_void,
    #[doc = "< Set asynchronous mode, only supported with HTTPS for now"]
    pub is_async: bool,
    #[doc = "< Use a global ca_store for all the connections in which this bool is set."]
    pub use_global_ca_store: bool,
}
extern "C" {
    #[doc = " @brief      Start a HTTP session"]
    #[doc = "             This function must be the first function to call,"]
    #[doc = "             and it returns a esp_http_client_handle_t that you must use as input to other functions in the interface."]
    #[doc = "             This call MUST have a corresponding call to esp_http_client_cleanup when the operation is complete."]
    #[doc = ""]
    #[doc = " @param[in]  config   The configurations, see `http_client_config_t`"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - `esp_http_client_handle_t`"]
    #[doc = "     - NULL if any errors"]
    pub fn esp_http_client_init(
        config: *const esp_http_client_config_t,
    ) -> esp_http_client_handle_t;
}
extern "C" {
    #[doc = " @brief      Invoke this function after `esp_http_client_init` and all the options calls are made, and will perform the"]
    #[doc = "             transfer as described in the options. It must be called with the same esp_http_client_handle_t as input as the esp_http_client_init call returned."]
    #[doc = "             esp_http_client_perform performs the entire request in either blocking or non-blocking manner. By default, the API performs request in a blocking manner and returns when done,"]
    #[doc = "             or if it failed, and in non-blocking manner, it returns if EAGAIN/EWOULDBLOCK or EINPROGRESS is encountered, or if it failed. And in case of non-blocking request,"]
    #[doc = "             the user may call this API multiple times unless request & response is complete or there is a failure. To enable non-blocking esp_http_client_perform(), `is_async` member of esp_http_client_config_t"]
    #[doc = "             must be set while making a call to esp_http_client_init() API."]
    #[doc = "             You can do any amount of calls to esp_http_client_perform while using the same esp_http_client_handle_t. The underlying connection may be kept open if the server allows it."]
    #[doc = "             If you intend to transfer more than one file, you are even encouraged to do so."]
    #[doc = "             esp_http_client will then attempt to re-use the same connection for the following transfers, thus making the operations faster, less CPU intense and using less network resources."]
    #[doc = "             Just note that you will have to use `esp_http_client_set_**` between the invokes to set options for the following esp_http_client_perform."]
    #[doc = ""]
    #[doc = " @note       You must never call this function simultaneously from two places using the same client handle."]
    #[doc = "             Let the function return first before invoking it another time."]
    #[doc = "             If you want parallel transfers, you must use several esp_http_client_handle_t."]
    #[doc = "             This function include `esp_http_client_open` -> `esp_http_client_write` -> `esp_http_client_fetch_headers` -> `esp_http_client_read` (and option) `esp_http_client_close`."]
    #[doc = ""]
    #[doc = " @param      client  The esp_http_client handle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK on successful"]
    #[doc = "  - ESP_FAIL on error"]
    pub fn esp_http_client_perform(client: esp_http_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set URL for client, when performing this behavior, the options in the URL will replace the old ones"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = " @param[in]  url     The url"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK"]
    #[doc = "  - ESP_FAIL"]
    pub fn esp_http_client_set_url(
        client: esp_http_client_handle_t,
        url: *const cty::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set post data, this function must be called before `esp_http_client_perform`."]
    #[doc = "             Note: The data parameter passed to this function is a pointer and this function will not copy the data"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = " @param[in]  data    post data pointer"]
    #[doc = " @param[in]  len     post length"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK"]
    #[doc = "  - ESP_FAIL"]
    pub fn esp_http_client_set_post_field(
        client: esp_http_client_handle_t,
        data: *const cty::c_char,
        len: cty::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get current post field information"]
    #[doc = ""]
    #[doc = " @param[in]  client  The client"]
    #[doc = " @param[out] data    Point to post data pointer"]
    #[doc = ""]
    #[doc = " @return     Size of post data"]
    pub fn esp_http_client_get_post_field(
        client: esp_http_client_handle_t,
        data: *mut *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      Set http request header, this function must be called after esp_http_client_init and before any"]
    #[doc = "             perform function"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = " @param[in]  key     The header key"]
    #[doc = " @param[in]  value   The header value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK"]
    #[doc = "  - ESP_FAIL"]
    pub fn esp_http_client_set_header(
        client: esp_http_client_handle_t,
        key: *const cty::c_char,
        value: *const cty::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get http request header."]
    #[doc = "             The value parameter will be set to NULL if there is no header which is same as"]
    #[doc = "             the key specified, otherwise the address of header value will be assigned to value parameter."]
    #[doc = "             This function must be called after `esp_http_client_init`."]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = " @param[in]  key     The header key"]
    #[doc = " @param[out] value   The header value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK"]
    #[doc = "     - ESP_FAIL"]
    pub fn esp_http_client_get_header(
        client: esp_http_client_handle_t,
        key: *const cty::c_char,
        value: *mut *mut cty::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set http request method"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = " @param[in]  method  The method"]
    #[doc = ""]
    #[doc = " @return     ESP_OK"]
    pub fn esp_http_client_set_method(
        client: esp_http_client_handle_t,
        method: esp_http_client_method_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Delete http request header"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = " @param[in]  key     The key"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK"]
    #[doc = "  - ESP_FAIL"]
    pub fn esp_http_client_delete_header(
        client: esp_http_client_handle_t,
        key: *const cty::c_char,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      This function will be open the connection, write all header strings and return"]
    #[doc = ""]
    #[doc = " @param[in]  client     The esp_http_client handle"]
    #[doc = " @param[in]  write_len  HTTP Content length need to write to the server"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - ESP_OK"]
    #[doc = "  - ESP_FAIL"]
    pub fn esp_http_client_open(
        client: esp_http_client_handle_t,
        write_len: cty::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief     This function will write data to the HTTP connection previously opened by esp_http_client_open()"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = " @param      buffer  The buffer"]
    #[doc = " @param[in]  len     This value must not be larger than the write_len parameter provided to esp_http_client_open()"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) if any errors"]
    #[doc = "     - Length of data written"]
    pub fn esp_http_client_write(
        client: esp_http_client_handle_t,
        buffer: *const cty::c_char,
        len: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      This function need to call after esp_http_client_open, it will read from http stream, process all receive headers"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (0) if stream doesn't contain content-length header, or chunked encoding (checked by `esp_http_client_is_chunked` response)"]
    #[doc = "     - (-1: ESP_FAIL) if any errors"]
    #[doc = "     - Download data length defined by content-length header"]
    pub fn esp_http_client_fetch_headers(client: esp_http_client_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      Check response data is chunked"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = ""]
    #[doc = " @return     true or false"]
    pub fn esp_http_client_is_chunked_response(client: esp_http_client_handle_t) -> bool;
}
extern "C" {
    #[doc = " @brief      Read data from http stream"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = " @param      buffer  The buffer"]
    #[doc = " @param[in]  len     The length"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) if any errors"]
    #[doc = "     - Length of data was read"]
    pub fn esp_http_client_read(
        client: esp_http_client_handle_t,
        buffer: *mut cty::c_char,
        len: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      Get http response status code, the valid value if this function invoke after `esp_http_client_perform`"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = ""]
    #[doc = " @return     Status code"]
    pub fn esp_http_client_get_status_code(client: esp_http_client_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      Get http response content length (from header Content-Length)"]
    #[doc = "             the valid value if this function invoke after `esp_http_client_perform`"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Chunked transfer"]
    #[doc = "     - Content-Length value as bytes"]
    pub fn esp_http_client_get_content_length(client: esp_http_client_handle_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      Close http connection, still kept all http request resources"]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK"]
    #[doc = "     - ESP_FAIL"]
    pub fn esp_http_client_close(client: esp_http_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      This function must be the last function to call for an session."]
    #[doc = "             It is the opposite of the esp_http_client_init function and must be called with the same handle as input that a esp_http_client_init call returned."]
    #[doc = "             This might close all connections this handle has used and possibly has kept open until now."]
    #[doc = "             Don't call this function if you intend to transfer more files, re-using handles is a key to good performance with esp_http_client."]
    #[doc = ""]
    #[doc = " @param[in]  client  The esp_http_client handle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK"]
    #[doc = "     - ESP_FAIL"]
    pub fn esp_http_client_cleanup(client: esp_http_client_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get transport type"]
    #[doc = ""]
    #[doc = " @param[in]  client   The esp_http_client handle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - HTTP_TRANSPORT_UNKNOWN"]
    #[doc = "     - HTTP_TRANSPORT_OVER_TCP"]
    #[doc = "     - HTTP_TRANSPORT_OVER_SSL"]
    pub fn esp_http_client_get_transport_type(
        client: esp_http_client_handle_t,
    ) -> esp_http_client_transport_t;
}
pub type err_t = s8_t;
#[doc = " No error, everything OK."]
pub const err_enum_t_ERR_OK: err_enum_t = 0;
#[doc = " Out of memory error."]
pub const err_enum_t_ERR_MEM: err_enum_t = -1;
#[doc = " Buffer error."]
pub const err_enum_t_ERR_BUF: err_enum_t = -2;
#[doc = " Timeout."]
pub const err_enum_t_ERR_TIMEOUT: err_enum_t = -3;
#[doc = " Routing problem."]
pub const err_enum_t_ERR_RTE: err_enum_t = -4;
#[doc = " Operation in progress"]
pub const err_enum_t_ERR_INPROGRESS: err_enum_t = -5;
#[doc = " Illegal value."]
pub const err_enum_t_ERR_VAL: err_enum_t = -6;
#[doc = " Operation would block."]
pub const err_enum_t_ERR_WOULDBLOCK: err_enum_t = -7;
#[doc = " Address in use."]
pub const err_enum_t_ERR_USE: err_enum_t = -8;
#[doc = " Already connecting."]
pub const err_enum_t_ERR_ALREADY: err_enum_t = -9;
#[doc = " Conn already established."]
pub const err_enum_t_ERR_ISCONN: err_enum_t = -10;
#[doc = " Not connected."]
pub const err_enum_t_ERR_CONN: err_enum_t = -11;
#[doc = " Low-level netif error"]
pub const err_enum_t_ERR_IF: err_enum_t = -12;
#[doc = " Connection aborted."]
pub const err_enum_t_ERR_ABRT: err_enum_t = -13;
#[doc = " Connection reset."]
pub const err_enum_t_ERR_RST: err_enum_t = -14;
#[doc = " Connection closed."]
pub const err_enum_t_ERR_CLSD: err_enum_t = -15;
#[doc = " Illegal argument."]
pub const err_enum_t_ERR_ARG: err_enum_t = -16;
#[doc = " Definitions for error constants."]
pub type err_enum_t = i32;
extern "C" {
    pub fn lwip_strerr(err: err_t) -> *const cty::c_char;
}
extern "C" {
    pub fn err_to_errno(err: err_t) -> cty::c_int;
}
#[doc = " Function prototype for thread functions"]
pub type lwip_thread_fn = ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>;
extern "C" {
    #[doc = " @ingroup sys_mutex"]
    #[doc = " Create a new mutex."]
    #[doc = " Note that mutexes are expected to not be taken recursively by the lwIP code,"]
    #[doc = " so both implementation types (recursive or non-recursive) should work."]
    #[doc = " @param mutex pointer to the mutex to create"]
    #[doc = " @return ERR_OK if successful, another err_t otherwise"]
    pub fn sys_mutex_new(mutex: *mut sys_mutex_t) -> err_t;
}
extern "C" {
    #[doc = " @ingroup sys_mutex"]
    #[doc = " Lock a mutex"]
    #[doc = " @param mutex the mutex to lock"]
    pub fn sys_mutex_lock(mutex: *mut sys_mutex_t);
}
extern "C" {
    #[doc = " @ingroup sys_mutex"]
    #[doc = " Unlock a mutex"]
    #[doc = " @param mutex the mutex to unlock"]
    pub fn sys_mutex_unlock(mutex: *mut sys_mutex_t);
}
extern "C" {
    #[doc = " @ingroup sys_mutex"]
    #[doc = " Delete a semaphore"]
    #[doc = " @param mutex the mutex to delete"]
    pub fn sys_mutex_free(mutex: *mut sys_mutex_t);
}
extern "C" {
    #[doc = " @ingroup sys_sem"]
    #[doc = " Create a new semaphore"]
    #[doc = " @param sem pointer to the semaphore to create"]
    #[doc = " @param count initial count of the semaphore"]
    #[doc = " @return ERR_OK if successful, another err_t otherwise"]
    pub fn sys_sem_new(sem: *mut sys_sem_t, count: u8_t) -> err_t;
}
extern "C" {
    #[doc = " @ingroup sys_sem"]
    #[doc = " Signals a semaphore"]
    #[doc = " @param sem the semaphore to signal"]
    pub fn sys_sem_signal(sem: *mut sys_sem_t);
}
extern "C" {
    #[doc = " Signals a semaphore (ISR version)"]
    #[doc = " @param sem the semaphore to signal"]
    #[doc = " @return non-zero if a higher priority task has been woken"]
    pub fn sys_sem_signal_isr(sem: *mut sys_sem_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @ingroup sys_sem"]
    #[doc = " Wait for a semaphore for the specified timeout"]
    #[doc = " @param sem the semaphore to wait for"]
    #[doc = " @param timeout timeout in milliseconds to wait (0 = wait forever)"]
    #[doc = " @return time (in milliseconds) waited for the semaphore"]
    #[doc = "         or SYS_ARCH_TIMEOUT on timeout"]
    pub fn sys_arch_sem_wait(sem: *mut sys_sem_t, timeout: u32_t) -> u32_t;
}
extern "C" {
    #[doc = " @ingroup sys_sem"]
    #[doc = " Delete a semaphore"]
    #[doc = " @param sem semaphore to delete"]
    pub fn sys_sem_free(sem: *mut sys_sem_t);
}
extern "C" {
    #[doc = " @ingroup sys_misc"]
    #[doc = " Sleep for specified number of ms"]
    pub fn sys_msleep(ms: u32_t);
}
extern "C" {
    #[doc = " @ingroup sys_mbox"]
    #[doc = " Create a new mbox of specified size"]
    #[doc = " @param mbox pointer to the mbox to create"]
    #[doc = " @param size (minimum) number of messages in this mbox"]
    #[doc = " @return ERR_OK if successful, another err_t otherwise"]
    pub fn sys_mbox_new(mbox: *mut sys_mbox_t, size: cty::c_int) -> err_t;
}
extern "C" {
    #[doc = " @ingroup sys_mbox"]
    #[doc = " Post a message to an mbox - may not fail"]
    #[doc = " -> blocks if full, only used from tasks not from ISR"]
    #[doc = " @param mbox mbox to posts the message"]
    #[doc = " @param msg message to post (ATTENTION: can be NULL)"]
    pub fn sys_mbox_post(mbox: *mut sys_mbox_t, msg: *mut cty::c_void);
}
extern "C" {
    #[doc = " @ingroup sys_mbox"]
    #[doc = " Try to post a message to an mbox - may fail if full or ISR"]
    #[doc = " @param mbox mbox to posts the message"]
    #[doc = " @param msg message to post (ATTENTION: can be NULL)"]
    pub fn sys_mbox_trypost(mbox: *mut sys_mbox_t, msg: *mut cty::c_void) -> err_t;
}
extern "C" {
    #[doc = " @ingroup sys_mbox"]
    #[doc = " Wait for a new message to arrive in the mbox"]
    #[doc = " @param mbox mbox to get a message from"]
    #[doc = " @param msg pointer where the message is stored"]
    #[doc = " @param timeout maximum time (in milliseconds) to wait for a message (0 = wait forever)"]
    #[doc = " @return time (in milliseconds) waited for a message, may be 0 if not waited"]
    #[doc = "or SYS_ARCH_TIMEOUT on timeout"]
    #[doc = "         The returned time has to be accurate to prevent timer jitter!"]
    pub fn sys_arch_mbox_fetch(
        mbox: *mut sys_mbox_t,
        msg: *mut *mut cty::c_void,
        timeout: u32_t,
    ) -> u32_t;
}
extern "C" {
    #[doc = " @ingroup sys_mbox"]
    #[doc = " Set the owner of the mbox"]
    #[doc = " @param mbox mbox to set the owner"]
    #[doc = " @param owner the owner of the mbox, it's a pointer to struct netconn"]
    pub fn sys_mbox_set_owner(mbox: *mut sys_mbox_t, owner: *mut cty::c_void);
}
extern "C" {
    #[doc = " @ingroup sys_mbox"]
    #[doc = " Wait for a new message to arrive in the mbox"]
    #[doc = " @param mbox mbox to get a message from"]
    #[doc = " @param msg pointer where the message is stored"]
    #[doc = " @return 0 (milliseconds) if a message has been received"]
    #[doc = "         or SYS_MBOX_EMPTY if the mailbox is empty"]
    pub fn sys_arch_mbox_tryfetch(mbox: *mut sys_mbox_t, msg: *mut *mut cty::c_void) -> u32_t;
}
extern "C" {
    #[doc = " @ingroup sys_mbox"]
    #[doc = " Delete an mbox"]
    #[doc = " @param mbox mbox to delete"]
    pub fn sys_mbox_free(mbox: *mut sys_mbox_t);
}
extern "C" {
    #[doc = " @ingroup sys_misc"]
    #[doc = " The only thread function:"]
    #[doc = " Creates a new thread"]
    #[doc = " ATTENTION: although this function returns a value, it MUST NOT FAIL (ports have to assert this!)"]
    #[doc = " @param name human-readable name for the thread (used for debugging purposes)"]
    #[doc = " @param thread thread-function"]
    #[doc = " @param arg parameter passed to 'thread'"]
    #[doc = " @param stacksize stack size in bytes for the new thread (may be ignored by ports)"]
    #[doc = " @param prio priority of the new thread (may be ignored by ports)"]
    pub fn sys_thread_new(
        name: *const cty::c_char,
        thread: lwip_thread_fn,
        arg: *mut cty::c_void,
        stacksize: cty::c_int,
        prio: cty::c_int,
    ) -> sys_thread_t;
}
extern "C" {
    pub fn sys_init();
}
extern "C" {
    #[doc = " Ticks/jiffies since power up."]
    pub fn sys_jiffies() -> u32_t;
}
extern "C" {
    #[doc = " @ingroup sys_time"]
    #[doc = " Returns the current time in milliseconds,"]
    #[doc = " may be the same as sys_jiffies or at least based on it."]
    pub fn sys_now() -> u32_t;
}
extern "C" {
    pub fn sys_arch_protect() -> sys_prot_t;
}
extern "C" {
    pub fn sys_arch_unprotect(pval: sys_prot_t);
}
pub type in_addr_t = u32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub un: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u32_addr: [u32_t; 4usize],
    pub u8_addr: [u8_t; 16usize],
    _bindgen_union_align: [u32; 4usize],
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
pub type sa_family_t = u8_t;
pub type in_port_t = u16_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: u8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [cty::c_char; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: u8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: u8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [cty::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub s2_len: u8_t,
    pub ss_family: sa_family_t,
    pub s2_data1: [cty::c_char; 2usize],
    pub s2_data2: [u32_t; 3usize],
    pub s2_data3: [u32_t; 3usize],
}
pub type socklen_t = u32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lwip_sock {
    _unused: [u8; 0],
}
#[doc = " This struct is used to pass data to the set/getsockopt_internal"]
#[doc = " functions running in tcpip_thread context (only a void* is allowed)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lwip_setgetsockopt_data {
    #[doc = " socket index for which to change options"]
    pub s: cty::c_int,
    #[doc = " level of the option to process"]
    pub level: cty::c_int,
    #[doc = " name of the option to process"]
    pub optname: cty::c_int,
    pub optval: lwip_setgetsockopt_data__bindgen_ty_1,
    #[doc = " size of *optval"]
    pub optlen: socklen_t,
    #[doc = " if an error occurs, it is temporarily stored here"]
    pub err: err_t,
    #[doc = " semaphore to wake up the calling task"]
    pub completed_sem: *mut cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lwip_setgetsockopt_data__bindgen_ty_1 {
    pub p: *mut cty::c_void,
    pub pc: *const cty::c_void,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut cty::c_void,
    pub iov_len: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut cty::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: cty::c_int,
    pub msg_control: *mut cty::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: cty::c_int,
    pub l_linger: cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: in6_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
extern "C" {
    pub fn lwip_socket_thread_init();
}
extern "C" {
    pub fn lwip_socket_thread_cleanup();
}
extern "C" {
    pub fn lwip_accept(s: cty::c_int, addr: *mut sockaddr, addrlen: *mut socklen_t) -> cty::c_int;
}
extern "C" {
    pub fn lwip_bind(s: cty::c_int, name: *const sockaddr, namelen: socklen_t) -> cty::c_int;
}
extern "C" {
    pub fn lwip_shutdown(s: cty::c_int, how: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_getpeername(
        s: cty::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_getsockname(
        s: cty::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_getsockopt(
        s: cty::c_int,
        level: cty::c_int,
        optname: cty::c_int,
        optval: *mut cty::c_void,
        optlen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_setsockopt(
        s: cty::c_int,
        level: cty::c_int,
        optname: cty::c_int,
        optval: *const cty::c_void,
        optlen: socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_close(s: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_connect(s: cty::c_int, name: *const sockaddr, namelen: socklen_t) -> cty::c_int;
}
extern "C" {
    pub fn lwip_listen(s: cty::c_int, backlog: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_recv(
        s: cty::c_int,
        mem: *mut cty::c_void,
        len: usize,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_read(s: cty::c_int, mem: *mut cty::c_void, len: usize) -> cty::c_int;
}
extern "C" {
    pub fn lwip_recvfrom(
        s: cty::c_int,
        mem: *mut cty::c_void,
        len: usize,
        flags: cty::c_int,
        from: *mut sockaddr,
        fromlen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_send(
        s: cty::c_int,
        dataptr: *const cty::c_void,
        size: usize,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_sendmsg(s: cty::c_int, message: *const msghdr, flags: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_sendto(
        s: cty::c_int,
        dataptr: *const cty::c_void,
        size: usize,
        flags: cty::c_int,
        to: *const sockaddr,
        tolen: socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_socket(domain: cty::c_int, type_: cty::c_int, protocol: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_write(s: cty::c_int, dataptr: *const cty::c_void, size: usize) -> cty::c_int;
}
extern "C" {
    pub fn lwip_writev(s: cty::c_int, iov: *const iovec, iovcnt: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_select(
        maxfdp1: cty::c_int,
        readset: *mut _types_fd_set,
        writeset: *mut _types_fd_set,
        exceptset: *mut _types_fd_set,
        timeout: *mut timeval,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_ioctl(s: cty::c_int, cmd: cty::c_long, argp: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn lwip_fcntl(s: cty::c_int, cmd: cty::c_int, val: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_accept_r(s: cty::c_int, addr: *mut sockaddr, addrlen: *mut socklen_t)
        -> cty::c_int;
}
extern "C" {
    pub fn lwip_bind_r(s: cty::c_int, name: *const sockaddr, namelen: socklen_t) -> cty::c_int;
}
extern "C" {
    pub fn lwip_shutdown_r(s: cty::c_int, how: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_getpeername_r(
        s: cty::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_getsockname_r(
        s: cty::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_getsockopt_r(
        s: cty::c_int,
        level: cty::c_int,
        optname: cty::c_int,
        optval: *mut cty::c_void,
        optlen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_setsockopt_r(
        s: cty::c_int,
        level: cty::c_int,
        optname: cty::c_int,
        optval: *const cty::c_void,
        optlen: socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_close_r(s: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_connect_r(s: cty::c_int, name: *const sockaddr, namelen: socklen_t) -> cty::c_int;
}
extern "C" {
    pub fn lwip_listen_r(s: cty::c_int, backlog: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_recvmsg_r(s: cty::c_int, message: *mut msghdr, flags: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_recv_r(
        s: cty::c_int,
        mem: *mut cty::c_void,
        len: usize,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_read_r(s: cty::c_int, mem: *mut cty::c_void, len: usize) -> cty::c_int;
}
extern "C" {
    pub fn lwip_recvfrom_r(
        s: cty::c_int,
        mem: *mut cty::c_void,
        len: usize,
        flags: cty::c_int,
        from: *mut sockaddr,
        fromlen: *mut socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_send_r(
        s: cty::c_int,
        dataptr: *const cty::c_void,
        size: usize,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_sendmsg_r(s: cty::c_int, message: *const msghdr, flags: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_sendto_r(
        s: cty::c_int,
        dataptr: *const cty::c_void,
        size: usize,
        flags: cty::c_int,
        to: *const sockaddr,
        tolen: socklen_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lwip_write_r(s: cty::c_int, dataptr: *const cty::c_void, size: usize) -> cty::c_int;
}
extern "C" {
    pub fn lwip_writev_r(s: cty::c_int, iov: *const iovec, iovcnt: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn lwip_ioctl_r(s: cty::c_int, cmd: cty::c_long, argp: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn lwip_fcntl_r(s: cty::c_int, cmd: cty::c_int, val: cty::c_int) -> cty::c_int;
}
pub type mbedtls_iso_c_forbids_empty_translation_units = cty::c_int;
pub type mbedtls_time_t = time_t;
#[doc = " \\brief   The platform context structure."]
#[doc = ""]
#[doc = " \\note    This structure may be used to assist platform-specific"]
#[doc = "          setup or teardown operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_platform_context {
    #[doc = "< A placeholder member, as empty structs are not portable."]
    pub dummy: cty::c_char,
}
extern "C" {
    #[doc = " \\brief   This function performs any platform-specific initialization"]
    #[doc = "          operations."]
    #[doc = ""]
    #[doc = " \\note    This function should be called before any other library functions."]
    #[doc = ""]
    #[doc = "          Its implementation is platform-specific, and unless"]
    #[doc = "          platform-specific code is provided, it does nothing."]
    #[doc = ""]
    #[doc = " \\note    The usage and necessity of this function is dependent on the platform."]
    #[doc = ""]
    #[doc = " \\param   ctx     The platform context."]
    #[doc = ""]
    #[doc = " \\return  \\c 0 on success."]
    pub fn mbedtls_platform_setup(ctx: *mut mbedtls_platform_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief   This function performs any platform teardown operations."]
    #[doc = ""]
    #[doc = " \\note    This function should be called after every other Mbed TLS module"]
    #[doc = "          has been correctly freed using the appropriate free function."]
    #[doc = ""]
    #[doc = "          Its implementation is platform-specific, and unless"]
    #[doc = "          platform-specific code is provided, it does nothing."]
    #[doc = ""]
    #[doc = " \\note    The usage and necessity of this function is dependent on the platform."]
    #[doc = ""]
    #[doc = " \\param   ctx     The platform context."]
    #[doc = ""]
    pub fn mbedtls_platform_teardown(ctx: *mut mbedtls_platform_context);
}
pub type mbedtls_mpi_sint = i32;
pub type mbedtls_mpi_uint = u32;
pub type mbedtls_t_udbl = u64;
#[doc = " \\brief          MPI structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_mpi {
    #[doc = "<  integer sign"]
    pub s: cty::c_int,
    #[doc = "<  total # of limbs"]
    pub n: usize,
    #[doc = "<  pointer to limbs"]
    pub p: *mut mbedtls_mpi_uint,
}
extern "C" {
    #[doc = " \\brief           Initialize one MPI (make internal references valid)"]
    #[doc = "                  This just makes it ready to be set or freed,"]
    #[doc = "                  but does not define a value for the MPI."]
    #[doc = ""]
    #[doc = " \\param X         One MPI to initialize."]
    pub fn mbedtls_mpi_init(X: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          Unallocate one MPI"]
    #[doc = ""]
    #[doc = " \\param X        One MPI to unallocate."]
    pub fn mbedtls_mpi_free(X: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          Enlarge to the specified number of limbs"]
    #[doc = ""]
    #[doc = "                 This function does nothing if the MPI is already large enough."]
    #[doc = ""]
    #[doc = " \\param X        MPI to grow"]
    #[doc = " \\param nblimbs  The target number of limbs"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_grow(X: *mut mbedtls_mpi, nblimbs: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Resize down, keeping at least the specified number of limbs"]
    #[doc = ""]
    #[doc = "                 If \\c X is smaller than \\c nblimbs, it is resized up"]
    #[doc = "                 instead."]
    #[doc = ""]
    #[doc = " \\param X        MPI to shrink"]
    #[doc = " \\param nblimbs  The minimum number of limbs to keep"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    #[doc = "                 (this can only happen when resizing up)."]
    pub fn mbedtls_mpi_shrink(X: *mut mbedtls_mpi, nblimbs: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Copy the contents of Y into X"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI. It is enlarged if necessary."]
    #[doc = " \\param Y        Source MPI."]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_copy(X: *mut mbedtls_mpi, Y: *const mbedtls_mpi) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Swap the contents of X and Y"]
    #[doc = ""]
    #[doc = " \\param X        First MPI value"]
    #[doc = " \\param Y        Second MPI value"]
    pub fn mbedtls_mpi_swap(X: *mut mbedtls_mpi, Y: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          Safe conditional assignement X = Y if assign is 1"]
    #[doc = ""]
    #[doc = " \\param X        MPI to conditionally assign to"]
    #[doc = " \\param Y        Value to be assigned"]
    #[doc = " \\param assign   1: perform the assignment, 0: keep X's original value"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = ""]
    #[doc = " \\note           This function is equivalent to"]
    #[doc = "                      if( assign ) mbedtls_mpi_copy( X, Y );"]
    #[doc = "                 except that it avoids leaking any information about whether"]
    #[doc = "                 the assignment was done or not (the above code may leak"]
    #[doc = "                 information through branch prediction and/or memory access"]
    #[doc = "                 patterns analysis)."]
    pub fn mbedtls_mpi_safe_cond_assign(
        X: *mut mbedtls_mpi,
        Y: *const mbedtls_mpi,
        assign: cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Safe conditional swap X <-> Y if swap is 1"]
    #[doc = ""]
    #[doc = " \\param X        First mbedtls_mpi value"]
    #[doc = " \\param Y        Second mbedtls_mpi value"]
    #[doc = " \\param assign   1: perform the swap, 0: keep X and Y's original values"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = ""]
    #[doc = " \\note           This function is equivalent to"]
    #[doc = "                      if( assign ) mbedtls_mpi_swap( X, Y );"]
    #[doc = "                 except that it avoids leaking any information about whether"]
    #[doc = "                 the assignment was done or not (the above code may leak"]
    #[doc = "                 information through branch prediction and/or memory access"]
    #[doc = "                 patterns analysis)."]
    pub fn mbedtls_mpi_safe_cond_swap(
        X: *mut mbedtls_mpi,
        Y: *mut mbedtls_mpi,
        assign: cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set value from integer"]
    #[doc = ""]
    #[doc = " \\param X        MPI to set"]
    #[doc = " \\param z        Value to use"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_lset(X: *mut mbedtls_mpi, z: mbedtls_mpi_sint) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Get a specific bit from X"]
    #[doc = ""]
    #[doc = " \\param X        MPI to use"]
    #[doc = " \\param pos      Zero-based index of the bit in X"]
    #[doc = ""]
    #[doc = " \\return         Either a 0 or a 1"]
    pub fn mbedtls_mpi_get_bit(X: *const mbedtls_mpi, pos: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set a bit of X to a specific value of 0 or 1"]
    #[doc = ""]
    #[doc = " \\note           Will grow X if necessary to set a bit to 1 in a not yet"]
    #[doc = "                 existing limb. Will not grow if bit should be set to 0"]
    #[doc = ""]
    #[doc = " \\param X        MPI to use"]
    #[doc = " \\param pos      Zero-based index of the bit in X"]
    #[doc = " \\param val      The value to set the bit to (0 or 1)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_MPI_BAD_INPUT_DATA if val is not 0 or 1"]
    pub fn mbedtls_mpi_set_bit(X: *mut mbedtls_mpi, pos: usize, val: cty::c_uchar) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of zero-bits before the least significant"]
    #[doc = "                 '1' bit"]
    #[doc = ""]
    #[doc = " Note: Thus also the zero-based index of the least significant '1' bit"]
    #[doc = ""]
    #[doc = " \\param X        MPI to use"]
    pub fn mbedtls_mpi_lsb(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the number of bits up to and including the most"]
    #[doc = "                 significant '1' bit'"]
    #[doc = ""]
    #[doc = " Note: Thus also the one-based index of the most significant '1' bit"]
    #[doc = ""]
    #[doc = " \\param X        MPI to use"]
    pub fn mbedtls_mpi_bitlen(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the total size in bytes"]
    #[doc = ""]
    #[doc = " \\param X        MPI to use"]
    pub fn mbedtls_mpi_size(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Import from an ASCII string"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param radix    Input numeric base"]
    #[doc = " \\param s        Null-terminated string buffer"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a MBEDTLS_ERR_MPI_XXX error code"]
    pub fn mbedtls_mpi_read_string(
        X: *mut mbedtls_mpi,
        radix: cty::c_int,
        s: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Export into an ASCII string"]
    #[doc = ""]
    #[doc = " \\param X        Source MPI"]
    #[doc = " \\param radix    Output numeric base"]
    #[doc = " \\param buf      Buffer to write the string to"]
    #[doc = " \\param buflen   Length of buf"]
    #[doc = " \\param olen     Length of the string written, including final NUL byte"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a MBEDTLS_ERR_MPI_XXX error code."]
    #[doc = "                 *olen is always updated to reflect the amount"]
    #[doc = "                 of data that has (or would have) been written."]
    #[doc = ""]
    #[doc = " \\note           Call this function with buflen = 0 to obtain the"]
    #[doc = "                 minimum required buffer size in *olen."]
    pub fn mbedtls_mpi_write_string(
        X: *const mbedtls_mpi,
        radix: cty::c_int,
        buf: *mut cty::c_char,
        buflen: usize,
        olen: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Read MPI from a line in an opened file"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param radix    Input numeric base"]
    #[doc = " \\param fin      Input file handle"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if"]
    #[doc = "                 the file read buffer is too small or a"]
    #[doc = "                 MBEDTLS_ERR_MPI_XXX error code"]
    #[doc = ""]
    #[doc = " \\note           On success, this function advances the file stream"]
    #[doc = "                 to the end of the current line or to EOF."]
    #[doc = ""]
    #[doc = "                 The function returns 0 on an empty line."]
    #[doc = ""]
    #[doc = "                 Leading whitespaces are ignored, as is a"]
    #[doc = "                 '0x' prefix for radix 16."]
    #[doc = ""]
    pub fn mbedtls_mpi_read_file(
        X: *mut mbedtls_mpi,
        radix: cty::c_int,
        fin: *mut FILE,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Write X into an opened file, or stdout if fout is NULL"]
    #[doc = ""]
    #[doc = " \\param p        Prefix, can be NULL"]
    #[doc = " \\param X        Source MPI"]
    #[doc = " \\param radix    Output numeric base"]
    #[doc = " \\param fout     Output file handle (can be NULL)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a MBEDTLS_ERR_MPI_XXX error code"]
    #[doc = ""]
    #[doc = " \\note           Set fout == NULL to print X on the console."]
    pub fn mbedtls_mpi_write_file(
        p: *const cty::c_char,
        X: *const mbedtls_mpi,
        radix: cty::c_int,
        fout: *mut FILE,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Import X from unsigned binary data, big endian"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param buf      Input buffer"]
    #[doc = " \\param buflen   Input buffer size"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_read_binary(
        X: *mut mbedtls_mpi,
        buf: *const cty::c_uchar,
        buflen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Export X into unsigned binary data, big endian."]
    #[doc = "                 Always fills the whole buffer, which will start with zeros"]
    #[doc = "                 if the number is smaller."]
    #[doc = ""]
    #[doc = " \\param X        Source MPI"]
    #[doc = " \\param buf      Output buffer"]
    #[doc = " \\param buflen   Output buffer size"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if buf isn't large enough"]
    pub fn mbedtls_mpi_write_binary(
        X: *const mbedtls_mpi,
        buf: *mut cty::c_uchar,
        buflen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Left-shift: X <<= count"]
    #[doc = ""]
    #[doc = " \\param X        MPI to shift"]
    #[doc = " \\param count    Amount to shift"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_shift_l(X: *mut mbedtls_mpi, count: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Right-shift: X >>= count"]
    #[doc = ""]
    #[doc = " \\param X        MPI to shift"]
    #[doc = " \\param count    Amount to shift"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_shift_r(X: *mut mbedtls_mpi, count: usize) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare unsigned values"]
    #[doc = ""]
    #[doc = " \\param X        Left-hand MPI"]
    #[doc = " \\param Y        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         1 if |X| is greater than |Y|,"]
    #[doc = "                -1 if |X| is lesser  than |Y| or"]
    #[doc = "                 0 if |X| is equal to |Y|"]
    pub fn mbedtls_mpi_cmp_abs(X: *const mbedtls_mpi, Y: *const mbedtls_mpi) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare signed values"]
    #[doc = ""]
    #[doc = " \\param X        Left-hand MPI"]
    #[doc = " \\param Y        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         1 if X is greater than Y,"]
    #[doc = "                -1 if X is lesser  than Y or"]
    #[doc = "                 0 if X is equal to Y"]
    pub fn mbedtls_mpi_cmp_mpi(X: *const mbedtls_mpi, Y: *const mbedtls_mpi) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare signed values"]
    #[doc = ""]
    #[doc = " \\param X        Left-hand MPI"]
    #[doc = " \\param z        The integer value to compare to"]
    #[doc = ""]
    #[doc = " \\return         1 if X is greater than z,"]
    #[doc = "                -1 if X is lesser  than z or"]
    #[doc = "                 0 if X is equal to z"]
    pub fn mbedtls_mpi_cmp_int(X: *const mbedtls_mpi, z: mbedtls_mpi_sint) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Unsigned addition: X = |A| + |B|"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param B        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_add_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Unsigned subtraction: X = |A| - |B|"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param B        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_NEGATIVE_VALUE if B is greater than A"]
    pub fn mbedtls_mpi_sub_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Signed addition: X = A + B"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param B        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_add_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Signed subtraction: X = A - B"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param B        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_sub_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Signed addition: X = A + b"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param b        The integer value to add"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_add_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Signed subtraction: X = A - b"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param b        The integer value to subtract"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_sub_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Baseline multiplication: X = A * B"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param B        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_mul_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Baseline multiplication: X = A * b"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param b        The unsigned integer value to multiply with"]
    #[doc = ""]
    #[doc = " \\note           b is unsigned"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_mul_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Division by mbedtls_mpi: A = Q * B + R"]
    #[doc = ""]
    #[doc = " \\param Q        Destination MPI for the quotient"]
    #[doc = " \\param R        Destination MPI for the rest value"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param B        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if B == 0"]
    #[doc = ""]
    #[doc = " \\note           Either Q or R can be NULL."]
    pub fn mbedtls_mpi_div_mpi(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Division by int: A = Q * b + R"]
    #[doc = ""]
    #[doc = " \\param Q        Destination MPI for the quotient"]
    #[doc = " \\param R        Destination MPI for the rest value"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param b        Integer to divide by"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if b == 0"]
    #[doc = ""]
    #[doc = " \\note           Either Q or R can be NULL."]
    pub fn mbedtls_mpi_div_int(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Modulo: R = A mod B"]
    #[doc = ""]
    #[doc = " \\param R        Destination MPI for the rest value"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param B        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if B == 0,"]
    #[doc = "                 MBEDTLS_ERR_MPI_NEGATIVE_VALUE if B < 0"]
    pub fn mbedtls_mpi_mod_mpi(
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Modulo: r = A mod b"]
    #[doc = ""]
    #[doc = " \\param r        Destination mbedtls_mpi_uint"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param b        Integer to divide by"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if b == 0,"]
    #[doc = "                 MBEDTLS_ERR_MPI_NEGATIVE_VALUE if b < 0"]
    pub fn mbedtls_mpi_mod_int(
        r: *mut mbedtls_mpi_uint,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Sliding-window exponentiation: X = A^E mod N"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param E        Exponent MPI"]
    #[doc = " \\param N        Modular MPI"]
    #[doc = " \\param _RR      Speed-up MPI used for recalculations"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_MPI_BAD_INPUT_DATA if N is negative or even or"]
    #[doc = "                 if E is negative"]
    #[doc = ""]
    #[doc = " \\note           _RR is used to avoid re-computing R*R mod N across"]
    #[doc = "                 multiple calls, which speeds up things a bit. It can"]
    #[doc = "                 be set to NULL if the extra performance is unneeded."]
    pub fn mbedtls_mpi_exp_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
        _RR: *mut mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Fill an MPI X with size bytes of random"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param size     Size in bytes"]
    #[doc = " \\param f_rng    RNG function"]
    #[doc = " \\param p_rng    RNG parameter"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    #[doc = ""]
    #[doc = " \\note           The bytes obtained from the PRNG are interpreted"]
    #[doc = "                 as a big-endian representation of an MPI; this can"]
    #[doc = "                 be relevant in applications like deterministic ECDSA."]
    pub fn mbedtls_mpi_fill_random(
        X: *mut mbedtls_mpi,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Greatest common divisor: G = gcd(A, B)"]
    #[doc = ""]
    #[doc = " \\param G        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param B        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    pub fn mbedtls_mpi_gcd(
        G: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Modular inverse: X = A^-1 mod N"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param A        Left-hand MPI"]
    #[doc = " \\param N        Right-hand MPI"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_MPI_BAD_INPUT_DATA if N is <= 1,"]
    #[doc = "MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if A has no inverse mod N."]
    pub fn mbedtls_mpi_inv_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Miller-Rabin primality test"]
    #[doc = ""]
    #[doc = " \\param X        MPI to check"]
    #[doc = " \\param f_rng    RNG function"]
    #[doc = " \\param p_rng    RNG parameter"]
    #[doc = ""]
    #[doc = " \\return         0 if successful (probably prime),"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if X is not prime"]
    pub fn mbedtls_mpi_is_prime(
        X: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Prime number generation"]
    #[doc = ""]
    #[doc = " \\param X        Destination MPI"]
    #[doc = " \\param nbits    Required size of X in bits"]
    #[doc = "                 ( 3 <= nbits <= MBEDTLS_MPI_MAX_BITS )"]
    #[doc = " \\param dh_flag  If 1, then (X-1)/2 will be prime too"]
    #[doc = " \\param f_rng    RNG function"]
    #[doc = " \\param p_rng    RNG parameter"]
    #[doc = ""]
    #[doc = " \\return         0 if successful (probably prime),"]
    #[doc = "                 MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_MPI_BAD_INPUT_DATA if nbits is < 3"]
    pub fn mbedtls_mpi_gen_prime(
        X: *mut mbedtls_mpi,
        nbits: usize,
        dh_flag: cty::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    pub fn mbedtls_mpi_self_test(verbose: cty::c_int) -> cty::c_int;
}
#[doc = "< Curve not defined."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_NONE: mbedtls_ecp_group_id = 0;
#[doc = "< Domain parameters for the 192-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192R1: mbedtls_ecp_group_id = 1;
#[doc = "< Domain parameters for the 224-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224R1: mbedtls_ecp_group_id = 2;
#[doc = "< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256R1: mbedtls_ecp_group_id = 3;
#[doc = "< Domain parameters for the 384-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP384R1: mbedtls_ecp_group_id = 4;
#[doc = "< Domain parameters for the 521-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP521R1: mbedtls_ecp_group_id = 5;
#[doc = "< Domain parameters for 256-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP256R1: mbedtls_ecp_group_id = 6;
#[doc = "< Domain parameters for 384-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP384R1: mbedtls_ecp_group_id = 7;
#[doc = "< Domain parameters for 512-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP512R1: mbedtls_ecp_group_id = 8;
#[doc = "< Domain parameters for Curve25519."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE25519: mbedtls_ecp_group_id = 9;
#[doc = "< Domain parameters for 192-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192K1: mbedtls_ecp_group_id = 10;
#[doc = "< Domain parameters for 224-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224K1: mbedtls_ecp_group_id = 11;
#[doc = "< Domain parameters for 256-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256K1: mbedtls_ecp_group_id = 12;
#[doc = "< Domain parameters for Curve448."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE448: mbedtls_ecp_group_id = 13;
#[doc = " Domain-parameter identifiers: curve, subgroup, and generator."]
#[doc = ""]
#[doc = " \\note Only curves over prime fields are supported."]
#[doc = ""]
#[doc = " \\warning This library does not support validation of arbitrary domain"]
#[doc = " parameters. Therefore, only standardized domain parameters from trusted"]
#[doc = " sources should be used. See mbedtls_ecp_group_load()."]
pub type mbedtls_ecp_group_id = u32;
#[doc = " Curve information, for use by other modules."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_curve_info {
    #[doc = "< An internal identifier."]
    pub grp_id: mbedtls_ecp_group_id,
    #[doc = "< The TLS NamedCurve identifier."]
    pub tls_id: u16,
    #[doc = "< The curve size in bits."]
    pub bit_size: u16,
    #[doc = "< A human-friendly name."]
    pub name: *const cty::c_char,
}
#[doc = " \\brief           The ECP point structure, in Jacobian coordinates."]
#[doc = ""]
#[doc = " \\note            All functions expect and return points satisfying"]
#[doc = "                  the following condition: <code>Z == 0</code> or"]
#[doc = "                  <code>Z == 1</code>. Other values of \\p Z are"]
#[doc = "                  used only by internal functions."]
#[doc = "                  The point is zero, or \"at infinity\", if <code>Z == 0</code>."]
#[doc = "                  Otherwise, \\p X and \\p Y are its standard (affine)"]
#[doc = "                  coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_point {
    #[doc = "< The X coordinate of the ECP point."]
    pub X: mbedtls_mpi,
    #[doc = "< The Y coordinate of the ECP point."]
    pub Y: mbedtls_mpi,
    #[doc = "< The Z coordinate of the ECP point."]
    pub Z: mbedtls_mpi,
}
#[doc = " \\brief           The ECP group structure."]
#[doc = ""]
#[doc = " We consider two types of curve equations:"]
#[doc = " <ul><li>Short Weierstrass: <code>y^2 = x^3 + A x + B mod P</code>"]
#[doc = " (SEC1 + RFC-4492)</li>"]
#[doc = " <li>Montgomery: <code>y^2 = x^3 + A x^2 + x mod P</code> (Curve25519,"]
#[doc = " Curve448)</li></ul>"]
#[doc = " In both cases, the generator (\\p G) for a prime-order subgroup is fixed."]
#[doc = ""]
#[doc = " For Short Weierstrass, this subgroup is the whole curve, and its"]
#[doc = " cardinality is denoted by \\p N. Our code requires that \\p N is an"]
#[doc = " odd prime as mbedtls_ecp_mul() requires an odd number, and"]
#[doc = " mbedtls_ecdsa_sign() requires that it is prime for blinding purposes."]
#[doc = ""]
#[doc = " For Montgomery curves, we do not store \\p A, but <code>(A + 2) / 4</code>,"]
#[doc = " which is the quantity used in the formulas. Additionally, \\p nbits is"]
#[doc = " not the size of \\p N but the required size for private keys."]
#[doc = ""]
#[doc = " If \\p modp is NULL, reduction modulo \\p P is done using a generic algorithm."]
#[doc = " Otherwise, \\p modp must point to a function that takes an \\p mbedtls_mpi in the"]
#[doc = " range of <code>0..2^(2*pbits)-1</code>, and transforms it in-place to an integer"]
#[doc = " which is congruent mod \\p P to the given MPI, and is close enough to \\p pbits"]
#[doc = " in size, so that it may be efficiently brought in the 0..P-1 range by a few"]
#[doc = " additions or subtractions. Therefore, it is only an approximative modular"]
#[doc = " reduction. It must return 0 on success and non-zero on failure."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_group {
    #[doc = "< An internal group identifier."]
    pub id: mbedtls_ecp_group_id,
    #[doc = "< The prime modulus of the base field."]
    pub P: mbedtls_mpi,
    #[doc = "< For Short Weierstrass: \\p A in the equation. For"]
    #[doc = "Montgomery curves: <code>(A + 2) / 4</code>."]
    pub A: mbedtls_mpi,
    #[doc = "< For Short Weierstrass: \\p B in the equation."]
    #[doc = "For Montgomery curves: unused."]
    pub B: mbedtls_mpi,
    #[doc = "< The generator of the subgroup used."]
    pub G: mbedtls_ecp_point,
    #[doc = "< The order of \\p G."]
    pub N: mbedtls_mpi,
    #[doc = "< The number of bits in \\p P."]
    pub pbits: usize,
    #[doc = "< For Short Weierstrass: The number of bits in \\p P."]
    #[doc = "For Montgomery curves: the number of bits in the"]
    #[doc = "private keys."]
    pub nbits: usize,
    #[doc = "< \\internal 1 if the constants are static."]
    pub h: cty::c_uint,
    #[doc = "< The function for fast pseudo-reduction"]
    #[doc = "mod \\p P (see above)."]
    pub modp: ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbedtls_mpi) -> cty::c_int>,
    #[doc = "< Unused."]
    pub t_pre: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut mbedtls_ecp_point, arg2: *mut cty::c_void) -> cty::c_int,
    >,
    #[doc = "< Unused."]
    pub t_post: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut mbedtls_ecp_point, arg2: *mut cty::c_void) -> cty::c_int,
    >,
    #[doc = "< Unused."]
    pub t_data: *mut cty::c_void,
    #[doc = "< Pre-computed points for ecp_mul_comb()."]
    pub T: *mut mbedtls_ecp_point,
    #[doc = "< The number of pre-computed points."]
    pub T_size: usize,
}
#[doc = " \\brief    The ECP key-pair structure."]
#[doc = ""]
#[doc = " A generic key-pair that may be used for ECDSA and fixed ECDH, for example."]
#[doc = ""]
#[doc = " \\note    Members are deliberately in the same order as in the"]
#[doc = "          ::mbedtls_ecdsa_context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_keypair {
    #[doc = "<  Elliptic curve and base point"]
    pub grp: mbedtls_ecp_group,
    #[doc = "<  our secret value"]
    pub d: mbedtls_mpi,
    #[doc = "<  our public value"]
    pub Q: mbedtls_ecp_point,
}
extern "C" {
    #[doc = " \\brief           This function retrieves the information defined in"]
    #[doc = "                  mbedtls_ecp_curve_info() for all supported curves in order"]
    #[doc = "                  of preference."]
    #[doc = ""]
    #[doc = " \\return          A statically allocated array. The last entry is 0."]
    pub fn mbedtls_ecp_curve_list() -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves the list of internal group"]
    #[doc = "                  identifiers of all supported curves in the order of"]
    #[doc = "                  preference."]
    #[doc = ""]
    #[doc = " \\return          A statically allocated array,"]
    #[doc = "                  terminated with MBEDTLS_ECP_DP_NONE."]
    pub fn mbedtls_ecp_grp_id_list() -> *const mbedtls_ecp_group_id;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from an internal"]
    #[doc = "                  group identifier."]
    #[doc = ""]
    #[doc = " \\param grp_id    An \\c MBEDTLS_ECP_DP_XXX value."]
    #[doc = ""]
    #[doc = " \\return          The associated curve information on success."]
    #[doc = " \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_grp_id(
        grp_id: mbedtls_ecp_group_id,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a TLS"]
    #[doc = "                  NamedCurve value."]
    #[doc = ""]
    #[doc = " \\param tls_id    An \\c MBEDTLS_ECP_DP_XXX value."]
    #[doc = ""]
    #[doc = " \\return          The associated curve information on success."]
    #[doc = " \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_tls_id(tls_id: u16) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a"]
    #[doc = "                  human-readable name."]
    #[doc = ""]
    #[doc = " \\param name      The human-readable name."]
    #[doc = ""]
    #[doc = " \\return          The associated curve information on success."]
    #[doc = " \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_name(
        name: *const cty::c_char,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function initializes a point as zero."]
    #[doc = ""]
    #[doc = " \\param pt        The point to initialize."]
    pub fn mbedtls_ecp_point_init(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECP group context"]
    #[doc = "                  without loading any domain parameters."]
    #[doc = ""]
    #[doc = " \\note            After this function is called, domain parameters"]
    #[doc = "                  for various ECP groups can be loaded through the"]
    #[doc = "                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group()"]
    #[doc = "                  functions."]
    pub fn mbedtls_ecp_group_init(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function initializes a key pair as an invalid one."]
    #[doc = ""]
    #[doc = " \\param key       The key pair to initialize."]
    pub fn mbedtls_ecp_keypair_init(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a point."]
    #[doc = ""]
    #[doc = " \\param pt        The point to free."]
    pub fn mbedtls_ecp_point_free(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of an ECP group."]
    #[doc = " \\param grp       The group to free."]
    pub fn mbedtls_ecp_group_free(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a key pair."]
    #[doc = " \\param key       The key pair to free."]
    pub fn mbedtls_ecp_keypair_free(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of point \\p Q into"]
    #[doc = "                  point \\p P."]
    #[doc = ""]
    #[doc = " \\param P         The destination point."]
    #[doc = " \\param Q         The source point."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_ecp_copy(P: *mut mbedtls_ecp_point, Q: *const mbedtls_ecp_point) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of group \\p src into"]
    #[doc = "                  group \\p dst."]
    #[doc = ""]
    #[doc = " \\param dst       The destination group."]
    #[doc = " \\param src       The source group."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_ecp_group_copy(
        dst: *mut mbedtls_ecp_group,
        src: *const mbedtls_ecp_group,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets a point to zero."]
    #[doc = ""]
    #[doc = " \\param pt        The point to set."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_ecp_set_zero(pt: *mut mbedtls_ecp_point) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks if a point is zero."]
    #[doc = ""]
    #[doc = " \\param pt        The point to test."]
    #[doc = ""]
    #[doc = " \\return          \\c 1 if the point is zero."]
    #[doc = " \\return          \\c 0 if the point is non-zero."]
    pub fn mbedtls_ecp_is_zero(pt: *mut mbedtls_ecp_point) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function compares two points."]
    #[doc = ""]
    #[doc = " \\note            This assumes that the points are normalized. Otherwise,"]
    #[doc = "                  they may compare as \"not equal\" even if they are."]
    #[doc = ""]
    #[doc = " \\param P         The first point to compare."]
    #[doc = " \\param Q         The second point to compare."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the points are equal."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the points are not equal."]
    pub fn mbedtls_ecp_point_cmp(
        P: *const mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a non-zero point from two ASCII"]
    #[doc = "                  strings."]
    #[doc = ""]
    #[doc = " \\param P         The destination point."]
    #[doc = " \\param radix     The numeric base of the input."]
    #[doc = " \\param x         The first affine coordinate, as a null-terminated string."]
    #[doc = " \\param y         The second affine coordinate, as a null-terminated string."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on failure."]
    pub fn mbedtls_ecp_point_read_string(
        P: *mut mbedtls_ecp_point,
        radix: cty::c_int,
        x: *const cty::c_char,
        y: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point into unsigned binary data."]
    #[doc = ""]
    #[doc = " \\param grp       The group to which the point should belong."]
    #[doc = " \\param P         The point to export."]
    #[doc = " \\param format    The point format. Should be an \\c MBEDTLS_ECP_PF_XXX macro."]
    #[doc = " \\param olen      The length of the output."]
    #[doc = " \\param buf       The output buffer."]
    #[doc = " \\param buflen    The length of the output buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA"]
    #[doc = "                  or #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL on failure."]
    pub fn mbedtls_ecp_point_write_binary(
        grp: *const mbedtls_ecp_group,
        P: *const mbedtls_ecp_point,
        format: cty::c_int,
        olen: *mut usize,
        buf: *mut cty::c_uchar,
        buflen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from unsigned binary data."]
    #[doc = ""]
    #[doc = " \\note            This function does not check that the point actually"]
    #[doc = "                  belongs to the given group, see mbedtls_ecp_check_pubkey()"]
    #[doc = "                  for that."]
    #[doc = ""]
    #[doc = " \\param grp       The group to which the point should belong."]
    #[doc = " \\param P         The point to import."]
    #[doc = " \\param buf       The input buffer."]
    #[doc = " \\param ilen      The length of the input."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format"]
    #[doc = "                  is not implemented."]
    #[doc = ""]
    pub fn mbedtls_ecp_point_read_binary(
        grp: *const mbedtls_ecp_group,
        P: *mut mbedtls_ecp_point,
        buf: *const cty::c_uchar,
        ilen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from a TLS ECPoint record."]
    #[doc = ""]
    #[doc = " \\note            On function return, \\p buf is updated to point to immediately"]
    #[doc = "                  after the ECPoint record."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group used."]
    #[doc = " \\param pt        The destination point."]
    #[doc = " \\param buf       The address of the pointer to the start of the input buffer."]
    #[doc = " \\param len       The length of the buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on initialization failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    pub fn mbedtls_ecp_tls_read_point(
        grp: *const mbedtls_ecp_group,
        pt: *mut mbedtls_ecp_point,
        buf: *mut *const cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point as a TLS ECPoint record."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group used."]
    #[doc = " \\param pt        The point format to export to. The point format is an"]
    #[doc = "                  \\c MBEDTLS_ECP_PF_XXX constant."]
    #[doc = " \\param format    The export format."]
    #[doc = " \\param olen      The length of the data written."]
    #[doc = " \\param buf       The buffer to write to."]
    #[doc = " \\param blen      The length of the buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA or"]
    #[doc = "                  #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL on failure."]
    pub fn mbedtls_ecp_tls_write_point(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
        format: cty::c_int,
        olen: *mut usize,
        buf: *mut cty::c_uchar,
        blen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets a group using standardized domain parameters."]
    #[doc = ""]
    #[doc = " \\note            The index should be a value of the NamedCurve enum,"]
    #[doc = "                  as defined in <em>RFC-4492: Elliptic Curve Cryptography"]
    #[doc = "                  (ECC) Cipher Suites for Transport Layer Security (TLS)</em>,"]
    #[doc = "                  usually in the form of an \\c MBEDTLS_ECP_DP_XXX macro."]
    #[doc = ""]
    #[doc = " \\param grp       The destination group."]
    #[doc = " \\param id        The identifier of the domain parameter set to load."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success,"]
    #[doc = " \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on initialization failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE for unkownn groups."]
    #[doc = ""]
    pub fn mbedtls_ecp_group_load(
        grp: *mut mbedtls_ecp_group,
        id: mbedtls_ecp_group_id,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets a group from a TLS ECParameters record."]
    #[doc = ""]
    #[doc = " \\note            \\p buf is updated to point right after the ECParameters record"]
    #[doc = "                  on exit."]
    #[doc = ""]
    #[doc = " \\param grp       The destination group."]
    #[doc = " \\param buf       The address of the pointer to the start of the input buffer."]
    #[doc = " \\param len       The length of the buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on initialization failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    pub fn mbedtls_ecp_tls_read_group(
        grp: *mut mbedtls_ecp_group,
        buf: *mut *const cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function writes the TLS ECParameters record for a group."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group used."]
    #[doc = " \\param olen      The number of Bytes written."]
    #[doc = " \\param buf       The buffer to write to."]
    #[doc = " \\param blen      The length of the buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL on failure."]
    pub fn mbedtls_ecp_tls_write_group(
        grp: *const mbedtls_ecp_group,
        olen: *mut usize,
        buf: *mut cty::c_uchar,
        blen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication of a point by"]
    #[doc = "                  an integer: \\p R = \\p m * \\p P."]
    #[doc = ""]
    #[doc = "                  It is not thread-safe to use same group in multiple threads."]
    #[doc = ""]
    #[doc = " \\note            To prevent timing attacks, this function"]
    #[doc = "                  executes the exact same sequence of base-field"]
    #[doc = "                  operations for any valid \\p m. It avoids any if-branch or"]
    #[doc = "                  array index depending on the value of \\p m."]
    #[doc = ""]
    #[doc = " \\note            If \\p f_rng is not NULL, it is used to randomize"]
    #[doc = "                  intermediate results to prevent potential timing attacks"]
    #[doc = "                  targeting these results. We recommend always providing"]
    #[doc = "                  a non-NULL \\p f_rng. The overhead is negligible."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group."]
    #[doc = " \\param R         The destination point."]
    #[doc = " \\param m         The integer by which to multiply."]
    #[doc = " \\param P         The point to multiply."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private"]
    #[doc = "                  key, or \\p P is not a valid public key."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_ecp_mul(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication and addition of two"]
    #[doc = "                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q"]
    #[doc = ""]
    #[doc = "                  It is not thread-safe to use same group in multiple threads."]
    #[doc = ""]
    #[doc = " \\note            In contrast to mbedtls_ecp_mul(), this function does not"]
    #[doc = "                  guarantee a constant execution flow and timing."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group."]
    #[doc = " \\param R         The destination point."]
    #[doc = " \\param m         The integer by which to multiply \\p P."]
    #[doc = " \\param P         The point to multiply by \\p m."]
    #[doc = " \\param n         The integer by which to multiply \\p Q."]
    #[doc = " \\param Q         The point to be multiplied by \\p n."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not"]
    #[doc = "                  valid private keys, or \\p P or \\p Q are not valid public"]
    #[doc = "                  keys."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_ecp_muladd(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that a point is a valid public key"]
    #[doc = "                  on this curve."]
    #[doc = ""]
    #[doc = "                  It only checks that the point is non-zero, has"]
    #[doc = "                  valid coordinates and lies on the curve. It does not verify"]
    #[doc = "                  that it is indeed a multiple of \\p G. This additional"]
    #[doc = "                  check is computationally more expensive, is not required"]
    #[doc = "                  by standards, and should not be necessary if the group"]
    #[doc = "                  used has a small cofactor. In particular, it is useless for"]
    #[doc = "                  the NIST groups which all have a cofactor of 1."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure, to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The curve the point should lie on."]
    #[doc = " \\param pt        The point to check."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the point is a valid public key."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY on failure."]
    pub fn mbedtls_ecp_check_pubkey(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that an \\p mbedtls_mpi is a valid private"]
    #[doc = "                  key for this curve."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The group used."]
    #[doc = " \\param d         The integer to check."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the point is a valid private key."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY on failure."]
    pub fn mbedtls_ecp_check_privkey(
        grp: *const mbedtls_ecp_group,
        d: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a keypair with a configurable base"]
    #[doc = "                  point."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group."]
    #[doc = " \\param G         The chosen base point."]
    #[doc = " \\param d         The destination MPI (secret part)."]
    #[doc = " \\param Q         The destination point (public part)."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    pub fn mbedtls_ecp_gen_keypair_base(
        grp: *mut mbedtls_ecp_group,
        G: *const mbedtls_ecp_point,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP keypair."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group."]
    #[doc = " \\param d         The destination MPI (secret part)."]
    #[doc = " \\param Q         The destination point (public part)."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    pub fn mbedtls_ecp_gen_keypair(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP key."]
    #[doc = ""]
    #[doc = " \\param grp_id    The ECP group identifier."]
    #[doc = " \\param key       The destination key."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    pub fn mbedtls_ecp_gen_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that the keypair objects"]
    #[doc = "                  \\p pub and \\p prv have the same group and the"]
    #[doc = "                  same public point, and that the private key in"]
    #[doc = "                  \\p prv is consistent with the public key."]
    #[doc = ""]
    #[doc = " \\param pub       The keypair structure holding the public key."]
    #[doc = "                  If it contains a private key, that part is ignored."]
    #[doc = " \\param prv       The keypair structure holding the full keypair."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success, meaning that the keys are valid and match."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the keys are invalid or do not match."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or an \\c MBEDTLS_ERR_MPI_XXX"]
    #[doc = "                  error code on calculation failure."]
    pub fn mbedtls_ecp_check_pub_priv(
        pub_: *const mbedtls_ecp_keypair,
        prv: *const mbedtls_ecp_keypair,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          The ECP checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_ecp_self_test(verbose: cty::c_int) -> cty::c_int;
}
#[doc = "< None."]
pub const mbedtls_md_type_t_MBEDTLS_MD_NONE: mbedtls_md_type_t = 0;
#[doc = "< The MD2 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_MD2: mbedtls_md_type_t = 1;
#[doc = "< The MD4 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_MD4: mbedtls_md_type_t = 2;
#[doc = "< The MD5 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_MD5: mbedtls_md_type_t = 3;
#[doc = "< The SHA-1 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA1: mbedtls_md_type_t = 4;
#[doc = "< The SHA-224 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA224: mbedtls_md_type_t = 5;
#[doc = "< The SHA-256 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA256: mbedtls_md_type_t = 6;
#[doc = "< The SHA-384 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA384: mbedtls_md_type_t = 7;
#[doc = "< The SHA-512 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA512: mbedtls_md_type_t = 8;
#[doc = "< The RIPEMD-160 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_RIPEMD160: mbedtls_md_type_t = 9;
#[doc = " \\brief     Supported message digests."]
#[doc = ""]
#[doc = " \\warning   MD2, MD4, MD5 and SHA-1 are considered weak message digests and"]
#[doc = "            their use constitutes a security risk. We recommend considering"]
#[doc = "            stronger message digests instead."]
#[doc = ""]
pub type mbedtls_md_type_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_info_t {
    _unused: [u8; 0],
}
#[doc = " The generic message-digest context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_context_t {
    #[doc = " Information about the associated message digest."]
    pub md_info: *const mbedtls_md_info_t,
    #[doc = " The digest-specific context."]
    pub md_ctx: *mut cty::c_void,
    #[doc = " The HMAC part of the context."]
    pub hmac_ctx: *mut cty::c_void,
}
extern "C" {
    #[doc = " \\brief           This function returns the list of digests supported by the"]
    #[doc = "                  generic digest module."]
    #[doc = ""]
    #[doc = " \\return          A statically allocated array of digests. Each element"]
    #[doc = "                  in the returned list is an integer belonging to the"]
    #[doc = "                  message-digest enumeration #mbedtls_md_type_t."]
    #[doc = "                  The last entry is 0."]
    pub fn mbedtls_md_list() -> *const cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information"]
    #[doc = "                  associated with the given digest name."]
    #[doc = ""]
    #[doc = " \\param md_name   The name of the digest to search for."]
    #[doc = ""]
    #[doc = " \\return          The message-digest information associated with \\p md_name."]
    #[doc = " \\return          NULL if the associated message-digest information is not found."]
    pub fn mbedtls_md_info_from_string(md_name: *const cty::c_char) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information"]
    #[doc = "                  associated with the given digest type."]
    #[doc = ""]
    #[doc = " \\param md_type   The type of digest to search for."]
    #[doc = ""]
    #[doc = " \\return          The message-digest information associated with \\p md_type."]
    #[doc = " \\return          NULL if the associated message-digest information is not found."]
    pub fn mbedtls_md_info_from_type(md_type: mbedtls_md_type_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function initializes a message-digest context without"]
    #[doc = "                  binding it to a particular message-digest algorithm."]
    #[doc = ""]
    #[doc = "                  This function should always be called first. It prepares the"]
    #[doc = "                  context for mbedtls_md_setup() for binding it to a"]
    #[doc = "                  message-digest algorithm."]
    pub fn mbedtls_md_init(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function clears the internal structure of \\p ctx and"]
    #[doc = "                  frees any embedded internal structure, but does not free"]
    #[doc = "                  \\p ctx itself."]
    #[doc = ""]
    #[doc = "                  If you have called mbedtls_md_setup() on \\p ctx, you must"]
    #[doc = "                  call mbedtls_md_free() when you are no longer using the"]
    #[doc = "                  context."]
    #[doc = "                  Calling this function if you have previously"]
    #[doc = "                  called mbedtls_md_init() and nothing else is optional."]
    #[doc = "                  You must not call this function if you have not called"]
    #[doc = "                  mbedtls_md_init()."]
    pub fn mbedtls_md_free(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function selects the message digest algorithm to use,"]
    #[doc = "                  and allocates internal structures."]
    #[doc = ""]
    #[doc = "                  It should be called after mbedtls_md_init() or mbedtls_md_free()."]
    #[doc = "                  Makes it necessary to call mbedtls_md_free() later."]
    #[doc = ""]
    #[doc = " \\deprecated      Superseded by mbedtls_md_setup() in 2.0.0"]
    #[doc = ""]
    #[doc = " \\param ctx       The context to set up."]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_md_init_ctx(
        ctx: *mut mbedtls_md_context_t,
        md_info: *const mbedtls_md_info_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function selects the message digest algorithm to use,"]
    #[doc = "                  and allocates internal structures."]
    #[doc = ""]
    #[doc = "                  It should be called after mbedtls_md_init() or"]
    #[doc = "                  mbedtls_md_free(). Makes it necessary to call"]
    #[doc = "                  mbedtls_md_free() later."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to set up."]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = " \\param hmac      Defines if HMAC is used. 0: HMAC is not used (saves some memory),"]
    #[doc = "                  or non-zero: HMAC is used with this context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_md_setup(
        ctx: *mut mbedtls_md_context_t,
        md_info: *const mbedtls_md_info_t,
        hmac: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function clones the state of an message-digest"]
    #[doc = "                  context."]
    #[doc = ""]
    #[doc = " \\note            You must call mbedtls_md_setup() on \\c dst before calling"]
    #[doc = "                  this function."]
    #[doc = ""]
    #[doc = " \\note            The two contexts must have the same type,"]
    #[doc = "                  for example, both are SHA-256."]
    #[doc = ""]
    #[doc = " \\warning         This function clones the message-digest state, not the"]
    #[doc = "                  HMAC state."]
    #[doc = ""]
    #[doc = " \\param dst       The destination context."]
    #[doc = " \\param src       The context to be cloned."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification failure."]
    pub fn mbedtls_md_clone(
        dst: *mut mbedtls_md_context_t,
        src: *const mbedtls_md_context_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest size from the"]
    #[doc = "                  message-digest information structure."]
    #[doc = ""]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          The size of the message-digest output in Bytes."]
    pub fn mbedtls_md_get_size(md_info: *const mbedtls_md_info_t) -> cty::c_uchar;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest type from the"]
    #[doc = "                  message-digest information structure."]
    #[doc = ""]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          The type of the message digest."]
    pub fn mbedtls_md_get_type(md_info: *const mbedtls_md_info_t) -> mbedtls_md_type_t;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest name from the"]
    #[doc = "                  message-digest information structure."]
    #[doc = ""]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          The name of the message digest."]
    pub fn mbedtls_md_get_name(md_info: *const mbedtls_md_info_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " \\brief           This function starts a message-digest computation."]
    #[doc = ""]
    #[doc = "                  You must call this function after setting up the context"]
    #[doc = "                  with mbedtls_md_setup(), and before passing data with"]
    #[doc = "                  mbedtls_md_update()."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic message-digest context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_starts(ctx: *mut mbedtls_md_context_t) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing"]
    #[doc = "                  message-digest computation."]
    #[doc = ""]
    #[doc = "                  You must call mbedtls_md_starts() before calling this"]
    #[doc = "                  function. You may call this function multiple times."]
    #[doc = "                  Afterwards, call mbedtls_md_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic message-digest context."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param ilen      The length of the input data."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const cty::c_uchar,
        ilen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the digest operation,"]
    #[doc = "                  and writes the result to the output buffer."]
    #[doc = ""]
    #[doc = "                  Call this function after a call to mbedtls_md_starts(),"]
    #[doc = "                  followed by any number of calls to mbedtls_md_update()."]
    #[doc = "                  Afterwards, you may either clear the context with"]
    #[doc = "                  mbedtls_md_free(), or call mbedtls_md_starts() to reuse"]
    #[doc = "                  the context for another digest operation with the same"]
    #[doc = "                  algorithm."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic message-digest context."]
    #[doc = " \\param output    The buffer for the generic message-digest checksum result."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the message-digest of a buffer,"]
    #[doc = "                 with respect to a configurable message-digest algorithm"]
    #[doc = "                 in a single call."]
    #[doc = ""]
    #[doc = "                 The result is calculated as"]
    #[doc = "                 Output = message_digest(input buffer)."]
    #[doc = ""]
    #[doc = " \\param md_info  The information structure of the message-digest algorithm"]
    #[doc = "                 to use."]
    #[doc = " \\param input    The buffer holding the data."]
    #[doc = " \\param ilen     The length of the input data."]
    #[doc = " \\param output   The generic message-digest checksum result."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                 failure."]
    pub fn mbedtls_md(
        md_info: *const mbedtls_md_info_t,
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the message-digest checksum"]
    #[doc = "                 result of the contents of the provided file."]
    #[doc = ""]
    #[doc = "                 The result is calculated as"]
    #[doc = "                 Output = message_digest(file contents)."]
    #[doc = ""]
    #[doc = " \\param md_info  The information structure of the message-digest algorithm"]
    #[doc = "                 to use."]
    #[doc = " \\param path     The input file name."]
    #[doc = " \\param output   The generic message-digest checksum result."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MD_FILE_IO_ERROR on an I/O error accessing"]
    #[doc = "                 the file pointed by \\p path."]
    #[doc = " \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA if \\p md_info was NULL."]
    pub fn mbedtls_md_file(
        md_info: *const mbedtls_md_info_t,
        path: *const cty::c_char,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the HMAC key and prepares to"]
    #[doc = "                  authenticate a new message."]
    #[doc = ""]
    #[doc = "                  Call this function after mbedtls_md_setup(), to use"]
    #[doc = "                  the MD context for an HMAC calculation, then call"]
    #[doc = "                  mbedtls_md_hmac_update() to provide the input data, and"]
    #[doc = "                  mbedtls_md_hmac_finish() to get the HMAC value."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = " \\param key       The HMAC secret key."]
    #[doc = " \\param keylen    The length of the HMAC key in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_hmac_starts(
        ctx: *mut mbedtls_md_context_t,
        key: *const cty::c_uchar,
        keylen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing HMAC"]
    #[doc = "                  computation."]
    #[doc = ""]
    #[doc = "                  Call mbedtls_md_hmac_starts() or mbedtls_md_hmac_reset()"]
    #[doc = "                  before calling this function."]
    #[doc = "                  You may call this function multiple times to pass the"]
    #[doc = "                  input piecewise."]
    #[doc = "                  Afterwards, call mbedtls_md_hmac_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param ilen      The length of the input data."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_hmac_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const cty::c_uchar,
        ilen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the HMAC operation, and writes"]
    #[doc = "                  the result to the output buffer."]
    #[doc = ""]
    #[doc = "                  Call this function after mbedtls_md_hmac_starts() and"]
    #[doc = "                  mbedtls_md_hmac_update() to get the HMAC value. Afterwards"]
    #[doc = "                  you may either call mbedtls_md_free() to clear the context,"]
    #[doc = "                  or call mbedtls_md_hmac_reset() to reuse the context with"]
    #[doc = "                  the same HMAC key."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = " \\param output    The generic HMAC checksum result."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_hmac_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function prepares to authenticate a new message with"]
    #[doc = "                  the same key as the previous HMAC operation."]
    #[doc = ""]
    #[doc = "                  You may call this function after mbedtls_md_hmac_finish()."]
    #[doc = "                  Afterwards call mbedtls_md_hmac_update() to pass the new"]
    #[doc = "                  input."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    pub fn mbedtls_md_hmac_reset(ctx: *mut mbedtls_md_context_t) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the full generic HMAC"]
    #[doc = "                 on the input buffer with the provided key."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The HMAC result is calculated as"]
    #[doc = "                 output = generic HMAC(hmac key, input buffer)."]
    #[doc = ""]
    #[doc = " \\param md_info  The information structure of the message-digest algorithm"]
    #[doc = "                 to use."]
    #[doc = " \\param key      The HMAC secret key."]
    #[doc = " \\param keylen   The length of the HMAC secret key in Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = " \\param ilen     The length of the input data."]
    #[doc = " \\param output   The generic HMAC result."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                 failure."]
    pub fn mbedtls_md_hmac(
        md_info: *const mbedtls_md_info_t,
        key: *const cty::c_uchar,
        keylen: usize,
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_md_process(
        ctx: *mut mbedtls_md_context_t,
        data: *const cty::c_uchar,
    ) -> cty::c_int;
}
#[doc = " \\brief   The RSA context structure."]
#[doc = ""]
#[doc = " \\note    Direct manipulation of the members of this structure"]
#[doc = "          is deprecated. All manipulation should instead be done through"]
#[doc = "          the public interface functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_rsa_context {
    #[doc = "<  Always 0."]
    pub ver: cty::c_int,
    #[doc = "<  The size of \\p N in Bytes."]
    pub len: usize,
    #[doc = "<  The public modulus."]
    pub N: mbedtls_mpi,
    #[doc = "<  The public exponent."]
    pub E: mbedtls_mpi,
    #[doc = "<  The private exponent."]
    pub D: mbedtls_mpi,
    #[doc = "<  The first prime factor."]
    pub P: mbedtls_mpi,
    #[doc = "<  The second prime factor."]
    pub Q: mbedtls_mpi,
    #[doc = "<  <code>D % (P - 1)</code>."]
    pub DP: mbedtls_mpi,
    #[doc = "<  <code>D % (Q - 1)</code>."]
    pub DQ: mbedtls_mpi,
    #[doc = "<  <code>1 / (Q % P)</code>."]
    pub QP: mbedtls_mpi,
    #[doc = "<  cached <code>R^2 mod N</code>."]
    pub RN: mbedtls_mpi,
    #[doc = "<  cached <code>R^2 mod P</code>."]
    pub RP: mbedtls_mpi,
    #[doc = "<  cached <code>R^2 mod Q</code>."]
    pub RQ: mbedtls_mpi,
    #[doc = "<  The cached blinding value."]
    pub Vi: mbedtls_mpi,
    #[doc = "<  The cached un-blinding value."]
    pub Vf: mbedtls_mpi,
    #[doc = "< Selects padding mode:"]
    #[doc = "#MBEDTLS_RSA_PKCS_V15 for 1.5 padding and"]
    #[doc = "#MBEDTLS_RSA_PKCS_V21 for OAEP or PSS."]
    pub padding: cty::c_int,
    #[doc = "< Hash identifier of mbedtls_md_type_t type,"]
    #[doc = "as specified in md.h for use in the MGF"]
    #[doc = "mask generating function used in the"]
    #[doc = "EME-OAEP and EMSA-PSS encodings."]
    pub hash_id: cty::c_int,
}
extern "C" {
    #[doc = " \\brief          This function initializes an RSA context."]
    #[doc = ""]
    #[doc = " \\note           Set padding to #MBEDTLS_RSA_PKCS_V21 for the RSAES-OAEP"]
    #[doc = "                 encryption scheme and the RSASSA-PSS signature scheme."]
    #[doc = ""]
    #[doc = " \\note           The \\p hash_id parameter is ignored when using"]
    #[doc = "                 #MBEDTLS_RSA_PKCS_V15 padding."]
    #[doc = ""]
    #[doc = " \\note           The choice of padding mode is strictly enforced for private key"]
    #[doc = "                 operations, since there might be security concerns in"]
    #[doc = "                 mixing padding modes. For public key operations it is"]
    #[doc = "                 a default value, which can be overriden by calling specific"]
    #[doc = "                 \\c rsa_rsaes_xxx or \\c rsa_rsassa_xxx functions."]
    #[doc = ""]
    #[doc = " \\note           The hash selected in \\p hash_id is always used for OEAP"]
    #[doc = "                 encryption. For PSS signatures, it is always used for"]
    #[doc = "                 making signatures, but can be overriden for verifying them."]
    #[doc = "                 If set to #MBEDTLS_MD_NONE, it is always overriden."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context to initialize."]
    #[doc = " \\param padding  Selects padding mode: #MBEDTLS_RSA_PKCS_V15 or"]
    #[doc = "                 #MBEDTLS_RSA_PKCS_V21."]
    #[doc = " \\param hash_id  The hash identifier of #mbedtls_md_type_t type, if"]
    #[doc = "                 \\p padding is #MBEDTLS_RSA_PKCS_V21."]
    pub fn mbedtls_rsa_init(
        ctx: *mut mbedtls_rsa_context,
        padding: cty::c_int,
        hash_id: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          This function imports a set of core parameters into an"]
    #[doc = "                 RSA context."]
    #[doc = ""]
    #[doc = " \\note           This function can be called multiple times for successive"]
    #[doc = "                 imports, if the parameters are not simultaneously present."]
    #[doc = ""]
    #[doc = "                 Any sequence of calls to this function should be followed"]
    #[doc = "                 by a call to mbedtls_rsa_complete(), which checks and"]
    #[doc = "                 completes the provided information to a ready-for-use"]
    #[doc = "                 public or private RSA key."]
    #[doc = ""]
    #[doc = " \\note           See mbedtls_rsa_complete() for more information on which"]
    #[doc = "                 parameters are necessary to set up a private or public"]
    #[doc = "                 RSA key."]
    #[doc = ""]
    #[doc = " \\note           The imported parameters are copied and need not be preserved"]
    #[doc = "                 for the lifetime of the RSA context being set up."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to store the parameters in."]
    #[doc = " \\param N        The RSA modulus, or NULL."]
    #[doc = " \\param P        The first prime factor of \\p N, or NULL."]
    #[doc = " \\param Q        The second prime factor of \\p N, or NULL."]
    #[doc = " \\param D        The private exponent, or NULL."]
    #[doc = " \\param E        The public exponent, or NULL."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A non-zero error code on failure."]
    pub fn mbedtls_rsa_import(
        ctx: *mut mbedtls_rsa_context,
        N: *const mbedtls_mpi,
        P: *const mbedtls_mpi,
        Q: *const mbedtls_mpi,
        D: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports core RSA parameters, in raw big-endian"]
    #[doc = "                 binary format, into an RSA context."]
    #[doc = ""]
    #[doc = " \\note           This function can be called multiple times for successive"]
    #[doc = "                 imports, if the parameters are not simultaneously present."]
    #[doc = ""]
    #[doc = "                 Any sequence of calls to this function should be followed"]
    #[doc = "                 by a call to mbedtls_rsa_complete(), which checks and"]
    #[doc = "                 completes the provided information to a ready-for-use"]
    #[doc = "                 public or private RSA key."]
    #[doc = ""]
    #[doc = " \\note           See mbedtls_rsa_complete() for more information on which"]
    #[doc = "                 parameters are necessary to set up a private or public"]
    #[doc = "                 RSA key."]
    #[doc = ""]
    #[doc = " \\note           The imported parameters are copied and need not be preserved"]
    #[doc = "                 for the lifetime of the RSA context being set up."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to store the parameters in."]
    #[doc = " \\param N        The RSA modulus, or NULL."]
    #[doc = " \\param N_len    The Byte length of \\p N, ignored if \\p N == NULL."]
    #[doc = " \\param P        The first prime factor of \\p N, or NULL."]
    #[doc = " \\param P_len    The Byte length of \\p P, ignored if \\p P == NULL."]
    #[doc = " \\param Q        The second prime factor of \\p N, or NULL."]
    #[doc = " \\param Q_len    The Byte length of \\p Q, ignored if \\p Q == NULL."]
    #[doc = " \\param D        The private exponent, or NULL."]
    #[doc = " \\param D_len    The Byte length of \\p D, ignored if \\p D == NULL."]
    #[doc = " \\param E        The public exponent, or NULL."]
    #[doc = " \\param E_len    The Byte length of \\p E, ignored if \\p E == NULL."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A non-zero error code on failure."]
    pub fn mbedtls_rsa_import_raw(
        ctx: *mut mbedtls_rsa_context,
        N: *const cty::c_uchar,
        N_len: usize,
        P: *const cty::c_uchar,
        P_len: usize,
        Q: *const cty::c_uchar,
        Q_len: usize,
        D: *const cty::c_uchar,
        D_len: usize,
        E: *const cty::c_uchar,
        E_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function completes an RSA context from"]
    #[doc = "                 a set of imported core parameters."]
    #[doc = ""]
    #[doc = "                 To setup an RSA public key, precisely \\p N and \\p E"]
    #[doc = "                 must have been imported."]
    #[doc = ""]
    #[doc = "                 To setup an RSA private key, sufficient information must"]
    #[doc = "                 be present for the other parameters to be derivable."]
    #[doc = ""]
    #[doc = "                 The default implementation supports the following:"]
    #[doc = "                 <ul><li>Derive \\p P, \\p Q from \\p N, \\p D, \\p E.</li>"]
    #[doc = "                 <li>Derive \\p N, \\p D from \\p P, \\p Q, \\p E.</li></ul>"]
    #[doc = "                 Alternative implementations need not support these."]
    #[doc = ""]
    #[doc = "                 If this function runs successfully, it guarantees that"]
    #[doc = "                 the RSA context can be used for RSA operations without"]
    #[doc = "                 the risk of failure or crash."]
    #[doc = ""]
    #[doc = " \\warning        This function need not perform consistency checks"]
    #[doc = "                 for the imported parameters. In particular, parameters that"]
    #[doc = "                 are not needed by the implementation might be silently"]
    #[doc = "                 discarded and left unchecked. To check the consistency"]
    #[doc = "                 of the key material, see mbedtls_rsa_check_privkey()."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context holding imported parameters."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_RSA_BAD_INPUT_DATA if the attempted derivations"]
    #[doc = "                 failed."]
    #[doc = ""]
    pub fn mbedtls_rsa_complete(ctx: *mut mbedtls_rsa_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports the core parameters of an RSA key."]
    #[doc = ""]
    #[doc = "                 If this function runs successfully, the non-NULL buffers"]
    #[doc = "                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully"]
    #[doc = "                 written, with additional unused space filled leading by"]
    #[doc = "                 zero Bytes."]
    #[doc = ""]
    #[doc = "                 Possible reasons for returning"]
    #[doc = "                 #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION:<ul>"]
    #[doc = "                 <li>An alternative RSA implementation is in use, which"]
    #[doc = "                 stores the key externally, and either cannot or should"]
    #[doc = "                 not export it into RAM.</li>"]
    #[doc = "                 <li>A SW or HW implementation might not support a certain"]
    #[doc = "                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,"]
    #[doc = "                 and \\p E if the former are not part of the"]
    #[doc = "                 implementation.</li></ul>"]
    #[doc = ""]
    #[doc = "                 If the function fails due to an unsupported operation,"]
    #[doc = "                 the RSA context stays intact and remains usable."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = " \\param N        The MPI to hold the RSA modulus, or NULL."]
    #[doc = " \\param P        The MPI to hold the first prime factor of \\p N, or NULL."]
    #[doc = " \\param Q        The MPI to hold the second prime factor of \\p N, or NULL."]
    #[doc = " \\param D        The MPI to hold the private exponent, or NULL."]
    #[doc = " \\param E        The MPI to hold the public exponent, or NULL."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION if exporting the"]
    #[doc = "                 requested parameters cannot be done due to missing"]
    #[doc = "                 functionality or because of security policies."]
    #[doc = " \\return         A non-zero return code on any other failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_export(
        ctx: *const mbedtls_rsa_context,
        N: *mut mbedtls_mpi,
        P: *mut mbedtls_mpi,
        Q: *mut mbedtls_mpi,
        D: *mut mbedtls_mpi,
        E: *mut mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports core parameters of an RSA key"]
    #[doc = "                 in raw big-endian binary format."]
    #[doc = ""]
    #[doc = "                 If this function runs successfully, the non-NULL buffers"]
    #[doc = "                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully"]
    #[doc = "                 written, with additional unused space filled leading by"]
    #[doc = "                 zero Bytes."]
    #[doc = ""]
    #[doc = "                 Possible reasons for returning"]
    #[doc = "                 #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION:<ul>"]
    #[doc = "                 <li>An alternative RSA implementation is in use, which"]
    #[doc = "                 stores the key externally, and either cannot or should"]
    #[doc = "                 not export it into RAM.</li>"]
    #[doc = "                 <li>A SW or HW implementation might not support a certain"]
    #[doc = "                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,"]
    #[doc = "                 and \\p E if the former are not part of the"]
    #[doc = "                 implementation.</li></ul>"]
    #[doc = "                 If the function fails due to an unsupported operation,"]
    #[doc = "                 the RSA context stays intact and remains usable."]
    #[doc = ""]
    #[doc = " \\note           The length parameters are ignored if the corresponding"]
    #[doc = "                 buffer pointers are NULL."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = " \\param N        The Byte array to store the RSA modulus, or NULL."]
    #[doc = " \\param N_len    The size of the buffer for the modulus."]
    #[doc = " \\param P        The Byte array to hold the first prime factor of \\p N, or"]
    #[doc = "                 NULL."]
    #[doc = " \\param P_len    The size of the buffer for the first prime factor."]
    #[doc = " \\param Q        The Byte array to hold the second prime factor of \\p N, or"]
    #[doc = "                 NULL."]
    #[doc = " \\param Q_len    The size of the buffer for the second prime factor."]
    #[doc = " \\param D        The Byte array to hold the private exponent, or NULL."]
    #[doc = " \\param D_len    The size of the buffer for the private exponent."]
    #[doc = " \\param E        The Byte array to hold the public exponent, or NULL."]
    #[doc = " \\param E_len    The size of the buffer for the public exponent."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION if exporting the"]
    #[doc = "                 requested parameters cannot be done due to missing"]
    #[doc = "                 functionality or because of security policies."]
    #[doc = " \\return         A non-zero return code on any other failure."]
    pub fn mbedtls_rsa_export_raw(
        ctx: *const mbedtls_rsa_context,
        N: *mut cty::c_uchar,
        N_len: usize,
        P: *mut cty::c_uchar,
        P_len: usize,
        Q: *mut cty::c_uchar,
        Q_len: usize,
        D: *mut cty::c_uchar,
        D_len: usize,
        E: *mut cty::c_uchar,
        E_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports CRT parameters of a private RSA key."]
    #[doc = ""]
    #[doc = " \\note           Alternative RSA implementations not using CRT-parameters"]
    #[doc = "                 internally can implement this function based on"]
    #[doc = "                 mbedtls_rsa_deduce_opt()."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = " \\param DP       The MPI to hold D modulo P-1, or NULL."]
    #[doc = " \\param DQ       The MPI to hold D modulo Q-1, or NULL."]
    #[doc = " \\param QP       The MPI to hold modular inverse of Q modulo P, or NULL."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A non-zero error code on failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_export_crt(
        ctx: *const mbedtls_rsa_context,
        DP: *mut mbedtls_mpi,
        DQ: *mut mbedtls_mpi,
        QP: *mut mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets padding for an already initialized RSA"]
    #[doc = "                 context. See mbedtls_rsa_init() for details."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context to be set."]
    #[doc = " \\param padding  Selects padding mode: #MBEDTLS_RSA_PKCS_V15 or"]
    #[doc = "                 #MBEDTLS_RSA_PKCS_V21."]
    #[doc = " \\param hash_id  The #MBEDTLS_RSA_PKCS_V21 hash identifier."]
    pub fn mbedtls_rsa_set_padding(
        ctx: *mut mbedtls_rsa_context,
        padding: cty::c_int,
        hash_id: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          This function retrieves the length of RSA modulus in Bytes."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = ""]
    #[doc = " \\return         The length of the RSA modulus in Bytes."]
    #[doc = ""]
    pub fn mbedtls_rsa_get_len(ctx: *const mbedtls_rsa_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          This function generates an RSA keypair."]
    #[doc = ""]
    #[doc = " \\note           mbedtls_rsa_init() must be called before this function,"]
    #[doc = "                 to set up the RSA context."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context used to hold the key."]
    #[doc = " \\param f_rng    The RNG function."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param nbits    The size of the public key in bits."]
    #[doc = " \\param exponent The public exponent. For example, 65537."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_gen_key(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        nbits: cty::c_uint,
        exponent: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks if a context contains at least an RSA"]
    #[doc = "                 public key."]
    #[doc = ""]
    #[doc = "                 If the function runs successfully, it is guaranteed that"]
    #[doc = "                 enough information is present to perform an RSA public key"]
    #[doc = "                 operation using mbedtls_rsa_public()."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context to check."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_check_pubkey(ctx: *const mbedtls_rsa_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief      This function checks if a context contains an RSA private key"]
    #[doc = "             and perform basic consistency checks."]
    #[doc = ""]
    #[doc = " \\note       The consistency checks performed by this function not only"]
    #[doc = "             ensure that mbedtls_rsa_private() can be called successfully"]
    #[doc = "             on the given context, but that the various parameters are"]
    #[doc = "             mutually consistent with high probability, in the sense that"]
    #[doc = "             mbedtls_rsa_public() and mbedtls_rsa_private() are inverses."]
    #[doc = ""]
    #[doc = " \\warning    This function should catch accidental misconfigurations"]
    #[doc = "             like swapping of parameters, but it cannot establish full"]
    #[doc = "             trust in neither the quality nor the consistency of the key"]
    #[doc = "             material that was used to setup the given RSA context:"]
    #[doc = "             <ul><li>Consistency: Imported parameters that are irrelevant"]
    #[doc = "             for the implementation might be silently dropped. If dropped,"]
    #[doc = "             the current function does not have access to them,"]
    #[doc = "             and therefore cannot check them. See mbedtls_rsa_complete()."]
    #[doc = "             If you want to check the consistency of the entire"]
    #[doc = "             content of an PKCS1-encoded RSA private key, for example, you"]
    #[doc = "             should use mbedtls_rsa_validate_params() before setting"]
    #[doc = "             up the RSA context."]
    #[doc = "             Additionally, if the implementation performs empirical checks,"]
    #[doc = "             these checks substantiate but do not guarantee consistency.</li>"]
    #[doc = "             <li>Quality: This function is not expected to perform"]
    #[doc = "             extended quality assessments like checking that the prime"]
    #[doc = "             factors are safe. Additionally, it is the responsibility of the"]
    #[doc = "             user to ensure the trustworthiness of the source of his RSA"]
    #[doc = "             parameters, which goes beyond what is effectively checkable"]
    #[doc = "             by the library.</li></ul>"]
    #[doc = ""]
    #[doc = " \\param ctx  The RSA context to check."]
    #[doc = ""]
    #[doc = " \\return     \\c 0 on success."]
    #[doc = " \\return     An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_check_privkey(ctx: *const mbedtls_rsa_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks a public-private RSA key pair."]
    #[doc = ""]
    #[doc = "                 It checks each of the contexts, and makes sure they match."]
    #[doc = ""]
    #[doc = " \\param pub      The RSA context holding the public key."]
    #[doc = " \\param prv      The RSA context holding the private key."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_check_pub_priv(
        pub_: *const mbedtls_rsa_context,
        prv: *const mbedtls_rsa_context,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA public key operation."]
    #[doc = ""]
    #[doc = " \\note           This function does not handle message padding."]
    #[doc = ""]
    #[doc = " \\note           Make sure to set \\p input[0] = 0 or ensure that"]
    #[doc = "                 input is smaller than \\p N."]
    #[doc = ""]
    #[doc = " \\note           The input and output buffers must be large"]
    #[doc = "                 enough. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context."]
    #[doc = " \\param input    The input buffer."]
    #[doc = " \\param output   The output buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_public(
        ctx: *mut mbedtls_rsa_context,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA private key operation."]
    #[doc = ""]
    #[doc = " \\note           The input and output buffers must be large"]
    #[doc = "                 enough. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           Blinding is used if and only if a PRNG is provided."]
    #[doc = ""]
    #[doc = " \\note           If blinding is used, both the base of exponentation"]
    #[doc = "                 and the exponent are blinded, providing protection"]
    #[doc = "                 against some side-channel attacks."]
    #[doc = ""]
    #[doc = " \\warning        It is deprecated and a security risk to not provide"]
    #[doc = "                 a PRNG here and thereby prevent the use of blinding."]
    #[doc = "                 Future versions of the library may enforce the presence"]
    #[doc = "                 of a PRNG."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context."]
    #[doc = " \\param f_rng    The RNG function. Needed for blinding."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param input    The input buffer."]
    #[doc = " \\param output   The output buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_private(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function adds the message padding, then performs an RSA"]
    #[doc = "                 operation."]
    #[doc = ""]
    #[doc = "                 It is the generic wrapper for performing a PKCS#1 encryption"]
    #[doc = "                 operation using the \\p mode from the context."]
    #[doc = ""]
    #[doc = " \\note           The input and output buffers must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context."]
    #[doc = " \\param f_rng    The RNG function. Needed for padding, PKCS#1 v2.1"]
    #[doc = "                 encoding, and #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param ilen     The length of the plaintext."]
    #[doc = " \\param input    The buffer holding the data to encrypt."]
    #[doc = " \\param output   The buffer used to hold the ciphertext."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        ilen: usize,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 encryption operation"]
    #[doc = "                 (RSAES-PKCS1-v1_5-ENCRYPT)."]
    #[doc = ""]
    #[doc = " \\note           The output buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context."]
    #[doc = " \\param f_rng    The RNG function. Needed for padding and"]
    #[doc = "                 #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param ilen     The length of the plaintext."]
    #[doc = " \\param input    The buffer holding the data to encrypt."]
    #[doc = " \\param output   The buffer used to hold the ciphertext."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        ilen: usize,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP encryption"]
    #[doc = "                   operation (RSAES-OAEP-ENCRYPT)."]
    #[doc = ""]
    #[doc = " \\note             The output buffer must be as large as the size"]
    #[doc = "                   of ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\deprecated       It is deprecated and discouraged to call this function"]
    #[doc = "                   in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                   are likely to remove the \\p mode argument and have it"]
    #[doc = "                   implicitly set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note             Alternative implementations of RSA need not support"]
    #[doc = "                   mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                   return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx        The RSA context."]
    #[doc = " \\param f_rng      The RNG function. Needed for padding and PKCS#1 v2.1"]
    #[doc = "                   encoding and #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng      The RNG context."]
    #[doc = " \\param mode       #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param label      The buffer holding the custom label to use."]
    #[doc = " \\param label_len  The length of the label."]
    #[doc = " \\param ilen       The length of the plaintext."]
    #[doc = " \\param input      The buffer holding the data to encrypt."]
    #[doc = " \\param output     The buffer used to hold the ciphertext."]
    #[doc = ""]
    #[doc = " \\return           \\c 0 on success."]
    #[doc = " \\return           An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_oaep_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        label: *const cty::c_uchar,
        label_len: usize,
        ilen: usize,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA operation, then removes the"]
    #[doc = "                 message padding."]
    #[doc = ""]
    #[doc = "                 It is the generic wrapper for performing a PKCS#1 decryption"]
    #[doc = "                 operation using the \\p mode from the context."]
    #[doc = ""]
    #[doc = " \\note           The output buffer length \\c output_max_len should be"]
    #[doc = "                 as large as the size \\p ctx->len of \\p ctx->N (for example,"]
    #[doc = "                 128 Bytes if RSA-1024 is used) to be able to hold an"]
    #[doc = "                 arbitrary decrypted message. If it is not large enough to"]
    #[doc = "                 hold the decryption of the particular ciphertext provided,"]
    #[doc = "                 the function returns \\c MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE."]
    #[doc = ""]
    #[doc = " \\note           The input buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context."]
    #[doc = " \\param f_rng    The RNG function. Only needed for #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param olen     The length of the plaintext."]
    #[doc = " \\param input    The buffer holding the encrypted data."]
    #[doc = " \\param output   The buffer used to hold the plaintext."]
    #[doc = " \\param output_max_len    The maximum length of the output buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        olen: *mut usize,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
        output_max_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 decryption"]
    #[doc = "                 operation (RSAES-PKCS1-v1_5-DECRYPT)."]
    #[doc = ""]
    #[doc = " \\note           The output buffer length \\c output_max_len should be"]
    #[doc = "                 as large as the size \\p ctx->len of \\p ctx->N, for example,"]
    #[doc = "                 128 Bytes if RSA-1024 is used, to be able to hold an"]
    #[doc = "                 arbitrary decrypted message. If it is not large enough to"]
    #[doc = "                 hold the decryption of the particular ciphertext provided,"]
    #[doc = "                 the function returns #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE."]
    #[doc = ""]
    #[doc = " \\note           The input buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context."]
    #[doc = " \\param f_rng    The RNG function. Only needed for #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param olen     The length of the plaintext."]
    #[doc = " \\param input    The buffer holding the encrypted data."]
    #[doc = " \\param output   The buffer to hold the plaintext."]
    #[doc = " \\param output_max_len    The maximum length of the output buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        olen: *mut usize,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
        output_max_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP decryption"]
    #[doc = "                   operation (RSAES-OAEP-DECRYPT)."]
    #[doc = ""]
    #[doc = " \\note             The output buffer length \\c output_max_len should be"]
    #[doc = "                   as large as the size \\p ctx->len of \\p ctx->N, for"]
    #[doc = "                   example, 128 Bytes if RSA-1024 is used, to be able to"]
    #[doc = "                   hold an arbitrary decrypted message. If it is not"]
    #[doc = "                   large enough to hold the decryption of the particular"]
    #[doc = "                   ciphertext provided, the function returns"]
    #[doc = "                   #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE."]
    #[doc = ""]
    #[doc = " \\note             The input buffer must be as large as the size"]
    #[doc = "                   of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\deprecated       It is deprecated and discouraged to call this function"]
    #[doc = "                   in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                   are likely to remove the \\p mode argument and have it"]
    #[doc = "                   implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note             Alternative implementations of RSA need not support"]
    #[doc = "                   mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                   return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx        The RSA context."]
    #[doc = " \\param f_rng      The RNG function. Only needed for #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng      The RNG context."]
    #[doc = " \\param mode       #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param label      The buffer holding the custom label to use."]
    #[doc = " \\param label_len  The length of the label."]
    #[doc = " \\param olen       The length of the plaintext."]
    #[doc = " \\param input      The buffer holding the encrypted data."]
    #[doc = " \\param output     The buffer to hold the plaintext."]
    #[doc = " \\param output_max_len    The maximum length of the output buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_oaep_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        label: *const cty::c_uchar,
        label_len: usize,
        olen: *mut usize,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
        output_max_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a private RSA operation to sign"]
    #[doc = "                 a message digest using PKCS#1."]
    #[doc = ""]
    #[doc = "                 It is the generic wrapper for performing a PKCS#1"]
    #[doc = "                 signature using the \\p mode from the context."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           For PKCS#1 v2.1 encoding, see comments on"]
    #[doc = "                 mbedtls_rsa_rsassa_pss_sign() for details on"]
    #[doc = "                 \\p md_alg and \\p hash_id."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context."]
    #[doc = " \\param f_rng    The RNG function. Needed for PKCS#1 v2.1 encoding and for"]
    #[doc = "                 #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest. Only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest."]
    #[doc = " \\param sig      The buffer to hold the ciphertext."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: cty::c_uint,
        hash: *const cty::c_uchar,
        sig: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 signature"]
    #[doc = "                 operation (RSASSA-PKCS1-v1_5-SIGN)."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context."]
    #[doc = " \\param f_rng    The RNG function. Only needed for #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest. Only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest."]
    #[doc = " \\param sig      The buffer to hold the ciphertext."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: cty::c_uint,
        hash: *const cty::c_uchar,
        sig: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS signature"]
    #[doc = "                 operation (RSASSA-PSS-SIGN)."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           The \\p hash_id in the RSA context is the one used for the"]
    #[doc = "                 encoding. \\p md_alg in the function call is the type of hash"]
    #[doc = "                 that is encoded. According to <em>RFC-3447: Public-Key"]
    #[doc = "                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography"]
    #[doc = "                 Specifications</em> it is advised to keep both hashes the"]
    #[doc = "                 same."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context."]
    #[doc = " \\param f_rng    The RNG function. Needed for PKCS#1 v2.1 encoding and for"]
    #[doc = "                 #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest. Only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest."]
    #[doc = " \\param sig      The buffer to hold the ciphertext."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: cty::c_uint,
        hash: *const cty::c_uchar,
        sig: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a public RSA operation and checks"]
    #[doc = "                 the message digest."]
    #[doc = ""]
    #[doc = "                 This is the generic wrapper for performing a PKCS#1"]
    #[doc = "                 verification using the mode from the context."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           For PKCS#1 v2.1 encoding, see comments on"]
    #[doc = "                 mbedtls_rsa_rsassa_pss_verify() about \\p md_alg and"]
    #[doc = "                 \\p hash_id."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA public key context."]
    #[doc = " \\param f_rng    The RNG function. Only needed for #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest. Only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest."]
    #[doc = " \\param sig      The buffer holding the ciphertext."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_verify(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: cty::c_uint,
        hash: *const cty::c_uchar,
        sig: *const cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 verification"]
    #[doc = "                 operation (RSASSA-PKCS1-v1_5-VERIFY)."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA public key context."]
    #[doc = " \\param f_rng    The RNG function. Only needed for #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest. Only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest."]
    #[doc = " \\param sig      The buffer holding the ciphertext."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_verify(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: cty::c_uint,
        hash: *const cty::c_uchar,
        sig: *const cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification"]
    #[doc = "                 operation (RSASSA-PSS-VERIFY)."]
    #[doc = ""]
    #[doc = "                 The hash function for the MGF mask generating function"]
    #[doc = "                 is that specified in the RSA context."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           The \\p hash_id in the RSA context is the one used for the"]
    #[doc = "                 verification. \\p md_alg in the function call is the type of"]
    #[doc = "                 hash that is verified. According to <em>RFC-3447: Public-Key"]
    #[doc = "                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography"]
    #[doc = "                 Specifications</em> it is advised to keep both hashes the"]
    #[doc = "                 same. If \\p hash_id in the RSA context is unset,"]
    #[doc = "                 the \\p md_alg from the function call is used."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_RSA_UNSUPPORTED_OPERATION."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA public key context."]
    #[doc = " \\param f_rng    The RNG function. Only needed for #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest. Only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest."]
    #[doc = " \\param sig      The buffer holding the ciphertext."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_verify(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: cty::c_uint,
        hash: *const cty::c_uchar,
        sig: *const cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification"]
    #[doc = "                 operation (RSASSA-PSS-VERIFY)."]
    #[doc = ""]
    #[doc = "                 The hash function for the MGF mask generating function"]
    #[doc = "                 is that specified in \\p mgf1_hash_id."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           The \\p hash_id in the RSA context is ignored."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA public key context."]
    #[doc = " \\param f_rng    The RNG function. Only needed for #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = " \\param mode     #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest. Only used if \\p md_alg is"]
    #[doc = "                 #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest."]
    #[doc = " \\param mgf1_hash_id       The message digest used for mask generation."]
    #[doc = " \\param expected_salt_len  The length of the salt used in padding. Use"]
    #[doc = "                           #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length."]
    #[doc = " \\param sig      The buffer holding the ciphertext."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_verify_ext(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: cty::c_uint,
        hash: *const cty::c_uchar,
        mgf1_hash_id: mbedtls_md_type_t,
        expected_salt_len: cty::c_int,
        sig: *const cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function copies the components of an RSA context."]
    #[doc = ""]
    #[doc = " \\param dst      The destination context."]
    #[doc = " \\param src      The source context."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory allocation failure."]
    pub fn mbedtls_rsa_copy(
        dst: *mut mbedtls_rsa_context,
        src: *const mbedtls_rsa_context,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function frees the components of an RSA key."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA Context to free."]
    pub fn mbedtls_rsa_free(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    #[doc = " \\brief          The RSA checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_rsa_self_test(verbose: cty::c_int) -> cty::c_int;
}
#[doc = " \\brief           The ECDSA context structure."]
pub type mbedtls_ecdsa_context = mbedtls_ecp_keypair;
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a"]
    #[doc = "                  previously-hashed message."]
    #[doc = ""]
    #[doc = " \\note            The deterministic version is usually preferred."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated"]
    #[doc = "                  as defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group."]
    #[doc = " \\param r         The first output integer."]
    #[doc = " \\param s         The second output integer."]
    #[doc = " \\param d         The private signing key."]
    #[doc = " \\param buf       The message hash."]
    #[doc = " \\param blen      The length of \\p buf."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX"]
    #[doc = "                  or \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdsa_sign(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const cty::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a"]
    #[doc = "                  previously-hashed message, deterministic version."]
    #[doc = ""]
    #[doc = "                  For more information, see <em>RFC-6979: Deterministic"]
    #[doc = "                  Usage of the Digital Signature Algorithm (DSA) and Elliptic"]
    #[doc = "                  Curve Digital Signature Algorithm (ECDSA)</em>."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group."]
    #[doc = " \\param r         The first output integer."]
    #[doc = " \\param s         The second output integer."]
    #[doc = " \\param d         The private signing key."]
    #[doc = " \\param buf       The message hash."]
    #[doc = " \\param blen      The length of \\p buf."]
    #[doc = " \\param md_alg    The MD algorithm used to hash the message."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX"]
    #[doc = "                  error code on failure."]
    pub fn mbedtls_ecdsa_sign_det(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const cty::c_uchar,
        blen: usize,
        md_alg: mbedtls_md_type_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function verifies the ECDSA signature of a"]
    #[doc = "                  previously-hashed message."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.4, step 3."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group."]
    #[doc = " \\param buf       The message hash."]
    #[doc = " \\param blen      The length of \\p buf."]
    #[doc = " \\param Q         The public key to use for verification."]
    #[doc = " \\param r         The first integer of the signature."]
    #[doc = " \\param s         The second integer of the signature."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the signature"]
    #[doc = "                  is invalid."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX"]
    #[doc = "                  error code on failure for any other reason."]
    pub fn mbedtls_ecdsa_verify(
        grp: *mut mbedtls_ecp_group,
        buf: *const cty::c_uchar,
        blen: usize,
        Q: *const mbedtls_ecp_point,
        r: *const mbedtls_mpi,
        s: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature and writes it"]
    #[doc = "                  to a buffer, serialized as defined in <em>RFC-4492:"]
    #[doc = "                  Elliptic Curve Cryptography (ECC) Cipher Suites for"]
    #[doc = "                  Transport Layer Security (TLS)</em>."]
    #[doc = ""]
    #[doc = " \\warning         It is not thread-safe to use the same context in"]
    #[doc = "                  multiple threads."]
    #[doc = ""]
    #[doc = " \\note            The deterministic version is used if"]
    #[doc = "                  #MBEDTLS_ECDSA_DETERMINISTIC is defined. For more"]
    #[doc = "                  information, see <em>RFC-6979: Deterministic Usage"]
    #[doc = "                  of the Digital Signature Algorithm (DSA) and Elliptic"]
    #[doc = "                  Curve Digital Signature Algorithm (ECDSA)</em>."]
    #[doc = ""]
    #[doc = " \\note            The \\p sig buffer must be at least twice as large as the"]
    #[doc = "                  size of the curve used, plus 9. For example, 73 Bytes if"]
    #[doc = "                  a 256-bit curve is used. A buffer length of"]
    #[doc = "                  #MBEDTLS_ECDSA_MAX_LEN is always safe."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context."]
    #[doc = " \\param md_alg    The message digest that was used to hash the message."]
    #[doc = " \\param hash      The message hash."]
    #[doc = " \\param hlen      The length of the hash."]
    #[doc = " \\param sig       The buffer that holds the signature."]
    #[doc = " \\param slen      The length of the signature written."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or"]
    #[doc = "                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    pub fn mbedtls_ecdsa_write_signature(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const cty::c_uchar,
        hlen: usize,
        sig: *mut cty::c_uchar,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes an ECDSA signature and writes"]
    #[doc = "                  it to a buffer, serialized as defined in <em>RFC-4492:"]
    #[doc = "                  Elliptic Curve Cryptography (ECC) Cipher Suites for"]
    #[doc = "                  Transport Layer Security (TLS)</em>."]
    #[doc = ""]
    #[doc = "                  The deterministic version is defined in <em>RFC-6979:"]
    #[doc = "                  Deterministic Usage of the Digital Signature Algorithm (DSA)"]
    #[doc = "                  and Elliptic Curve Digital Signature Algorithm (ECDSA)</em>."]
    #[doc = ""]
    #[doc = " \\warning         It is not thread-safe to use the same context in"]
    #[doc = "                  multiple threads."]
    #[doc = ""]
    #[doc = " \\note            The \\p sig buffer must be at least twice as large as the"]
    #[doc = "                  size of the curve used, plus 9. For example, 73 Bytes if a"]
    #[doc = "                  256-bit curve is used. A buffer length of"]
    #[doc = "                  #MBEDTLS_ECDSA_MAX_LEN is always safe."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\deprecated      Superseded by mbedtls_ecdsa_write_signature() in"]
    #[doc = "                  Mbed TLS version 2.0 and later."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context."]
    #[doc = " \\param hash      The message hash."]
    #[doc = " \\param hlen      The length of the hash."]
    #[doc = " \\param sig       The buffer that holds the signature."]
    #[doc = " \\param slen      The length of the signature written."]
    #[doc = " \\param md_alg    The MD algorithm used to hash the message."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or"]
    #[doc = "                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    pub fn mbedtls_ecdsa_write_signature_det(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const cty::c_uchar,
        hlen: usize,
        sig: *mut cty::c_uchar,
        slen: *mut usize,
        md_alg: mbedtls_md_type_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads and verifies an ECDSA signature."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.4, step 3."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context."]
    #[doc = " \\param hash      The message hash."]
    #[doc = " \\param hlen      The size of the hash."]
    #[doc = " \\param sig       The signature to read and verify."]
    #[doc = " \\param slen      The size of \\p sig."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in \\p sig, but its length is less than \\p siglen."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX"]
    #[doc = "                  error code on failure for any other reason."]
    pub fn mbedtls_ecdsa_read_signature(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const cty::c_uchar,
        hlen: usize,
        sig: *const cty::c_uchar,
        slen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function generates an ECDSA keypair on the given curve."]
    #[doc = ""]
    #[doc = " \\see            ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx      The ECDSA context to store the keypair in."]
    #[doc = " \\param gid      The elliptic curve to use. One of the various"]
    #[doc = "                 \\c MBEDTLS_ECP_DP_XXX macros depending on configuration."]
    #[doc = " \\param f_rng    The RNG function."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    pub fn mbedtls_ecdsa_genkey(
        ctx: *mut mbedtls_ecdsa_context,
        gid: mbedtls_ecp_group_id,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets an ECDSA context from an EC key pair."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to set."]
    #[doc = " \\param key       The EC key to use."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    pub fn mbedtls_ecdsa_from_keypair(
        ctx: *mut mbedtls_ecdsa_context,
        key: *const mbedtls_ecp_keypair,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDSA context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to initialize."]
    pub fn mbedtls_ecdsa_init(ctx: *mut mbedtls_ecdsa_context);
}
extern "C" {
    #[doc = " \\brief           This function frees an ECDSA context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to free."]
    pub fn mbedtls_ecdsa_free(ctx: *mut mbedtls_ecdsa_context);
}
pub const mbedtls_pk_type_t_MBEDTLS_PK_NONE: mbedtls_pk_type_t = 0;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA: mbedtls_pk_type_t = 1;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY: mbedtls_pk_type_t = 2;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY_DH: mbedtls_pk_type_t = 3;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECDSA: mbedtls_pk_type_t = 4;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA_ALT: mbedtls_pk_type_t = 5;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSASSA_PSS: mbedtls_pk_type_t = 6;
#[doc = " \\brief          Public key types"]
pub type mbedtls_pk_type_t = u32;
#[doc = " \\brief           Options for RSASSA-PSS signature verification."]
#[doc = "                  See \\c mbedtls_rsa_rsassa_pss_verify_ext()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_rsassa_pss_options {
    pub mgf1_hash_id: mbedtls_md_type_t,
    pub expected_salt_len: cty::c_int,
}
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_NONE: mbedtls_pk_debug_type = 0;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_MPI: mbedtls_pk_debug_type = 1;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_ECP: mbedtls_pk_debug_type = 2;
#[doc = " \\brief           Types for interfacing with the debug module"]
pub type mbedtls_pk_debug_type = u32;
#[doc = " \\brief           Item to send to the debug module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_debug_item {
    pub type_: mbedtls_pk_debug_type,
    pub name: *const cty::c_char,
    pub value: *mut cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_info_t {
    _unused: [u8; 0],
}
#[doc = " \\brief           Public key container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_context {
    #[doc = "< Public key informations"]
    pub pk_info: *const mbedtls_pk_info_t,
    #[doc = "< Underlying public key context"]
    pub pk_ctx: *mut cty::c_void,
}
#[doc = " \\brief           Types for RSA-alt abstraction"]
pub type mbedtls_pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut cty::c_void,
        mode: cty::c_int,
        olen: *mut usize,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
        output_max_len: usize,
    ) -> cty::c_int,
>;
pub type mbedtls_pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut cty::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
        mode: cty::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: cty::c_uint,
        hash: *const cty::c_uchar,
        sig: *mut cty::c_uchar,
    ) -> cty::c_int,
>;
pub type mbedtls_pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut cty::c_void) -> usize>;
extern "C" {
    #[doc = " \\brief           Return information associated with the given PK type"]
    #[doc = ""]
    #[doc = " \\param pk_type   PK type to search for."]
    #[doc = ""]
    #[doc = " \\return          The PK info associated with the type or NULL if not found."]
    pub fn mbedtls_pk_info_from_type(pk_type: mbedtls_pk_type_t) -> *const mbedtls_pk_info_t;
}
extern "C" {
    #[doc = " \\brief           Initialize a mbedtls_pk_context (as NONE)"]
    pub fn mbedtls_pk_init(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    #[doc = " \\brief           Free a mbedtls_pk_context"]
    pub fn mbedtls_pk_free(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    #[doc = " \\brief           Initialize a PK context with the information given"]
    #[doc = "                  and allocates the type-specific PK subcontext."]
    #[doc = ""]
    #[doc = " \\param ctx       Context to initialize. Must be empty (type NONE)."]
    #[doc = " \\param info      Information to use"]
    #[doc = ""]
    #[doc = " \\return          0 on success,"]
    #[doc = "                  MBEDTLS_ERR_PK_BAD_INPUT_DATA on invalid input,"]
    #[doc = "                  MBEDTLS_ERR_PK_ALLOC_FAILED on allocation failure."]
    #[doc = ""]
    #[doc = " \\note            For contexts holding an RSA-alt key, use"]
    #[doc = "                  \\c mbedtls_pk_setup_rsa_alt() instead."]
    pub fn mbedtls_pk_setup(
        ctx: *mut mbedtls_pk_context,
        info: *const mbedtls_pk_info_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Initialize an RSA-alt context"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to initialize. Must be empty (type NONE)."]
    #[doc = " \\param key       RSA key pointer"]
    #[doc = " \\param decrypt_func  Decryption function"]
    #[doc = " \\param sign_func     Signing function"]
    #[doc = " \\param key_len_func  Function returning key length in bytes"]
    #[doc = ""]
    #[doc = " \\return          0 on success, or MBEDTLS_ERR_PK_BAD_INPUT_DATA if the"]
    #[doc = "                  context wasn't already initialized as RSA_ALT."]
    #[doc = ""]
    #[doc = " \\note            This function replaces \\c mbedtls_pk_setup() for RSA-alt."]
    pub fn mbedtls_pk_setup_rsa_alt(
        ctx: *mut mbedtls_pk_context,
        key: *mut cty::c_void,
        decrypt_func: mbedtls_pk_rsa_alt_decrypt_func,
        sign_func: mbedtls_pk_rsa_alt_sign_func,
        key_len_func: mbedtls_pk_rsa_alt_key_len_func,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Get the size in bits of the underlying key"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to use"]
    #[doc = ""]
    #[doc = " \\return          Key size in bits, or 0 on error"]
    pub fn mbedtls_pk_get_bitlen(ctx: *const mbedtls_pk_context) -> usize;
}
extern "C" {
    #[doc = " \\brief           Tell if a context can do the operation given by type"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to test"]
    #[doc = " \\param type      Target type"]
    #[doc = ""]
    #[doc = " \\return          0 if context can't do the operations,"]
    #[doc = "                  1 otherwise."]
    pub fn mbedtls_pk_can_do(
        ctx: *const mbedtls_pk_context,
        type_: mbedtls_pk_type_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature (including padding if relevant)."]
    #[doc = ""]
    #[doc = " \\param ctx       PK context to use"]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes)"]
    #[doc = " \\param sig       Signature to verify"]
    #[doc = " \\param sig_len   Signature length"]
    #[doc = ""]
    #[doc = " \\return          0 on success (signature is valid),"]
    #[doc = "                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in sig but its length is less than \\p siglen,"]
    #[doc = "                  or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = "                  Use \\c mbedtls_pk_verify_ext( MBEDTLS_PK_RSASSA_PSS, ... )"]
    #[doc = "                  to verify RSASSA_PSS signatures."]
    #[doc = ""]
    #[doc = " \\note            If hash_len is 0, then the length associated with md_alg"]
    #[doc = "                  is used instead, or an error returned if it is invalid."]
    #[doc = ""]
    #[doc = " \\note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0"]
    pub fn mbedtls_pk_verify(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const cty::c_uchar,
        hash_len: usize,
        sig: *const cty::c_uchar,
        sig_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature, with options."]
    #[doc = "                  (Includes verification of the padding depending on type.)"]
    #[doc = ""]
    #[doc = " \\param type      Signature type (inc. possible padding type) to verify"]
    #[doc = " \\param options   Pointer to type-specific options, or NULL"]
    #[doc = " \\param ctx       PK context to use"]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes)"]
    #[doc = " \\param sig       Signature to verify"]
    #[doc = " \\param sig_len   Signature length"]
    #[doc = ""]
    #[doc = " \\return          0 on success (signature is valid),"]
    #[doc = "                  #MBEDTLS_ERR_PK_TYPE_MISMATCH if the PK context can't be"]
    #[doc = "                  used for this type of signatures,"]
    #[doc = "                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in sig but its length is less than \\p siglen,"]
    #[doc = "                  or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            If hash_len is 0, then the length associated with md_alg"]
    #[doc = "                  is used instead, or an error returned if it is invalid."]
    #[doc = ""]
    #[doc = " \\note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0"]
    #[doc = ""]
    #[doc = " \\note            If type is MBEDTLS_PK_RSASSA_PSS, then options must point"]
    #[doc = "                  to a mbedtls_pk_rsassa_pss_options structure,"]
    #[doc = "                  otherwise it must be NULL."]
    pub fn mbedtls_pk_verify_ext(
        type_: mbedtls_pk_type_t,
        options: *const cty::c_void,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const cty::c_uchar,
        hash_len: usize,
        sig: *const cty::c_uchar,
        sig_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Make signature, including padding if relevant."]
    #[doc = ""]
    #[doc = " \\param ctx       PK context to use - must hold a private key"]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes)"]
    #[doc = " \\param sig       Place to write the signature"]
    #[doc = " \\param sig_len   Number of bytes written"]
    #[doc = " \\param f_rng     RNG function"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = "                  There is no interface in the PK module to make RSASSA-PSS"]
    #[doc = "                  signatures yet."]
    #[doc = ""]
    #[doc = " \\note            If hash_len is 0, then the length associated with md_alg"]
    #[doc = "                  is used instead, or an error returned if it is invalid."]
    #[doc = ""]
    #[doc = " \\note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0."]
    #[doc = "                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE."]
    pub fn mbedtls_pk_sign(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const cty::c_uchar,
        hash_len: usize,
        sig: *mut cty::c_uchar,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Decrypt message (including padding if relevant)."]
    #[doc = ""]
    #[doc = " \\param ctx       PK context to use - must hold a private key"]
    #[doc = " \\param input     Input to decrypt"]
    #[doc = " \\param ilen      Input size"]
    #[doc = " \\param output    Decrypted output"]
    #[doc = " \\param olen      Decrypted message length"]
    #[doc = " \\param osize     Size of the output buffer"]
    #[doc = " \\param f_rng     RNG function"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    pub fn mbedtls_pk_decrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Encrypt message (including padding if relevant)."]
    #[doc = ""]
    #[doc = " \\param ctx       PK context to use"]
    #[doc = " \\param input     Message to encrypt"]
    #[doc = " \\param ilen      Message size"]
    #[doc = " \\param output    Encrypted output"]
    #[doc = " \\param olen      Encrypted output length"]
    #[doc = " \\param osize     Size of the output buffer"]
    #[doc = " \\param f_rng     RNG function"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    pub fn mbedtls_pk_encrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Check if a public-private pair of keys matches."]
    #[doc = ""]
    #[doc = " \\param pub       Context holding a public key."]
    #[doc = " \\param prv       Context holding a private (and public) key."]
    #[doc = ""]
    #[doc = " \\return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA"]
    pub fn mbedtls_pk_check_pair(
        pub_: *const mbedtls_pk_context,
        prv: *const mbedtls_pk_context,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Export debug information"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to use"]
    #[doc = " \\param items     Place to write debug items"]
    #[doc = ""]
    #[doc = " \\return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA"]
    pub fn mbedtls_pk_debug(
        ctx: *const mbedtls_pk_context,
        items: *mut mbedtls_pk_debug_item,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Access the type name"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to use"]
    #[doc = ""]
    #[doc = " \\return          Type name on success, or \"invalid PK\""]
    pub fn mbedtls_pk_get_name(ctx: *const mbedtls_pk_context) -> *const cty::c_char;
}
extern "C" {
    #[doc = " \\brief           Get the key type"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to use"]
    #[doc = ""]
    #[doc = " \\return          Type on success, or MBEDTLS_PK_NONE"]
    pub fn mbedtls_pk_get_type(ctx: *const mbedtls_pk_context) -> mbedtls_pk_type_t;
}
extern "C" {
    #[doc = " \\ingroup pk_module */"]
    #[doc = " \\brief           Parse a private key in PEM or DER format"]
    #[doc = ""]
    #[doc = " \\param ctx       key to be initialized"]
    #[doc = " \\param key       input buffer"]
    #[doc = " \\param keylen    size of the buffer"]
    #[doc = "                  (including the terminating null byte for PEM data)"]
    #[doc = " \\param pwd       password for decryption (optional)"]
    #[doc = " \\param pwdlen    size of the password"]
    #[doc = ""]
    #[doc = " \\note            On entry, ctx must be empty, either freshly initialised"]
    #[doc = "                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a"]
    #[doc = "                  specific key type, check the result with mbedtls_pk_can_do()."]
    #[doc = ""]
    #[doc = " \\note            The key is also checked for correctness."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_key(
        ctx: *mut mbedtls_pk_context,
        key: *const cty::c_uchar,
        keylen: usize,
        pwd: *const cty::c_uchar,
        pwdlen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\ingroup pk_module */"]
    #[doc = " \\brief           Parse a public key in PEM or DER format"]
    #[doc = ""]
    #[doc = " \\param ctx       key to be initialized"]
    #[doc = " \\param key       input buffer"]
    #[doc = " \\param keylen    size of the buffer"]
    #[doc = "                  (including the terminating null byte for PEM data)"]
    #[doc = ""]
    #[doc = " \\note            On entry, ctx must be empty, either freshly initialised"]
    #[doc = "                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a"]
    #[doc = "                  specific key type, check the result with mbedtls_pk_can_do()."]
    #[doc = ""]
    #[doc = " \\note            The key is also checked for correctness."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_public_key(
        ctx: *mut mbedtls_pk_context,
        key: *const cty::c_uchar,
        keylen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\ingroup pk_module */"]
    #[doc = " \\brief           Load and parse a private key"]
    #[doc = ""]
    #[doc = " \\param ctx       key to be initialized"]
    #[doc = " \\param path      filename to read the private key from"]
    #[doc = " \\param password  password to decrypt the file (can be NULL)"]
    #[doc = ""]
    #[doc = " \\note            On entry, ctx must be empty, either freshly initialised"]
    #[doc = "                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a"]
    #[doc = "                  specific key type, check the result with mbedtls_pk_can_do()."]
    #[doc = ""]
    #[doc = " \\note            The key is also checked for correctness."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_keyfile(
        ctx: *mut mbedtls_pk_context,
        path: *const cty::c_char,
        password: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\ingroup pk_module */"]
    #[doc = " \\brief           Load and parse a public key"]
    #[doc = ""]
    #[doc = " \\param ctx       key to be initialized"]
    #[doc = " \\param path      filename to read the public key from"]
    #[doc = ""]
    #[doc = " \\note            On entry, ctx must be empty, either freshly initialised"]
    #[doc = "                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If"]
    #[doc = "                  you need a specific key type, check the result with"]
    #[doc = "                  mbedtls_pk_can_do()."]
    #[doc = ""]
    #[doc = " \\note            The key is also checked for correctness."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_public_keyfile(
        ctx: *mut mbedtls_pk_context,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       private to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    pub fn mbedtls_pk_write_key_der(
        ctx: *mut mbedtls_pk_context,
        buf: *mut cty::c_uchar,
        size: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a SubjectPublicKeyInfo DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       public key to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    pub fn mbedtls_pk_write_pubkey_der(
        ctx: *mut mbedtls_pk_context,
        buf: *mut cty::c_uchar,
        size: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       public key to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    pub fn mbedtls_pk_write_pubkey_pem(
        ctx: *mut mbedtls_pk_context,
        buf: *mut cty::c_uchar,
        size: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       private to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    pub fn mbedtls_pk_write_key_pem(
        ctx: *mut mbedtls_pk_context,
        buf: *mut cty::c_uchar,
        size: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Parse a SubjectPublicKeyInfo DER structure"]
    #[doc = ""]
    #[doc = " \\param p         the position in the ASN.1 data"]
    #[doc = " \\param end       end of the buffer"]
    #[doc = " \\param pk        the key to fill"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK error code"]
    pub fn mbedtls_pk_parse_subpubkey(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        pk: *mut mbedtls_pk_context,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a subjectPublicKey to ASN.1 data"]
    #[doc = "                  Note: function works backwards in data buffer"]
    #[doc = ""]
    #[doc = " \\param p         reference to current position pointer"]
    #[doc = " \\param start     start of the buffer (for bounds-checking)"]
    #[doc = " \\param key       public key to write away"]
    #[doc = ""]
    #[doc = " \\return          the length written or a negative error code"]
    pub fn mbedtls_pk_write_pubkey(
        p: *mut *mut cty::c_uchar,
        start: *mut cty::c_uchar,
        key: *const mbedtls_pk_context,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_pk_load_file(
        path: *const cty::c_char,
        buf: *mut *mut cty::c_uchar,
        n: *mut usize,
    ) -> cty::c_int;
}
#[doc = "< Placeholder to mark the end of cipher ID lists."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NONE: mbedtls_cipher_id_t = 0;
#[doc = "< The identity cipher, treated as a stream cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NULL: mbedtls_cipher_id_t = 1;
#[doc = "< The AES cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_AES: mbedtls_cipher_id_t = 2;
#[doc = "< The DES cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_DES: mbedtls_cipher_id_t = 3;
#[doc = "< The Triple DES cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_3DES: mbedtls_cipher_id_t = 4;
#[doc = "< The Camellia cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CAMELLIA: mbedtls_cipher_id_t = 5;
#[doc = "< The Blowfish cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_BLOWFISH: mbedtls_cipher_id_t = 6;
#[doc = "< The RC4 cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_ARC4: mbedtls_cipher_id_t = 7;
#[doc = "< The Aria cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_ARIA: mbedtls_cipher_id_t = 8;
#[doc = "< The ChaCha20 cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CHACHA20: mbedtls_cipher_id_t = 9;
#[doc = " \\brief     Supported cipher types."]
#[doc = ""]
#[doc = " \\warning   RC4 and DES are considered weak ciphers and their use"]
#[doc = "            constitutes a security risk. Arm recommends considering stronger"]
#[doc = "            ciphers instead."]
pub type mbedtls_cipher_id_t = u32;
#[doc = "< Placeholder to mark the end of cipher-pair lists."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NONE: mbedtls_cipher_type_t = 0;
#[doc = "< The identity stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NULL: mbedtls_cipher_type_t = 1;
#[doc = "< AES cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_ECB: mbedtls_cipher_type_t = 2;
#[doc = "< AES cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_ECB: mbedtls_cipher_type_t = 3;
#[doc = "< AES cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_ECB: mbedtls_cipher_type_t = 4;
#[doc = "< AES cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CBC: mbedtls_cipher_type_t = 5;
#[doc = "< AES cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CBC: mbedtls_cipher_type_t = 6;
#[doc = "< AES cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CBC: mbedtls_cipher_type_t = 7;
#[doc = "< AES cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CFB128: mbedtls_cipher_type_t = 8;
#[doc = "< AES cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CFB128: mbedtls_cipher_type_t = 9;
#[doc = "< AES cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CFB128: mbedtls_cipher_type_t = 10;
#[doc = "< AES cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CTR: mbedtls_cipher_type_t = 11;
#[doc = "< AES cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CTR: mbedtls_cipher_type_t = 12;
#[doc = "< AES cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CTR: mbedtls_cipher_type_t = 13;
#[doc = "< AES cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_GCM: mbedtls_cipher_type_t = 14;
#[doc = "< AES cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_GCM: mbedtls_cipher_type_t = 15;
#[doc = "< AES cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_GCM: mbedtls_cipher_type_t = 16;
#[doc = "< Camellia cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_ECB: mbedtls_cipher_type_t = 17;
#[doc = "< Camellia cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_ECB: mbedtls_cipher_type_t = 18;
#[doc = "< Camellia cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_ECB: mbedtls_cipher_type_t = 19;
#[doc = "< Camellia cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CBC: mbedtls_cipher_type_t = 20;
#[doc = "< Camellia cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CBC: mbedtls_cipher_type_t = 21;
#[doc = "< Camellia cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CBC: mbedtls_cipher_type_t = 22;
#[doc = "< Camellia cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CFB128: mbedtls_cipher_type_t = 23;
#[doc = "< Camellia cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CFB128: mbedtls_cipher_type_t = 24;
#[doc = "< Camellia cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CFB128: mbedtls_cipher_type_t = 25;
#[doc = "< Camellia cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CTR: mbedtls_cipher_type_t = 26;
#[doc = "< Camellia cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CTR: mbedtls_cipher_type_t = 27;
#[doc = "< Camellia cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CTR: mbedtls_cipher_type_t = 28;
#[doc = "< Camellia cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_GCM: mbedtls_cipher_type_t = 29;
#[doc = "< Camellia cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_GCM: mbedtls_cipher_type_t = 30;
#[doc = "< Camellia cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_GCM: mbedtls_cipher_type_t = 31;
#[doc = "< DES cipher with ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_ECB: mbedtls_cipher_type_t = 32;
#[doc = "< DES cipher with CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_CBC: mbedtls_cipher_type_t = 33;
#[doc = "< DES cipher with EDE ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_ECB: mbedtls_cipher_type_t = 34;
#[doc = "< DES cipher with EDE CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_CBC: mbedtls_cipher_type_t = 35;
#[doc = "< DES cipher with EDE3 ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_ECB: mbedtls_cipher_type_t = 36;
#[doc = "< DES cipher with EDE3 CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_CBC: mbedtls_cipher_type_t = 37;
#[doc = "< Blowfish cipher with ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_BLOWFISH_ECB: mbedtls_cipher_type_t = 38;
#[doc = "< Blowfish cipher with CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_BLOWFISH_CBC: mbedtls_cipher_type_t = 39;
#[doc = "< Blowfish cipher with CFB64 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_BLOWFISH_CFB64: mbedtls_cipher_type_t = 40;
#[doc = "< Blowfish cipher with CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_BLOWFISH_CTR: mbedtls_cipher_type_t = 41;
#[doc = "< RC4 cipher with 128-bit mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARC4_128: mbedtls_cipher_type_t = 42;
#[doc = "< AES cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM: mbedtls_cipher_type_t = 43;
#[doc = "< AES cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM: mbedtls_cipher_type_t = 44;
#[doc = "< AES cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM: mbedtls_cipher_type_t = 45;
#[doc = "< Camellia cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM: mbedtls_cipher_type_t = 46;
#[doc = "< Camellia cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM: mbedtls_cipher_type_t = 47;
#[doc = "< Camellia cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM: mbedtls_cipher_type_t = 48;
#[doc = "< Aria cipher with 128-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_ECB: mbedtls_cipher_type_t = 49;
#[doc = "< Aria cipher with 192-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_ECB: mbedtls_cipher_type_t = 50;
#[doc = "< Aria cipher with 256-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_ECB: mbedtls_cipher_type_t = 51;
#[doc = "< Aria cipher with 128-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CBC: mbedtls_cipher_type_t = 52;
#[doc = "< Aria cipher with 192-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CBC: mbedtls_cipher_type_t = 53;
#[doc = "< Aria cipher with 256-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CBC: mbedtls_cipher_type_t = 54;
#[doc = "< Aria cipher with 128-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CFB128: mbedtls_cipher_type_t = 55;
#[doc = "< Aria cipher with 192-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CFB128: mbedtls_cipher_type_t = 56;
#[doc = "< Aria cipher with 256-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CFB128: mbedtls_cipher_type_t = 57;
#[doc = "< Aria cipher with 128-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CTR: mbedtls_cipher_type_t = 58;
#[doc = "< Aria cipher with 192-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CTR: mbedtls_cipher_type_t = 59;
#[doc = "< Aria cipher with 256-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CTR: mbedtls_cipher_type_t = 60;
#[doc = "< Aria cipher with 128-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_GCM: mbedtls_cipher_type_t = 61;
#[doc = "< Aria cipher with 192-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_GCM: mbedtls_cipher_type_t = 62;
#[doc = "< Aria cipher with 256-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_GCM: mbedtls_cipher_type_t = 63;
#[doc = "< Aria cipher with 128-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM: mbedtls_cipher_type_t = 64;
#[doc = "< Aria cipher with 192-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM: mbedtls_cipher_type_t = 65;
#[doc = "< Aria cipher with 256-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM: mbedtls_cipher_type_t = 66;
#[doc = "< AES 128-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_OFB: mbedtls_cipher_type_t = 67;
#[doc = "< AES 192-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_OFB: mbedtls_cipher_type_t = 68;
#[doc = "< AES 256-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_OFB: mbedtls_cipher_type_t = 69;
#[doc = "< AES 128-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_XTS: mbedtls_cipher_type_t = 70;
#[doc = "< AES 256-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_XTS: mbedtls_cipher_type_t = 71;
#[doc = "< ChaCha20 stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20: mbedtls_cipher_type_t = 72;
#[doc = "< ChaCha20-Poly1305 AEAD cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20_POLY1305: mbedtls_cipher_type_t = 73;
#[doc = " \\brief     Supported {cipher type, cipher mode} pairs."]
#[doc = ""]
#[doc = " \\warning   RC4 and DES are considered weak ciphers and their use"]
#[doc = "            constitutes a security risk. Arm recommends considering stronger"]
#[doc = "            ciphers instead."]
pub type mbedtls_cipher_type_t = u32;
#[doc = "< None."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_NONE: mbedtls_cipher_mode_t = 0;
#[doc = "< The ECB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_ECB: mbedtls_cipher_mode_t = 1;
#[doc = "< The CBC cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CBC: mbedtls_cipher_mode_t = 2;
#[doc = "< The CFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CFB: mbedtls_cipher_mode_t = 3;
#[doc = "< The OFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_OFB: mbedtls_cipher_mode_t = 4;
#[doc = "< The CTR cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CTR: mbedtls_cipher_mode_t = 5;
#[doc = "< The GCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_GCM: mbedtls_cipher_mode_t = 6;
#[doc = "< The stream cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_STREAM: mbedtls_cipher_mode_t = 7;
#[doc = "< The CCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM: mbedtls_cipher_mode_t = 8;
#[doc = "< The XTS cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_XTS: mbedtls_cipher_mode_t = 9;
#[doc = "< The ChaCha-Poly cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CHACHAPOLY: mbedtls_cipher_mode_t = 10;
#[doc = " Supported cipher modes."]
pub type mbedtls_cipher_mode_t = u32;
#[doc = "< PKCS7 padding (default)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_PKCS7: mbedtls_cipher_padding_t = 0;
#[doc = "< ISO/IEC 7816-4 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ONE_AND_ZEROS: mbedtls_cipher_padding_t = 1;
#[doc = "< ANSI X.923 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS_AND_LEN: mbedtls_cipher_padding_t = 2;
#[doc = "< Zero padding (not reversible)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS: mbedtls_cipher_padding_t = 3;
#[doc = "< Never pad (full blocks only)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_NONE: mbedtls_cipher_padding_t = 4;
#[doc = " Supported cipher padding types."]
pub type mbedtls_cipher_padding_t = u32;
pub const mbedtls_operation_t_MBEDTLS_OPERATION_NONE: mbedtls_operation_t = -1;
pub const mbedtls_operation_t_MBEDTLS_DECRYPT: mbedtls_operation_t = 0;
pub const mbedtls_operation_t_MBEDTLS_ENCRYPT: mbedtls_operation_t = 1;
#[doc = " Type of operation."]
pub type mbedtls_operation_t = i32;
#[doc = " Undefined key length."]
pub const MBEDTLS_KEY_LENGTH_NONE: _bindgen_ty_3 = 0;
#[doc = " Key length, in bits (including parity), for DES keys."]
pub const MBEDTLS_KEY_LENGTH_DES: _bindgen_ty_3 = 64;
#[doc = " Key length in bits, including parity, for DES in two-key EDE."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE: _bindgen_ty_3 = 128;
#[doc = " Key length in bits, including parity, for DES in three-key EDE."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE3: _bindgen_ty_3 = 192;
pub type _bindgen_ty_3 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_base_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cmac_context_t {
    _unused: [u8; 0],
}
#[doc = " Cipher information. Allows calling cipher functions"]
#[doc = " in a generic way."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_info_t {
    #[doc = " Full cipher identifier. For example,"]
    #[doc = " MBEDTLS_CIPHER_AES_256_CBC."]
    pub type_: mbedtls_cipher_type_t,
    #[doc = " The cipher mode. For example, MBEDTLS_MODE_CBC."]
    pub mode: mbedtls_cipher_mode_t,
    #[doc = " The cipher key length, in bits. This is the"]
    #[doc = " default length for variable sized ciphers."]
    #[doc = " Includes parity bits for ciphers like DES."]
    pub key_bitlen: cty::c_uint,
    #[doc = " Name of the cipher."]
    pub name: *const cty::c_char,
    #[doc = " IV or nonce size, in Bytes."]
    #[doc = " For ciphers that accept variable IV sizes,"]
    #[doc = " this is the recommended size."]
    pub iv_size: cty::c_uint,
    #[doc = " Bitflag comprised of MBEDTLS_CIPHER_VARIABLE_IV_LEN and"]
    #[doc = "  MBEDTLS_CIPHER_VARIABLE_KEY_LEN indicating whether the"]
    #[doc = "  cipher supports variable IV or variable key sizes, respectively."]
    pub flags: cty::c_int,
    #[doc = " The block size, in Bytes."]
    pub block_size: cty::c_uint,
    #[doc = " Struct for base cipher information and functions."]
    pub base: *const mbedtls_cipher_base_t,
}
#[doc = " Generic cipher context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_context_t {
    #[doc = " Information about the associated cipher."]
    pub cipher_info: *const mbedtls_cipher_info_t,
    #[doc = " Key length to use."]
    pub key_bitlen: cty::c_int,
    #[doc = " Operation that the key of the context has been"]
    #[doc = " initialized for."]
    pub operation: mbedtls_operation_t,
    #[doc = " Padding functions to use, if relevant for"]
    #[doc = " the specific cipher mode."]
    pub add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut cty::c_uchar, olen: usize, data_len: usize),
    >,
    pub get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut cty::c_uchar,
            ilen: usize,
            data_len: *mut usize,
        ) -> cty::c_int,
    >,
    #[doc = " Buffer for input that has not been processed yet."]
    pub unprocessed_data: [cty::c_uchar; 16usize],
    #[doc = " Number of Bytes that have not been processed yet."]
    pub unprocessed_len: usize,
    #[doc = " Current IV or NONCE_COUNTER for CTR-mode, data unit (or sector) number"]
    #[doc = " for XTS-mode."]
    pub iv: [cty::c_uchar; 16usize],
    #[doc = " IV size in Bytes, for ciphers with variable-length IVs."]
    pub iv_size: usize,
    #[doc = " The cipher-specific context."]
    pub cipher_ctx: *mut cty::c_void,
}
extern "C" {
    #[doc = " \\brief This function retrieves the list of ciphers supported by the generic"]
    #[doc = " cipher module."]
    #[doc = ""]
    #[doc = " \\return      A statically-allocated array of ciphers. The last entry"]
    #[doc = "              is zero."]
    pub fn mbedtls_cipher_list() -> *const cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information"]
    #[doc = "                      structure associated with the given cipher name."]
    #[doc = ""]
    #[doc = " \\param cipher_name   Name of the cipher to search for."]
    #[doc = ""]
    #[doc = " \\return              The cipher information structure associated with the"]
    #[doc = "                      given \\p cipher_name."]
    #[doc = " \\return              NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_string(
        cipher_name: *const cty::c_char,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information"]
    #[doc = "                      structure associated with the given cipher type."]
    #[doc = ""]
    #[doc = " \\param cipher_type   Type of the cipher to search for."]
    #[doc = ""]
    #[doc = " \\return              The cipher information structure associated with the"]
    #[doc = "                      given \\p cipher_type."]
    #[doc = " \\return              NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_type(
        cipher_type: mbedtls_cipher_type_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information"]
    #[doc = "                      structure associated with the given cipher ID,"]
    #[doc = "                      key size and mode."]
    #[doc = ""]
    #[doc = " \\param cipher_id     The ID of the cipher to search for. For example,"]
    #[doc = "                      #MBEDTLS_CIPHER_ID_AES."]
    #[doc = " \\param key_bitlen    The length of the key in bits."]
    #[doc = " \\param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC."]
    #[doc = ""]
    #[doc = " \\return              The cipher information structure associated with the"]
    #[doc = "                      given \\p cipher_id."]
    #[doc = " \\return              NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_values(
        cipher_id: mbedtls_cipher_id_t,
        key_bitlen: cty::c_int,
        mode: mbedtls_cipher_mode_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function initializes a \\p cipher_context as NONE."]
    pub fn mbedtls_cipher_init(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function frees and clears the cipher-specific"]
    #[doc = "                      context of \\p ctx. Freeing \\p ctx itself remains the"]
    #[doc = "                      responsibility of the caller."]
    pub fn mbedtls_cipher_free(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function initializes and fills the cipher-context"]
    #[doc = "                      structure with the appropriate values. It also clears"]
    #[doc = "                      the structure."]
    #[doc = ""]
    #[doc = " \\param ctx           The context to initialize. May not be NULL."]
    #[doc = " \\param cipher_info   The cipher to use."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the"]
    #[doc = "                      cipher-specific context fails."]
    #[doc = ""]
    #[doc = " \\internal Currently, the function also clears the structure."]
    #[doc = " In future versions, the caller will be required to call"]
    #[doc = " mbedtls_cipher_init() on the structure first."]
    pub fn mbedtls_cipher_setup(
        ctx: *mut mbedtls_cipher_context_t,
        cipher_info: *const mbedtls_cipher_info_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the key to use with the given context."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. May not be NULL. Must have"]
    #[doc = "                      been initialized using mbedtls_cipher_info_from_type()"]
    #[doc = "                      or mbedtls_cipher_info_from_string()."]
    #[doc = " \\param key           The key to use."]
    #[doc = " \\param key_bitlen    The key length to use, in bits."]
    #[doc = " \\param operation     The operation that the key will be used for:"]
    #[doc = "                      #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_setkey(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const cty::c_uchar,
        key_bitlen: cty::c_int,
        operation: mbedtls_operation_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the padding mode, for cipher modes"]
    #[doc = "                      that use padding."]
    #[doc = ""]
    #[doc = "                      The default passing mode is PKCS7 padding."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context."]
    #[doc = " \\param mode          The padding mode."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE"]
    #[doc = "                      if the selected padding mode is not supported."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode"]
    #[doc = "                      does not support padding."]
    pub fn mbedtls_cipher_set_padding_mode(
        ctx: *mut mbedtls_cipher_context_t,
        mode: mbedtls_cipher_padding_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the initialization vector (IV)"]
    #[doc = "                  or nonce."]
    #[doc = ""]
    #[doc = " \\note            Some ciphers do not use IVs nor nonce. For these"]
    #[doc = "                  ciphers, this function has no effect."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic cipher context."]
    #[doc = " \\param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers."]
    #[doc = " \\param iv_len    The IV length for ciphers with variable-size IV."]
    #[doc = "                  This parameter is discarded by ciphers with fixed-size IV."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                  parameter-verification failure."]
    pub fn mbedtls_cipher_set_iv(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const cty::c_uchar,
        iv_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief         This function resets the cipher state."]
    #[doc = ""]
    #[doc = " \\param ctx     The generic cipher context."]
    #[doc = ""]
    #[doc = " \\return        \\c 0 on success."]
    #[doc = " \\return        #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                parameter-verification failure."]
    pub fn mbedtls_cipher_reset(ctx: *mut mbedtls_cipher_context_t) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function adds additional data for AEAD ciphers."]
    #[doc = "                      Currently supported with GCM and ChaCha20+Poly1305."]
    #[doc = "                      Must be called exactly once, after mbedtls_cipher_reset()."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context."]
    #[doc = " \\param ad            The additional data to use."]
    #[doc = " \\param ad_len        the Length of \\p ad."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_update_ad(
        ctx: *mut mbedtls_cipher_context_t,
        ad: *const cty::c_uchar,
        ad_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher update function. It encrypts or"]
    #[doc = "                      decrypts using the given cipher context. Writes as"]
    #[doc = "                      many block-sized blocks of data as possible to output."]
    #[doc = "                      Any data that cannot be written immediately is either"]
    #[doc = "                      added to the next block, or flushed when"]
    #[doc = "                      mbedtls_cipher_finish() is called."]
    #[doc = "                      Exception: For MBEDTLS_MODE_ECB, expects a single block"]
    #[doc = "                      in size. For example, 16 Bytes for AES."]
    #[doc = ""]
    #[doc = " \\note                If the underlying cipher is used in GCM mode, all calls"]
    #[doc = "                      to this function, except for the last one before"]
    #[doc = "                      mbedtls_cipher_finish(), must have \\p ilen as a"]
    #[doc = "                      multiple of the block size of the cipher."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context."]
    #[doc = " \\param input         The buffer holding the input data."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the output data. Must be able to hold at"]
    #[doc = "                      least \\p ilen + block_size. Must not be the same buffer"]
    #[doc = "                      as input."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an"]
    #[doc = "                      unsupported mode for a cipher."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
        olen: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher finalization function. If data still"]
    #[doc = "                      needs to be flushed from an incomplete block, the data"]
    #[doc = "                      contained in it is padded to the size of"]
    #[doc = "                      the last block, and written to the \\p output buffer."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context."]
    #[doc = " \\param output        The buffer to write data to. Needs block_size available."]
    #[doc = " \\param olen          The length of the data written to the \\p output buffer."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption"]
    #[doc = "                      expecting a full block but not receiving one."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding"]
    #[doc = "                      while decrypting."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut cty::c_uchar,
        olen: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function writes a tag for AEAD ciphers."]
    #[doc = "                      Currently supported with GCM and ChaCha20+Poly1305."]
    #[doc = "                      Must be called after mbedtls_cipher_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context."]
    #[doc = " \\param tag           The buffer to write the tag to."]
    #[doc = " \\param tag_len       The length of the tag to write."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_write_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *mut cty::c_uchar,
        tag_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function checks the tag for AEAD ciphers."]
    #[doc = "                      Currently supported with GCM and ChaCha20+Poly1305."]
    #[doc = "                      Must be called after mbedtls_cipher_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context."]
    #[doc = " \\param tag           The buffer holding the tag."]
    #[doc = " \\param tag_len       The length of the tag to check."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_check_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *const cty::c_uchar,
        tag_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic all-in-one encryption/decryption function,"]
    #[doc = "                      for all ciphers except AEAD constructs."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context."]
    #[doc = " \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers."]
    #[doc = " \\param iv_len        The IV length for ciphers with variable-size IV."]
    #[doc = "                      This parameter is discarded by ciphers with fixed-size"]
    #[doc = "                      IV."]
    #[doc = " \\param input         The buffer holding the input data."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the output data. Must be able to hold at"]
    #[doc = "                      least \\p ilen + block_size. Must not be the same buffer"]
    #[doc = "                      as input."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written."]
    #[doc = ""]
    #[doc = " \\note                Some ciphers do not use IVs nor nonce. For these"]
    #[doc = "                      ciphers, use \\p iv = NULL and \\p iv_len = 0."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption"]
    #[doc = "                      expecting a full block but not receiving one."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding"]
    #[doc = "                      while decrypting."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_crypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const cty::c_uchar,
        iv_len: usize,
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
        olen: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic autenticated encryption (AEAD) function."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context."]
    #[doc = " \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers."]
    #[doc = " \\param iv_len        The IV length for ciphers with variable-size IV."]
    #[doc = "                      This parameter is discarded by ciphers with fixed-size IV."]
    #[doc = " \\param ad            The additional data to authenticate."]
    #[doc = " \\param ad_len        The length of \\p ad."]
    #[doc = " \\param input         The buffer holding the input data."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the output data."]
    #[doc = "                      Must be able to hold at least \\p ilen."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written."]
    #[doc = " \\param tag           The buffer for the authentication tag."]
    #[doc = " \\param tag_len       The desired length of the authentication tag."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_auth_encrypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const cty::c_uchar,
        iv_len: usize,
        ad: *const cty::c_uchar,
        ad_len: usize,
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
        olen: *mut usize,
        tag: *mut cty::c_uchar,
        tag_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic autenticated decryption (AEAD) function."]
    #[doc = ""]
    #[doc = " \\note                If the data is not authentic, then the output buffer"]
    #[doc = "                      is zeroed out to prevent the unauthentic plaintext being"]
    #[doc = "                      used, making this interface safer."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context."]
    #[doc = " \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers."]
    #[doc = " \\param iv_len        The IV length for ciphers with variable-size IV."]
    #[doc = "                      This parameter is discarded by ciphers with fixed-size IV."]
    #[doc = " \\param ad            The additional data to be authenticated."]
    #[doc = " \\param ad_len        The length of \\p ad."]
    #[doc = " \\param input         The buffer holding the input data."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the output data."]
    #[doc = "                      Must be able to hold at least \\p ilen."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written."]
    #[doc = " \\param tag           The buffer holding the authentication tag."]
    #[doc = " \\param tag_len       The length of the authentication tag."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_auth_decrypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const cty::c_uchar,
        iv_len: usize,
        ad: *const cty::c_uchar,
        ad_len: usize,
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
        olen: *mut usize,
        tag: *const cty::c_uchar,
        tag_len: usize,
    ) -> cty::c_int;
}
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_NONE: mbedtls_key_exchange_type_t = 0;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA: mbedtls_key_exchange_type_t = 1;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_RSA: mbedtls_key_exchange_type_t = 2;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: mbedtls_key_exchange_type_t =
    3;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
    mbedtls_key_exchange_type_t = 4;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_PSK: mbedtls_key_exchange_type_t = 5;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_PSK: mbedtls_key_exchange_type_t = 6;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA_PSK: mbedtls_key_exchange_type_t = 7;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_PSK: mbedtls_key_exchange_type_t =
    8;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: mbedtls_key_exchange_type_t =
    9;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: mbedtls_key_exchange_type_t =
    10;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECJPAKE: mbedtls_key_exchange_type_t =
    11;
pub type mbedtls_key_exchange_type_t = u32;
#[doc = " \\brief   This structure is used for storing ciphersuite information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_ciphersuite_t {
    pub id: cty::c_int,
    pub name: *const cty::c_char,
    pub cipher: mbedtls_cipher_type_t,
    pub mac: mbedtls_md_type_t,
    pub key_exchange: mbedtls_key_exchange_type_t,
    pub min_major_ver: cty::c_int,
    pub min_minor_ver: cty::c_int,
    pub max_major_ver: cty::c_int,
    pub max_minor_ver: cty::c_int,
    pub flags: cty::c_uchar,
}
extern "C" {
    pub fn mbedtls_ssl_list_ciphersuites() -> *const cty::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_string(
        ciphersuite_name: *const cty::c_char,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_id(
        ciphersuite_id: cty::c_int,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_pk_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_ec(info: *const mbedtls_ssl_ciphersuite_t) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_psk(info: *const mbedtls_ssl_ciphersuite_t) -> cty::c_int;
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_buf {
    #[doc = "< ASN1 type, e.g. MBEDTLS_ASN1_UTF8_STRING."]
    pub tag: cty::c_int,
    #[doc = "< ASN1 length, in octets."]
    pub len: usize,
    #[doc = "< ASN1 data, e.g. in ASCII."]
    pub p: *mut cty::c_uchar,
}
#[doc = " Container for ASN1 bit strings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_bitstring {
    #[doc = "< ASN1 length, in octets."]
    pub len: usize,
    #[doc = "< Number of unused bits at the end of the string"]
    pub unused_bits: cty::c_uchar,
    #[doc = "< Raw ASN1 data for the bit string"]
    pub p: *mut cty::c_uchar,
}
#[doc = " Container for a sequence of ASN.1 items"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_sequence {
    #[doc = "< Buffer containing the given ASN.1 item."]
    pub buf: mbedtls_asn1_buf,
    #[doc = "< The next entry in the sequence."]
    pub next: *mut mbedtls_asn1_sequence,
}
#[doc = " Container for a sequence or list of 'named' ASN.1 data items"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_named_data {
    #[doc = "< The object identifier."]
    pub oid: mbedtls_asn1_buf,
    #[doc = "< The named value."]
    pub val: mbedtls_asn1_buf,
    #[doc = "< The next entry in the sequence."]
    pub next: *mut mbedtls_asn1_named_data,
    #[doc = "< Merge next item into the current one?"]
    pub next_merged: cty::c_uchar,
}
extern "C" {
    #[doc = " \\brief       Get the length of an ASN.1 element."]
    #[doc = "              Updates the pointer to immediately behind the length."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param len   The variable that will receive the value"]
    #[doc = ""]
    #[doc = " \\return      0 if successful, MBEDTLS_ERR_ASN1_OUT_OF_DATA on reaching"]
    #[doc = "              end of data, MBEDTLS_ERR_ASN1_INVALID_LENGTH if length is"]
    #[doc = "              unparseable."]
    pub fn mbedtls_asn1_get_len(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        len: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Get the tag and length of the tag. Check for the requested tag."]
    #[doc = "              Updates the pointer to immediately behind the tag and length."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param len   The variable that will receive the length"]
    #[doc = " \\param tag   The expected tag"]
    #[doc = ""]
    #[doc = " \\return      0 if successful, MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if tag did"]
    #[doc = "              not match requested tag, or another specific ASN.1 error code."]
    pub fn mbedtls_asn1_get_tag(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        len: *mut usize,
        tag: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a boolean ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param val   The variable that will receive the value"]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 error code."]
    pub fn mbedtls_asn1_get_bool(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        val: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an integer ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param val   The variable that will receive the value"]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 error code."]
    pub fn mbedtls_asn1_get_int(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        val: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param bs    The variable that will receive the value"]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 error code."]
    pub fn mbedtls_asn1_get_bitstring(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        bs: *mut mbedtls_asn1_bitstring,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag without unused bits and its"]
    #[doc = "              value."]
    #[doc = "              Updates the pointer to the beginning of the bit/octet string."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param len   Length of the actual bit/octect string in bytes"]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 error code."]
    pub fn mbedtls_asn1_get_bitstring_null(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        len: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Parses and splits an ASN.1 \"SEQUENCE OF <tag>\""]
    #[doc = "              Updated the pointer to immediately behind the full sequence tag."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param cur   First variable in the chain to fill"]
    #[doc = " \\param tag   Type of sequence"]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 error code."]
    pub fn mbedtls_asn1_get_sequence_of(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        cur: *mut mbedtls_asn1_sequence,
        tag: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a MPI value from an integer ASN.1 tag."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param X     The MPI that will receive the value"]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 or MPI error code."]
    pub fn mbedtls_asn1_get_mpi(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        X: *mut mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence."]
    #[doc = "              Updates the pointer to immediately behind the full"]
    #[doc = "              AlgorithmIdentifier."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param alg   The buffer to receive the OID"]
    #[doc = " \\param params The buffer to receive the params (if any)"]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 or MPI error code."]
    pub fn mbedtls_asn1_get_alg(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        alg: *mut mbedtls_asn1_buf,
        params: *mut mbedtls_asn1_buf,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no"]
    #[doc = "              params."]
    #[doc = "              Updates the pointer to immediately behind the full"]
    #[doc = "              AlgorithmIdentifier."]
    #[doc = ""]
    #[doc = " \\param p     The position in the ASN.1 data"]
    #[doc = " \\param end   End of data"]
    #[doc = " \\param alg   The buffer to receive the OID"]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 or MPI error code."]
    pub fn mbedtls_asn1_get_alg_null(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        alg: *mut mbedtls_asn1_buf,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       Find a specific named_data entry in a sequence or list based on"]
    #[doc = "              the OID."]
    #[doc = ""]
    #[doc = " \\param list  The list to seek through"]
    #[doc = " \\param oid   The OID to look for"]
    #[doc = " \\param len   Size of the OID"]
    #[doc = ""]
    #[doc = " \\return      NULL if not found, or a pointer to the existing entry."]
    pub fn mbedtls_asn1_find_named_data(
        list: *mut mbedtls_asn1_named_data,
        oid: *const cty::c_char,
        len: usize,
    ) -> *mut mbedtls_asn1_named_data;
}
extern "C" {
    #[doc = " \\brief       Free a mbedtls_asn1_named_data entry"]
    #[doc = ""]
    #[doc = " \\param entry The named data entry to free"]
    pub fn mbedtls_asn1_free_named_data(entry: *mut mbedtls_asn1_named_data);
}
extern "C" {
    #[doc = " \\brief       Free all entries in a mbedtls_asn1_named_data list"]
    #[doc = "              Head will be set to NULL"]
    #[doc = ""]
    #[doc = " \\param head  Pointer to the head of the list of named data entries to free"]
    pub fn mbedtls_asn1_free_named_data_list(head: *mut *mut mbedtls_asn1_named_data);
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
pub type mbedtls_x509_buf = mbedtls_asn1_buf;
#[doc = " Container for ASN1 bit strings."]
pub type mbedtls_x509_bitstring = mbedtls_asn1_bitstring;
#[doc = " Container for ASN1 named information objects."]
#[doc = " It allows for Relative Distinguished Names (e.g. cn=localhost,ou=code,etc.)."]
pub type mbedtls_x509_name = mbedtls_asn1_named_data;
#[doc = " Container for a sequence of ASN.1 items"]
pub type mbedtls_x509_sequence = mbedtls_asn1_sequence;
#[doc = " Container for date and time (precision in seconds)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_time {
    #[doc = "< Date."]
    pub year: cty::c_int,
    #[doc = "< Date."]
    pub mon: cty::c_int,
    #[doc = "< Date."]
    pub day: cty::c_int,
    #[doc = "< Time."]
    pub hour: cty::c_int,
    #[doc = "< Time."]
    pub min: cty::c_int,
    #[doc = "< Time."]
    pub sec: cty::c_int,
}
extern "C" {
    #[doc = " \\brief          Store the certificate DN in printable form into buf;"]
    #[doc = "                 no more than size characters will be written."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param dn       The X509 name to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_dn_gets(
        buf: *mut cty::c_char,
        size: usize,
        dn: *const mbedtls_x509_name,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Store the certificate serial in printable form into buf;"]
    #[doc = "                 no more than size characters will be written."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param serial   The X509 serial to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_serial_gets(
        buf: *mut cty::c_char,
        size: usize,
        serial: *const mbedtls_x509_buf,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time"]
    #[doc = "                 and tell if it's in the past."]
    #[doc = ""]
    #[doc = " \\note           Intended usage is \"if( is_past( valid_to ) ) ERROR\"."]
    #[doc = "                 Hence the return value of 1 if on internal errors."]
    #[doc = ""]
    #[doc = " \\param to       mbedtls_x509_time to check"]
    #[doc = ""]
    #[doc = " \\return         1 if the given time is in the past or an error occured,"]
    #[doc = "                 0 otherwise."]
    pub fn mbedtls_x509_time_is_past(to: *const mbedtls_x509_time) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time"]
    #[doc = "                 and tell if it's in the future."]
    #[doc = ""]
    #[doc = " \\note           Intended usage is \"if( is_future( valid_from ) ) ERROR\"."]
    #[doc = "                 Hence the return value of 1 if on internal errors."]
    #[doc = ""]
    #[doc = " \\param from     mbedtls_x509_time to check"]
    #[doc = ""]
    #[doc = " \\return         1 if the given time is in the future or an error occured,"]
    #[doc = "                 0 otherwise."]
    pub fn mbedtls_x509_time_is_future(from: *const mbedtls_x509_time) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    pub fn mbedtls_x509_self_test(verbose: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_name(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        cur: *mut mbedtls_x509_name,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg_null(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        alg: *mut mbedtls_x509_buf,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        alg: *mut mbedtls_x509_buf,
        params: *mut mbedtls_x509_buf,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_rsassa_pss_params(
        params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        mgf_md: *mut mbedtls_md_type_t,
        salt_len: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        sig: *mut mbedtls_x509_buf,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig_alg(
        sig_oid: *const mbedtls_x509_buf,
        sig_params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        pk_alg: *mut mbedtls_pk_type_t,
        sig_opts: *mut *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_time(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        t: *mut mbedtls_x509_time,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_serial(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        serial: *mut mbedtls_x509_buf,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_ext(
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
        ext: *mut mbedtls_x509_buf,
        tag: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_sig_alg_gets(
        buf: *mut cty::c_char,
        size: usize,
        sig_oid: *const mbedtls_x509_buf,
        pk_alg: mbedtls_pk_type_t,
        md_alg: mbedtls_md_type_t,
        sig_opts: *const cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_key_size_helper(
        buf: *mut cty::c_char,
        buf_size: usize,
        name: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_string_to_names(
        head: *mut *mut mbedtls_asn1_named_data,
        name: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_set_extension(
        head: *mut *mut mbedtls_asn1_named_data,
        oid: *const cty::c_char,
        oid_len: usize,
        critical: cty::c_int,
        val: *const cty::c_uchar,
        val_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_extensions(
        p: *mut *mut cty::c_uchar,
        start: *mut cty::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_names(
        p: *mut *mut cty::c_uchar,
        start: *mut cty::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_sig(
        p: *mut *mut cty::c_uchar,
        start: *mut cty::c_uchar,
        oid: *const cty::c_char,
        oid_len: usize,
        sig: *mut cty::c_uchar,
        size: usize,
    ) -> cty::c_int;
}
#[doc = " Certificate revocation list entry."]
#[doc = " Contains the CA-specific serial numbers and revocation dates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crl_entry {
    pub raw: mbedtls_x509_buf,
    pub serial: mbedtls_x509_buf,
    pub revocation_date: mbedtls_x509_time,
    pub entry_ext: mbedtls_x509_buf,
    pub next: *mut mbedtls_x509_crl_entry,
}
#[doc = " Certificate revocation list structure."]
#[doc = " Every CRL may have multiple entries."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crl {
    #[doc = "< The raw certificate data (DER)."]
    pub raw: mbedtls_x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: mbedtls_x509_buf,
    #[doc = "< CRL version (1=v1, 2=v2)"]
    pub version: cty::c_int,
    #[doc = "< CRL signature type identifier"]
    pub sig_oid: mbedtls_x509_buf,
    #[doc = "< The raw issuer data (DER)."]
    pub issuer_raw: mbedtls_x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: mbedtls_x509_name,
    pub this_update: mbedtls_x509_time,
    pub next_update: mbedtls_x509_time,
    #[doc = "< The CRL entries containing the certificate revocation times for this CA."]
    pub entry: mbedtls_x509_crl_entry,
    pub crl_ext: mbedtls_x509_buf,
    pub sig_oid2: mbedtls_x509_buf,
    pub sig: mbedtls_x509_buf,
    #[doc = "< Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256"]
    pub sig_md: mbedtls_md_type_t,
    #[doc = "< Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA"]
    pub sig_pk: mbedtls_pk_type_t,
    #[doc = "< Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS"]
    pub sig_opts: *mut cty::c_void,
    pub next: *mut mbedtls_x509_crl,
}
extern "C" {
    #[doc = " \\brief          Parse a DER-encoded CRL and append it to the chained list"]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param buf      buffer holding the CRL data in DER format"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = "                 (including the terminating null byte for PEM data)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse_der(
        chain: *mut mbedtls_x509_crl,
        buf: *const cty::c_uchar,
        buflen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one or more CRLs and append them to the chained list"]
    #[doc = ""]
    #[doc = " \\note           Mutliple CRLs are accepted only if using PEM format"]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param buf      buffer holding the CRL data in PEM or DER format"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = "                 (including the terminating null byte for PEM data)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse(
        chain: *mut mbedtls_x509_crl,
        buf: *const cty::c_uchar,
        buflen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Load one or more CRLs and append them to the chained list"]
    #[doc = ""]
    #[doc = " \\note           Mutliple CRLs are accepted only if using PEM format"]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param path     filename to read the CRLs from (in PEM or DER encoding)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse_file(
        chain: *mut mbedtls_x509_crl,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the CRL."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param crl      The X509 CRL to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crl_info(
        buf: *mut cty::c_char,
        size: usize,
        prefix: *const cty::c_char,
        crl: *const mbedtls_x509_crl,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a CRL (chain)"]
    #[doc = ""]
    #[doc = " \\param crl      CRL chain to initialize"]
    pub fn mbedtls_x509_crl_init(crl: *mut mbedtls_x509_crl);
}
extern "C" {
    #[doc = " \\brief          Unallocate all CRL data"]
    #[doc = ""]
    #[doc = " \\param crl      CRL chain to free"]
    pub fn mbedtls_x509_crl_free(crl: *mut mbedtls_x509_crl);
}
#[doc = " Container for an X.509 certificate. The certificate may be chained."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt {
    #[doc = "< The raw certificate data (DER)."]
    pub raw: mbedtls_x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: mbedtls_x509_buf,
    #[doc = "< The X.509 version. (1=v1, 2=v2, 3=v3)"]
    pub version: cty::c_int,
    #[doc = "< Unique id for certificate issued by a specific CA."]
    pub serial: mbedtls_x509_buf,
    #[doc = "< Signature algorithm, e.g. sha1RSA"]
    pub sig_oid: mbedtls_x509_buf,
    #[doc = "< The raw issuer data (DER). Used for quick comparison."]
    pub issuer_raw: mbedtls_x509_buf,
    #[doc = "< The raw subject data (DER). Used for quick comparison."]
    pub subject_raw: mbedtls_x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: mbedtls_x509_name,
    #[doc = "< The parsed subject data (named information object)."]
    pub subject: mbedtls_x509_name,
    #[doc = "< Start time of certificate validity."]
    pub valid_from: mbedtls_x509_time,
    #[doc = "< End time of certificate validity."]
    pub valid_to: mbedtls_x509_time,
    #[doc = "< Container for the public key context."]
    pub pk: mbedtls_pk_context,
    #[doc = "< Optional X.509 v2/v3 issuer unique identifier."]
    pub issuer_id: mbedtls_x509_buf,
    #[doc = "< Optional X.509 v2/v3 subject unique identifier."]
    pub subject_id: mbedtls_x509_buf,
    #[doc = "< Optional X.509 v3 extensions."]
    pub v3_ext: mbedtls_x509_buf,
    #[doc = "< Optional list of Subject Alternative Names (Only dNSName supported)."]
    pub subject_alt_names: mbedtls_x509_sequence,
    #[doc = "< Bit string containing detected and parsed extensions"]
    pub ext_types: cty::c_int,
    #[doc = "< Optional Basic Constraint extension value: 1 if this certificate belongs to a CA, 0 otherwise."]
    pub ca_istrue: cty::c_int,
    #[doc = "< Optional Basic Constraint extension value: The maximum path length to the root certificate. Path length is 1 higher than RFC 5280 'meaning', so 1+"]
    pub max_pathlen: cty::c_int,
    #[doc = "< Optional key usage extension value: See the values in x509.h"]
    pub key_usage: cty::c_uint,
    #[doc = "< Optional list of extended key usage OIDs."]
    pub ext_key_usage: mbedtls_x509_sequence,
    #[doc = "< Optional Netscape certificate type extension value: See the values in x509.h"]
    pub ns_cert_type: cty::c_uchar,
    #[doc = "< Signature: hash of the tbs part signed with the private key."]
    pub sig: mbedtls_x509_buf,
    #[doc = "< Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256"]
    pub sig_md: mbedtls_md_type_t,
    #[doc = "< Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA"]
    pub sig_pk: mbedtls_pk_type_t,
    #[doc = "< Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS"]
    pub sig_opts: *mut cty::c_void,
    #[doc = "< Next certificate in the CA-chain."]
    pub next: *mut mbedtls_x509_crt,
}
#[doc = " Security profile for certificate verification."]
#[doc = ""]
#[doc = " All lists are bitfields, built by ORing flags from MBEDTLS_X509_ID_FLAG()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt_profile {
    #[doc = "< MDs for signatures"]
    pub allowed_mds: u32,
    #[doc = "< PK algs for signatures"]
    pub allowed_pks: u32,
    #[doc = "< Elliptic curves for ECDSA"]
    pub allowed_curves: u32,
    #[doc = "< Minimum size for RSA keys"]
    pub rsa_min_bitlen: u32,
}
#[doc = " Container for writing a certificate (CRT)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509write_cert {
    pub version: cty::c_int,
    pub serial: mbedtls_mpi,
    pub subject_key: *mut mbedtls_pk_context,
    pub issuer_key: *mut mbedtls_pk_context,
    pub subject: *mut mbedtls_asn1_named_data,
    pub issuer: *mut mbedtls_asn1_named_data,
    pub md_alg: mbedtls_md_type_t,
    pub not_before: [cty::c_char; 16usize],
    pub not_after: [cty::c_char; 16usize],
    pub extensions: *mut mbedtls_asn1_named_data,
}
extern "C" {
    pub static mbedtls_x509_crt_profile_default: mbedtls_x509_crt_profile;
}
extern "C" {
    pub static mbedtls_x509_crt_profile_next: mbedtls_x509_crt_profile;
}
extern "C" {
    pub static mbedtls_x509_crt_profile_suiteb: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " \\brief          Parse a single DER formatted certificate and add it"]
    #[doc = "                 to the chained list."]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param buf      buffer holding the certificate DER data"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crt_parse_der(
        chain: *mut mbedtls_x509_crt,
        buf: *const cty::c_uchar,
        buflen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one or more certificates and add them"]
    #[doc = "                 to the chained list. Parses permissively. If some"]
    #[doc = "                 certificates can be parsed, the result is the number"]
    #[doc = "                 of failed certificates it encountered. If none complete"]
    #[doc = "                 correctly, the first error is returned."]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param buf      buffer holding the certificate data in PEM or DER format"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = "                 (including the terminating null byte for PEM data)"]
    #[doc = ""]
    #[doc = " \\return         0 if all certificates parsed successfully, a positive number"]
    #[doc = "                 if partly successful or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crt_parse(
        chain: *mut mbedtls_x509_crt,
        buf: *const cty::c_uchar,
        buflen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Load one or more certificates and add them"]
    #[doc = "                 to the chained list. Parses permissively. If some"]
    #[doc = "                 certificates can be parsed, the result is the number"]
    #[doc = "                 of failed certificates it encountered. If none complete"]
    #[doc = "                 correctly, the first error is returned."]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param path     filename to read the certificates from"]
    #[doc = ""]
    #[doc = " \\return         0 if all certificates parsed successfully, a positive number"]
    #[doc = "                 if partly successful or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crt_parse_file(
        chain: *mut mbedtls_x509_crt,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Load one or more certificate files from a path and add them"]
    #[doc = "                 to the chained list. Parses permissively. If some"]
    #[doc = "                 certificates can be parsed, the result is the number"]
    #[doc = "                 of failed certificates it encountered. If none complete"]
    #[doc = "                 correctly, the first error is returned."]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param path     directory / folder to read the certificate files from"]
    #[doc = ""]
    #[doc = " \\return         0 if all certificates parsed successfully, a positive number"]
    #[doc = "                 if partly successful or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crt_parse_path(
        chain: *mut mbedtls_x509_crt,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the"]
    #[doc = "                 certificate."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param crt      The X509 certificate to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crt_info(
        buf: *mut cty::c_char,
        size: usize,
        prefix: *const cty::c_char,
        crt: *const mbedtls_x509_crt,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the"]
    #[doc = "                 verification status of a certificate."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param flags    Verification flags created by mbedtls_x509_crt_verify()"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crt_verify_info(
        buf: *mut cty::c_char,
        size: usize,
        prefix: *const cty::c_char,
        flags: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify the certificate signature"]
    #[doc = ""]
    #[doc = "                 The verify callback is a user-supplied callback that"]
    #[doc = "                 can clear / modify / add flags for a certificate. If set,"]
    #[doc = "                 the verification callback is called for each"]
    #[doc = "                 certificate in the chain (from the trust-ca down to the"]
    #[doc = "                 presented crt). The parameters for the callback are:"]
    #[doc = "                 (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,"]
    #[doc = "                 int *flags). With the flags representing current flags for"]
    #[doc = "                 that specific certificate and the certificate depth from"]
    #[doc = "                 the bottom (Peer cert depth = 0)."]
    #[doc = ""]
    #[doc = "                 All flags left after returning from the callback"]
    #[doc = "                 are also returned to the application. The function should"]
    #[doc = "                 return 0 for anything (including invalid certificates)"]
    #[doc = "                 other than fatal error, as a non-zero return code"]
    #[doc = "                 immediately aborts the verification process. For fatal"]
    #[doc = "                 errors, a specific error code should be used (different"]
    #[doc = "                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not"]
    #[doc = "                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR"]
    #[doc = "                 can be used if no better code is available."]
    #[doc = ""]
    #[doc = " \\note           In case verification failed, the results can be displayed"]
    #[doc = "                 using \\c mbedtls_x509_crt_verify_info()"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_x509_crt_verify_with_profile() with the"]
    #[doc = "                 default security profile."]
    #[doc = ""]
    #[doc = " \\note           It is your responsibility to provide up-to-date CRLs for"]
    #[doc = "                 all trusted CAs. If no CRL is provided for the CA that was"]
    #[doc = "                 used to sign the certificate, CRL verification is skipped"]
    #[doc = "                 silently, that is *without* setting any flag."]
    #[doc = ""]
    #[doc = " \\note           The \\c trust_ca list can contain two types of certificates:"]
    #[doc = "                 (1) those of trusted root CAs, so that certificates"]
    #[doc = "                 chaining up to those CAs will be trusted, and (2)"]
    #[doc = "                 self-signed end-entity certificates to be trusted (for"]
    #[doc = "                 specific peers you know) - in that case, the self-signed"]
    #[doc = "                 certificate doesn't need to have the CA bit set."]
    #[doc = ""]
    #[doc = " \\param crt      a certificate (chain) to be verified"]
    #[doc = " \\param trust_ca the list of trusted CAs (see note above)"]
    #[doc = " \\param ca_crl   the list of CRLs for trusted CAs (see note above)"]
    #[doc = " \\param cn       expected Common Name (can be set to"]
    #[doc = "                 NULL if the CN must not be verified)"]
    #[doc = " \\param flags    result of the verification"]
    #[doc = " \\param f_vrfy   verification function"]
    #[doc = " \\param p_vrfy   verification parameter"]
    #[doc = ""]
    #[doc = " \\return         0 (and flags set to 0) if the chain was verified and valid,"]
    #[doc = "                 MBEDTLS_ERR_X509_CERT_VERIFY_FAILED if the chain was verified"]
    #[doc = "                 but found to be invalid, in which case *flags will have one"]
    #[doc = "                 or more MBEDTLS_X509_BADCERT_XXX or MBEDTLS_X509_BADCRL_XXX"]
    #[doc = "                 flags set, or another error (and flags set to 0xffffffff)"]
    #[doc = "                 in case of a fatal error encountered during the"]
    #[doc = "                 verification process."]
    pub fn mbedtls_x509_crt_verify(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        cn: *const cty::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: cty::c_int,
                arg4: *mut u32,
            ) -> cty::c_int,
        >,
        p_vrfy: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify the certificate signature according to profile"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_x509_crt_verify(), but with explicit"]
    #[doc = "                 security profile."]
    #[doc = ""]
    #[doc = " \\note           The restrictions on keys (RSA minimum size, allowed curves"]
    #[doc = "                 for ECDSA) apply to all certificates: trusted root,"]
    #[doc = "                 intermediate CAs if any, and end entity certificate."]
    #[doc = ""]
    #[doc = " \\param crt      a certificate (chain) to be verified"]
    #[doc = " \\param trust_ca the list of trusted CAs"]
    #[doc = " \\param ca_crl   the list of CRLs for trusted CAs"]
    #[doc = " \\param profile  security profile for verification"]
    #[doc = " \\param cn       expected Common Name (can be set to"]
    #[doc = "                 NULL if the CN must not be verified)"]
    #[doc = " \\param flags    result of the verification"]
    #[doc = " \\param f_vrfy   verification function"]
    #[doc = " \\param p_vrfy   verification parameter"]
    #[doc = ""]
    #[doc = " \\return         0 if successful or MBEDTLS_ERR_X509_CERT_VERIFY_FAILED"]
    #[doc = "                 in which case *flags will have one or more"]
    #[doc = "                 MBEDTLS_X509_BADCERT_XXX or MBEDTLS_X509_BADCRL_XXX flags"]
    #[doc = "                 set,"]
    #[doc = "                 or another error in case of a fatal error encountered"]
    #[doc = "                 during the verification process."]
    pub fn mbedtls_x509_crt_verify_with_profile(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const cty::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: cty::c_int,
                arg4: *mut u32,
            ) -> cty::c_int,
        >,
        p_vrfy: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Check usage of certificate against keyUsage extension."]
    #[doc = ""]
    #[doc = " \\param crt      Leaf certificate used."]
    #[doc = " \\param usage    Intended usage(s) (eg MBEDTLS_X509_KU_KEY_ENCIPHERMENT"]
    #[doc = "                 before using the certificate to perform an RSA key"]
    #[doc = "                 exchange)."]
    #[doc = ""]
    #[doc = " \\note           Except for decipherOnly and encipherOnly, a bit set in the"]
    #[doc = "                 usage argument means this bit MUST be set in the"]
    #[doc = "                 certificate. For decipherOnly and encipherOnly, it means"]
    #[doc = "                 that bit MAY be set."]
    #[doc = ""]
    #[doc = " \\return         0 is these uses of the certificate are allowed,"]
    #[doc = "                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if the keyUsage extension"]
    #[doc = "                 is present but does not match the usage argument."]
    #[doc = ""]
    #[doc = " \\note           You should only call this function on leaf certificates, on"]
    #[doc = "                 (intermediate) CAs the keyUsage extension is automatically"]
    #[doc = "                 checked by \\c mbedtls_x509_crt_verify()."]
    pub fn mbedtls_x509_crt_check_key_usage(
        crt: *const mbedtls_x509_crt,
        usage: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Check usage of certificate against extendedKeyUsage."]
    #[doc = ""]
    #[doc = " \\param crt       Leaf certificate used."]
    #[doc = " \\param usage_oid Intended usage (eg MBEDTLS_OID_SERVER_AUTH or"]
    #[doc = "                  MBEDTLS_OID_CLIENT_AUTH)."]
    #[doc = " \\param usage_len Length of usage_oid (eg given by MBEDTLS_OID_SIZE())."]
    #[doc = ""]
    #[doc = " \\return          0 if this use of the certificate is allowed,"]
    #[doc = "                  MBEDTLS_ERR_X509_BAD_INPUT_DATA if not."]
    #[doc = ""]
    #[doc = " \\note            Usually only makes sense on leaf certificates."]
    pub fn mbedtls_x509_crt_check_extended_key_usage(
        crt: *const mbedtls_x509_crt,
        usage_oid: *const cty::c_char,
        usage_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify the certificate revocation status"]
    #[doc = ""]
    #[doc = " \\param crt      a certificate to be verified"]
    #[doc = " \\param crl      the CRL to verify against"]
    #[doc = ""]
    #[doc = " \\return         1 if the certificate is revoked, 0 otherwise"]
    #[doc = ""]
    pub fn mbedtls_x509_crt_is_revoked(
        crt: *const mbedtls_x509_crt,
        crl: *const mbedtls_x509_crl,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a certificate (chain)"]
    #[doc = ""]
    #[doc = " \\param crt      Certificate chain to initialize"]
    pub fn mbedtls_x509_crt_init(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief          Unallocate all certificate data"]
    #[doc = ""]
    #[doc = " \\param crt      Certificate chain to free"]
    pub fn mbedtls_x509_crt_free(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief           Initialize a CRT writing context"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to initialize"]
    pub fn mbedtls_x509write_crt_init(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Set the verion for a Certificate"]
    #[doc = "                  Default: MBEDTLS_X509_CRT_VERSION_3"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param version   version to set (MBEDTLS_X509_CRT_VERSION_1, MBEDTLS_X509_CRT_VERSION_2 or"]
    #[doc = "                                  MBEDTLS_X509_CRT_VERSION_3)"]
    pub fn mbedtls_x509write_crt_set_version(ctx: *mut mbedtls_x509write_cert, version: cty::c_int);
}
extern "C" {
    #[doc = " \\brief           Set the serial number for a Certificate."]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param serial    serial number to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful"]
    pub fn mbedtls_x509write_crt_set_serial(
        ctx: *mut mbedtls_x509write_cert,
        serial: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the validity period for a Certificate"]
    #[doc = "                  Timestamps should be in string format for UTC timezone"]
    #[doc = "                  i.e. \"YYYYMMDDhhmmss\""]
    #[doc = "                  e.g. \"20131231235959\" for December 31st 2013"]
    #[doc = "                       at 23:59:59"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param not_before    not_before timestamp"]
    #[doc = " \\param not_after     not_after timestamp"]
    #[doc = ""]
    #[doc = " \\return          0 if timestamp was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_validity(
        ctx: *mut mbedtls_x509write_cert,
        not_before: *const cty::c_char,
        not_after: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the issuer name for a Certificate"]
    #[doc = "                  Issuer names should contain a comma-separated list"]
    #[doc = "                  of OID types and values:"]
    #[doc = "                  e.g. \"C=UK,O=ARM,CN=mbed TLS CA\""]
    #[doc = ""]
    #[doc = " \\param ctx           CRT context to use"]
    #[doc = " \\param issuer_name   issuer name to set"]
    #[doc = ""]
    #[doc = " \\return          0 if issuer name was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_issuer_name(
        ctx: *mut mbedtls_x509write_cert,
        issuer_name: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject name for a Certificate"]
    #[doc = "                  Subject names should contain a comma-separated list"]
    #[doc = "                  of OID types and values:"]
    #[doc = "                  e.g. \"C=UK,O=ARM,CN=mbed TLS Server 1\""]
    #[doc = ""]
    #[doc = " \\param ctx           CRT context to use"]
    #[doc = " \\param subject_name  subject name to set"]
    #[doc = ""]
    #[doc = " \\return          0 if subject name was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_subject_name(
        ctx: *mut mbedtls_x509write_cert,
        subject_name: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject public key for the certificate"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param key       public key to include"]
    pub fn mbedtls_x509write_crt_set_subject_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    #[doc = " \\brief           Set the issuer key used for signing the certificate"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param key       private key to sign with"]
    pub fn mbedtls_x509write_crt_set_issuer_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    #[doc = " \\brief           Set the MD algorithm to use for the signature"]
    #[doc = "                  (e.g. MBEDTLS_MD_SHA1)"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param md_alg    MD algorithm to use"]
    pub fn mbedtls_x509write_crt_set_md_alg(
        ctx: *mut mbedtls_x509write_cert,
        md_alg: mbedtls_md_type_t,
    );
}
extern "C" {
    #[doc = " \\brief           Generic function to add to or replace an extension in the"]
    #[doc = "                  CRT"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param oid       OID of the extension"]
    #[doc = " \\param oid_len   length of the OID"]
    #[doc = " \\param critical  if the extension is critical (per the RFC's definition)"]
    #[doc = " \\param val       value of the extension OCTET STRING"]
    #[doc = " \\param val_len   length of the value data"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_extension(
        ctx: *mut mbedtls_x509write_cert,
        oid: *const cty::c_char,
        oid_len: usize,
        critical: cty::c_int,
        val: *const cty::c_uchar,
        val_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the basicConstraints extension for a CRT"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param is_ca     is this a CA certificate"]
    #[doc = " \\param max_pathlen   maximum length of certificate chains below this"]
    #[doc = "                      certificate (only for CA certificates, -1 is"]
    #[doc = "                      inlimited)"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_basic_constraints(
        ctx: *mut mbedtls_x509write_cert,
        is_ca: cty::c_int,
        max_pathlen: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subjectKeyIdentifier extension for a CRT"]
    #[doc = "                  Requires that mbedtls_x509write_crt_set_subject_key() has been"]
    #[doc = "                  called before"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_subject_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the authorityKeyIdentifier extension for a CRT"]
    #[doc = "                  Requires that mbedtls_x509write_crt_set_issuer_key() has been"]
    #[doc = "                  called before"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_authority_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Key Usage Extension flags"]
    #[doc = "                  (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param key_usage key usage flags to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_key_usage(
        ctx: *mut mbedtls_x509write_cert,
        key_usage: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Netscape Cert Type flags"]
    #[doc = "                  (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)"]
    #[doc = ""]
    #[doc = " \\param ctx           CRT context to use"]
    #[doc = " \\param ns_cert_type  Netscape Cert Type flags to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_ns_cert_type(
        ctx: *mut mbedtls_x509write_cert,
        ns_cert_type: cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Free the contents of a CRT write context"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to free"]
    pub fn mbedtls_x509write_crt_free(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       certificate to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = " \\param f_rng     RNG function (for signature, see note)"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    #[doc = ""]
    #[doc = " \\note            f_rng may be NULL if RSA is used for signature and the"]
    #[doc = "                  signature is made offline (otherwise f_rng is desirable"]
    #[doc = "                  for countermeasures against timing attacks)."]
    #[doc = "                  ECDSA signatures always require a non-NULL f_rng."]
    pub fn mbedtls_x509write_crt_der(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut cty::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       certificate to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = " \\param f_rng     RNG function (for signature, see note)"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    #[doc = ""]
    #[doc = " \\note            f_rng may be NULL if RSA is used for signature and the"]
    #[doc = "                  signature is made offline (otherwise f_rng is desirable"]
    #[doc = "                  for countermeasures against timing attacks)."]
    #[doc = "                  ECDSA signatures always require a non-NULL f_rng."]
    pub fn mbedtls_x509write_crt_pem(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut cty::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
#[doc = " \\brief          The DHM context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_dhm_context {
    #[doc = "<  The size of \\p P in Bytes."]
    pub len: usize,
    #[doc = "<  The prime modulus."]
    pub P: mbedtls_mpi,
    #[doc = "<  The generator."]
    pub G: mbedtls_mpi,
    #[doc = "<  Our secret value."]
    pub X: mbedtls_mpi,
    #[doc = "<  Our public key = \\c G^X mod \\c P."]
    pub GX: mbedtls_mpi,
    #[doc = "<  The public key of the peer = \\c G^Y mod \\c P."]
    pub GY: mbedtls_mpi,
    #[doc = "<  The shared secret = \\c G^(XY) mod \\c P."]
    pub K: mbedtls_mpi,
    #[doc = "<  The cached value = \\c R^2 mod \\c P."]
    pub RP: mbedtls_mpi,
    #[doc = "<  The blinding value."]
    pub Vi: mbedtls_mpi,
    #[doc = "<  The unblinding value."]
    pub Vf: mbedtls_mpi,
    #[doc = "<  The previous \\c X."]
    pub pX: mbedtls_mpi,
}
extern "C" {
    #[doc = " \\brief          This function initializes the DHM context."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to initialize."]
    pub fn mbedtls_dhm_init(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    #[doc = " \\brief          This function parses the ServerKeyExchange parameters."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context."]
    #[doc = " \\param p        On input, *p must be the start of the input buffer."]
    #[doc = "                 On output, *p is updated to point to the end of the data"]
    #[doc = "                 that has been read. On success, this is the first byte"]
    #[doc = "                 past the end of the ServerKeyExchange parameters."]
    #[doc = "                 On error, this is the point at which an error has been"]
    #[doc = "                 detected, which is usually not useful except to debug"]
    #[doc = "                 failures."]
    #[doc = " \\param end      The end of the input buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_read_params(
        ctx: *mut mbedtls_dhm_context,
        p: *mut *mut cty::c_uchar,
        end: *const cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets up and writes the ServerKeyExchange"]
    #[doc = "                 parameters."]
    #[doc = ""]
    #[doc = " \\note           The destination buffer must be large enough to hold"]
    #[doc = "                 the reduced binary presentation of the modulus, the generator"]
    #[doc = "                 and the public key, each wrapped with a 2-byte length field."]
    #[doc = "                 It is the responsibility of the caller to ensure that enough"]
    #[doc = "                 space is available. Refer to \\c mbedtls_mpi_size to computing"]
    #[doc = "                 the byte-size of an MPI."]
    #[doc = ""]
    #[doc = " \\note           This function assumes that \\c ctx->P and \\c ctx->G"]
    #[doc = "                 have already been properly set. For that, use"]
    #[doc = "                 mbedtls_dhm_set_group() below in conjunction with"]
    #[doc = "                 mbedtls_mpi_read_binary() and mbedtls_mpi_read_string()."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context."]
    #[doc = " \\param x_size   The private key size in Bytes."]
    #[doc = " \\param olen     The number of characters written."]
    #[doc = " \\param output   The destination buffer."]
    #[doc = " \\param f_rng    The RNG function."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_make_params(
        ctx: *mut mbedtls_dhm_context,
        x_size: cty::c_int,
        output: *mut cty::c_uchar,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets the prime modulus and generator."]
    #[doc = ""]
    #[doc = " \\note           This function can be used to set \\p P, \\p G"]
    #[doc = "                 in preparation for mbedtls_dhm_make_params()."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context."]
    #[doc = " \\param P        The MPI holding the DHM prime modulus."]
    #[doc = " \\param G        The MPI holding the DHM generator."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_set_group(
        ctx: *mut mbedtls_dhm_context,
        P: *const mbedtls_mpi,
        G: *const mbedtls_mpi,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports the public value of the peer, G^Y."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context."]
    #[doc = " \\param input    The input buffer containing the G^Y value of the peer."]
    #[doc = " \\param ilen     The size of the input buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_read_public(
        ctx: *mut mbedtls_dhm_context,
        input: *const cty::c_uchar,
        ilen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function creates its own private key, \\c X, and"]
    #[doc = "                 exports \\c G^X."]
    #[doc = ""]
    #[doc = " \\note           The destination buffer is always fully written"]
    #[doc = "                 so as to contain a big-endian representation of G^X mod P."]
    #[doc = "                 If it is larger than ctx->len, it is padded accordingly"]
    #[doc = "                 with zero-bytes at the beginning."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context."]
    #[doc = " \\param x_size   The private key size in Bytes."]
    #[doc = " \\param output   The destination buffer."]
    #[doc = " \\param olen     The length of the destination buffer. Must be at least"]
    #[doc = "                  equal to ctx->len (the size of \\c P)."]
    #[doc = " \\param f_rng    The RNG function."]
    #[doc = " \\param p_rng    The RNG context."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_make_public(
        ctx: *mut mbedtls_dhm_context,
        x_size: cty::c_int,
        output: *mut cty::c_uchar,
        olen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function derives and exports the shared secret"]
    #[doc = "                      \\c (G^Y)^X mod \\c P."]
    #[doc = ""]
    #[doc = " \\note                If \\p f_rng is not NULL, it is used to blind the input as"]
    #[doc = "                      a countermeasure against timing attacks. Blinding is used"]
    #[doc = "                      only if our private key \\c X is re-used, and not used"]
    #[doc = "                      otherwise. We recommend always passing a non-NULL"]
    #[doc = "                      \\p f_rng argument."]
    #[doc = ""]
    #[doc = " \\param ctx           The DHM context."]
    #[doc = " \\param output        The destination buffer."]
    #[doc = " \\param output_size   The size of the destination buffer. Must be at least"]
    #[doc = "                      the size of ctx->len (the size of \\c P)."]
    #[doc = " \\param olen          On exit, holds the actual number of Bytes written."]
    #[doc = " \\param f_rng         The RNG function, for blinding purposes."]
    #[doc = " \\param p_rng         The RNG context."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_calc_secret(
        ctx: *mut mbedtls_dhm_context,
        output: *mut cty::c_uchar,
        output_size: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function frees and clears the components of a DHM context."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to free and clear."]
    pub fn mbedtls_dhm_free(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    #[doc = " \\ingroup x509_module */"]
    #[doc = " \\brief             This function parses DHM parameters in PEM or DER format."]
    #[doc = ""]
    #[doc = " \\param dhm         The DHM context to initialize."]
    #[doc = " \\param dhmin       The input buffer."]
    #[doc = " \\param dhminlen    The size of the buffer, including the terminating null"]
    #[doc = "                    Byte for PEM data."]
    #[doc = ""]
    #[doc = " \\return            \\c 0 on success."]
    #[doc = " \\return            An \\c MBEDTLS_ERR_DHM_XXX or \\c MBEDTLS_ERR_PEM_XXX error code"]
    #[doc = "                    error code on failure."]
    pub fn mbedtls_dhm_parse_dhm(
        dhm: *mut mbedtls_dhm_context,
        dhmin: *const cty::c_uchar,
        dhminlen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\ingroup x509_module */"]
    #[doc = " \\brief          This function loads and parses DHM parameters from a file."]
    #[doc = ""]
    #[doc = " \\param dhm      The DHM context to load the parameters to."]
    #[doc = " \\param path     The filename to read the DHM parameters from."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return            An \\c MBEDTLS_ERR_DHM_XXX or \\c MBEDTLS_ERR_PEM_XXX error code"]
    #[doc = "                    error code on failure."]
    pub fn mbedtls_dhm_parse_dhmfile(
        dhm: *mut mbedtls_dhm_context,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          The DMH checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_dhm_self_test(verbose: cty::c_int) -> cty::c_int;
}
#[doc = "< Our key."]
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_OURS: mbedtls_ecdh_side = 0;
#[doc = "< The key of the peer."]
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_THEIRS: mbedtls_ecdh_side = 1;
#[doc = " Defines the source of the imported EC key."]
pub type mbedtls_ecdh_side = u32;
#[doc = " \\brief           The ECDH context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecdh_context {
    #[doc = "< The elliptic curve used."]
    pub grp: mbedtls_ecp_group,
    #[doc = "< The private key."]
    pub d: mbedtls_mpi,
    #[doc = "< The public key."]
    pub Q: mbedtls_ecp_point,
    #[doc = "< The value of the public key of the peer."]
    pub Qp: mbedtls_ecp_point,
    #[doc = "< The shared secret."]
    pub z: mbedtls_mpi,
    #[doc = "< The format of point export in TLS messages."]
    pub point_format: cty::c_int,
    #[doc = "< The blinding value."]
    pub Vi: mbedtls_ecp_point,
    #[doc = "< The unblinding value."]
    pub Vf: mbedtls_ecp_point,
    #[doc = "< The previous \\p d."]
    pub _d: mbedtls_mpi,
}
extern "C" {
    #[doc = " \\brief           This function generates an ECDH keypair on an elliptic"]
    #[doc = "                  curve."]
    #[doc = ""]
    #[doc = "                  This function performs the first of two core computations"]
    #[doc = "                  implemented during the ECDH key exchange. The second core"]
    #[doc = "                  computation is performed by mbedtls_ecdh_compute_shared()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group."]
    #[doc = " \\param d         The destination MPI (private key)."]
    #[doc = " \\param Q         The destination point (public key)."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or"]
    #[doc = "                  \\c MBEDTLS_MPI_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_ecdh_gen_public(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the shared secret."]
    #[doc = ""]
    #[doc = "                  This function performs the second of two core computations"]
    #[doc = "                  implemented during the ECDH key exchange. The first core"]
    #[doc = "                  computation is performed by mbedtls_ecdh_gen_public()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\note            If \\p f_rng is not NULL, it is used to implement"]
    #[doc = "                  countermeasures against side-channel attacks."]
    #[doc = "                  For more information, see mbedtls_ecp_mul()."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group."]
    #[doc = " \\param z         The destination MPI (shared secret)."]
    #[doc = " \\param Q         The public key from another party."]
    #[doc = " \\param d         Our secret exponent (private key)."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or"]
    #[doc = "                  \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdh_compute_shared(
        grp: *mut mbedtls_ecp_group,
        z: *mut mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        d: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDH context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to initialize."]
    pub fn mbedtls_ecdh_init(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function frees a context."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to free."]
    pub fn mbedtls_ecdh_free(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function generates a public key and a TLS"]
    #[doc = "                  ServerKeyExchange payload."]
    #[doc = ""]
    #[doc = "                  This is the first function used by a TLS server for ECDHE"]
    #[doc = "                  ciphersuites."]
    #[doc = ""]
    #[doc = " \\note            This function assumes that the ECP group (grp) of the"]
    #[doc = "                  \\p ctx context has already been properly set,"]
    #[doc = "                  for example, using mbedtls_ecp_group_load()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context."]
    #[doc = " \\param olen      The number of characters written."]
    #[doc = " \\param buf       The destination buffer."]
    #[doc = " \\param blen      The length of the destination buffer."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_make_params(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut cty::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function parses and processes a TLS ServerKeyExhange"]
    #[doc = "                  payload."]
    #[doc = ""]
    #[doc = "                  This is the first function used by a TLS client for ECDHE"]
    #[doc = "                  ciphersuites."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context."]
    #[doc = " \\param buf       The pointer to the start of the input buffer."]
    #[doc = " \\param end       The address for one Byte past the end of the buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_ecdh_read_params(
        ctx: *mut mbedtls_ecdh_context,
        buf: *mut *const cty::c_uchar,
        end: *const cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECDH context from an EC key."]
    #[doc = ""]
    #[doc = "                  It is used by clients and servers in place of the"]
    #[doc = "                  ServerKeyEchange for static ECDH, and imports ECDH"]
    #[doc = "                  parameters from the EC key information of a certificate."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to set up."]
    #[doc = " \\param key       The EC key to use."]
    #[doc = " \\param side      Defines the source of the key: 1: Our key, or"]
    #[doc = "                  0: The key of the peer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[doc = ""]
    pub fn mbedtls_ecdh_get_params(
        ctx: *mut mbedtls_ecdh_context,
        key: *const mbedtls_ecp_keypair,
        side: mbedtls_ecdh_side,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a public key and a TLS"]
    #[doc = "                  ClientKeyExchange payload."]
    #[doc = ""]
    #[doc = "                  This is the second function used by a TLS client for ECDH(E)"]
    #[doc = "                  ciphersuites."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context."]
    #[doc = " \\param olen      The number of Bytes written."]
    #[doc = " \\param buf       The destination buffer."]
    #[doc = " \\param blen      The size of the destination buffer."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_make_public(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut cty::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       This function parses and processes a TLS ClientKeyExchange"]
    #[doc = "              payload."]
    #[doc = ""]
    #[doc = "              This is the second function used by a TLS server for ECDH(E)"]
    #[doc = "              ciphersuites."]
    #[doc = ""]
    #[doc = " \\see         ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx   The ECDH context."]
    #[doc = " \\param buf   The start of the input buffer."]
    #[doc = " \\param blen  The length of the input buffer."]
    #[doc = ""]
    #[doc = " \\return      \\c 0 on success."]
    #[doc = " \\return      An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_read_public(
        ctx: *mut mbedtls_ecdh_context,
        buf: *const cty::c_uchar,
        blen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           This function derives and exports the shared secret."]
    #[doc = ""]
    #[doc = "                  This is the last function used by both TLS client"]
    #[doc = "                  and servers."]
    #[doc = ""]
    #[doc = " \\note            If \\p f_rng is not NULL, it is used to implement"]
    #[doc = "                  countermeasures against side-channel attacks."]
    #[doc = "                  For more information, see mbedtls_ecp_mul()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context."]
    #[doc = " \\param olen      The number of Bytes written."]
    #[doc = " \\param buf       The destination buffer."]
    #[doc = " \\param blen      The length of the destination buffer."]
    #[doc = " \\param f_rng     The RNG function."]
    #[doc = " \\param p_rng     The RNG context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_calc_secret(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut cty::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_premaster_secret {
    pub _pms_rsa: [cty::c_uchar; 48usize],
    pub _pms_dhm: [cty::c_uchar; 1024usize],
    pub _pms_ecdh: [cty::c_uchar; 66usize],
    pub _pms_psk: [cty::c_uchar; 68usize],
    pub _pms_dhe_psk: [cty::c_uchar; 1060usize],
    pub _pms_rsa_psk: [cty::c_uchar; 84usize],
    pub _pms_ecdhe_psk: [cty::c_uchar; 102usize],
    _bindgen_union_align: [u8; 1060usize],
}
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_REQUEST: mbedtls_ssl_states = 0;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_HELLO: mbedtls_ssl_states = 1;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO: mbedtls_ssl_states = 2;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CERTIFICATE: mbedtls_ssl_states = 3;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_KEY_EXCHANGE: mbedtls_ssl_states = 4;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_REQUEST: mbedtls_ssl_states = 5;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_DONE: mbedtls_ssl_states = 6;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE: mbedtls_ssl_states = 7;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_KEY_EXCHANGE: mbedtls_ssl_states = 8;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_VERIFY: mbedtls_ssl_states = 9;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 10;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_FINISHED: mbedtls_ssl_states = 11;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 12;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_FINISHED: mbedtls_ssl_states = 13;
pub const mbedtls_ssl_states_MBEDTLS_SSL_FLUSH_BUFFERS: mbedtls_ssl_states = 14;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_WRAPUP: mbedtls_ssl_states = 15;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_OVER: mbedtls_ssl_states = 16;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET: mbedtls_ssl_states = 17;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT: mbedtls_ssl_states = 18;
pub type mbedtls_ssl_states = u32;
#[doc = " \\brief          Callback type: send data on the network."]
#[doc = ""]
#[doc = " \\note           That callback may be either blocking or non-blocking."]
#[doc = ""]
#[doc = " \\param ctx      Context for the send callback (typically a file descriptor)"]
#[doc = " \\param buf      Buffer holding the data to send"]
#[doc = " \\param len      Length of the data to send"]
#[doc = ""]
#[doc = " \\return         The callback must return the number of bytes sent if any,"]
#[doc = "                 or a non-zero error code."]
#[doc = "                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_WRITE"]
#[doc = "                 must be returned when the operation would block."]
#[doc = ""]
#[doc = " \\note           The callback is allowed to send fewer bytes than requested."]
#[doc = "                 It must always return the number of bytes actually sent."]
pub type mbedtls_ssl_send_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut cty::c_void, buf: *const cty::c_uchar, len: usize) -> cty::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network."]
#[doc = ""]
#[doc = " \\note           That callback may be either blocking or non-blocking."]
#[doc = ""]
#[doc = " \\param ctx      Context for the receive callback (typically a file"]
#[doc = "                 descriptor)"]
#[doc = " \\param buf      Buffer to write the received data to"]
#[doc = " \\param len      Length of the receive buffer"]
#[doc = ""]
#[doc = " \\return         The callback must return the number of bytes received,"]
#[doc = "                 or a non-zero error code."]
#[doc = "                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_READ"]
#[doc = "                 must be returned when the operation would block."]
#[doc = ""]
#[doc = " \\note           The callback may receive fewer bytes than the length of the"]
#[doc = "                 buffer. It must always return the number of bytes actually"]
#[doc = "                 received and written to the buffer."]
pub type mbedtls_ssl_recv_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut cty::c_void, buf: *mut cty::c_uchar, len: usize) -> cty::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network, with timeout"]
#[doc = ""]
#[doc = " \\note           That callback must block until data is received, or the"]
#[doc = "                 timeout delay expires, or the operation is interrupted by a"]
#[doc = "                 signal."]
#[doc = ""]
#[doc = " \\param ctx      Context for the receive callback (typically a file descriptor)"]
#[doc = " \\param buf      Buffer to write the received data to"]
#[doc = " \\param len      Length of the receive buffer"]
#[doc = " \\param timeout  Maximum nomber of millisecondes to wait for data"]
#[doc = "                 0 means no timeout (potentially waiting forever)"]
#[doc = ""]
#[doc = " \\return         The callback must return the number of bytes received,"]
#[doc = "                 or a non-zero error code:"]
#[doc = "                 \\c MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,"]
#[doc = "                 \\c MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal."]
#[doc = ""]
#[doc = " \\note           The callback may receive fewer bytes than the length of the"]
#[doc = "                 buffer. It must always return the number of bytes actually"]
#[doc = "                 received and written to the buffer."]
pub type mbedtls_ssl_recv_timeout_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut cty::c_void,
        buf: *mut cty::c_uchar,
        len: usize,
        timeout: u32,
    ) -> cty::c_int,
>;
#[doc = " \\brief          Callback type: set a pair of timers/delays to watch"]
#[doc = ""]
#[doc = " \\param ctx      Context pointer"]
#[doc = " \\param int_ms   Intermediate delay in milliseconds"]
#[doc = " \\param fin_ms   Final delay in milliseconds"]
#[doc = "                 0 cancels the current timer."]
#[doc = ""]
#[doc = " \\note           This callback must at least store the necessary information"]
#[doc = "                 for the associated \\c mbedtls_ssl_get_timer_t callback to"]
#[doc = "                 return correct information."]
#[doc = ""]
#[doc = " \\note           If using a event-driven style of programming, an event must"]
#[doc = "                 be generated when the final delay is passed. The event must"]
#[doc = "                 cause a call to \\c mbedtls_ssl_handshake() with the proper"]
#[doc = "                 SSL context to be scheduled. Care must be taken to ensure"]
#[doc = "                 that at most one such call happens at a time."]
#[doc = ""]
#[doc = " \\note           Only one timer at a time must be running. Calling this"]
#[doc = "                 function while a timer is running must cancel it. Cancelled"]
#[doc = "                 timers must not generate any event."]
pub type mbedtls_ssl_set_timer_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut cty::c_void, int_ms: u32, fin_ms: u32)>;
#[doc = " \\brief          Callback type: get status of timers/delays"]
#[doc = ""]
#[doc = " \\param ctx      Context pointer"]
#[doc = ""]
#[doc = " \\return         This callback must return:"]
#[doc = "                 -1 if cancelled (fin_ms == 0),"]
#[doc = "                  0 if none of the delays have passed,"]
#[doc = "                  1 if only the intermediate delay has passed,"]
#[doc = "                  2 if the final delay has passed."]
pub type mbedtls_ssl_get_timer_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut cty::c_void) -> cty::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_transform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_handshake_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_sig_hash_set_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_key_cert {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_flight_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_session {
    #[doc = "< starting time"]
    pub start: mbedtls_time_t,
    #[doc = "< chosen ciphersuite"]
    pub ciphersuite: cty::c_int,
    #[doc = "< chosen compression"]
    pub compression: cty::c_int,
    #[doc = "< session id length"]
    pub id_len: usize,
    #[doc = "< session identifier"]
    pub id: [cty::c_uchar; 32usize],
    #[doc = "< the master secret"]
    pub master: [cty::c_uchar; 48usize],
    #[doc = "< peer X.509 cert chain"]
    pub peer_cert: *mut mbedtls_x509_crt,
    #[doc = "<  verification result"]
    pub verify_result: u32,
    #[doc = "< RFC 5077 session ticket"]
    pub ticket: *mut cty::c_uchar,
    #[doc = "< session ticket length"]
    pub ticket_len: usize,
    #[doc = "< ticket lifetime hint"]
    pub ticket_lifetime: u32,
    #[doc = "< MaxFragmentLength negotiated by peer"]
    pub mfl_code: cty::c_uchar,
    #[doc = "< flag for truncated hmac activation"]
    pub trunc_hmac: cty::c_int,
    #[doc = "< flag for EtM activation"]
    pub encrypt_then_mac: cty::c_int,
}
#[doc = " SSL/TLS configuration to be shared between mbedtls_ssl_context structures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_config {
    #[doc = "< allowed ciphersuites per version"]
    pub ciphersuite_list: [*const cty::c_int; 4usize],
    #[doc = " Callback for printing debug output"]
    pub f_dbg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: cty::c_int,
            arg3: *const cty::c_char,
            arg4: cty::c_int,
            arg5: *const cty::c_char,
        ),
    >,
    #[doc = "< context for the debug function"]
    pub p_dbg: *mut cty::c_void,
    #[doc = " Callback for getting (pseudo-)random numbers"]
    pub f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *mut cty::c_uchar,
            arg3: usize,
        ) -> cty::c_int,
    >,
    #[doc = "< context for the RNG function"]
    pub p_rng: *mut cty::c_void,
    #[doc = " Callback to retrieve a session from the cache"]
    pub f_get_cache: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut mbedtls_ssl_session) -> cty::c_int,
    >,
    #[doc = " Callback to store a session into the cache"]
    pub f_set_cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *const mbedtls_ssl_session,
        ) -> cty::c_int,
    >,
    #[doc = "< context for cache callbacks"]
    pub p_cache: *mut cty::c_void,
    #[doc = " Callback for setting cert according to SNI extension"]
    pub f_sni: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const cty::c_uchar,
            arg4: usize,
        ) -> cty::c_int,
    >,
    #[doc = "< context for SNI callback"]
    pub p_sni: *mut cty::c_void,
    #[doc = " Callback to customize X.509 certificate chain verification"]
    pub f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: cty::c_int,
            arg4: *mut u32,
        ) -> cty::c_int,
    >,
    #[doc = "< context for X.509 verify calllback"]
    pub p_vrfy: *mut cty::c_void,
    #[doc = " Callback to retrieve PSK key from identity"]
    pub f_psk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const cty::c_uchar,
            arg4: usize,
        ) -> cty::c_int,
    >,
    #[doc = "< context for PSK callback"]
    pub p_psk: *mut cty::c_void,
    #[doc = " Callback to create & write a cookie for ClientHello veirifcation"]
    pub f_cookie_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *mut *mut cty::c_uchar,
            arg3: *mut cty::c_uchar,
            arg4: *const cty::c_uchar,
            arg5: usize,
        ) -> cty::c_int,
    >,
    #[doc = " Callback to verify validity of a ClientHello cookie"]
    pub f_cookie_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *const cty::c_uchar,
            arg3: usize,
            arg4: *const cty::c_uchar,
            arg5: usize,
        ) -> cty::c_int,
    >,
    #[doc = "< context for the cookie callbacks"]
    pub p_cookie: *mut cty::c_void,
    #[doc = " Callback to create & write a session ticket"]
    pub f_ticket_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *const mbedtls_ssl_session,
            arg3: *mut cty::c_uchar,
            arg4: *const cty::c_uchar,
            arg5: *mut usize,
            arg6: *mut u32,
        ) -> cty::c_int,
    >,
    #[doc = " Callback to parse a session ticket into a session structure"]
    pub f_ticket_parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *mut mbedtls_ssl_session,
            arg3: *mut cty::c_uchar,
            arg4: usize,
        ) -> cty::c_int,
    >,
    #[doc = "< context for the ticket callbacks"]
    pub p_ticket: *mut cty::c_void,
    #[doc = " Callback to export key block and master secret"]
    pub f_export_keys: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *const cty::c_uchar,
            arg3: *const cty::c_uchar,
            arg4: usize,
            arg5: usize,
            arg6: usize,
        ) -> cty::c_int,
    >,
    #[doc = "< context for key export callback"]
    pub p_export_keys: *mut cty::c_void,
    #[doc = "< verification profile"]
    pub cert_profile: *const mbedtls_x509_crt_profile,
    #[doc = "< own certificate/key pair(s)"]
    pub key_cert: *mut mbedtls_ssl_key_cert,
    #[doc = "< trusted CAs"]
    pub ca_chain: *mut mbedtls_x509_crt,
    #[doc = "< trusted CAs CRLs"]
    pub ca_crl: *mut mbedtls_x509_crl,
    #[doc = "< allowed signature hashes"]
    pub sig_hashes: *const cty::c_int,
    #[doc = "< allowed curves"]
    pub curve_list: *const mbedtls_ecp_group_id,
    #[doc = "< prime modulus for DHM"]
    pub dhm_P: mbedtls_mpi,
    #[doc = "< generator for DHM"]
    pub dhm_G: mbedtls_mpi,
    #[doc = "< pre-shared key. This field should"]
    #[doc = "only be set via"]
    #[doc = "mbedtls_ssl_conf_psk()"]
    pub psk: *mut cty::c_uchar,
    #[doc = "< length of the pre-shared key. This"]
    #[doc = "field should only be set via"]
    #[doc = "mbedtls_ssl_conf_psk()"]
    pub psk_len: usize,
    #[doc = "< identity for PSK negotiation. This"]
    #[doc = "field should only be set via"]
    #[doc = "mbedtls_ssl_conf_psk()"]
    pub psk_identity: *mut cty::c_uchar,
    #[doc = "< length of identity. This field should"]
    #[doc = "only be set via"]
    #[doc = "mbedtls_ssl_conf_psk()"]
    pub psk_identity_len: usize,
    #[doc = "< ordered list of protocols"]
    pub alpn_list: *mut *const cty::c_char,
    #[doc = "< timeout for mbedtls_ssl_read (ms)"]
    pub read_timeout: u32,
    #[doc = "< initial value of the handshake"]
    #[doc = "retransmission timeout (ms)"]
    pub hs_timeout_min: u32,
    #[doc = "< maximum value of the handshake"]
    #[doc = "retransmission timeout (ms)"]
    pub hs_timeout_max: u32,
    #[doc = "< grace period for renegotiation"]
    pub renego_max_records: cty::c_int,
    #[doc = "< value of the record counters"]
    #[doc = "that triggers renegotiation"]
    pub renego_period: [cty::c_uchar; 8usize],
    #[doc = "< limit of records with a bad MAC"]
    pub badmac_limit: cty::c_uint,
    #[doc = "< min. bit length of the DHM prime"]
    pub dhm_min_bitlen: cty::c_uint,
    #[doc = "< max. major version used"]
    pub max_major_ver: cty::c_uchar,
    #[doc = "< max. minor version used"]
    pub max_minor_ver: cty::c_uchar,
    #[doc = "< min. major version used"]
    pub min_major_ver: cty::c_uchar,
    #[doc = "< min. minor version used"]
    pub min_minor_ver: cty::c_uchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl mbedtls_ssl_config {
    #[inline]
    pub fn endpoint(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_endpoint(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transport(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transport(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authmode(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_authmode(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_legacy_renegotiation(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_allow_legacy_renegotiation(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn arc4_disabled(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arc4_disabled(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mfl_code(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mfl_code(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn encrypt_then_mac(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encrypt_then_mac(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_ms(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_extended_ms(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn anti_replay(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_anti_replay(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cbc_record_splitting(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cbc_record_splitting(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_renegotiation(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_renegotiation(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trunc_hmac(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trunc_hmac(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn session_tickets(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_session_tickets(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fallback(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fallback(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cert_req_ca_list(&self) -> cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cert_req_ca_list(&mut self, val: cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        endpoint: cty::c_uint,
        transport: cty::c_uint,
        authmode: cty::c_uint,
        allow_legacy_renegotiation: cty::c_uint,
        arc4_disabled: cty::c_uint,
        mfl_code: cty::c_uint,
        encrypt_then_mac: cty::c_uint,
        extended_ms: cty::c_uint,
        anti_replay: cty::c_uint,
        cbc_record_splitting: cty::c_uint,
        disable_renegotiation: cty::c_uint,
        trunc_hmac: cty::c_uint,
        session_tickets: cty::c_uint,
        fallback: cty::c_uint,
        cert_req_ca_list: cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let endpoint: u32 = unsafe { ::core::mem::transmute(endpoint) };
            endpoint as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transport: u32 = unsafe { ::core::mem::transmute(transport) };
            transport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let authmode: u32 = unsafe { ::core::mem::transmute(authmode) };
            authmode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let allow_legacy_renegotiation: u32 =
                unsafe { ::core::mem::transmute(allow_legacy_renegotiation) };
            allow_legacy_renegotiation as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let arc4_disabled: u32 = unsafe { ::core::mem::transmute(arc4_disabled) };
            arc4_disabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let mfl_code: u32 = unsafe { ::core::mem::transmute(mfl_code) };
            mfl_code as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let encrypt_then_mac: u32 = unsafe { ::core::mem::transmute(encrypt_then_mac) };
            encrypt_then_mac as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let extended_ms: u32 = unsafe { ::core::mem::transmute(extended_ms) };
            extended_ms as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let anti_replay: u32 = unsafe { ::core::mem::transmute(anti_replay) };
            anti_replay as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let cbc_record_splitting: u32 = unsafe { ::core::mem::transmute(cbc_record_splitting) };
            cbc_record_splitting as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let disable_renegotiation: u32 =
                unsafe { ::core::mem::transmute(disable_renegotiation) };
            disable_renegotiation as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trunc_hmac: u32 = unsafe { ::core::mem::transmute(trunc_hmac) };
            trunc_hmac as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let session_tickets: u32 = unsafe { ::core::mem::transmute(session_tickets) };
            session_tickets as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let fallback: u32 = unsafe { ::core::mem::transmute(fallback) };
            fallback as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let cert_req_ca_list: u32 = unsafe { ::core::mem::transmute(cert_req_ca_list) };
            cert_req_ca_list as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_context {
    #[doc = "< configuration information"]
    pub conf: *const mbedtls_ssl_config,
    #[doc = "< SSL handshake: current state"]
    pub state: cty::c_int,
    #[doc = "< Initial, in progress, pending?"]
    pub renego_status: cty::c_int,
    #[doc = "< Records since renego request, or with DTLS,"]
    #[doc = "number of retransmissions of request if"]
    #[doc = "renego_max_records is < 0"]
    pub renego_records_seen: cty::c_int,
    #[doc = "< equal to  MBEDTLS_SSL_MAJOR_VERSION_3"]
    pub major_ver: cty::c_int,
    #[doc = "< either 0 (SSL3) or 1 (TLS1.0)"]
    pub minor_ver: cty::c_int,
    #[doc = "< records with a bad MAC received"]
    pub badmac_seen: cty::c_uint,
    #[doc = "< Callback for network send"]
    pub f_send: mbedtls_ssl_send_t,
    #[doc = "< Callback for network receive"]
    pub f_recv: mbedtls_ssl_recv_t,
    pub f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    #[doc = "< context for I/O operations"]
    pub p_bio: *mut cty::c_void,
    #[doc = "<  current session data (in)"]
    pub session_in: *mut mbedtls_ssl_session,
    #[doc = "<  current session data (out)"]
    pub session_out: *mut mbedtls_ssl_session,
    #[doc = "<  negotiated session data"]
    pub session: *mut mbedtls_ssl_session,
    #[doc = "<  session data in negotiation"]
    pub session_negotiate: *mut mbedtls_ssl_session,
    #[doc = "<  params required only during"]
    #[doc = "the handshake process"]
    pub handshake: *mut mbedtls_ssl_handshake_params,
    #[doc = "<  current transform params (in)"]
    pub transform_in: *mut mbedtls_ssl_transform,
    #[doc = "<  current transform params (in)"]
    pub transform_out: *mut mbedtls_ssl_transform,
    #[doc = "<  negotiated transform params"]
    pub transform: *mut mbedtls_ssl_transform,
    #[doc = "<  transform params in negotiation"]
    pub transform_negotiate: *mut mbedtls_ssl_transform,
    #[doc = "< context for the timer callbacks"]
    pub p_timer: *mut cty::c_void,
    #[doc = "< set timer callback"]
    pub f_set_timer: mbedtls_ssl_set_timer_t,
    #[doc = "< get timer callback"]
    pub f_get_timer: mbedtls_ssl_get_timer_t,
    #[doc = "< input buffer"]
    pub in_buf: *mut cty::c_uchar,
    #[doc = "< 64-bit incoming message counter"]
    #[doc = "TLS: maintained by us"]
    #[doc = "DTLS: read from peer"]
    pub in_ctr: *mut cty::c_uchar,
    #[doc = "< start of record header"]
    pub in_hdr: *mut cty::c_uchar,
    #[doc = "< two-bytes message length field"]
    pub in_len: *mut cty::c_uchar,
    #[doc = "< ivlen-byte IV"]
    pub in_iv: *mut cty::c_uchar,
    #[doc = "< message contents (in_iv+ivlen)"]
    pub in_msg: *mut cty::c_uchar,
    #[doc = "< read offset in application data"]
    pub in_offt: *mut cty::c_uchar,
    #[doc = "< record header: message type"]
    pub in_msgtype: cty::c_int,
    #[doc = "< record header: message length"]
    pub in_msglen: usize,
    #[doc = "< amount of data read so far"]
    pub in_left: usize,
    #[doc = "< DTLS epoch for incoming records"]
    pub in_epoch: u16,
    #[doc = "< offset of the next record in datagram"]
    #[doc = "(equal to in_left if none)"]
    pub next_record_offset: usize,
    #[doc = "< last validated record seq_num"]
    pub in_window_top: u64,
    #[doc = "< bitmask for replay detection"]
    pub in_window: u64,
    #[doc = "< current handshake message length,"]
    #[doc = "including the handshake header"]
    pub in_hslen: usize,
    #[doc = "< # of 0-length encrypted messages"]
    pub nb_zero: cty::c_int,
    #[doc = "< drop or reuse current message"]
    #[doc = "on next call to record layer?"]
    pub keep_current_message: cty::c_int,
    #[doc = "< Disable packing multiple records"]
    #[doc = "   within a single datagram."]
    pub disable_datagram_packing: u8,
    #[doc = "< output buffer"]
    pub out_buf: *mut cty::c_uchar,
    #[doc = "< 64-bit outgoing message counter"]
    pub out_ctr: *mut cty::c_uchar,
    #[doc = "< start of record header"]
    pub out_hdr: *mut cty::c_uchar,
    #[doc = "< two-bytes message length field"]
    pub out_len: *mut cty::c_uchar,
    #[doc = "< ivlen-byte IV"]
    pub out_iv: *mut cty::c_uchar,
    #[doc = "< message contents (out_iv+ivlen)"]
    pub out_msg: *mut cty::c_uchar,
    #[doc = "< record header: message type"]
    pub out_msgtype: cty::c_int,
    #[doc = "< record header: message length"]
    pub out_msglen: usize,
    #[doc = "< amount of data not yet written"]
    pub out_left: usize,
    #[doc = "<  Outgoing record sequence  number."]
    pub cur_out_ctr: [cty::c_uchar; 8usize],
    #[doc = "< path mtu, used to fragment outgoing messages"]
    pub mtu: u16,
    #[doc = "< current record already splitted?"]
    pub split_done: cty::c_schar,
    #[doc = "<  flag for client auth."]
    pub client_auth: cty::c_int,
    #[doc = "< expected peer CN for verification"]
    #[doc = "(and SNI if available)"]
    pub hostname: *mut cty::c_char,
    #[doc = "<  negotiated protocol"]
    pub alpn_chosen: *const cty::c_char,
    #[doc = "<  transport-level ID of the client"]
    pub cli_id: *mut cty::c_uchar,
    #[doc = "<  length of cli_id"]
    pub cli_id_len: usize,
    #[doc = "<  does peer support legacy or"]
    #[doc = "secure renegotiation"]
    pub secure_renegotiation: cty::c_int,
    #[doc = "<  length of verify data stored"]
    pub verify_data_len: usize,
    #[doc = "<  previous handshake verify data"]
    pub own_verify_data: [cty::c_char; 12usize],
    #[doc = "<  previous handshake verify data"]
    pub peer_verify_data: [cty::c_char; 12usize],
}
extern "C" {
    #[doc = " \\brief               Return the name of the ciphersuite associated with the"]
    #[doc = "                      given ID"]
    #[doc = ""]
    #[doc = " \\param ciphersuite_id SSL ciphersuite ID"]
    #[doc = ""]
    #[doc = " \\return              a string containing the ciphersuite name"]
    pub fn mbedtls_ssl_get_ciphersuite_name(ciphersuite_id: cty::c_int) -> *const cty::c_char;
}
extern "C" {
    #[doc = " \\brief               Return the ID of the ciphersuite associated with the"]
    #[doc = "                      given name"]
    #[doc = ""]
    #[doc = " \\param ciphersuite_name SSL ciphersuite name"]
    #[doc = ""]
    #[doc = " \\return              the ID with the ciphersuite or 0 if not found"]
    pub fn mbedtls_ssl_get_ciphersuite_id(ciphersuite_name: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL context"]
    #[doc = "                 Just makes the context ready for mbedtls_ssl_setup() or"]
    #[doc = "                 mbedtls_ssl_free()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    pub fn mbedtls_ssl_init(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    #[doc = " \\brief          Set up an SSL context for use"]
    #[doc = ""]
    #[doc = " \\note           No copy of the configuration context is made, it can be"]
    #[doc = "                 shared by many mbedtls_ssl_context structures."]
    #[doc = ""]
    #[doc = " \\warning        The conf structure will be accessed during the session."]
    #[doc = "                 It must not be modified or freed as long as the session"]
    #[doc = "                 is active."]
    #[doc = ""]
    #[doc = " \\warning        This function must be called exactly once per context."]
    #[doc = "                 Calling mbedtls_ssl_setup again is not supported, even"]
    #[doc = "                 if no session is active."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param conf     SSL configuration to use"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if"]
    #[doc = "                 memory allocation failed"]
    pub fn mbedtls_ssl_setup(
        ssl: *mut mbedtls_ssl_context,
        conf: *const mbedtls_ssl_config,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Reset an already initialized SSL context for re-use"]
    #[doc = "                 while retaining application-set variables, function"]
    #[doc = "                 pointers and data."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED,"]
    #[doc = "MBEDTLS_ERR_SSL_HW_ACCEL_FAILED or"]
    #[doc = "                 MBEDTLS_ERR_SSL_COMPRESSION_FAILED"]
    pub fn mbedtls_ssl_session_reset(ssl: *mut mbedtls_ssl_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the current endpoint type"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param endpoint must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER"]
    pub fn mbedtls_ssl_conf_endpoint(conf: *mut mbedtls_ssl_config, endpoint: cty::c_int);
}
extern "C" {
    #[doc = " \\brief           Set the transport type (TLS or DTLS)."]
    #[doc = "                  Default: TLS"]
    #[doc = ""]
    #[doc = " \\note            For DTLS, you must either provide a recv callback that"]
    #[doc = "                  doesn't block, or one that handles timeouts, see"]
    #[doc = "                  \\c mbedtls_ssl_set_bio(). You also need to provide timer"]
    #[doc = "                  callbacks with \\c mbedtls_ssl_set_timer_cb()."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration"]
    #[doc = " \\param transport transport type:"]
    #[doc = "                  MBEDTLS_SSL_TRANSPORT_STREAM for TLS,"]
    #[doc = "                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS."]
    pub fn mbedtls_ssl_conf_transport(conf: *mut mbedtls_ssl_config, transport: cty::c_int);
}
extern "C" {
    #[doc = " \\brief          Set the certificate verification mode"]
    #[doc = "                 Default: NONE on server, REQUIRED on client"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param authmode can be:"]
    #[doc = ""]
    #[doc = "  MBEDTLS_SSL_VERIFY_NONE:      peer certificate is not checked"]
    #[doc = "                        (default on server)"]
    #[doc = "                        (insecure on client)"]
    #[doc = ""]
    #[doc = "  MBEDTLS_SSL_VERIFY_OPTIONAL:  peer certificate is checked, however the"]
    #[doc = "                        handshake continues even if verification failed;"]
    #[doc = "                        mbedtls_ssl_get_verify_result() can be called after the"]
    #[doc = "                        handshake is complete."]
    #[doc = ""]
    #[doc = "  MBEDTLS_SSL_VERIFY_REQUIRED:  peer *must* present a valid certificate,"]
    #[doc = "                        handshake is aborted if verification failed."]
    #[doc = "                        (default on client)"]
    #[doc = ""]
    #[doc = " \\note On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode."]
    #[doc = " With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call mbedtls_ssl_get_verify_result() at"]
    #[doc = " the right time(s), which may not be obvious, while REQUIRED always perform"]
    #[doc = " the verification as soon as possible. For example, REQUIRED was protecting"]
    #[doc = " against the \"triple handshake\" attack even before it was found."]
    pub fn mbedtls_ssl_conf_authmode(conf: *mut mbedtls_ssl_config, authmode: cty::c_int);
}
extern "C" {
    #[doc = " \\brief          Set the verification callback (Optional)."]
    #[doc = ""]
    #[doc = "                 If set, the verify callback is called for each"]
    #[doc = "                 certificate in the chain. For implementation"]
    #[doc = "                 information, please see \\c mbedtls_x509_crt_verify()"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_vrfy   verification function"]
    #[doc = " \\param p_vrfy   verification parameter"]
    pub fn mbedtls_ssl_conf_verify(
        conf: *mut mbedtls_ssl_config,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: cty::c_int,
                arg4: *mut u32,
            ) -> cty::c_int,
        >,
        p_vrfy: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the random number generator callback"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_rng    RNG function"]
    #[doc = " \\param p_rng    RNG parameter"]
    pub fn mbedtls_ssl_conf_rng(
        conf: *mut mbedtls_ssl_config,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_rng: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the debug callback"]
    #[doc = ""]
    #[doc = "                 The callback has the following argument:"]
    #[doc = "                 void *           opaque context for the callback"]
    #[doc = "                 int              debug level"]
    #[doc = "                 const char *     file name"]
    #[doc = "                 int              line number"]
    #[doc = "                 const char *     message"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_dbg    debug function"]
    #[doc = " \\param p_dbg    debug parameter"]
    pub fn mbedtls_ssl_conf_dbg(
        conf: *mut mbedtls_ssl_config,
        f_dbg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: cty::c_int,
                arg3: *const cty::c_char,
                arg4: cty::c_int,
                arg5: *const cty::c_char,
            ),
        >,
        p_dbg: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the underlying BIO callbacks for write, read and"]
    #[doc = "                 read-with-timeout."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param p_bio    parameter (context) shared by BIO callbacks"]
    #[doc = " \\param f_send   write callback"]
    #[doc = " \\param f_recv   read callback"]
    #[doc = " \\param f_recv_timeout blocking read callback with timeout."]
    #[doc = ""]
    #[doc = " \\note           One of f_recv or f_recv_timeout can be NULL, in which case"]
    #[doc = "                 the other is used. If both are non-NULL, f_recv_timeout is"]
    #[doc = "                 used and f_recv is ignored (as if it were NULL)."]
    #[doc = ""]
    #[doc = " \\note           The two most common use cases are:"]
    #[doc = "                 - non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL"]
    #[doc = "                 - blocking I/O, f_recv == NULL, f_recv_timout != NULL"]
    #[doc = ""]
    #[doc = " \\note           For DTLS, you need to provide either a non-NULL"]
    #[doc = "                 f_recv_timeout callback, or a f_recv that doesn't block."]
    #[doc = ""]
    #[doc = " \\note           See the documentations of \\c mbedtls_ssl_sent_t,"]
    #[doc = "                 \\c mbedtls_ssl_recv_t and \\c mbedtls_ssl_recv_timeout_t for"]
    #[doc = "                 the conventions those callbacks must follow."]
    #[doc = ""]
    #[doc = " \\note           On some platforms, net_sockets.c provides"]
    #[doc = "                 \\c mbedtls_net_send(), \\c mbedtls_net_recv() and"]
    #[doc = "                 \\c mbedtls_net_recv_timeout() that are suitable to be used"]
    #[doc = "                 here."]
    pub fn mbedtls_ssl_set_bio(
        ssl: *mut mbedtls_ssl_context,
        p_bio: *mut cty::c_void,
        f_send: mbedtls_ssl_send_t,
        f_recv: mbedtls_ssl_recv_t,
        f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    );
}
extern "C" {
    #[doc = " \\brief          Set the Maximum Tranport Unit (MTU)."]
    #[doc = "                 Special value: 0 means unset (no limit)."]
    #[doc = "                 This represents the maximum size of a datagram payload"]
    #[doc = "                 handled by the transport layer (usually UDP) as determined"]
    #[doc = "                 by the network link and stack. In practice, this controls"]
    #[doc = "                 the maximum size datagram the DTLS layer will pass to the"]
    #[doc = "                 \\c f_send() callback set using \\c mbedtls_ssl_set_bio()."]
    #[doc = ""]
    #[doc = " \\note           The limit on datagram size is converted to a limit on"]
    #[doc = "                 record payload by subtracting the current overhead of"]
    #[doc = "                 encapsulation and encryption/authentication if any."]
    #[doc = ""]
    #[doc = " \\note           This can be called at any point during the connection, for"]
    #[doc = "                 example when a Path Maximum Transfer Unit (PMTU)"]
    #[doc = "                 estimate becomes available from other sources,"]
    #[doc = "                 such as lower (or higher) protocol layers."]
    #[doc = ""]
    #[doc = " \\note           This setting only controls the size of the packets we send,"]
    #[doc = "                 and does not restrict the size of the datagrams we're"]
    #[doc = "                 willing to receive. Client-side, you can request the"]
    #[doc = "                 server to use smaller records with \\c"]
    #[doc = "                 mbedtls_ssl_conf_max_frag_len()."]
    #[doc = ""]
    #[doc = " \\note           If both a MTU and a maximum fragment length have been"]
    #[doc = "                 configured (or negotiated with the peer), the resulting"]
    #[doc = "                 lower limit on record payload (see first note) is used."]
    #[doc = ""]
    #[doc = " \\note           This can only be used to decrease the maximum size"]
    #[doc = "                 of datagrams (hence records, see first note) sent. It"]
    #[doc = "                 cannot be used to increase the maximum size of records over"]
    #[doc = "                 the limit set by #MBEDTLS_SSL_OUT_CONTENT_LEN."]
    #[doc = ""]
    #[doc = " \\note           Values lower than the current record layer expansion will"]
    #[doc = "                 result in an error when trying to send data."]
    #[doc = ""]
    #[doc = " \\note           Using record compression together with a non-zero MTU value"]
    #[doc = "                 will result in an error when trying to send data."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param mtu      Value of the path MTU in bytes"]
    pub fn mbedtls_ssl_set_mtu(ssl: *mut mbedtls_ssl_context, mtu: u16);
}
extern "C" {
    #[doc = " \\brief          Set the timeout period for mbedtls_ssl_read()"]
    #[doc = "                 (Default: no timeout.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    #[doc = " \\param timeout  Timeout value in milliseconds."]
    #[doc = "                 Use 0 for no timeout (default)."]
    #[doc = ""]
    #[doc = " \\note           With blocking I/O, this will only work if a non-NULL"]
    #[doc = "                 \\c f_recv_timeout was set with \\c mbedtls_ssl_set_bio()."]
    #[doc = "                 With non-blocking I/O, this will only work if timer"]
    #[doc = "                 callbacks were set with \\c mbedtls_ssl_set_timer_cb()."]
    #[doc = ""]
    #[doc = " \\note           With non-blocking I/O, you may also skip this function"]
    #[doc = "                 altogether and handle timeouts at the application layer."]
    pub fn mbedtls_ssl_conf_read_timeout(conf: *mut mbedtls_ssl_config, timeout: u32);
}
extern "C" {
    #[doc = " \\brief          Set the timer callbacks (Mandatory for DTLS.)"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param p_timer  parameter (context) shared by timer callbacks"]
    #[doc = " \\param f_set_timer   set timer callback"]
    #[doc = " \\param f_get_timer   get timer callback. Must return:"]
    #[doc = ""]
    #[doc = " \\note           See the documentation of \\c mbedtls_ssl_set_timer_t and"]
    #[doc = "                 \\c mbedtls_ssl_get_timer_t for the conventions this pair of"]
    #[doc = "                 callbacks must follow."]
    #[doc = ""]
    #[doc = " \\note           On some platforms, timing.c provides"]
    #[doc = "                 \\c mbedtls_timing_set_delay() and"]
    #[doc = "                 \\c mbedtls_timing_get_delay() that are suitable for using"]
    #[doc = "                 here, except if using an event-driven style."]
    #[doc = ""]
    #[doc = " \\note           See also the \"DTLS tutorial\" article in our knowledge base."]
    #[doc = "                 https://tls.mbed.org/kb/how-to/dtls-tutorial"]
    pub fn mbedtls_ssl_set_timer_cb(
        ssl: *mut mbedtls_ssl_context,
        p_timer: *mut cty::c_void,
        f_set_timer: mbedtls_ssl_set_timer_t,
        f_get_timer: mbedtls_ssl_get_timer_t,
    );
}
#[doc = " \\brief           Callback type: generate and write session ticket"]
#[doc = ""]
#[doc = " \\note            This describes what a callback implementation should do."]
#[doc = "                  This callback should generate an encrypted and"]
#[doc = "                  authenticated ticket for the session and write it to the"]
#[doc = "                  output buffer. Here, ticket means the opaque ticket part"]
#[doc = "                  of the NewSessionTicket structure of RFC 5077."]
#[doc = ""]
#[doc = " \\param p_ticket  Context for the callback"]
#[doc = " \\param session   SSL session to be written in the ticket"]
#[doc = " \\param start     Start of the output buffer"]
#[doc = " \\param end       End of the output buffer"]
#[doc = " \\param tlen      On exit, holds the length written"]
#[doc = " \\param lifetime  On exit, holds the lifetime of the ticket in seconds"]
#[doc = ""]
#[doc = " \\return          0 if successful, or"]
#[doc = "                  a specific MBEDTLS_ERR_XXX code."]
pub type mbedtls_ssl_ticket_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut cty::c_void,
        session: *const mbedtls_ssl_session,
        start: *mut cty::c_uchar,
        end: *const cty::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> cty::c_int,
>;
#[doc = " \\brief           Callback type: Export key block and master secret"]
#[doc = ""]
#[doc = " \\note            This is required for certain uses of TLS, e.g. EAP-TLS"]
#[doc = "                  (RFC 5216) and Thread. The key pointers are ephemeral and"]
#[doc = "                  therefore must not be stored. The master secret and keys"]
#[doc = "                  should not be used directly except as an input to a key"]
#[doc = "                  derivation function."]
#[doc = ""]
#[doc = " \\param p_expkey  Context for the callback"]
#[doc = " \\param ms        Pointer to master secret (fixed length: 48 bytes)"]
#[doc = " \\param kb        Pointer to key block, see RFC 5246 section 6.3"]
#[doc = "                  (variable length: 2 * maclen + 2 * keylen + 2 * ivlen)."]
#[doc = " \\param maclen    MAC length"]
#[doc = " \\param keylen    Key length"]
#[doc = " \\param ivlen     IV length"]
#[doc = ""]
#[doc = " \\return          0 if successful, or"]
#[doc = "                  a specific MBEDTLS_ERR_XXX code."]
pub type mbedtls_ssl_export_keys_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut cty::c_void,
        ms: *const cty::c_uchar,
        kb: *const cty::c_uchar,
        maclen: usize,
        keylen: usize,
        ivlen: usize,
    ) -> cty::c_int,
>;
#[doc = " \\brief           Callback type: parse and load session ticket"]
#[doc = ""]
#[doc = " \\note            This describes what a callback implementation should do."]
#[doc = "                  This callback should parse a session ticket as generated"]
#[doc = "                  by the corresponding mbedtls_ssl_ticket_write_t function,"]
#[doc = "                  and, if the ticket is authentic and valid, load the"]
#[doc = "                  session."]
#[doc = ""]
#[doc = " \\note            The implementation is allowed to modify the first len"]
#[doc = "                  bytes of the input buffer, eg to use it as a temporary"]
#[doc = "                  area for the decrypted ticket contents."]
#[doc = ""]
#[doc = " \\param p_ticket  Context for the callback"]
#[doc = " \\param session   SSL session to be loaded"]
#[doc = " \\param buf       Start of the buffer containing the ticket"]
#[doc = " \\param len       Length of the ticket."]
#[doc = ""]
#[doc = " \\return          0 if successful, or"]
#[doc = "                  MBEDTLS_ERR_SSL_INVALID_MAC if not authentic, or"]
#[doc = "                  MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED if expired, or"]
#[doc = "                  any other non-zero code for other failures."]
pub type mbedtls_ssl_ticket_parse_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut cty::c_void,
        session: *mut mbedtls_ssl_session,
        buf: *mut cty::c_uchar,
        len: usize,
    ) -> cty::c_int,
>;
extern "C" {
    #[doc = " \\brief           Configure SSL session ticket callbacks (server only)."]
    #[doc = "                  (Default: none.)"]
    #[doc = ""]
    #[doc = " \\note            On server, session tickets are enabled by providing"]
    #[doc = "                  non-NULL callbacks."]
    #[doc = ""]
    #[doc = " \\note            On client, use \\c mbedtls_ssl_conf_session_tickets()."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration context"]
    #[doc = " \\param f_ticket_write    Callback for writing a ticket"]
    #[doc = " \\param f_ticket_parse    Callback for parsing a ticket"]
    #[doc = " \\param p_ticket          Context shared by the two callbacks"]
    pub fn mbedtls_ssl_conf_session_tickets_cb(
        conf: *mut mbedtls_ssl_config,
        f_ticket_write: mbedtls_ssl_ticket_write_t,
        f_ticket_parse: mbedtls_ssl_ticket_parse_t,
        p_ticket: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " \\brief           Configure key export callback."]
    #[doc = "                  (Default: none.)"]
    #[doc = ""]
    #[doc = " \\note            See \\c mbedtls_ssl_export_keys_t."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration context"]
    #[doc = " \\param f_export_keys     Callback for exporting keys"]
    #[doc = " \\param p_export_keys     Context for the callback"]
    pub fn mbedtls_ssl_conf_export_keys_cb(
        conf: *mut mbedtls_ssl_config,
        f_export_keys: mbedtls_ssl_export_keys_t,
        p_export_keys: *mut cty::c_void,
    );
}
#[doc = " \\brief          Callback type: generate a cookie"]
#[doc = ""]
#[doc = " \\param ctx      Context for the callback"]
#[doc = " \\param p        Buffer to write to,"]
#[doc = "                 must be updated to point right after the cookie"]
#[doc = " \\param end      Pointer to one past the end of the output buffer"]
#[doc = " \\param info     Client ID info that was passed to"]
#[doc = "                 \\c mbedtls_ssl_set_client_transport_id()"]
#[doc = " \\param ilen     Length of info in bytes"]
#[doc = ""]
#[doc = " \\return         The callback must return 0 on success,"]
#[doc = "                 or a negative error code."]
pub type mbedtls_ssl_cookie_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut cty::c_void,
        p: *mut *mut cty::c_uchar,
        end: *mut cty::c_uchar,
        info: *const cty::c_uchar,
        ilen: usize,
    ) -> cty::c_int,
>;
#[doc = " \\brief          Callback type: verify a cookie"]
#[doc = ""]
#[doc = " \\param ctx      Context for the callback"]
#[doc = " \\param cookie   Cookie to verify"]
#[doc = " \\param clen     Length of cookie"]
#[doc = " \\param info     Client ID info that was passed to"]
#[doc = "                 \\c mbedtls_ssl_set_client_transport_id()"]
#[doc = " \\param ilen     Length of info in bytes"]
#[doc = ""]
#[doc = " \\return         The callback must return 0 if cookie is valid,"]
#[doc = "                 or a negative error code."]
pub type mbedtls_ssl_cookie_check_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut cty::c_void,
        cookie: *const cty::c_uchar,
        clen: usize,
        info: *const cty::c_uchar,
        ilen: usize,
    ) -> cty::c_int,
>;
extern "C" {
    #[doc = " \\brief           Register callbacks for DTLS cookies"]
    #[doc = "                  (Server only. DTLS only.)"]
    #[doc = ""]
    #[doc = "                  Default: dummy callbacks that fail, in order to force you to"]
    #[doc = "                  register working callbacks (and initialize their context)."]
    #[doc = ""]
    #[doc = "                  To disable HelloVerifyRequest, register NULL callbacks."]
    #[doc = ""]
    #[doc = " \\warning         Disabling hello verification allows your server to be used"]
    #[doc = "                  for amplification in DoS attacks against other hosts."]
    #[doc = "                  Only disable if you known this can't happen in your"]
    #[doc = "                  particular environment."]
    #[doc = ""]
    #[doc = " \\note            See comments on \\c mbedtls_ssl_handshake() about handling"]
    #[doc = "                  the MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED that is expected"]
    #[doc = "                  on the first handshake attempt when this is enabled."]
    #[doc = ""]
    #[doc = " \\note            This is also necessary to handle client reconnection from"]
    #[doc = "                  the same port as described in RFC 6347 section 4.2.8 (only"]
    #[doc = "                  the variant with cookies is supported currently). See"]
    #[doc = "                  comments on \\c mbedtls_ssl_read() for details."]
    #[doc = ""]
    #[doc = " \\param conf              SSL configuration"]
    #[doc = " \\param f_cookie_write    Cookie write callback"]
    #[doc = " \\param f_cookie_check    Cookie check callback"]
    #[doc = " \\param p_cookie          Context for both callbacks"]
    pub fn mbedtls_ssl_conf_dtls_cookies(
        conf: *mut mbedtls_ssl_config,
        f_cookie_write: mbedtls_ssl_cookie_write_t,
        f_cookie_check: mbedtls_ssl_cookie_check_t,
        p_cookie: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set client's transport-level identification info."]
    #[doc = "                 (Server only. DTLS only.)"]
    #[doc = ""]
    #[doc = "                 This is usually the IP address (and port), but could be"]
    #[doc = "                 anything identify the client depending on the underlying"]
    #[doc = "                 network stack. Used for HelloVerifyRequest with DTLS."]
    #[doc = "                 This is *not* used to route the actual packets."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param info     Transport-level info identifying the client (eg IP + port)"]
    #[doc = " \\param ilen     Length of info in bytes"]
    #[doc = ""]
    #[doc = " \\note           An internal copy is made, so the info buffer can be reused."]
    #[doc = ""]
    #[doc = " \\return         0 on success,"]
    #[doc = "                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used on client,"]
    #[doc = "                 MBEDTLS_ERR_SSL_ALLOC_FAILED if out of memory."]
    pub fn mbedtls_ssl_set_client_transport_id(
        ssl: *mut mbedtls_ssl_context,
        info: *const cty::c_uchar,
        ilen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Enable or disable anti-replay protection for DTLS."]
    #[doc = "                 (DTLS only, no effect on TLS.)"]
    #[doc = "                 Default: enabled."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param mode     MBEDTLS_SSL_ANTI_REPLAY_ENABLED or MBEDTLS_SSL_ANTI_REPLAY_DISABLED."]
    #[doc = ""]
    #[doc = " \\warning        Disabling this is a security risk unless the application"]
    #[doc = "                 protocol handles duplicated packets in a safe way. You"]
    #[doc = "                 should not disable this without careful consideration."]
    #[doc = "                 However, if your application already detects duplicated"]
    #[doc = "                 packets and needs information about them to adjust its"]
    #[doc = "                 transmission strategy, then you'll want to disable this."]
    pub fn mbedtls_ssl_conf_dtls_anti_replay(conf: *mut mbedtls_ssl_config, mode: cty::c_char);
}
extern "C" {
    #[doc = " \\brief          Set a limit on the number of records with a bad MAC"]
    #[doc = "                 before terminating the connection."]
    #[doc = "                 (DTLS only, no effect on TLS.)"]
    #[doc = "                 Default: 0 (disabled)."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param limit    Limit, or 0 to disable."]
    #[doc = ""]
    #[doc = " \\note           If the limit is N, then the connection is terminated when"]
    #[doc = "                 the Nth non-authentic record is seen."]
    #[doc = ""]
    #[doc = " \\note           Records with an invalid header are not counted, only the"]
    #[doc = "                 ones going through the authentication-decryption phase."]
    #[doc = ""]
    #[doc = " \\note           This is a security trade-off related to the fact that it's"]
    #[doc = "                 often relatively easy for an active attacker ot inject UDP"]
    #[doc = "                 datagrams. On one hand, setting a low limit here makes it"]
    #[doc = "                 easier for such an attacker to forcibly terminated a"]
    #[doc = "                 connection. On the other hand, a high limit or no limit"]
    #[doc = "                 might make us waste resources checking authentication on"]
    #[doc = "                 many bogus packets."]
    pub fn mbedtls_ssl_conf_dtls_badmac_limit(conf: *mut mbedtls_ssl_config, limit: cty::c_uint);
}
extern "C" {
    #[doc = " \\brief          Allow or disallow packing of multiple handshake records"]
    #[doc = "                 within a single datagram."]
    #[doc = ""]
    #[doc = " \\param ssl           The SSL context to configure."]
    #[doc = " \\param allow_packing This determines whether datagram packing may"]
    #[doc = "                      be used or not. A value of \\c 0 means that every"]
    #[doc = "                      record will be sent in a separate datagram; a"]
    #[doc = "                      value of \\c 1 means that, if space permits,"]
    #[doc = "                      multiple handshake messages (including CCS) belonging to"]
    #[doc = "                      a single flight may be packed within a single datagram."]
    #[doc = ""]
    #[doc = " \\note           This is enabled by default and should only be disabled"]
    #[doc = "                 for test purposes, or if datagram packing causes"]
    #[doc = "                 interoperability issues with peers that don't support it."]
    #[doc = ""]
    #[doc = " \\note           Allowing datagram packing reduces the network load since"]
    #[doc = "                 there's less overhead if multiple messages share the same"]
    #[doc = "                 datagram. Also, it increases the handshake efficiency"]
    #[doc = "                 since messages belonging to a single datagram will not"]
    #[doc = "                 be reordered in transit, and so future message buffering"]
    #[doc = "                 or flight retransmission (if no buffering is used) as"]
    #[doc = "                 means to deal with reordering are needed less frequently."]
    #[doc = ""]
    #[doc = " \\note           Application records are not affected by this option and"]
    #[doc = "                 are currently always sent in separate datagrams."]
    #[doc = ""]
    pub fn mbedtls_ssl_set_datagram_packing(
        ssl: *mut mbedtls_ssl_context,
        allow_packing: cty::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief          Set retransmit timeout values for the DTLS handshake."]
    #[doc = "                 (DTLS only, no effect on TLS.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param min      Initial timeout value in milliseconds."]
    #[doc = "                 Default: 1000 (1 second)."]
    #[doc = " \\param max      Maximum timeout value in milliseconds."]
    #[doc = "                 Default: 60000 (60 seconds)."]
    #[doc = ""]
    #[doc = " \\note           Default values are from RFC 6347 section 4.2.4.1."]
    #[doc = ""]
    #[doc = " \\note           The 'min' value should typically be slightly above the"]
    #[doc = "                 expected round-trip time to your peer, plus whatever time"]
    #[doc = "                 it takes for the peer to process the message. For example,"]
    #[doc = "                 if your RTT is about 600ms and you peer needs up to 1s to"]
    #[doc = "                 do the cryptographic operations in the handshake, then you"]
    #[doc = "                 should set 'min' slightly above 1600. Lower values of 'min'"]
    #[doc = "                 might cause spurious resends which waste network resources,"]
    #[doc = "                 while larger value of 'min' will increase overall latency"]
    #[doc = "                 on unreliable network links."]
    #[doc = ""]
    #[doc = " \\note           The more unreliable your network connection is, the larger"]
    #[doc = "                 your max / min ratio needs to be in order to achieve"]
    #[doc = "                 reliable handshakes."]
    #[doc = ""]
    #[doc = " \\note           Messages are retransmitted up to log2(ceil(max/min)) times."]
    #[doc = "                 For example, if min = 1s and max = 5s, the retransmit plan"]
    #[doc = "                 goes: send ... 1s -> resend ... 2s -> resend ... 4s ->"]
    #[doc = "                 resend ... 5s -> give up and return a timeout error."]
    pub fn mbedtls_ssl_conf_handshake_timeout(conf: *mut mbedtls_ssl_config, min: u32, max: u32);
}
extern "C" {
    #[doc = " \\brief          Set the session cache callbacks (server-side only)"]
    #[doc = "                 If not set, no session resuming is done (except if session"]
    #[doc = "                 tickets are enabled too)."]
    #[doc = ""]
    #[doc = "                 The session cache has the responsibility to check for stale"]
    #[doc = "                 entries based on timeout. See RFC 5246 for recommendations."]
    #[doc = ""]
    #[doc = "                 Warning: session.peer_cert is cleared by the SSL/TLS layer on"]
    #[doc = "                 connection shutdown, so do not cache the pointer! Either set"]
    #[doc = "                 it to NULL or make a full copy of the certificate."]
    #[doc = ""]
    #[doc = "                 The get callback is called once during the initial handshake"]
    #[doc = "                 to enable session resuming. The get function has the"]
    #[doc = "                 following parameters: (void *parameter, mbedtls_ssl_session *session)"]
    #[doc = "                 If a valid entry is found, it should fill the master of"]
    #[doc = "                 the session object with the cached values and return 0,"]
    #[doc = "                 return 1 otherwise. Optionally peer_cert can be set as well"]
    #[doc = "                 if it is properly present in cache entry."]
    #[doc = ""]
    #[doc = "                 The set callback is called once during the initial handshake"]
    #[doc = "                 to enable session resuming after the entire handshake has"]
    #[doc = "                 been finished. The set function has the following parameters:"]
    #[doc = "                 (void *parameter, const mbedtls_ssl_session *session). The function"]
    #[doc = "                 should create a cache entry for future retrieval based on"]
    #[doc = "                 the data in the session structure and should keep in mind"]
    #[doc = "                 that the mbedtls_ssl_session object presented (and all its referenced"]
    #[doc = "                 data) is cleared by the SSL/TLS layer when the connection is"]
    #[doc = "                 terminated. It is recommended to add metadata to determine if"]
    #[doc = "                 an entry is still valid in the future. Return 0 if"]
    #[doc = "                 successfully cached, return 1 otherwise."]
    #[doc = ""]
    #[doc = " \\param conf           SSL configuration"]
    #[doc = " \\param p_cache        parmater (context) for both callbacks"]
    #[doc = " \\param f_get_cache    session get callback"]
    #[doc = " \\param f_set_cache    session set callback"]
    pub fn mbedtls_ssl_conf_session_cache(
        conf: *mut mbedtls_ssl_config,
        p_cache: *mut cty::c_void,
        f_get_cache: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut mbedtls_ssl_session,
            ) -> cty::c_int,
        >,
        f_set_cache: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *const mbedtls_ssl_session,
            ) -> cty::c_int,
        >,
    );
}
extern "C" {
    #[doc = " \\brief          Request resumption of session (client-side only)"]
    #[doc = "                 Session data is copied from presented session structure."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param session  session context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or"]
    #[doc = "                 arguments are otherwise invalid"]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_get_session()"]
    pub fn mbedtls_ssl_set_session(
        ssl: *mut mbedtls_ssl_context,
        session: *const mbedtls_ssl_session,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               Set the list of allowed ciphersuites and the preference"]
    #[doc = "                      order. First in the list has the highest preference."]
    #[doc = "                      (Overrides all version-specific lists)"]
    #[doc = ""]
    #[doc = "                      The ciphersuites array is not copied, and must remain"]
    #[doc = "                      valid for the lifetime of the ssl_config."]
    #[doc = ""]
    #[doc = "                      Note: The server uses its own preferences"]
    #[doc = "                      over the preference of the client unless"]
    #[doc = "                      MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE is defined!"]
    #[doc = ""]
    #[doc = " \\param conf          SSL configuration"]
    #[doc = " \\param ciphersuites  0-terminated list of allowed ciphersuites"]
    pub fn mbedtls_ssl_conf_ciphersuites(
        conf: *mut mbedtls_ssl_config,
        ciphersuites: *const cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               Set the list of allowed ciphersuites and the"]
    #[doc = "                      preference order for a specific version of the protocol."]
    #[doc = "                      (Only useful on the server side)"]
    #[doc = ""]
    #[doc = "                      The ciphersuites array is not copied, and must remain"]
    #[doc = "                      valid for the lifetime of the ssl_config."]
    #[doc = ""]
    #[doc = " \\param conf          SSL configuration"]
    #[doc = " \\param ciphersuites  0-terminated list of allowed ciphersuites"]
    #[doc = " \\param major         Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3"]
    #[doc = "                      supported)"]
    #[doc = " \\param minor         Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,"]
    #[doc = "                      MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,"]
    #[doc = "                      MBEDTLS_SSL_MINOR_VERSION_3 supported)"]
    #[doc = ""]
    #[doc = " \\note                With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0"]
    #[doc = "                      and MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2"]
    pub fn mbedtls_ssl_conf_ciphersuites_for_version(
        conf: *mut mbedtls_ssl_config,
        ciphersuites: *const cty::c_int,
        major: cty::c_int,
        minor: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the X.509 security profile used for verification"]
    #[doc = ""]
    #[doc = " \\note           The restrictions are enforced for all certificates in the"]
    #[doc = "                 chain. However, signatures in the handshake are not covered"]
    #[doc = "                 by this setting but by \\b mbedtls_ssl_conf_sig_hashes()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param profile  Profile to use"]
    pub fn mbedtls_ssl_conf_cert_profile(
        conf: *mut mbedtls_ssl_config,
        profile: *const mbedtls_x509_crt_profile,
    );
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate"]
    #[doc = ""]
    #[doc = " \\note           See \\c mbedtls_x509_crt_verify() for notes regarding the"]
    #[doc = "                 parameters ca_chain (maps to trust_ca for that function)"]
    #[doc = "                 and ca_crl."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)"]
    #[doc = " \\param ca_crl   trusted CA CRLs"]
    pub fn mbedtls_ssl_conf_ca_chain(
        conf: *mut mbedtls_ssl_config,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    #[doc = " \\brief          Set own certificate chain and private key"]
    #[doc = ""]
    #[doc = " \\note           own_cert should contain in order from the bottom up your"]
    #[doc = "                 certificate chain. The top certificate (self-signed)"]
    #[doc = "                 can be omitted."]
    #[doc = ""]
    #[doc = " \\note           On server, this function can be called multiple times to"]
    #[doc = "                 provision more than one cert/key pair (eg one ECDSA, one"]
    #[doc = "                 RSA with SHA-256, one RSA with SHA-1). An adequate"]
    #[doc = "                 certificate will be selected according to the client's"]
    #[doc = "                 advertised capabilities. In case mutliple certificates are"]
    #[doc = "                 adequate, preference is given to the one set by the first"]
    #[doc = "                 call to this function, then second, etc."]
    #[doc = ""]
    #[doc = " \\note           On client, only the first call has any effect. That is,"]
    #[doc = "                 only one client certificate can be provisioned. The"]
    #[doc = "                 server's preferences in its CertficateRequest message will"]
    #[doc = "                 be ignored and our only cert will be sent regardless of"]
    #[doc = "                 whether it matches those preferences - the server can then"]
    #[doc = "                 decide what it wants to do with it."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param own_cert own public certificate chain"]
    #[doc = " \\param pk_key   own private key"]
    #[doc = ""]
    #[doc = " \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_conf_own_cert(
        conf: *mut mbedtls_ssl_config,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Pre Shared Key (PSK) and the expected identity name"]
    #[doc = ""]
    #[doc = " \\note           This is mainly useful for clients. Servers will usually"]
    #[doc = "                 want to use \\c mbedtls_ssl_conf_psk_cb() instead."]
    #[doc = ""]
    #[doc = " \\note           Currently clients can only register one pre-shared key."]
    #[doc = "                 In other words, the servers' identity hint is ignored."]
    #[doc = "                 Support for setting multiple PSKs on clients and selecting"]
    #[doc = "                 one based on the identity hint is not a planned feature but"]
    #[doc = "                 feedback is welcomed."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param psk      pointer to the pre-shared key"]
    #[doc = " \\param psk_len  pre-shared key length"]
    #[doc = " \\param psk_identity      pointer to the pre-shared key identity"]
    #[doc = " \\param psk_identity_len  identity key length"]
    #[doc = ""]
    #[doc = " \\return         0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_conf_psk(
        conf: *mut mbedtls_ssl_config,
        psk: *const cty::c_uchar,
        psk_len: usize,
        psk_identity: *const cty::c_uchar,
        psk_identity_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Pre Shared Key (PSK) for the current handshake"]
    #[doc = ""]
    #[doc = " \\note           This should only be called inside the PSK callback,"]
    #[doc = "                 ie the function passed to \\c mbedtls_ssl_conf_psk_cb()."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param psk      pointer to the pre-shared key"]
    #[doc = " \\param psk_len  pre-shared key length"]
    #[doc = ""]
    #[doc = " \\return         0 if successful or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_set_hs_psk(
        ssl: *mut mbedtls_ssl_context,
        psk: *const cty::c_uchar,
        psk_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the PSK callback (server-side only)."]
    #[doc = ""]
    #[doc = "                 If set, the PSK callback is called for each"]
    #[doc = "                 handshake where a PSK ciphersuite was negotiated."]
    #[doc = "                 The caller provides the identity received and wants to"]
    #[doc = "                 receive the actual PSK data and length."]
    #[doc = ""]
    #[doc = "                 The callback has the following parameters: (void *parameter,"]
    #[doc = "                 mbedtls_ssl_context *ssl, const unsigned char *psk_identity,"]
    #[doc = "                 size_t identity_len)"]
    #[doc = "                 If a valid PSK identity is found, the callback should use"]
    #[doc = "                 \\c mbedtls_ssl_set_hs_psk() on the ssl context to set the"]
    #[doc = "                 correct PSK and return 0."]
    #[doc = "                 Any other return value will result in a denied PSK identity."]
    #[doc = ""]
    #[doc = " \\note           If you set a PSK callback using this function, then you"]
    #[doc = "                 don't need to set a PSK key and identity using"]
    #[doc = "                 \\c mbedtls_ssl_conf_psk()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_psk    PSK identity function"]
    #[doc = " \\param p_psk    PSK identity parameter"]
    pub fn mbedtls_ssl_conf_psk_cb(
        conf: *mut mbedtls_ssl_config,
        f_psk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const cty::c_uchar,
                arg4: usize,
            ) -> cty::c_int,
        >,
        p_psk: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values,"]
    #[doc = "                 read as hexadecimal strings (server-side only)"]
    #[doc = "                 (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG])"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param dhm_P    Diffie-Hellman-Merkle modulus"]
    #[doc = " \\param dhm_G    Diffie-Hellman-Merkle generator"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by \\c mbedtls_ssl_conf_dh_param_bin."]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_ssl_conf_dh_param(
        conf: *mut mbedtls_ssl_config,
        dhm_P: *const cty::c_char,
        dhm_G: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values"]
    #[doc = "                 from big-endian binary presentations."]
    #[doc = "                 (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG]_BIN)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param dhm_P    Diffie-Hellman-Merkle modulus in big-endian binary form"]
    #[doc = " \\param P_len    Length of DHM modulus"]
    #[doc = " \\param dhm_G    Diffie-Hellman-Merkle generator in big-endian binary form"]
    #[doc = " \\param G_len    Length of DHM generator"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_ssl_conf_dh_param_bin(
        conf: *mut mbedtls_ssl_config,
        dhm_P: *const cty::c_uchar,
        P_len: usize,
        dhm_G: *const cty::c_uchar,
        G_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values,"]
    #[doc = "                 read from existing context (server-side only)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param dhm_ctx  Diffie-Hellman-Merkle context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    pub fn mbedtls_ssl_conf_dh_param_ctx(
        conf: *mut mbedtls_ssl_config,
        dhm_ctx: *mut mbedtls_dhm_context,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the minimum length for Diffie-Hellman parameters."]
    #[doc = "                 (Client-side only.)"]
    #[doc = "                 (Default: 1024 bits.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param bitlen   Minimum bit length of the DHM prime"]
    pub fn mbedtls_ssl_conf_dhm_min_bitlen(conf: *mut mbedtls_ssl_config, bitlen: cty::c_uint);
}
extern "C" {
    #[doc = " \\brief          Set the allowed curves in order of preference."]
    #[doc = "                 (Default: all defined curves.)"]
    #[doc = ""]
    #[doc = "                 On server: this only affects selection of the ECDHE curve;"]
    #[doc = "                 the curves used for ECDH and ECDSA are determined by the"]
    #[doc = "                 list of available certificates instead."]
    #[doc = ""]
    #[doc = "                 On client: this affects the list of curves offered for any"]
    #[doc = "                 use. The server can override our preference order."]
    #[doc = ""]
    #[doc = "                 Both sides: limits the set of curves accepted for use in"]
    #[doc = "                 ECDHE and in the peer's end-entity certificate."]
    #[doc = ""]
    #[doc = " \\note           This has no influence on which curves are allowed inside the"]
    #[doc = "                 certificate chains, see \\c mbedtls_ssl_conf_cert_profile()"]
    #[doc = "                 for that. For the end-entity certificate however, the key"]
    #[doc = "                 will be accepted only if it is allowed both by this list"]
    #[doc = "                 and by the cert profile."]
    #[doc = ""]
    #[doc = " \\note           This list should be ordered by decreasing preference"]
    #[doc = "                 (preferred curve first)."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param curves   Ordered list of allowed curves,"]
    #[doc = "                 terminated by MBEDTLS_ECP_DP_NONE."]
    pub fn mbedtls_ssl_conf_curves(
        conf: *mut mbedtls_ssl_config,
        curves: *const mbedtls_ecp_group_id,
    );
}
extern "C" {
    #[doc = " \\brief          Set the allowed hashes for signatures during the handshake."]
    #[doc = "                 (Default: all available hashes except MD5.)"]
    #[doc = ""]
    #[doc = " \\note           This only affects which hashes are offered and can be used"]
    #[doc = "                 for signatures during the handshake. Hashes for message"]
    #[doc = "                 authentication and the TLS PRF are controlled by the"]
    #[doc = "                 ciphersuite, see \\c mbedtls_ssl_conf_ciphersuites(). Hashes"]
    #[doc = "                 used for certificate signature are controlled by the"]
    #[doc = "                 verification profile, see \\c mbedtls_ssl_conf_cert_profile()."]
    #[doc = ""]
    #[doc = " \\note           This list should be ordered by decreasing preference"]
    #[doc = "                 (preferred hash first)."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param hashes   Ordered list of allowed signature hashes,"]
    #[doc = "                 terminated by \\c MBEDTLS_MD_NONE."]
    pub fn mbedtls_ssl_conf_sig_hashes(conf: *mut mbedtls_ssl_config, hashes: *const cty::c_int);
}
extern "C" {
    #[doc = " \\brief          Set or reset the hostname to check against the received"]
    #[doc = "                 server certificate. It sets the ServerName TLS extension,"]
    #[doc = "                 too, if that extension is enabled. (client-side only)"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param hostname the server hostname, may be NULL to clear hostname"]
    #[doc = ""]
    #[doc = " \\note           Maximum hostname length MBEDTLS_SSL_MAX_HOST_NAME_LEN."]
    #[doc = ""]
    #[doc = " \\return         0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED on"]
    #[doc = "                 allocation failure, MBEDTLS_ERR_SSL_BAD_INPUT_DATA on"]
    #[doc = "                 too long input hostname."]
    #[doc = ""]
    #[doc = "                 Hostname set to the one provided on success (cleared"]
    #[doc = "                 when NULL). On allocation failure hostname is cleared."]
    #[doc = "                 On too long input failure, old hostname is unchanged."]
    pub fn mbedtls_ssl_set_hostname(
        ssl: *mut mbedtls_ssl_context,
        hostname: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set own certificate and key for the current handshake"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_own_cert() but for use within"]
    #[doc = "                 the SNI callback."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param own_cert own public certificate chain"]
    #[doc = " \\param pk_key   own private key"]
    #[doc = ""]
    #[doc = " \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_set_hs_own_cert(
        ssl: *mut mbedtls_ssl_context,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate for the"]
    #[doc = "                 current handshake"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_ca_chain() but for use within"]
    #[doc = "                 the SNI callback."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)"]
    #[doc = " \\param ca_crl   trusted CA CRLs"]
    pub fn mbedtls_ssl_set_hs_ca_chain(
        ssl: *mut mbedtls_ssl_context,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    #[doc = " \\brief          Set authmode for the current handshake."]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_authmode() but for use within"]
    #[doc = "                 the SNI callback."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param authmode MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or"]
    #[doc = "                 MBEDTLS_SSL_VERIFY_REQUIRED"]
    pub fn mbedtls_ssl_set_hs_authmode(ssl: *mut mbedtls_ssl_context, authmode: cty::c_int);
}
extern "C" {
    #[doc = " \\brief          Set server side ServerName TLS extension callback"]
    #[doc = "                 (optional, server-side only)."]
    #[doc = ""]
    #[doc = "                 If set, the ServerName callback is called whenever the"]
    #[doc = "                 server receives a ServerName TLS extension from the client"]
    #[doc = "                 during a handshake. The ServerName callback has the"]
    #[doc = "                 following parameters: (void *parameter, mbedtls_ssl_context *ssl,"]
    #[doc = "                 const unsigned char *hostname, size_t len). If a suitable"]
    #[doc = "                 certificate is found, the callback must set the"]
    #[doc = "                 certificate(s) and key(s) to use with \\c"]
    #[doc = "                 mbedtls_ssl_set_hs_own_cert() (can be called repeatedly),"]
    #[doc = "                 and may optionally adjust the CA and associated CRL with \\c"]
    #[doc = "                 mbedtls_ssl_set_hs_ca_chain() as well as the client"]
    #[doc = "                 authentication mode with \\c mbedtls_ssl_set_hs_authmode(),"]
    #[doc = "                 then must return 0. If no matching name is found, the"]
    #[doc = "                 callback must either set a default cert, or"]
    #[doc = "                 return non-zero to abort the handshake at this point."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_sni    verification function"]
    #[doc = " \\param p_sni    verification parameter"]
    pub fn mbedtls_ssl_conf_sni(
        conf: *mut mbedtls_ssl_config,
        f_sni: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const cty::c_uchar,
                arg4: usize,
            ) -> cty::c_int,
        >,
        p_sni: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the supported Application Layer Protocols."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param protos   Pointer to a NULL-terminated list of supported protocols,"]
    #[doc = "                 in decreasing preference order. The pointer to the list is"]
    #[doc = "                 recorded by the library for later reference as required, so"]
    #[doc = "                 the lifetime of the table must be atleast as long as the"]
    #[doc = "                 lifetime of the SSL configuration structure."]
    #[doc = ""]
    #[doc = " \\return         0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA."]
    pub fn mbedtls_ssl_conf_alpn_protocols(
        conf: *mut mbedtls_ssl_config,
        protos: *mut *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Get the name of the negotiated Application Layer Protocol."]
    #[doc = "                 This function should be called after the handshake is"]
    #[doc = "                 completed."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Protcol name, or NULL if no protocol was negotiated."]
    pub fn mbedtls_ssl_get_alpn_protocol(ssl: *const mbedtls_ssl_context) -> *const cty::c_char;
}
extern "C" {
    #[doc = " \\brief          Set the maximum supported version sent from the client side"]
    #[doc = "                 and/or accepted at the server side"]
    #[doc = "                 (Default: MBEDTLS_SSL_MAX_MAJOR_VERSION, MBEDTLS_SSL_MAX_MINOR_VERSION)"]
    #[doc = ""]
    #[doc = " \\note           This ignores ciphersuites from higher versions."]
    #[doc = ""]
    #[doc = " \\note           With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param major    Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported)"]
    #[doc = " \\param minor    Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_3 supported)"]
    pub fn mbedtls_ssl_conf_max_version(
        conf: *mut mbedtls_ssl_config,
        major: cty::c_int,
        minor: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the minimum accepted SSL/TLS protocol version"]
    #[doc = "                 (Default: TLS 1.0)"]
    #[doc = ""]
    #[doc = " \\note           Input outside of the SSL_MAX_XXXXX_VERSION and"]
    #[doc = "                 SSL_MIN_XXXXX_VERSION range is ignored."]
    #[doc = ""]
    #[doc = " \\note           MBEDTLS_SSL_MINOR_VERSION_0 (SSL v3) should be avoided."]
    #[doc = ""]
    #[doc = " \\note           With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param major    Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported)"]
    #[doc = " \\param minor    Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_3 supported)"]
    pub fn mbedtls_ssl_conf_min_version(
        conf: *mut mbedtls_ssl_config,
        major: cty::c_int,
        minor: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the fallback flag (client-side only)."]
    #[doc = "                 (Default: MBEDTLS_SSL_IS_NOT_FALLBACK)."]
    #[doc = ""]
    #[doc = " \\note           Set to MBEDTLS_SSL_IS_FALLBACK when preparing a fallback"]
    #[doc = "                 connection, that is a connection with max_version set to a"]
    #[doc = "                 lower value than the value you're willing to use. Such"]
    #[doc = "                 fallback connections are not recommended but are sometimes"]
    #[doc = "                 necessary to interoperate with buggy (version-intolerant)"]
    #[doc = "                 servers."]
    #[doc = ""]
    #[doc = " \\warning        You should NOT set this to MBEDTLS_SSL_IS_FALLBACK for"]
    #[doc = "                 non-fallback connections! This would appear to work for a"]
    #[doc = "                 while, then cause failures when the server is upgraded to"]
    #[doc = "                 support a newer TLS version."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param fallback MBEDTLS_SSL_IS_NOT_FALLBACK or MBEDTLS_SSL_IS_FALLBACK"]
    pub fn mbedtls_ssl_conf_fallback(conf: *mut mbedtls_ssl_config, fallback: cty::c_char);
}
extern "C" {
    #[doc = " \\brief           Enable or disable Encrypt-then-MAC"]
    #[doc = "                  (Default: MBEDTLS_SSL_ETM_ENABLED)"]
    #[doc = ""]
    #[doc = " \\note            This should always be enabled, it is a security"]
    #[doc = "                  improvement, and should not cause any interoperability"]
    #[doc = "                  issue (used only if the peer supports it too)."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration"]
    #[doc = " \\param etm       MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED"]
    pub fn mbedtls_ssl_conf_encrypt_then_mac(conf: *mut mbedtls_ssl_config, etm: cty::c_char);
}
extern "C" {
    #[doc = " \\brief           Enable or disable Extended Master Secret negotiation."]
    #[doc = "                  (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)"]
    #[doc = ""]
    #[doc = " \\note            This should always be enabled, it is a security fix to the"]
    #[doc = "                  protocol, and should not cause any interoperability issue"]
    #[doc = "                  (used only if the peer supports it too)."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration"]
    #[doc = " \\param ems       MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED"]
    pub fn mbedtls_ssl_conf_extended_master_secret(conf: *mut mbedtls_ssl_config, ems: cty::c_char);
}
extern "C" {
    #[doc = " \\brief          Disable or enable support for RC4"]
    #[doc = "                 (Default: MBEDTLS_SSL_ARC4_DISABLED)"]
    #[doc = ""]
    #[doc = " \\warning        Use of RC4 in DTLS/TLS has been prohibited by RFC 7465"]
    #[doc = "                 for security reasons. Use at your own risk."]
    #[doc = ""]
    #[doc = " \\note           This function is deprecated and will likely be removed in"]
    #[doc = "                 a future version of the library."]
    #[doc = "                 RC4 is disabled by default at compile time and needs to be"]
    #[doc = "                 actively enabled for use with legacy systems."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param arc4     MBEDTLS_SSL_ARC4_ENABLED or MBEDTLS_SSL_ARC4_DISABLED"]
    pub fn mbedtls_ssl_conf_arc4_support(conf: *mut mbedtls_ssl_config, arc4: cty::c_char);
}
extern "C" {
    #[doc = " \\brief          Whether to send a list of acceptable CAs in"]
    #[doc = "                 CertificateRequest messages."]
    #[doc = "                 (Default: do send)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param cert_req_ca_list   MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or"]
    #[doc = "                          MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED"]
    pub fn mbedtls_ssl_conf_cert_req_ca_list(
        conf: *mut mbedtls_ssl_config,
        cert_req_ca_list: cty::c_char,
    );
}
extern "C" {
    #[doc = " \\brief          Set the maximum fragment length to emit and/or negotiate"]
    #[doc = "                 (Default: the smaller of MBEDTLS_SSL_IN_CONTENT_LEN and"]
    #[doc = "                 MBEDTLS_SSL_OUT_CONTENT_LEN, usually 2^14 bytes)"]
    #[doc = "                 (Server: set maximum fragment length to emit,"]
    #[doc = "                 usually negotiated by the client during handshake"]
    #[doc = "                 (Client: set maximum fragment length to emit *and*"]
    #[doc = "                 negotiate with the server during handshake)"]
    #[doc = ""]
    #[doc = " \\note           With TLS, this currently only affects ApplicationData (sent"]
    #[doc = "                 with \\c mbedtls_ssl_read()), not handshake messages."]
    #[doc = "                 With DTLS, this affects both ApplicationData and handshake."]
    #[doc = ""]
    #[doc = " \\note           This sets the maximum length for a record's payload,"]
    #[doc = "                 excluding record overhead that will be added to it, see"]
    #[doc = "                 \\c mbedtls_ssl_get_record_expansion()."]
    #[doc = ""]
    #[doc = " \\note           For DTLS, it is also possible to set a limit for the total"]
    #[doc = "                 size of daragrams passed to the transport layer, including"]
    #[doc = "                 record overhead, see \\c mbedtls_ssl_set_mtu()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param mfl_code Code for maximum fragment length (allowed values:"]
    #[doc = "                 MBEDTLS_SSL_MAX_FRAG_LEN_512,  MBEDTLS_SSL_MAX_FRAG_LEN_1024,"]
    #[doc = "                 MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA"]
    pub fn mbedtls_ssl_conf_max_frag_len(
        conf: *mut mbedtls_ssl_config,
        mfl_code: cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Activate negotiation of truncated HMAC"]
    #[doc = "                 (Default: MBEDTLS_SSL_TRUNC_HMAC_DISABLED)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param truncate Enable or disable (MBEDTLS_SSL_TRUNC_HMAC_ENABLED or"]
    #[doc = "                                    MBEDTLS_SSL_TRUNC_HMAC_DISABLED)"]
    pub fn mbedtls_ssl_conf_truncated_hmac(conf: *mut mbedtls_ssl_config, truncate: cty::c_int);
}
extern "C" {
    #[doc = " \\brief          Enable / Disable 1/n-1 record splitting"]
    #[doc = "                 (Default: MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED)"]
    #[doc = ""]
    #[doc = " \\note           Only affects SSLv3 and TLS 1.0, not higher versions."]
    #[doc = "                 Does not affect non-CBC ciphersuites in any version."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param split    MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED or"]
    #[doc = "                 MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED"]
    pub fn mbedtls_ssl_conf_cbc_record_splitting(conf: *mut mbedtls_ssl_config, split: cty::c_char);
}
extern "C" {
    #[doc = " \\brief          Enable / Disable session tickets (client only)."]
    #[doc = "                 (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)"]
    #[doc = ""]
    #[doc = " \\note           On server, use \\c mbedtls_ssl_conf_session_tickets_cb()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param use_tickets   Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or"]
    #[doc = "                                         MBEDTLS_SSL_SESSION_TICKETS_DISABLED)"]
    pub fn mbedtls_ssl_conf_session_tickets(conf: *mut mbedtls_ssl_config, use_tickets: cty::c_int);
}
extern "C" {
    #[doc = " \\brief          Enable / Disable renegotiation support for connection when"]
    #[doc = "                 initiated by peer"]
    #[doc = "                 (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)"]
    #[doc = ""]
    #[doc = " \\warning        It is recommended to always disable renegotation unless you"]
    #[doc = "                 know you need it and you know what you're doing. In the"]
    #[doc = "                 past, there have been several issues associated with"]
    #[doc = "                 renegotiation or a poor understanding of its properties."]
    #[doc = ""]
    #[doc = " \\note           Server-side, enabling renegotiation also makes the server"]
    #[doc = "                 susceptible to a resource DoS by a malicious client."]
    #[doc = ""]
    #[doc = " \\param conf    SSL configuration"]
    #[doc = " \\param renegotiation     Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or"]
    #[doc = "                                             MBEDTLS_SSL_RENEGOTIATION_DISABLED)"]
    pub fn mbedtls_ssl_conf_renegotiation(conf: *mut mbedtls_ssl_config, renegotiation: cty::c_int);
}
extern "C" {
    #[doc = " \\brief          Prevent or allow legacy renegotiation."]
    #[doc = "                 (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)"]
    #[doc = ""]
    #[doc = "                 MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to"]
    #[doc = "                 be established even if the peer does not support"]
    #[doc = "                 secure renegotiation, but does not allow renegotiation"]
    #[doc = "                 to take place if not secure."]
    #[doc = "                 (Interoperable and secure option)"]
    #[doc = ""]
    #[doc = "                 MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations"]
    #[doc = "                 with non-upgraded peers. Allowing legacy renegotiation"]
    #[doc = "                 makes the connection vulnerable to specific man in the"]
    #[doc = "                 middle attacks. (See RFC 5746)"]
    #[doc = "                 (Most interoperable and least secure option)"]
    #[doc = ""]
    #[doc = "                 MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections"]
    #[doc = "                 if peer does not support secure renegotiation. Results"]
    #[doc = "                 in interoperability issues with non-upgraded peers"]
    #[doc = "                 that do not support renegotiation altogether."]
    #[doc = "                 (Most secure option, interoperability issues)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param allow_legacy  Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION,"]
    #[doc = "                                        SSL_ALLOW_LEGACY_RENEGOTIATION or"]
    #[doc = "                                        MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE)"]
    pub fn mbedtls_ssl_conf_legacy_renegotiation(
        conf: *mut mbedtls_ssl_config,
        allow_legacy: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Enforce renegotiation requests."]
    #[doc = "                 (Default: enforced, max_records = 16)"]
    #[doc = ""]
    #[doc = "                 When we request a renegotiation, the peer can comply or"]
    #[doc = "                 ignore the request. This function allows us to decide"]
    #[doc = "                 whether to enforce our renegotiation requests by closing"]
    #[doc = "                 the connection if the peer doesn't comply."]
    #[doc = ""]
    #[doc = "                 However, records could already be in transit from the peer"]
    #[doc = "                 when the request is emitted. In order to increase"]
    #[doc = "                 reliability, we can accept a number of records before the"]
    #[doc = "                 expected handshake records."]
    #[doc = ""]
    #[doc = "                 The optimal value is highly dependent on the specific usage"]
    #[doc = "                 scenario."]
    #[doc = ""]
    #[doc = " \\note           With DTLS and server-initiated renegotiation, the"]
    #[doc = "                 HelloRequest is retransmited every time mbedtls_ssl_read() times"]
    #[doc = "                 out or receives Application Data, until:"]
    #[doc = "                 - max_records records have beens seen, if it is >= 0, or"]
    #[doc = "                 - the number of retransmits that would happen during an"]
    #[doc = "                 actual handshake has been reached."]
    #[doc = "                 Please remember the request might be lost a few times"]
    #[doc = "                 if you consider setting max_records to a really low value."]
    #[doc = ""]
    #[doc = " \\warning        On client, the grace period can only happen during"]
    #[doc = "                 mbedtls_ssl_read(), as opposed to mbedtls_ssl_write() and mbedtls_ssl_renegotiate()"]
    #[doc = "                 which always behave as if max_record was 0. The reason is,"]
    #[doc = "                 if we receive application data from the server, we need a"]
    #[doc = "                 place to write it, which only happens during mbedtls_ssl_read()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param max_records Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to"]
    #[doc = "                 enforce renegotiation, or a non-negative value to enforce"]
    #[doc = "                 it but allow for a grace period of max_records records."]
    pub fn mbedtls_ssl_conf_renegotiation_enforced(
        conf: *mut mbedtls_ssl_config,
        max_records: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set record counter threshold for periodic renegotiation."]
    #[doc = "                 (Default: 2^48 - 1)"]
    #[doc = ""]
    #[doc = "                 Renegotiation is automatically triggered when a record"]
    #[doc = "                 counter (outgoing or ingoing) crosses the defined"]
    #[doc = "                 threshold. The default value is meant to prevent the"]
    #[doc = "                 connection from being closed when the counter is about to"]
    #[doc = "                 reached its maximal value (it is not allowed to wrap)."]
    #[doc = ""]
    #[doc = "                 Lower values can be used to enforce policies such as \"keys"]
    #[doc = "                 must be refreshed every N packets with cipher X\"."]
    #[doc = ""]
    #[doc = "                 The renegotiation period can be disabled by setting"]
    #[doc = "                 conf->disable_renegotiation to"]
    #[doc = "                 MBEDTLS_SSL_RENEGOTIATION_DISABLED."]
    #[doc = ""]
    #[doc = " \\note           When the configured transport is"]
    #[doc = "                 MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation"]
    #[doc = "                 period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM,"]
    #[doc = "                 the maximum renegotiation period is 2^64 - 1."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param period   The threshold value: a big-endian 64-bit number."]
    pub fn mbedtls_ssl_conf_renegotiation_period(
        conf: *mut mbedtls_ssl_config,
        period: *const cty::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Check if there is data already read from the"]
    #[doc = "                 underlying transport but not yet processed."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         0 if nothing's pending, 1 otherwise."]
    #[doc = ""]
    #[doc = " \\note           This is different in purpose and behaviour from"]
    #[doc = "                 \\c mbedtls_ssl_get_bytes_avail in that it considers"]
    #[doc = "                 any kind of unprocessed data, not only unread"]
    #[doc = "                 application data. If \\c mbedtls_ssl_get_bytes"]
    #[doc = "                 returns a non-zero value, this function will"]
    #[doc = "                 also signal pending data, but the converse does"]
    #[doc = "                 not hold. For example, in DTLS there might be"]
    #[doc = "                 further records waiting to be processed from"]
    #[doc = "                 the current underlying transport's datagram."]
    #[doc = ""]
    #[doc = " \\note           If this function returns 1 (data pending), this"]
    #[doc = "                 does not imply that a subsequent call to"]
    #[doc = "                 \\c mbedtls_ssl_read will provide any data;"]
    #[doc = "                 e.g., the unprocessed data might turn out"]
    #[doc = "                 to be an alert or a handshake message."]
    #[doc = ""]
    #[doc = " \\note           This function is useful in the following situation:"]
    #[doc = "                 If the SSL/TLS module successfully returns from an"]
    #[doc = "                 operation - e.g. a handshake or an application record"]
    #[doc = "                 read - and you're awaiting incoming data next, you"]
    #[doc = "                 must not immediately idle on the underlying transport"]
    #[doc = "                 to have data ready, but you need to check the value"]
    #[doc = "                 of this function first. The reason is that the desired"]
    #[doc = "                 data might already be read but not yet processed."]
    #[doc = "                 If, in contrast, a previous call to the SSL/TLS module"]
    #[doc = "                 returned MBEDTLS_ERR_SSL_WANT_READ, it is not necessary"]
    #[doc = "                 to call this function, as the latter error code entails"]
    #[doc = "                 that all internal data has been processed."]
    #[doc = ""]
    pub fn mbedtls_ssl_check_pending(ssl: *const mbedtls_ssl_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of application data bytes"]
    #[doc = "                 remaining to be read from the current record."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         How many bytes are available in the application"]
    #[doc = "                 data record read buffer."]
    #[doc = ""]
    #[doc = " \\note           When working over a datagram transport, this is"]
    #[doc = "                 useful to detect the current datagram's boundary"]
    #[doc = "                 in case \\c mbedtls_ssl_read has written the maximal"]
    #[doc = "                 amount of data fitting into the input buffer."]
    #[doc = ""]
    pub fn mbedtls_ssl_get_bytes_avail(ssl: *const mbedtls_ssl_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the result of the certificate verification"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 -1 if result is not available (eg because the handshake was"]
    #[doc = "                 aborted too early), or"]
    #[doc = "                 a combination of BADCERT_xxx and BADCRL_xxx flags, see"]
    #[doc = "                 x509.h"]
    pub fn mbedtls_ssl_get_verify_result(ssl: *const mbedtls_ssl_context) -> u32;
}
extern "C" {
    #[doc = " \\brief          Return the name of the current ciphersuite"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         a string containing the ciphersuite name"]
    pub fn mbedtls_ssl_get_ciphersuite(ssl: *const mbedtls_ssl_context) -> *const cty::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the current SSL version (SSLv3/TLSv1/etc)"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         a string containing the SSL version"]
    pub fn mbedtls_ssl_get_version(ssl: *const mbedtls_ssl_context) -> *const cty::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the (maximum) number of bytes added by the record"]
    #[doc = "                 layer: header + encryption/MAC overhead (inc. padding)"]
    #[doc = ""]
    #[doc = " \\note           This function is not available (always returns an error)"]
    #[doc = "                 when record compression is enabled."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum record expansion in bytes, or"]
    #[doc = "                 MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if compression is"]
    #[doc = "                 enabled, which makes expansion much less predictable"]
    pub fn mbedtls_ssl_get_record_expansion(ssl: *const mbedtls_ssl_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the maximum fragment length (payload, in bytes)."]
    #[doc = "                 This is the value negotiated with peer if any,"]
    #[doc = "                 or the locally configured value."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_conf_max_frag_len()"]
    #[doc = " \\sa             mbedtls_ssl_get_max_record_payload()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum fragment length."]
    pub fn mbedtls_ssl_get_max_frag_len(ssl: *const mbedtls_ssl_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the current maximum outgoing record payload in bytes."]
    #[doc = "                 This takes into account the config.h setting \\c"]
    #[doc = "                 MBEDTLS_SSL_OUT_CONTENT_LEN, the configured and negotiated"]
    #[doc = "                 max fragment length extension if used, and for DTLS the"]
    #[doc = "                 path MTU as configured and current record expansion."]
    #[doc = ""]
    #[doc = " \\note           With DTLS, \\c mbedtls_ssl_write() will return an error if"]
    #[doc = "                 called with a larger length value."]
    #[doc = "                 With TLS, \\c mbedtls_ssl_write() will fragment the input if"]
    #[doc = "                 necessary and return the number of bytes written; it is up"]
    #[doc = "                 to the caller to call \\c mbedtls_ssl_write() again in"]
    #[doc = "                 order to send the remaining bytes if any."]
    #[doc = ""]
    #[doc = " \\note           This function is not available (always returns an error)"]
    #[doc = "                 when record compression is enabled."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_set_mtu()"]
    #[doc = " \\sa             mbedtls_ssl_get_max_frag_len()"]
    #[doc = " \\sa             mbedtls_ssl_get_record_expansion()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum payload for an outgoing record,"]
    #[doc = "                 or a negative error code."]
    pub fn mbedtls_ssl_get_max_out_record_payload(ssl: *const mbedtls_ssl_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the peer certificate from the current connection"]
    #[doc = ""]
    #[doc = "                 Note: Can be NULL in case no certificate was sent during"]
    #[doc = "                 the handshake. Different calls for the same connection can"]
    #[doc = "                 return the same or different pointers for the same"]
    #[doc = "                 certificate and even a different certificate altogether."]
    #[doc = "                 The peer cert CAN change in a single connection if"]
    #[doc = "                 renegotiation is performed."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         the current peer certificate"]
    pub fn mbedtls_ssl_get_peer_cert(ssl: *const mbedtls_ssl_context) -> *const mbedtls_x509_crt;
}
extern "C" {
    #[doc = " \\brief          Save session in order to resume it later (client-side only)"]
    #[doc = "                 Session data is copied to presented session structure."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param session  session context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or"]
    #[doc = "                 arguments are otherwise invalid."]
    #[doc = ""]
    #[doc = " \\note           Only the server certificate is copied, and not the full chain,"]
    #[doc = "                 so you should not attempt to validate the certificate again"]
    #[doc = "                 by calling \\c mbedtls_x509_crt_verify() on it."]
    #[doc = "                 Instead, you should use the results from the verification"]
    #[doc = "                 in the original handshake by calling \\c mbedtls_ssl_get_verify_result()"]
    #[doc = "                 after loading the session again into a new SSL context"]
    #[doc = "                 using \\c mbedtls_ssl_set_session()."]
    #[doc = ""]
    #[doc = " \\note           Once the session object is not needed anymore, you should"]
    #[doc = "                 free it by calling \\c mbedtls_ssl_session_free()."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_set_session()"]
    pub fn mbedtls_ssl_get_session(
        ssl: *const mbedtls_ssl_context,
        session: *mut mbedtls_ssl_session,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform the SSL handshake"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ or MBEDTLS_ERR_SSL_WANT_WRITE, or"]
    #[doc = "                 MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED (see below), or"]
    #[doc = "                 a specific SSL error code."]
    #[doc = ""]
    #[doc = "                 If this function returns MBEDTLS_ERR_SSL_WANT_READ, the"]
    #[doc = "                 handshake is unfinished and no further data is available"]
    #[doc = "                 from the underlying transport. In this case, you must call"]
    #[doc = "                 the function again at some later stage."]
    #[doc = ""]
    #[doc = " \\note           Remarks regarding event-driven DTLS:"]
    #[doc = "                 If the function returns MBEDTLS_ERR_SSL_WANT_READ, no datagram"]
    #[doc = "                 from the underlying transport layer is currently being processed,"]
    #[doc = "                 and it is safe to idle until the timer or the underlying transport"]
    #[doc = "                 signal a new event. This is not true for a successful handshake,"]
    #[doc = "                 in which case the datagram of the underlying transport that is"]
    #[doc = "                 currently being processed might or might not contain further"]
    #[doc = "                 DTLS records."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0 or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it or"]
    #[doc = "                 call \\c mbedtls_ssl_session_reset() on it before re-using it"]
    #[doc = "                 for a new connection; the current connection must be closed."]
    #[doc = ""]
    #[doc = " \\note           If DTLS is in use, then you may choose to handle"]
    #[doc = "                 MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging"]
    #[doc = "                 purposes, as it is an expected return value rather than an"]
    #[doc = "                 actual error, but you still need to reset/free the context."]
    pub fn mbedtls_ssl_handshake(ssl: *mut mbedtls_ssl_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a single step of the SSL handshake"]
    #[doc = ""]
    #[doc = " \\note           The state of the context (ssl->state) will be at"]
    #[doc = "                 the next state after execution of this function. Do not"]
    #[doc = "                 call this function if state is MBEDTLS_SSL_HANDSHAKE_OVER."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0 or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it or"]
    #[doc = "                 call \\c mbedtls_ssl_session_reset() on it before re-using it"]
    #[doc = "                 for a new connection; the current connection must be closed."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ or MBEDTLS_ERR_SSL_WANT_WRITE, or"]
    #[doc = "                 a specific SSL error code."]
    pub fn mbedtls_ssl_handshake_step(ssl: *mut mbedtls_ssl_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Initiate an SSL renegotiation on the running connection."]
    #[doc = "                 Client: perform the renegotiation right now."]
    #[doc = "                 Server: request renegotiation, which will be performed"]
    #[doc = "                 during the next call to mbedtls_ssl_read() if honored by"]
    #[doc = "                 client."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or any mbedtls_ssl_handshake() return"]
    #[doc = "                 value."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0 or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it or"]
    #[doc = "                 call \\c mbedtls_ssl_session_reset() on it before re-using it"]
    #[doc = "                 for a new connection; the current connection must be closed."]
    pub fn mbedtls_ssl_renegotiate(ssl: *mut mbedtls_ssl_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Read at most 'len' application data bytes"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param buf      buffer that will hold the data"]
    #[doc = " \\param len      maximum number of bytes to read"]
    #[doc = ""]
    #[doc = " \\return         One of the following:"]
    #[doc = "                 - 0 if the read end of the underlying transport was closed,"]
    #[doc = "                 - the (positive) number of bytes read, or"]
    #[doc = "                 - a negative error code on failure."]
    #[doc = ""]
    #[doc = "                 If MBEDTLS_ERR_SSL_WANT_READ is returned, no application data"]
    #[doc = "                 is available from the underlying transport. In this case,"]
    #[doc = "                 the function needs to be called again at some later stage."]
    #[doc = ""]
    #[doc = "                 If MBEDTLS_ERR_SSL_WANT_WRITE is returned, a write is pending"]
    #[doc = "                 but the underlying transport isn't available for writing. In this"]
    #[doc = "                 case, the function needs to be called again at some later stage."]
    #[doc = ""]
    #[doc = "                 When this function return MBEDTLS_ERR_SSL_CLIENT_RECONNECT"]
    #[doc = "                 (which can only happen server-side), it means that a client"]
    #[doc = "                 is initiating a new connection using the same source port."]
    #[doc = "                 You can either treat that as a connection close and wait"]
    #[doc = "                 for the client to resend a ClientHello, or directly"]
    #[doc = "                 continue with \\c mbedtls_ssl_handshake() with the same"]
    #[doc = "                 context (as it has beeen reset internally). Either way, you"]
    #[doc = "                 should make sure this is seen by the application as a new"]
    #[doc = "                 connection: application state, if any, should be reset, and"]
    #[doc = "                 most importantly the identity of the client must be checked"]
    #[doc = "                 again. WARNING: not validating the identity of the client"]
    #[doc = "                 again, or not transmitting the new identity to the"]
    #[doc = "                 application layer, would allow authentication bypass!"]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than a positive value"]
    #[doc = "                 or MBEDTLS_ERR_SSL_WANT_READ/WRITE or MBEDTLS_ERR_SSL_CLIENT_RECONNECT,"]
    #[doc = "                 you must stop using the SSL context for reading or writing,"]
    #[doc = "                 and either free it or call \\c mbedtls_ssl_session_reset() on it"]
    #[doc = "                 before re-using it for a new connection; the current connection"]
    #[doc = "                 must be closed."]
    #[doc = ""]
    #[doc = " \\note           Remarks regarding event-driven DTLS:"]
    #[doc = "                 - If the function returns MBEDTLS_ERR_SSL_WANT_READ, no datagram"]
    #[doc = "                   from the underlying transport layer is currently being processed,"]
    #[doc = "                   and it is safe to idle until the timer or the underlying transport"]
    #[doc = "                   signal a new event."]
    #[doc = "                 - This function may return MBEDTLS_ERR_SSL_WANT_READ even if data was"]
    #[doc = "                   initially available on the underlying transport, as this data may have"]
    #[doc = "                   been only e.g. duplicated messages or a renegotiation request."]
    #[doc = "                   Therefore, you must be prepared to receive MBEDTLS_ERR_SSL_WANT_READ even"]
    #[doc = "                   when reacting to an incoming-data event from the underlying transport."]
    #[doc = "                 - On success, the datagram of the underlying transport that is currently"]
    #[doc = "                   being processed may contain further DTLS records. You should call"]
    #[doc = "                   \\c mbedtls_ssl_check_pending to check for remaining records."]
    #[doc = ""]
    pub fn mbedtls_ssl_read(
        ssl: *mut mbedtls_ssl_context,
        buf: *mut cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Try to write exactly 'len' application data bytes"]
    #[doc = ""]
    #[doc = " \\warning        This function will do partial writes in some cases. If the"]
    #[doc = "                 return value is non-negative but less than length, the"]
    #[doc = "                 function must be called again with updated arguments:"]
    #[doc = "                 buf + ret, len - ret (if ret is the return value) until"]
    #[doc = "                 it returns a value equal to the last 'len' argument."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param buf      buffer holding the data"]
    #[doc = " \\param len      how many bytes must be written"]
    #[doc = ""]
    #[doc = " \\return         the number of bytes actually written (may be less than len),"]
    #[doc = "                 or MBEDTLS_ERR_SSL_WANT_WRITE or MBEDTLS_ERR_SSL_WANT_READ,"]
    #[doc = "                 or another negative error code."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0, a positive"]
    #[doc = "                 value or MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop"]
    #[doc = "                 using the SSL context for reading or writing, and either"]
    #[doc = "                 free it or call \\c mbedtls_ssl_session_reset() on it before"]
    #[doc = "                 re-using it for a new connection; the current connection"]
    #[doc = "                 must be closed."]
    #[doc = ""]
    #[doc = " \\note           When this function returns MBEDTLS_ERR_SSL_WANT_WRITE/READ,"]
    #[doc = "                 it must be called later with the *same* arguments,"]
    #[doc = "                 until it returns a value greater that or equal to 0. When"]
    #[doc = "                 the function returns MBEDTLS_ERR_SSL_WANT_WRITE there may be"]
    #[doc = "                 some partial data in the output buffer, however this is not"]
    #[doc = "                 yet sent."]
    #[doc = ""]
    #[doc = " \\note           If the requested length is greater than the maximum"]
    #[doc = "                 fragment length (either the built-in limit or the one set"]
    #[doc = "                 or negotiated with the peer), then:"]
    #[doc = "                 - with TLS, less bytes than requested are written."]
    #[doc = "                 - with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned."]
    #[doc = "                 \\c mbedtls_ssl_get_max_frag_len() may be used to query the"]
    #[doc = "                 active maximum fragment length."]
    #[doc = ""]
    #[doc = " \\note           Attempting to write 0 bytes will result in an empty TLS"]
    #[doc = "                 application record being sent."]
    pub fn mbedtls_ssl_write(
        ssl: *mut mbedtls_ssl_context,
        buf: *const cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Send an alert message"]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     The alert level of the message"]
    #[doc = "                  (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL)"]
    #[doc = " \\param message   The alert message (SSL_ALERT_MSG_*)"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific SSL error code."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0 or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it or"]
    #[doc = "                 call \\c mbedtls_ssl_session_reset() on it before re-using it"]
    #[doc = "                 for a new connection; the current connection must be closed."]
    pub fn mbedtls_ssl_send_alert_message(
        ssl: *mut mbedtls_ssl_context,
        level: cty::c_uchar,
        message: cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Notify the peer that the connection is being closed"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific SSL error code."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0 or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it or"]
    #[doc = "                 call \\c mbedtls_ssl_session_reset() on it before re-using it"]
    #[doc = "                 for a new connection; the current connection must be closed."]
    pub fn mbedtls_ssl_close_notify(ssl: *mut mbedtls_ssl_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL context and clear memory"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    pub fn mbedtls_ssl_free(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL configuration context"]
    #[doc = "                 Just makes the context ready for"]
    #[doc = "                 mbedtls_ssl_config_defaults() or mbedtls_ssl_config_free()."]
    #[doc = ""]
    #[doc = " \\note           You need to call mbedtls_ssl_config_defaults() unless you"]
    #[doc = "                 manually set all of the relevent fields yourself."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    pub fn mbedtls_ssl_config_init(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    #[doc = " \\brief          Load reasonnable default SSL configuration values."]
    #[doc = "                 (You need to call mbedtls_ssl_config_init() first.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    #[doc = " \\param endpoint MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER"]
    #[doc = " \\param transport MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or"]
    #[doc = "                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS"]
    #[doc = " \\param preset   a MBEDTLS_SSL_PRESET_XXX value"]
    #[doc = ""]
    #[doc = " \\note           See \\c mbedtls_ssl_conf_transport() for notes on DTLS."]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or"]
    #[doc = "                 MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error."]
    pub fn mbedtls_ssl_config_defaults(
        conf: *mut mbedtls_ssl_config,
        endpoint: cty::c_int,
        transport: cty::c_int,
        preset: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Free an SSL configuration context"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    pub fn mbedtls_ssl_config_free(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    #[doc = " \\brief          Initialize SSL session structure"]
    #[doc = ""]
    #[doc = " \\param session  SSL session"]
    pub fn mbedtls_ssl_session_init(session: *mut mbedtls_ssl_session);
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL session including the"]
    #[doc = "                 peer certificate and clear memory"]
    #[doc = ""]
    #[doc = " \\note           A session object can be freed even if the SSL context"]
    #[doc = "                 that was used to retrieve the session is still in use."]
    #[doc = ""]
    #[doc = " \\param session  SSL session"]
    pub fn mbedtls_ssl_session_free(session: *mut mbedtls_ssl_session);
}
#[doc = " Wrapper type for sockets."]
#[doc = ""]
#[doc = " Currently backed by just a file descriptor, but might be more in the future"]
#[doc = " (eg two file descriptors for combined IPv4 + IPv6 support, or additional"]
#[doc = " structures for hand-made UDP demultiplexing)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_net_context {
    #[doc = "< The underlying file descriptor"]
    pub fd: cty::c_int,
}
extern "C" {
    #[doc = " \\brief          Initialize a context"]
    #[doc = "                 Just makes the context ready to be used or freed safely."]
    #[doc = ""]
    #[doc = " \\param ctx      Context to initialize"]
    pub fn mbedtls_net_init(ctx: *mut mbedtls_net_context);
}
extern "C" {
    #[doc = " \\brief          Initiate a connection with host:port in the given protocol"]
    #[doc = ""]
    #[doc = " \\param ctx      Socket to use"]
    #[doc = " \\param host     Host to connect to"]
    #[doc = " \\param port     Port to connect to"]
    #[doc = " \\param proto    Protocol: MBEDTLS_NET_PROTO_TCP or MBEDTLS_NET_PROTO_UDP"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or one of:"]
    #[doc = "                      MBEDTLS_ERR_NET_SOCKET_FAILED,"]
    #[doc = "                      MBEDTLS_ERR_NET_UNKNOWN_HOST,"]
    #[doc = "                      MBEDTLS_ERR_NET_CONNECT_FAILED"]
    #[doc = ""]
    #[doc = " \\note           Sets the socket in connected mode even with UDP."]
    pub fn mbedtls_net_connect(
        ctx: *mut mbedtls_net_context,
        host: *const cty::c_char,
        port: *const cty::c_char,
        proto: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Create a receiving socket on bind_ip:port in the chosen"]
    #[doc = "                 protocol. If bind_ip == NULL, all interfaces are bound."]
    #[doc = ""]
    #[doc = " \\param ctx      Socket to use"]
    #[doc = " \\param bind_ip  IP to bind to, can be NULL"]
    #[doc = " \\param port     Port number to use"]
    #[doc = " \\param proto    Protocol: MBEDTLS_NET_PROTO_TCP or MBEDTLS_NET_PROTO_UDP"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or one of:"]
    #[doc = "                      MBEDTLS_ERR_NET_SOCKET_FAILED,"]
    #[doc = "                      MBEDTLS_ERR_NET_BIND_FAILED,"]
    #[doc = "                      MBEDTLS_ERR_NET_LISTEN_FAILED"]
    #[doc = ""]
    #[doc = " \\note           Regardless of the protocol, opens the sockets and binds it."]
    #[doc = "                 In addition, make the socket listening if protocol is TCP."]
    pub fn mbedtls_net_bind(
        ctx: *mut mbedtls_net_context,
        bind_ip: *const cty::c_char,
        port: *const cty::c_char,
        proto: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Accept a connection from a remote client"]
    #[doc = ""]
    #[doc = " \\param bind_ctx  Relevant socket"]
    #[doc = " \\param client_ctx Will contain the connected client socket"]
    #[doc = " \\param client_ip Will contain the client IP address, can be NULL"]
    #[doc = " \\param buf_size  Size of the client_ip buffer"]
    #[doc = " \\param ip_len    Will receive the size of the client IP written,"]
    #[doc = "                  can be NULL if client_ip is null"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or"]
    #[doc = "                  MBEDTLS_ERR_NET_ACCEPT_FAILED, or"]
    #[doc = "                  MBEDTLS_ERR_NET_BUFFER_TOO_SMALL if buf_size is too small,"]
    #[doc = "                  MBEDTLS_ERR_SSL_WANT_READ if bind_fd was set to"]
    #[doc = "                  non-blocking and accept() would block."]
    pub fn mbedtls_net_accept(
        bind_ctx: *mut mbedtls_net_context,
        client_ctx: *mut mbedtls_net_context,
        client_ip: *mut cty::c_void,
        buf_size: usize,
        ip_len: *mut usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Check and wait for the context to be ready for read/write"]
    #[doc = ""]
    #[doc = " \\param ctx      Socket to check"]
    #[doc = " \\param rw       Bitflag composed of MBEDTLS_NET_POLL_READ and"]
    #[doc = "                 MBEDTLS_NET_POLL_WRITE specifying the events"]
    #[doc = "                 to wait for:"]
    #[doc = "                 - If MBEDTLS_NET_POLL_READ is set, the function"]
    #[doc = "                   will return as soon as the net context is available"]
    #[doc = "                   for reading."]
    #[doc = "                 - If MBEDTLS_NET_POLL_WRITE is set, the function"]
    #[doc = "                   will return as soon as the net context is available"]
    #[doc = "                   for writing."]
    #[doc = " \\param timeout  Maximal amount of time to wait before returning,"]
    #[doc = "                 in milliseconds. If \\c timeout is zero, the"]
    #[doc = "                 function returns immediately. If \\c timeout is"]
    #[doc = "                 -1u, the function blocks potentially indefinitely."]
    #[doc = ""]
    #[doc = " \\return         Bitmask composed of MBEDTLS_NET_POLL_READ/WRITE"]
    #[doc = "                 on success or timeout, or a negative return code otherwise."]
    pub fn mbedtls_net_poll(ctx: *mut mbedtls_net_context, rw: u32, timeout: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the socket blocking"]
    #[doc = ""]
    #[doc = " \\param ctx      Socket to set"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a non-zero error code"]
    pub fn mbedtls_net_set_block(ctx: *mut mbedtls_net_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the socket non-blocking"]
    #[doc = ""]
    #[doc = " \\param ctx      Socket to set"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a non-zero error code"]
    pub fn mbedtls_net_set_nonblock(ctx: *mut mbedtls_net_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Portable usleep helper"]
    #[doc = ""]
    #[doc = " \\param usec     Amount of microseconds to sleep"]
    #[doc = ""]
    #[doc = " \\note           Real amount of time slept will not be less than"]
    #[doc = "                 select()'s timeout granularity (typically, 10ms)."]
    pub fn mbedtls_net_usleep(usec: cty::c_ulong);
}
extern "C" {
    #[doc = " \\brief          Read at most 'len' characters. If no error occurs,"]
    #[doc = "                 the actual amount read is returned."]
    #[doc = ""]
    #[doc = " \\param ctx      Socket"]
    #[doc = " \\param buf      The buffer to write to"]
    #[doc = " \\param len      Maximum length of the buffer"]
    #[doc = ""]
    #[doc = " \\return         the number of bytes received,"]
    #[doc = "                 or a non-zero error code; with a non-blocking socket,"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ indicates read() would block."]
    pub fn mbedtls_net_recv(
        ctx: *mut cty::c_void,
        buf: *mut cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Write at most 'len' characters. If no error occurs,"]
    #[doc = "                 the actual amount read is returned."]
    #[doc = ""]
    #[doc = " \\param ctx      Socket"]
    #[doc = " \\param buf      The buffer to read from"]
    #[doc = " \\param len      The length of the buffer"]
    #[doc = ""]
    #[doc = " \\return         the number of bytes sent,"]
    #[doc = "                 or a non-zero error code; with a non-blocking socket,"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_WRITE indicates write() would block."]
    pub fn mbedtls_net_send(
        ctx: *mut cty::c_void,
        buf: *const cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Read at most 'len' characters, blocking for at most"]
    #[doc = "                 'timeout' seconds. If no error occurs, the actual amount"]
    #[doc = "                 read is returned."]
    #[doc = ""]
    #[doc = " \\param ctx      Socket"]
    #[doc = " \\param buf      The buffer to write to"]
    #[doc = " \\param len      Maximum length of the buffer"]
    #[doc = " \\param timeout  Maximum number of milliseconds to wait for data"]
    #[doc = "                 0 means no timeout (wait forever)"]
    #[doc = ""]
    #[doc = " \\return         the number of bytes received,"]
    #[doc = "                 or a non-zero error code:"]
    #[doc = "                 MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal."]
    #[doc = ""]
    #[doc = " \\note           This function will block (until data becomes available or"]
    #[doc = "                 timeout is reached) even if the socket is set to"]
    #[doc = "                 non-blocking. Handling timeouts with non-blocking reads"]
    #[doc = "                 requires a different strategy."]
    pub fn mbedtls_net_recv_timeout(
        ctx: *mut cty::c_void,
        buf: *mut cty::c_uchar,
        len: usize,
        timeout: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Gracefully shutdown the connection and free associated data"]
    #[doc = ""]
    #[doc = " \\param ctx      The context to free"]
    pub fn mbedtls_net_free(ctx: *mut mbedtls_net_context);
}
extern "C" {
    #[doc = " @brief Enable mbedTLS debug logging via the esp_log mechanism."]
    #[doc = ""]
    #[doc = " mbedTLS internal debugging is filtered from a specified mbedTLS"]
    #[doc = " threshold level to esp_log level at runtime:"]
    #[doc = ""]
    #[doc = " - 1 - Warning"]
    #[doc = " - 2 - Info"]
    #[doc = " - 3 - Debug"]
    #[doc = " - 4 - Verbose"]
    #[doc = ""]
    #[doc = " (Note that mbedTLS debug thresholds are not always consistently used.)"]
    #[doc = ""]
    #[doc = " This function will set the esp log level for \"mbedtls\" to the specified mbedTLS"]
    #[doc = " threshold level that matches. However, the overall max ESP log level must be set high"]
    #[doc = " enough in menuconfig, or some messages may be filtered at compile time."]
    #[doc = ""]
    #[doc = " @param conf mbedtls_ssl_config structure"]
    #[doc = " @param mbedTLS debug threshold, 0-4. Messages are filtered at runtime."]
    pub fn mbedtls_esp_enable_debug_log(conf: *mut mbedtls_ssl_config, threshold: cty::c_int);
}
extern "C" {
    #[doc = " @brief Disable mbedTLS debug logging via the esp_log mechanism."]
    #[doc = ""]
    pub fn mbedtls_esp_disable_debug_log(conf: *mut mbedtls_ssl_config);
}
#[doc = " \\brief          The SHA-512 context structure."]
#[doc = ""]
#[doc = "                 The structure is used both for SHA-384 and for SHA-512"]
#[doc = "                 checksum calculations. The choice between these two is"]
#[doc = "                 made in the call to mbedtls_sha512_starts_ret()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha512_context {
    #[doc = "< The number of Bytes processed."]
    pub total: [u64; 2usize],
    #[doc = "< The intermediate digest state."]
    pub state: [u64; 8usize],
    #[doc = "< The data block being processed."]
    pub buffer: [cty::c_uchar; 128usize],
    #[doc = "< Determines which function to use:"]
    #[doc = "0: Use SHA-512, or 1: Use SHA-384."]
    pub is384: cty::c_int,
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-512 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to initialize."]
    pub fn mbedtls_sha512_init(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-512 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to clear."]
    pub fn mbedtls_sha512_free(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-512 context."]
    #[doc = ""]
    #[doc = " \\param dst      The destination context."]
    #[doc = " \\param src      The context to clone."]
    pub fn mbedtls_sha512_clone(
        dst: *mut mbedtls_sha512_context,
        src: *const mbedtls_sha512_context,
    );
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-384 or SHA-512 checksum"]
    #[doc = "                 calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to initialize."]
    #[doc = " \\param is384    Determines which function to use:"]
    #[doc = "                 0: Use SHA-512, or 1: Use SHA-384."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_sha512_starts_ret(
        ctx: *mut mbedtls_sha512_context,
        is384: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing"]
    #[doc = "                 SHA-512 checksum calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = " \\param ilen     The length of the input data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_sha512_update_ret(
        ctx: *mut mbedtls_sha512_context,
        input: *const cty::c_uchar,
        ilen: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-512 operation, and writes"]
    #[doc = "                 the result to the output buffer. This function is for"]
    #[doc = "                 internal use only."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_sha512_finish_ret(
        ctx: *mut mbedtls_sha512_context,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within"]
    #[doc = "                 the ongoing SHA-512 computation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context."]
    #[doc = " \\param data     The buffer holding one block of data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_internal_sha512_process(
        ctx: *mut mbedtls_sha512_context,
        data: *const cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-384 or SHA-512 checksum"]
    #[doc = "                 calculation."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha512_starts_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to initialize."]
    #[doc = " \\param is384    Determines which function to use:"]
    #[doc = "                 0: Use SHA-512, or 1: Use SHA-384."]
    pub fn mbedtls_sha512_starts(ctx: *mut mbedtls_sha512_context, is384: cty::c_int);
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing"]
    #[doc = "                 SHA-512 checksum calculation."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha512_update_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context."]
    #[doc = " \\param input    The buffer holding the data."]
    #[doc = " \\param ilen     The length of the input data."]
    pub fn mbedtls_sha512_update(
        ctx: *mut mbedtls_sha512_context,
        input: *const cty::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-512 operation, and writes"]
    #[doc = "                 the result to the output buffer."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha512_finish_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result."]
    pub fn mbedtls_sha512_finish(ctx: *mut mbedtls_sha512_context, output: *mut cty::c_uchar);
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within"]
    #[doc = "                 the ongoing SHA-512 computation. This function is for"]
    #[doc = "                 internal use only."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_internal_sha512_process() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context."]
    #[doc = " \\param data     The buffer holding one block of data."]
    pub fn mbedtls_sha512_process(ctx: *mut mbedtls_sha512_context, data: *const cty::c_uchar);
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-512 or SHA-384"]
    #[doc = "                 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-512 result is calculated as"]
    #[doc = "                 output = SHA-512(input buffer)."]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = " \\param ilen     The length of the input data."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result."]
    #[doc = " \\param is384    Determines which function to use:"]
    #[doc = "                 0: Use SHA-512, or 1: Use SHA-384."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_sha512_ret(
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
        is384: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-512 or SHA-384"]
    #[doc = "                 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-512 result is calculated as"]
    #[doc = "                 output = SHA-512(input buffer)."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha512_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the data."]
    #[doc = " \\param ilen     The length of the input data."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result."]
    #[doc = " \\param is384    Determines which function to use:"]
    #[doc = "                 0: Use SHA-512, or 1: Use SHA-384."]
    pub fn mbedtls_sha512(
        input: *const cty::c_uchar,
        ilen: usize,
        output: *mut cty::c_uchar,
        is384: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          The SHA-384 or SHA-512 checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_sha512_self_test(verbose: cty::c_int) -> cty::c_int;
}
#[doc = " \\brief           Entropy poll callback pointer"]
#[doc = ""]
#[doc = " \\param data      Callback-specific data pointer"]
#[doc = " \\param output    Data to fill"]
#[doc = " \\param len       Maximum size to provide"]
#[doc = " \\param olen      The actual amount of bytes put into the buffer (Can be 0)"]
#[doc = ""]
#[doc = " \\return          0 if no critical failures occurred,"]
#[doc = "                  MBEDTLS_ERR_ENTROPY_SOURCE_FAILED otherwise"]
pub type mbedtls_entropy_f_source_ptr = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut cty::c_void,
        output: *mut cty::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> cty::c_int,
>;
#[doc = " \\brief           Entropy source state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_entropy_source_state {
    #[doc = "< The entropy source callback"]
    pub f_source: mbedtls_entropy_f_source_ptr,
    #[doc = "< The callback data pointer"]
    pub p_source: *mut cty::c_void,
    #[doc = "< Amount received in bytes"]
    pub size: usize,
    #[doc = "< Minimum bytes required before release"]
    pub threshold: usize,
    #[doc = "< Is the source strong?"]
    pub strong: cty::c_int,
}
#[doc = " \\brief           Entropy context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_entropy_context {
    pub accumulator_started: cty::c_int,
    pub accumulator: mbedtls_sha512_context,
    pub source_count: cty::c_int,
    pub source: [mbedtls_entropy_source_state; 20usize],
}
extern "C" {
    #[doc = " \\brief           Initialize the context"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context to initialize"]
    pub fn mbedtls_entropy_init(ctx: *mut mbedtls_entropy_context);
}
extern "C" {
    #[doc = " \\brief           Free the data in the context"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context to free"]
    pub fn mbedtls_entropy_free(ctx: *mut mbedtls_entropy_context);
}
extern "C" {
    #[doc = " \\brief           Adds an entropy source to poll"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context"]
    #[doc = " \\param f_source  Entropy function"]
    #[doc = " \\param p_source  Function data"]
    #[doc = " \\param threshold Minimum required from source before entropy is released"]
    #[doc = "                  ( with mbedtls_entropy_func() ) (in bytes)"]
    #[doc = " \\param strong    MBEDTLS_ENTROPY_SOURCE_STRONG or"]
    #[doc = "                  MBEDTLS_ENTROPY_SOURCE_WEAK."]
    #[doc = "                  At least one strong source needs to be added."]
    #[doc = "                  Weaker sources (such as the cycle counter) can be used as"]
    #[doc = "                  a complement."]
    #[doc = ""]
    #[doc = " \\return          0 if successful or MBEDTLS_ERR_ENTROPY_MAX_SOURCES"]
    pub fn mbedtls_entropy_add_source(
        ctx: *mut mbedtls_entropy_context,
        f_source: mbedtls_entropy_f_source_ptr,
        p_source: *mut cty::c_void,
        threshold: usize,
        strong: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Trigger an extra gather poll for the accumulator"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    pub fn mbedtls_entropy_gather(ctx: *mut mbedtls_entropy_context) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Retrieve entropy from the accumulator"]
    #[doc = "                  (Maximum length: MBEDTLS_ENTROPY_BLOCK_SIZE)"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param data      Entropy context"]
    #[doc = " \\param output    Buffer to fill"]
    #[doc = " \\param len       Number of bytes desired, must be at most MBEDTLS_ENTROPY_BLOCK_SIZE"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    pub fn mbedtls_entropy_func(
        data: *mut cty::c_void,
        output: *mut cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Add data to the accumulator manually"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context"]
    #[doc = " \\param data      Data to add"]
    #[doc = " \\param len       Length of data"]
    #[doc = ""]
    #[doc = " \\return          0 if successful"]
    pub fn mbedtls_entropy_update_manual(
        ctx: *mut mbedtls_entropy_context,
        data: *const cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               Write a seed file"]
    #[doc = ""]
    #[doc = " \\param ctx           Entropy context"]
    #[doc = " \\param path          Name of the file"]
    #[doc = ""]
    #[doc = " \\return              0 if successful,"]
    #[doc = "                      MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR on file error, or"]
    #[doc = "                      MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    pub fn mbedtls_entropy_write_seed_file(
        ctx: *mut mbedtls_entropy_context,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               Read and update a seed file. Seed is added to this"]
    #[doc = "                      instance. No more than MBEDTLS_ENTROPY_MAX_SEED_SIZE bytes are"]
    #[doc = "                      read from the seed file. The rest is ignored."]
    #[doc = ""]
    #[doc = " \\param ctx           Entropy context"]
    #[doc = " \\param path          Name of the file"]
    #[doc = ""]
    #[doc = " \\return              0 if successful,"]
    #[doc = "                      MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR on file error,"]
    #[doc = "                      MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    pub fn mbedtls_entropy_update_seed_file(
        ctx: *mut mbedtls_entropy_context,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = "                 This module self-test also calls the entropy self-test,"]
    #[doc = "                 mbedtls_entropy_source_self_test();"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if a test failed"]
    pub fn mbedtls_entropy_self_test(verbose: cty::c_int) -> cty::c_int;
}
#[doc = " \\brief The AES context-type definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_aes_context {
    #[doc = "< The number of rounds."]
    pub nr: cty::c_int,
    #[doc = "< AES round keys."]
    pub rk: *mut u32,
    #[doc = "< Unaligned data buffer. This buffer can"]
    #[doc = "hold 32 extra Bytes, which can be used for"]
    #[doc = "one of the following purposes:"]
    #[doc = "<ul><li>Alignment if VIA padlock is"]
    #[doc = "used.</li>"]
    #[doc = "<li>Simplifying key expansion in the 256-bit"]
    #[doc = "case by generating an extra round key."]
    #[doc = "</li></ul>"]
    pub buf: [u32; 68usize],
}
#[doc = " \\brief The AES XTS context-type definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_aes_xts_context {
    #[doc = "< The AES context to use for AES block"]
    #[doc = "encryption or decryption."]
    pub crypt: mbedtls_aes_context,
    #[doc = "< The AES context used for tweak"]
    #[doc = "computation."]
    pub tweak: mbedtls_aes_context,
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified AES context."]
    #[doc = ""]
    #[doc = "                 It must be the first API called before using"]
    #[doc = "                 the context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to initialize."]
    pub fn mbedtls_aes_init(ctx: *mut mbedtls_aes_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified AES context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to clear."]
    pub fn mbedtls_aes_free(ctx: *mut mbedtls_aes_context);
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified AES XTS context."]
    #[doc = ""]
    #[doc = "                 It must be the first API called before using"]
    #[doc = "                 the context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to initialize."]
    pub fn mbedtls_aes_xts_init(ctx: *mut mbedtls_aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified AES XTS context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to clear."]
    pub fn mbedtls_aes_xts_free(ctx: *mut mbedtls_aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          This function sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to which the key should be bound."]
    #[doc = " \\param key      The encryption key."]
    #[doc = " \\param keybits  The size of data passed in bits. Valid options are:"]
    #[doc = "                 <ul><li>128 bits</li>"]
    #[doc = "                 <li>192 bits</li>"]
    #[doc = "                 <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_setkey_enc(
        ctx: *mut mbedtls_aes_context,
        key: *const cty::c_uchar,
        keybits: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets the decryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to which the key should be bound."]
    #[doc = " \\param key      The decryption key."]
    #[doc = " \\param keybits  The size of data passed. Valid options are:"]
    #[doc = "                 <ul><li>128 bits</li>"]
    #[doc = "                 <li>192 bits</li>"]
    #[doc = "                 <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_setkey_dec(
        ctx: *mut mbedtls_aes_context,
        key: *const cty::c_uchar,
        keybits: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for encryption and"]
    #[doc = "                 sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to which the key should be bound."]
    #[doc = " \\param key      The encryption key. This is comprised of the XTS key1"]
    #[doc = "                 concatenated with the XTS key2."]
    #[doc = " \\param keybits  The size of \\p key passed in bits. Valid options are:"]
    #[doc = "                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>"]
    #[doc = "                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_xts_setkey_enc(
        ctx: *mut mbedtls_aes_xts_context,
        key: *const cty::c_uchar,
        keybits: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for decryption and"]
    #[doc = "                 sets the decryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to which the key should be bound."]
    #[doc = " \\param key      The decryption key. This is comprised of the XTS key1"]
    #[doc = "                 concatenated with the XTS key2."]
    #[doc = " \\param keybits  The size of \\p key passed in bits. Valid options are:"]
    #[doc = "                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>"]
    #[doc = "                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_xts_setkey_dec(
        ctx: *mut mbedtls_aes_xts_context,
        key: *const cty::c_uchar,
        keybits: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an AES single-block encryption or"]
    #[doc = "                 decryption operation."]
    #[doc = ""]
    #[doc = "                 It performs the operation defined in the \\p mode parameter"]
    #[doc = "                 (encrypt or decrypt), on the input data buffer defined in"]
    #[doc = "                 the \\p input parameter."]
    #[doc = ""]
    #[doc = "                 mbedtls_aes_init(), and either mbedtls_aes_setkey_enc() or"]
    #[doc = "                 mbedtls_aes_setkey_dec() must be called before the first"]
    #[doc = "                 call to this API with the same context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param input    The 16-Byte buffer holding the input data."]
    #[doc = " \\param output   The 16-Byte buffer holding the output data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_ecb(
        ctx: *mut mbedtls_aes_context,
        mode: cty::c_int,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief  This function performs an AES-CBC encryption or decryption operation"]
    #[doc = "         on full blocks."]
    #[doc = ""]
    #[doc = "         It performs the operation defined in the \\p mode"]
    #[doc = "         parameter (encrypt/decrypt), on the input data buffer defined in"]
    #[doc = "         the \\p input parameter."]
    #[doc = ""]
    #[doc = "         It can be called as many times as needed, until all the input"]
    #[doc = "         data is processed. mbedtls_aes_init(), and either"]
    #[doc = "         mbedtls_aes_setkey_enc() or mbedtls_aes_setkey_dec() must be called"]
    #[doc = "         before the first call to this API with the same context."]
    #[doc = ""]
    #[doc = " \\note   This function operates on aligned blocks, that is, the input size"]
    #[doc = "         must be a multiple of the AES block size of 16 Bytes."]
    #[doc = ""]
    #[doc = " \\note   Upon exit, the content of the IV is updated so that you can"]
    #[doc = "         call the same function again on the next"]
    #[doc = "         block(s) of data and get the same result as if it was"]
    #[doc = "         encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "         If you need to retain the contents of the IV, you should"]
    #[doc = "         either save it manually or use the cipher module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param length   The length of the input data in Bytes. This must be a"]
    #[doc = "                 multiple of the block size (16 Bytes)."]
    #[doc = " \\param iv       Initialization vector (updated after use)."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH"]
    #[doc = "                 on failure."]
    pub fn mbedtls_aes_crypt_cbc(
        ctx: *mut mbedtls_aes_context,
        mode: cty::c_int,
        length: usize,
        iv: *mut cty::c_uchar,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief      This function performs an AES-XTS encryption or decryption"]
    #[doc = "             operation for an entire XTS data unit."]
    #[doc = ""]
    #[doc = "             AES-XTS encrypts or decrypts blocks based on their location as"]
    #[doc = "             defined by a data unit number. The data unit number must be"]
    #[doc = "             provided by \\p data_unit."]
    #[doc = ""]
    #[doc = "             NIST SP 800-38E limits the maximum size of a data unit to 2^20"]
    #[doc = "             AES blocks. If the data unit is larger than this, this function"]
    #[doc = "             returns #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH."]
    #[doc = ""]
    #[doc = " \\param ctx          The AES XTS context to use for AES XTS operations."]
    #[doc = " \\param mode         The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                     #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param length       The length of a data unit in bytes. This can be any"]
    #[doc = "                     length between 16 bytes and 2^24 bytes inclusive"]
    #[doc = "                     (between 1 and 2^20 block cipher blocks)."]
    #[doc = " \\param data_unit    The address of the data unit encoded as an array of 16"]
    #[doc = "                     bytes in little-endian format. For disk encryption, this"]
    #[doc = "                     is typically the index of the block device sector that"]
    #[doc = "                     contains the data."]
    #[doc = " \\param input        The buffer holding the input data (which is an entire"]
    #[doc = "                     data unit). This function reads \\p length bytes from \\p"]
    #[doc = "                     input."]
    #[doc = " \\param output       The buffer holding the output data (which is an entire"]
    #[doc = "                     data unit). This function writes \\p length bytes to \\p"]
    #[doc = "                     output."]
    #[doc = ""]
    #[doc = " \\return             \\c 0 on success."]
    #[doc = " \\return             #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH if \\p length is"]
    #[doc = "                     smaller than an AES block in size (16 bytes) or if \\p"]
    #[doc = "                     length is larger than 2^20 blocks (16 MiB)."]
    pub fn mbedtls_aes_crypt_xts(
        ctx: *mut mbedtls_aes_xts_context,
        mode: cty::c_int,
        length: usize,
        data_unit: *const cty::c_uchar,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief This function performs an AES-CFB128 encryption or decryption"]
    #[doc = "        operation."]
    #[doc = ""]
    #[doc = "        It performs the operation defined in the \\p mode"]
    #[doc = "        parameter (encrypt or decrypt), on the input data buffer"]
    #[doc = "        defined in the \\p input parameter."]
    #[doc = ""]
    #[doc = "        For CFB, you must set up the context with mbedtls_aes_setkey_enc(),"]
    #[doc = "        regardless of whether you are performing an encryption or decryption"]
    #[doc = "        operation, that is, regardless of the \\p mode parameter. This is"]
    #[doc = "        because CFB mode uses the same key schedule for encryption and"]
    #[doc = "        decryption."]
    #[doc = ""]
    #[doc = " \\note  Upon exit, the content of the IV is updated so that you can"]
    #[doc = "        call the same function again on the next"]
    #[doc = "        block(s) of data and get the same result as if it was"]
    #[doc = "        encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "        If you need to retain the contents of the"]
    #[doc = "        IV, you must either save it manually or use the cipher"]
    #[doc = "        module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param length   The length of the input data."]
    #[doc = " \\param iv_off   The offset in IV (updated after use)."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_cfb128(
        ctx: *mut mbedtls_aes_context,
        mode: cty::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut cty::c_uchar,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief This function performs an AES-CFB8 encryption or decryption"]
    #[doc = "        operation."]
    #[doc = ""]
    #[doc = "        It performs the operation defined in the \\p mode"]
    #[doc = "        parameter (encrypt/decrypt), on the input data buffer defined"]
    #[doc = "        in the \\p input parameter."]
    #[doc = ""]
    #[doc = "        Due to the nature of CFB, you must use the same key schedule for"]
    #[doc = "        both encryption and decryption operations. Therefore, you must"]
    #[doc = "        use the context initialized with mbedtls_aes_setkey_enc() for"]
    #[doc = "        both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT."]
    #[doc = ""]
    #[doc = " \\note  Upon exit, the content of the IV is updated so that you can"]
    #[doc = "        call the same function again on the next"]
    #[doc = "        block(s) of data and get the same result as if it was"]
    #[doc = "        encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "        If you need to retain the contents of the"]
    #[doc = "        IV, you should either save it manually or use the cipher"]
    #[doc = "        module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT"]
    #[doc = " \\param length   The length of the input data."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_cfb8(
        ctx: *mut mbedtls_aes_context,
        mode: cty::c_int,
        length: usize,
        iv: *mut cty::c_uchar,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief       This function performs an AES-OFB (Output Feedback Mode)"]
    #[doc = "              encryption or decryption operation."]
    #[doc = ""]
    #[doc = "              For OFB, you must set up the context with"]
    #[doc = "              mbedtls_aes_setkey_enc(), regardless of whether you are"]
    #[doc = "              performing an encryption or decryption operation. This is"]
    #[doc = "              because OFB mode uses the same key schedule for encryption and"]
    #[doc = "              decryption."]
    #[doc = ""]
    #[doc = "              The OFB operation is identical for encryption or decryption,"]
    #[doc = "              therefore no operation mode needs to be specified."]
    #[doc = ""]
    #[doc = " \\note        Upon exit, the content of iv, the Initialisation Vector, is"]
    #[doc = "              updated so that you can call the same function again on the next"]
    #[doc = "              block(s) of data and get the same result as if it was encrypted"]
    #[doc = "              in one call. This allows a \"streaming\" usage, by initialising"]
    #[doc = "              iv_off to 0 before the first call, and preserving its value"]
    #[doc = "              between calls."]
    #[doc = ""]
    #[doc = "              For non-streaming use, the iv should be initialised on each call"]
    #[doc = "              to a unique value, and iv_off set to 0 on each call."]
    #[doc = ""]
    #[doc = "              If you need to retain the contents of the initialisation vector,"]
    #[doc = "              you must either save it manually or use the cipher module"]
    #[doc = "              instead."]
    #[doc = ""]
    #[doc = " \\warning     For the OFB mode, the initialisation vector must be unique"]
    #[doc = "              every encryption operation. Reuse of an initialisation vector"]
    #[doc = "              will compromise security."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = " \\param length   The length of the input data."]
    #[doc = " \\param iv_off   The offset in IV (updated after use)."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_ofb(
        ctx: *mut mbedtls_aes_context,
        length: usize,
        iv_off: *mut usize,
        iv: *mut cty::c_uchar,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief      This function performs an AES-CTR encryption or decryption"]
    #[doc = "             operation."]
    #[doc = ""]
    #[doc = "             This function performs the operation defined in the \\p mode"]
    #[doc = "             parameter (encrypt/decrypt), on the input data buffer"]
    #[doc = "             defined in the \\p input parameter."]
    #[doc = ""]
    #[doc = "             Due to the nature of CTR, you must use the same key schedule"]
    #[doc = "             for both encryption and decryption operations. Therefore, you"]
    #[doc = "             must use the context initialized with mbedtls_aes_setkey_enc()"]
    #[doc = "             for both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT."]
    #[doc = ""]
    #[doc = " \\warning    You must never reuse a nonce value with the same key. Doing so"]
    #[doc = "             would void the encryption for the two messages encrypted with"]
    #[doc = "             the same nonce and key."]
    #[doc = ""]
    #[doc = "             There are two common strategies for managing nonces with CTR:"]
    #[doc = ""]
    #[doc = "             1. You can handle everything as a single message processed over"]
    #[doc = "             successive calls to this function. In that case, you want to"]
    #[doc = "             set \\p nonce_counter and \\p nc_off to 0 for the first call, and"]
    #[doc = "             then preserve the values of \\p nonce_counter, \\p nc_off and \\p"]
    #[doc = "             stream_block across calls to this function as they will be"]
    #[doc = "             updated by this function."]
    #[doc = ""]
    #[doc = "             With this strategy, you must not encrypt more than 2**128"]
    #[doc = "             blocks of data with the same key."]
    #[doc = ""]
    #[doc = "             2. You can encrypt separate messages by dividing the \\p"]
    #[doc = "             nonce_counter buffer in two areas: the first one used for a"]
    #[doc = "             per-message nonce, handled by yourself, and the second one"]
    #[doc = "             updated by this function internally."]
    #[doc = ""]
    #[doc = "             For example, you might reserve the first 12 bytes for the"]
    #[doc = "             per-message nonce, and the last 4 bytes for internal use. In that"]
    #[doc = "             case, before calling this function on a new message you need to"]
    #[doc = "             set the first 12 bytes of \\p nonce_counter to your chosen nonce"]
    #[doc = "             value, the last 4 to 0, and \\p nc_off to 0 (which will cause \\p"]
    #[doc = "             stream_block to be ignored). That way, you can encrypt at most"]
    #[doc = "             2**96 messages of up to 2**32 blocks each with the same key."]
    #[doc = ""]
    #[doc = "             The per-message nonce (or information sufficient to reconstruct"]
    #[doc = "             it) needs to be communicated with the ciphertext and must be unique."]
    #[doc = "             The recommended way to ensure uniqueness is to use a message"]
    #[doc = "             counter. An alternative is to generate random nonces, but this"]
    #[doc = "             limits the number of messages that can be securely encrypted:"]
    #[doc = "             for example, with 96-bit random nonces, you should not encrypt"]
    #[doc = "             more than 2**32 messages with the same key."]
    #[doc = ""]
    #[doc = "             Note that for both stategies, sizes are measured in blocks and"]
    #[doc = "             that an AES block is 16 bytes."]
    #[doc = ""]
    #[doc = " \\warning    Upon return, \\p stream_block contains sensitive data. Its"]
    #[doc = "             content must not be written to insecure storage and should be"]
    #[doc = "             securely discarded as soon as it's no longer needed."]
    #[doc = ""]
    #[doc = " \\param ctx              The AES context to use for encryption or decryption."]
    #[doc = " \\param length           The length of the input data."]
    #[doc = " \\param nc_off           The offset in the current \\p stream_block, for"]
    #[doc = "                         resuming within the current cipher stream. The"]
    #[doc = "                         offset pointer should be 0 at the start of a stream."]
    #[doc = " \\param nonce_counter    The 128-bit nonce and counter."]
    #[doc = " \\param stream_block     The saved stream block for resuming. This is"]
    #[doc = "                         overwritten by the function."]
    #[doc = " \\param input            The buffer holding the input data."]
    #[doc = " \\param output           The buffer holding the output data."]
    #[doc = ""]
    #[doc = " \\return                 \\c 0 on success."]
    pub fn mbedtls_aes_crypt_ctr(
        ctx: *mut mbedtls_aes_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut cty::c_uchar,
        stream_block: *mut cty::c_uchar,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block encryption function. This is only"]
    #[doc = "                  exposed to allow overriding it using"]
    #[doc = "                  \\c MBEDTLS_AES_ENCRYPT_ALT."]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for encryption."]
    #[doc = " \\param input     The plaintext block."]
    #[doc = " \\param output    The output (ciphertext) block."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    pub fn mbedtls_internal_aes_encrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block decryption function. This is only"]
    #[doc = "                  exposed to allow overriding it using see"]
    #[doc = "                  \\c MBEDTLS_AES_DECRYPT_ALT."]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for decryption."]
    #[doc = " \\param input     The ciphertext block."]
    #[doc = " \\param output    The output (plaintext) block."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    pub fn mbedtls_internal_aes_decrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief           Deprecated internal AES block encryption function"]
    #[doc = "                  without return value."]
    #[doc = ""]
    #[doc = " \\deprecated      Superseded by mbedtls_aes_encrypt_ext() in 2.5.0."]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for encryption."]
    #[doc = " \\param input     Plaintext block."]
    #[doc = " \\param output    Output (ciphertext) block."]
    pub fn mbedtls_aes_encrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief           Deprecated internal AES block decryption function"]
    #[doc = "                  without return value."]
    #[doc = ""]
    #[doc = " \\deprecated      Superseded by mbedtls_aes_decrypt_ext() in 2.5.0."]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for decryption."]
    #[doc = " \\param input     Ciphertext block."]
    #[doc = " \\param output    Output (plaintext) block."]
    pub fn mbedtls_aes_decrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const cty::c_uchar,
        output: *mut cty::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    pub fn mbedtls_aes_self_test(verbose: cty::c_int) -> cty::c_int;
}
#[doc = " \\brief          The CTR_DRBG context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ctr_drbg_context {
    #[doc = "< The counter (V)."]
    pub counter: [cty::c_uchar; 16usize],
    #[doc = "< The reseed counter."]
    pub reseed_counter: cty::c_int,
    #[doc = "< This determines whether prediction"]
    #[doc = "resistance is enabled, that is"]
    #[doc = "whether to systematically reseed before"]
    #[doc = "each random generation."]
    pub prediction_resistance: cty::c_int,
    #[doc = "< The amount of entropy grabbed on each"]
    #[doc = "seed or reseed operation."]
    pub entropy_len: usize,
    #[doc = "< The reseed interval."]
    pub reseed_interval: cty::c_int,
    #[doc = "< The AES context."]
    pub aes_ctx: mbedtls_aes_context,
    pub f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cty::c_void,
            arg2: *mut cty::c_uchar,
            arg3: usize,
        ) -> cty::c_int,
    >,
    #[doc = "< The context for the entropy function."]
    pub p_entropy: *mut cty::c_void,
}
extern "C" {
    #[doc = " \\brief               This function initializes the CTR_DRBG context,"]
    #[doc = "                      and prepares it for mbedtls_ctr_drbg_seed()"]
    #[doc = "                      or mbedtls_ctr_drbg_free()."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context to initialize."]
    pub fn mbedtls_ctr_drbg_init(ctx: *mut mbedtls_ctr_drbg_context);
}
extern "C" {
    #[doc = " \\brief               This function seeds and sets up the CTR_DRBG"]
    #[doc = "                      entropy source for future reseeds."]
    #[doc = ""]
    #[doc = " \\note Personalization data can be provided in addition to the more generic"]
    #[doc = "       entropy source, to make this instantiation as unique as possible."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context to seed."]
    #[doc = " \\param f_entropy     The entropy callback, taking as arguments the"]
    #[doc = "                      \\p p_entropy context, the buffer to fill, and the"]
    #[doc = "length of the buffer."]
    #[doc = " \\param p_entropy     The entropy context."]
    #[doc = " \\param custom        Personalization data, that is device-specific"]
    #[doc = "identifiers. Can be NULL."]
    #[doc = " \\param len           The length of the personalization data."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure."]
    pub fn mbedtls_ctr_drbg_seed(
        ctx: *mut mbedtls_ctr_drbg_context,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        p_entropy: *mut cty::c_void,
        custom: *const cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function clears CTR_CRBG context data."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context to clear."]
    pub fn mbedtls_ctr_drbg_free(ctx: *mut mbedtls_ctr_drbg_context);
}
extern "C" {
    #[doc = " \\brief               This function turns prediction resistance on or off."]
    #[doc = "                      The default value is off."]
    #[doc = ""]
    #[doc = " \\note                If enabled, entropy is gathered at the beginning of"]
    #[doc = "                      every call to mbedtls_ctr_drbg_random_with_add()."]
    #[doc = "                      Only use this if your entropy source has sufficient"]
    #[doc = "                      throughput."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param resistance    #MBEDTLS_CTR_DRBG_PR_ON or #MBEDTLS_CTR_DRBG_PR_OFF."]
    pub fn mbedtls_ctr_drbg_set_prediction_resistance(
        ctx: *mut mbedtls_ctr_drbg_context,
        resistance: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               This function sets the amount of entropy grabbed on each"]
    #[doc = "                      seed or reseed. The default value is"]
    #[doc = "                      #MBEDTLS_CTR_DRBG_ENTROPY_LEN."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param len           The amount of entropy to grab."]
    pub fn mbedtls_ctr_drbg_set_entropy_len(ctx: *mut mbedtls_ctr_drbg_context, len: usize);
}
extern "C" {
    #[doc = " \\brief               This function sets the reseed interval."]
    #[doc = "                      The default value is #MBEDTLS_CTR_DRBG_RESEED_INTERVAL."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param interval      The reseed interval."]
    pub fn mbedtls_ctr_drbg_set_reseed_interval(
        ctx: *mut mbedtls_ctr_drbg_context,
        interval: cty::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               This function reseeds the CTR_DRBG context, that is"]
    #[doc = "                      extracts data from the entropy source."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param additional    Additional data to add to the state. Can be NULL."]
    #[doc = " \\param len           The length of the additional data."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure."]
    pub fn mbedtls_ctr_drbg_reseed(
        ctx: *mut mbedtls_ctr_drbg_context,
        additional: *const cty::c_uchar,
        len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief              This function updates the state of the CTR_DRBG context."]
    #[doc = ""]
    #[doc = " \\note               If \\p add_len is greater than"]
    #[doc = "                     #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT, only the first"]
    #[doc = "                     #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT Bytes are used."]
    #[doc = "                     The remaining Bytes are silently discarded."]
    #[doc = ""]
    #[doc = " \\param ctx          The CTR_DRBG context."]
    #[doc = " \\param additional   The data to update the state with."]
    #[doc = " \\param add_len      Length of \\p additional data."]
    #[doc = ""]
    pub fn mbedtls_ctr_drbg_update(
        ctx: *mut mbedtls_ctr_drbg_context,
        additional: *const cty::c_uchar,
        add_len: usize,
    );
}
extern "C" {
    #[doc = " \\brief   This function updates a CTR_DRBG instance with additional"]
    #[doc = "          data and uses it to generate random data."]
    #[doc = ""]
    #[doc = " \\note    The function automatically reseeds if the reseed counter is exceeded."]
    #[doc = ""]
    #[doc = " \\param p_rng         The CTR_DRBG context. This must be a pointer to a"]
    #[doc = "                      #mbedtls_ctr_drbg_context structure."]
    #[doc = " \\param output        The buffer to fill."]
    #[doc = " \\param output_len    The length of the buffer."]
    #[doc = " \\param additional    Additional data to update. Can be NULL."]
    #[doc = " \\param add_len       The length of the additional data."]
    #[doc = ""]
    #[doc = " \\return    \\c 0 on success."]
    #[doc = " \\return    #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or"]
    #[doc = "            #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure."]
    pub fn mbedtls_ctr_drbg_random_with_add(
        p_rng: *mut cty::c_void,
        output: *mut cty::c_uchar,
        output_len: usize,
        additional: *const cty::c_uchar,
        add_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief   This function uses CTR_DRBG to generate random data."]
    #[doc = ""]
    #[doc = " \\note    The function automatically reseeds if the reseed counter is exceeded."]
    #[doc = ""]
    #[doc = " \\param p_rng         The CTR_DRBG context. This must be a pointer to a"]
    #[doc = "                      #mbedtls_ctr_drbg_context structure."]
    #[doc = " \\param output        The buffer to fill."]
    #[doc = " \\param output_len    The length of the buffer."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or"]
    #[doc = "                      #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure."]
    pub fn mbedtls_ctr_drbg_random(
        p_rng: *mut cty::c_void,
        output: *mut cty::c_uchar,
        output_len: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function writes a seed file."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param path          The name of the file."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR on file error."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on"]
    #[doc = "                      failure."]
    pub fn mbedtls_ctr_drbg_write_seed_file(
        ctx: *mut mbedtls_ctr_drbg_context,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               This function reads and updates a seed file. The seed"]
    #[doc = "                      is added to this instance."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param path          The name of the file."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR on file error."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or"]
    #[doc = "                      #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG on failure."]
    pub fn mbedtls_ctr_drbg_update_seed_file(
        ctx: *mut mbedtls_ctr_drbg_context,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief               The CTR_DRBG checkup routine."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              \\c 1 on failure."]
    pub fn mbedtls_ctr_drbg_self_test(verbose: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn mbedtls_ctr_drbg_seed_entropy_len(
        arg1: *mut mbedtls_ctr_drbg_context,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *mut cty::c_uchar,
                arg3: usize,
            ) -> cty::c_int,
        >,
        arg3: *mut cty::c_void,
        arg4: *const cty::c_uchar,
        arg5: usize,
        arg6: usize,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Translate a mbed TLS error code into a string representation,"]
    #[doc = "        Result is truncated if necessary and always includes a terminating"]
    #[doc = "        null byte."]
    #[doc = ""]
    #[doc = " \\param errnum    error code"]
    #[doc = " \\param buffer    buffer to place representation in"]
    #[doc = " \\param buflen    length of the buffer"]
    pub fn mbedtls_strerror(errnum: cty::c_int, buffer: *mut cty::c_char, buflen: usize);
}
extern "C" {
    pub static mut mbedtls_test_cas_pem: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_cas_pem_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_cas: [*const cty::c_char; 0usize];
}
extern "C" {
    pub static mut mbedtls_test_cas_len: [usize; 0usize];
}
extern "C" {
    pub static mut mbedtls_test_ca_crt: *const cty::c_char;
}
extern "C" {
    pub static mbedtls_test_ca_crt_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_ca_key: *const cty::c_char;
}
extern "C" {
    pub static mbedtls_test_ca_key_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_ca_pwd: *const cty::c_char;
}
extern "C" {
    pub static mbedtls_test_ca_pwd_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_srv_crt: *const cty::c_char;
}
extern "C" {
    pub static mbedtls_test_srv_crt_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_srv_key: *const cty::c_char;
}
extern "C" {
    pub static mbedtls_test_srv_key_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_cli_crt: *const cty::c_char;
}
extern "C" {
    pub static mbedtls_test_cli_crt_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_cli_key: *const cty::c_char;
}
extern "C" {
    pub static mbedtls_test_cli_key_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_ca_crt_ec: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_ca_crt_ec_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_ca_key_ec: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_ca_key_ec_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_ca_pwd_ec: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_ca_pwd_ec_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_srv_crt_ec: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_srv_crt_ec_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_srv_key_ec: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_srv_key_ec_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_cli_crt_ec: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_cli_crt_ec_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_cli_key_ec: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_cli_key_ec_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_ca_crt_rsa: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_ca_crt_rsa_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_ca_key_rsa: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_ca_key_rsa_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_ca_pwd_rsa: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_ca_pwd_rsa_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_srv_crt_rsa: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_srv_crt_rsa_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_srv_key_rsa: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_srv_key_rsa_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_cli_crt_rsa: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_cli_crt_rsa_len: usize;
}
extern "C" {
    pub static mut mbedtls_test_cli_key_rsa: [cty::c_char; 0usize];
}
extern "C" {
    pub static mbedtls_test_cli_key_rsa_len: usize;
}
pub const esp_tls_conn_state_ESP_TLS_INIT: esp_tls_conn_state = 0;
pub const esp_tls_conn_state_ESP_TLS_CONNECTING: esp_tls_conn_state = 1;
pub const esp_tls_conn_state_ESP_TLS_HANDSHAKE: esp_tls_conn_state = 2;
pub const esp_tls_conn_state_ESP_TLS_FAIL: esp_tls_conn_state = 3;
pub const esp_tls_conn_state_ESP_TLS_DONE: esp_tls_conn_state = 4;
#[doc = "  @brief ESP-TLS Connection State"]
pub type esp_tls_conn_state = u32;
pub use self::esp_tls_conn_state as esp_tls_conn_state_t;
#[doc = " @brief      ESP-TLS configuration parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_tls_cfg {
    #[doc = "< Application protocols required for HTTP2."]
    #[doc = "If HTTP2/ALPN support is required, a list"]
    #[doc = "of protocols that should be negotiated."]
    #[doc = "The format is length followed by protocol"]
    #[doc = "name."]
    #[doc = "For the most common cases the following is ok:"]
    #[doc = "\"\\x02h2\""]
    #[doc = "- where the first '2' is the length of the protocol and"]
    #[doc = "- the subsequent 'h2' is the protocol name"]
    pub alpn_protos: *mut *const cty::c_char,
    #[doc = "< Certificate Authority's certificate in a buffer"]
    pub cacert_pem_buf: *const cty::c_uchar,
    #[doc = "< Size of Certificate Authority certificate"]
    #[doc = "pointed to by cacert_pem_buf"]
    pub cacert_pem_bytes: cty::c_uint,
    #[doc = "< Client certificate in a buffer"]
    pub clientcert_pem_buf: *const cty::c_uchar,
    #[doc = "< Size of client certificate pointed to by"]
    #[doc = "clientcert_pem_buf"]
    pub clientcert_pem_bytes: cty::c_uint,
    #[doc = "< Client key in a buffer"]
    pub clientkey_pem_buf: *const cty::c_uchar,
    #[doc = "< Size of client key pointed to by"]
    #[doc = "clientkey_pem_buf"]
    pub clientkey_pem_bytes: cty::c_uint,
    #[doc = "< Client key decryption password string"]
    pub clientkey_password: *const cty::c_uchar,
    #[doc = "< String length of the password pointed to by"]
    #[doc = "clientkey_password"]
    pub clientkey_password_len: cty::c_uint,
    #[doc = "< Configure non-blocking mode. If set to true the"]
    #[doc = "underneath socket will be configured in non"]
    #[doc = "blocking mode after tls session is established"]
    pub non_block: bool,
    #[doc = "< Network timeout in milliseconds"]
    pub timeout_ms: cty::c_int,
    #[doc = "< Use a global ca_store for all the connections in which"]
    #[doc = "this bool is set."]
    pub use_global_ca_store: bool,
}
pub type esp_tls_cfg_t = esp_tls_cfg;
#[doc = " @brief      ESP-TLS Connection Handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_tls {
    #[doc = "< TLS/SSL context"]
    pub ssl: mbedtls_ssl_context,
    #[doc = "< mbedTLS entropy context structure"]
    pub entropy: mbedtls_entropy_context,
    #[doc = "< mbedTLS ctr drbg context structure."]
    #[doc = "CTR_DRBG is deterministic random"]
    #[doc = "bit generation based on AES-256"]
    pub ctr_drbg: mbedtls_ctr_drbg_context,
    #[doc = "< TLS/SSL configuration to be shared"]
    #[doc = "between mbedtls_ssl_context"]
    #[doc = "structures"]
    pub conf: mbedtls_ssl_config,
    #[doc = "< mbedTLS wrapper type for sockets"]
    pub server_fd: mbedtls_net_context,
    #[doc = "< Container for the X.509 CA certificate"]
    pub cacert: mbedtls_x509_crt,
    #[doc = "< Pointer to the cacert being used."]
    pub cacert_ptr: *mut mbedtls_x509_crt,
    #[doc = "< Container for the X.509 client certificate"]
    pub clientcert: mbedtls_x509_crt,
    #[doc = "< Container for the private key of the client"]
    #[doc = "certificate"]
    pub clientkey: mbedtls_pk_context,
    #[doc = "< Underlying socket file descriptor."]
    pub sockfd: cty::c_int,
    #[doc = "< Callback function for reading data from TLS/SSL"]
    #[doc = "connection."]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(tls: *mut esp_tls, data: *mut cty::c_char, datalen: usize) -> isize,
    >,
    #[doc = "< Callback function for writing data to TLS/SSL"]
    #[doc = "connection."]
    pub write: ::core::option::Option<
        unsafe extern "C" fn(tls: *mut esp_tls, data: *const cty::c_char, datalen: usize) -> isize,
    >,
    #[doc = "< ESP-TLS Connection state"]
    pub conn_state: esp_tls_conn_state_t,
    #[doc = "< read file descriptors"]
    pub rset: _types_fd_set,
    #[doc = "< write file descriptors"]
    pub wset: _types_fd_set,
}
pub type esp_tls_t = esp_tls;
extern "C" {
    #[doc = " @brief      Create a new blocking TLS/SSL connection"]
    #[doc = ""]
    #[doc = " This function establishes a TLS/SSL connection with the specified host in blocking manner."]
    #[doc = ""]
    #[doc = " @param[in]  hostname  Hostname of the host."]
    #[doc = " @param[in]  hostlen   Length of hostname."]
    #[doc = " @param[in]  port      Port number of the host."]
    #[doc = " @param[in]  cfg       TLS configuration as esp_tls_cfg_t. If you wish to open"]
    #[doc = "                       non-TLS connection, keep this NULL. For TLS connection,"]
    #[doc = "                       a pass pointer to esp_tls_cfg_t. At a minimum, this"]
    #[doc = "                       structure should be zero-initialized."]
    #[doc = " @return pointer to esp_tls_t, or NULL if connection couldn't be opened."]
    pub fn esp_tls_conn_new(
        hostname: *const cty::c_char,
        hostlen: cty::c_int,
        port: cty::c_int,
        cfg: *const esp_tls_cfg_t,
    ) -> *mut esp_tls_t;
}
extern "C" {
    #[doc = " @brief      Create a new blocking TLS/SSL connection with a given \"HTTP\" url"]
    #[doc = ""]
    #[doc = " The behaviour is same as esp_tls_conn_new() API. However this API accepts host's url."]
    #[doc = ""]
    #[doc = " @param[in]  url  url of host."]
    #[doc = " @param[in]  cfg  TLS configuration as esp_tls_cfg_t. If you wish to open"]
    #[doc = "                  non-TLS connection, keep this NULL. For TLS connection,"]
    #[doc = "                  a pass pointer to 'esp_tls_cfg_t'. At a minimum, this"]
    #[doc = "                  structure should be zero-initialized."]
    #[doc = " @return pointer to esp_tls_t, or NULL if connection couldn't be opened."]
    pub fn esp_tls_conn_http_new(
        url: *const cty::c_char,
        cfg: *const esp_tls_cfg_t,
    ) -> *mut esp_tls_t;
}
extern "C" {
    #[doc = " @brief      Create a new non-blocking TLS/SSL connection"]
    #[doc = ""]
    #[doc = " This function initiates a non-blocking TLS/SSL connection with the specified host, but due to"]
    #[doc = " its non-blocking nature, it doesn't wait for the connection to get established."]
    #[doc = ""]
    #[doc = " @param[in]  hostname  Hostname of the host."]
    #[doc = " @param[in]  hostlen   Length of hostname."]
    #[doc = " @param[in]  port      Port number of the host."]
    #[doc = " @param[in]  cfg       TLS configuration as esp_tls_cfg_t. `non_block` member of"]
    #[doc = "                       this structure should be set to be true."]
    #[doc = " @param[in]  tls       pointer to esp-tls as esp-tls handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - -1      If connection establishment fails."]
    #[doc = "             -  0      If connection establishment is in progress."]
    #[doc = "             -  1      If connection establishment is successful."]
    pub fn esp_tls_conn_new_async(
        hostname: *const cty::c_char,
        hostlen: cty::c_int,
        port: cty::c_int,
        cfg: *const esp_tls_cfg_t,
        tls: *mut esp_tls_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      Create a new non-blocking TLS/SSL connection with a given \"HTTP\" url"]
    #[doc = ""]
    #[doc = " The behaviour is same as esp_tls_conn_new() API. However this API accepts host's url."]
    #[doc = ""]
    #[doc = " @param[in]  url     url of host."]
    #[doc = " @param[in]  cfg     TLS configuration as esp_tls_cfg_t."]
    #[doc = " @param[in]  tls     pointer to esp-tls as esp-tls handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - -1     If connection establishment fails."]
    #[doc = "             -  0     If connection establishment is in progress."]
    #[doc = "             -  1     If connection establishment is successful."]
    pub fn esp_tls_conn_http_new_async(
        url: *const cty::c_char,
        cfg: *const esp_tls_cfg_t,
        tls: *mut esp_tls_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief      Close the TLS/SSL connection and free any allocated resources."]
    #[doc = ""]
    #[doc = " This function should be called to close each tls connection opened with esp_tls_conn_new() or"]
    #[doc = " esp_tls_conn_http_new() APIs."]
    #[doc = ""]
    #[doc = " @param[in]  tls  pointer to esp-tls as esp-tls handle."]
    pub fn esp_tls_conn_delete(tls: *mut esp_tls_t);
}
extern "C" {
    #[doc = " @brief      Return the number of application data bytes remaining to be"]
    #[doc = "             read from the current record"]
    #[doc = ""]
    #[doc = " This API is a wrapper over mbedtls's mbedtls_ssl_get_bytes_avail() API."]
    #[doc = ""]
    #[doc = " @param[in]  tls  pointer to esp-tls as esp-tls handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "            - -1  in case of invalid arg"]
    #[doc = "            - bytes available in the application data"]
    #[doc = "              record read buffer"]
    pub fn esp_tls_get_bytes_avail(tls: *mut esp_tls_t) -> usize;
}
extern "C" {
    #[doc = " @brief      Create a global CA store, initially empty."]
    #[doc = ""]
    #[doc = " This function should be called if the application wants to use the same CA store for multiple connections."]
    #[doc = " This function initialises the global CA store which can be then set by calling esp_tls_set_global_ca_store()."]
    #[doc = " To be effective, this function must be called before any call to esp_tls_set_global_ca_store()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK             if creating global CA store was successful."]
    #[doc = "             - ESP_ERR_NO_MEM     if an error occured when allocating the mbedTLS resources."]
    pub fn esp_tls_init_global_ca_store() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Set the global CA store with the buffer provided in pem format."]
    #[doc = ""]
    #[doc = " This function should be called if the application wants to set the global CA store for"]
    #[doc = " multiple connections i.e. to add the certificates in the provided buffer to the certificate chain."]
    #[doc = " This function implicitly calls esp_tls_init_global_ca_store() if it has not already been called."]
    #[doc = " The application must call this function before calling esp_tls_conn_new()."]
    #[doc = ""]
    #[doc = " @param[in]  cacert_pem_buf    Buffer which has certificates in pem format. This buffer"]
    #[doc = "                               is used for creating a global CA store, which can be used"]
    #[doc = "                               by other tls connections."]
    #[doc = " @param[in]  cacert_pem_bytes  Length of the buffer."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - ESP_OK  if adding certificates was successful."]
    #[doc = "             - Other   if an error occured or an action must be taken by the calling process."]
    pub fn esp_tls_set_global_ca_store(
        cacert_pem_buf: *const cty::c_uchar,
        cacert_pem_bytes: cty::c_uint,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief      Get the pointer to the global CA store currently being used."]
    #[doc = ""]
    #[doc = " The application must first call esp_tls_set_global_ca_store(). Then the same"]
    #[doc = " CA store could be used by the application for APIs other than esp_tls."]
    #[doc = ""]
    #[doc = " @note       Modifying the pointer might cause a failure in verifying the certificates."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "             - Pointer to the global CA store currently being used    if successful."]
    #[doc = "             - NULL                                                   if there is no global CA store set."]
    pub fn esp_tls_get_global_ca_store() -> *mut mbedtls_x509_crt;
}
extern "C" {
    #[doc = " @brief      Free the global CA store currently being used."]
    #[doc = ""]
    #[doc = " The memory being used by the global CA store to store all the parsed certificates is"]
    #[doc = " freed up. The application can call this API if it no longer needs the global CA store."]
    pub fn esp_tls_free_global_ca_store();
}
extern "C" {
    pub fn sntp_setoperatingmode(operating_mode: u8_t);
}
extern "C" {
    pub fn sntp_getoperatingmode() -> u8_t;
}
extern "C" {
    pub fn sntp_init();
}
extern "C" {
    pub fn sntp_stop();
}
extern "C" {
    pub fn sntp_enabled() -> u8_t;
}
extern "C" {
    pub fn sntp_setserver(idx: u8_t, addr: *const ip_addr_t);
}
extern "C" {
    pub fn sntp_getserver(idx: u8_t) -> *const ip_addr_t;
}
extern "C" {
    pub fn sntp_setservername(idx: u8_t, server: *mut cty::c_char);
}
extern "C" {
    pub fn sntp_getservername(idx: u8_t) -> *mut cty::c_char;
}
pub type __builtin_va_list = __va_list_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub __va_stk: *mut cty::c_int,
    pub __va_reg: *mut cty::c_int,
    pub __va_ndx: cty::c_int,
}
